{"pages":[{"title":"关于我","text":"Founder of Workspacelovin ,iOS开发者,正在努力做好产品。 个人信息 Blog：http://hl1987.com Github: http://github.com/koalahl Weibo: 寒先生的江雪 Twitter: Levi Han Email： hanangellove.@icloud.com 个人项目####Web网站 WorkspaceLovin | 发现全世界最优雅的工作环境 ####App ReadHub X-科技媒体资讯聚合阅读:ReadHux X 是一款非官方的ReadHub iOS客户端，使用swift开发，即将上架。 火箭快递:火箭快递🚀，简单好用的快递查询app,swift3,已上架 简记:简记app，日记类工具，文件夹管理，基于swift3，已上架。 ####Open Source LVTransition:swift封装的转场动画组件 LVPageMenuController:swift封装的多页面可滑动视图控制器，类似网易新闻。 HLQRCode : 使用AVFoundation实现的二维码扫描和生成以及条形码的扫描。 LVCategoryMenu : 电商产品分类视图组件。 PythonIniOS : 一个在iOS客户端中执行python的方案。 More…","link":"/about/index.html"},{"title":"all-tags","text":"","link":"/all-tags/index.html"},{"title":"历史文章","text":"","link":"/archives/index.html"},{"title":"category","text":"","link":"/category/index-1.html"},{"title":"category","text":"","link":"/category/index.html"},{"title":"优秀的技术博客","text":"今日头条技术博客 微信读书技术博客 MrPeak杂货铺，facebook iOS工程师 Bang’s blog Bestswift-张星宇的技术博客 YYKit作者郭耀源的技术博客，《深入理解Runloop》作者","link":"/link/index.html"},{"title":"Project","text":"","link":"/project/index.html"},{"title":"分类","text":"","link":"/categories/index.html"},{"title":"all-categories","text":"","link":"/all-categories/index.html"},{"title":"search","text":"","link":"/search/index.html"},{"title":"标签云","text":"","link":"/tags/index.html"},{"title":"tag","text":"","link":"/tag/index.html"},{"title":"all-archives","text":"","link":"/all-archives/index.html"},{"title":"iOS面试题","text":"","link":"/iOSInterview/index.html"}],"posts":[{"title":"Effective-Objective C 2.0 要点","text":"Effective-Ojective C 2.0 读书笔记 第一章的内容比较基础，就没有列在笔记当中了。另外该笔记只记录每一个要点之后的总结，重点地方会另外探讨。 第二章 消息、对象、运行期 7.在对象内部尽量直接访问实例变量 在对象内部读取数据时，应该直接通过实例变量来读取；而写入数据时，应该通过属性的设置方法来写。 在初始化方法多及dealloc方法中，总是通过实例变量来读写数据。 有时会使用lazy initializition方式来初始化某数据，这种情况下，需要通过属性来读取数据。 8.理解“对象同等性”这一概念 若想检测对象的等同性，请提供isEqual:与hash方法。 相同的对象必须具有相同的哈希码，但是两个哈希码相同的对象却未必相同。 编写hash方法时，应该使用计算速度快而且哈希吗碰撞几率低的算法。 9.以类簇模式隐藏实现细节 类簇模式可以把实现细节隐藏在一套简单的公共接口后面。 系统框架中经常使用类簇。 从类簇的公共抽象基类中继承子类时要当心，若有开发文档，则应首先阅读。 10.在既有类中使用关联对象存放自定义数据 1.关联对象的存储策略：枚举值 OBJC_ASSOCIATION_ASSIGN —&gt;assignOBJC_ASSOCIATION_RETAIN_NONATOMIC —&gt;nonatomic,retainOBJC_ASSOCIATION_COPY_NONATOMIC —&gt;nonatomic,copyOBJC_ASSOCIATION_RETAIN —&gt;retainOBJC_ASSOCIATION_COPY —&gt;copy 创建关联对象方法：void objc_setAssociatedObject(id object,void *key,id value,objc_AssociationPolicy policy) 以给定的键获取某对象的关联对象的值id objc_getAssociatedObject(id object,void *key) 移除该对象的所有关联对象void objc_removeAssociatedObjects(id object) Note:设置关联对象时的key是一个“不透明指针”（opaque pointer：其所指向的数据结构不局限与某种特定类型指针）； 在设置关联对象时，通常使用静态全局变量作为key。 可以通过“associateObject”机制来吧两个对象连起来。 定义关联对象时可指定内存管理语义，用于模仿定义属性时所在用的拥有关系和非拥有关系。 只有在其他做法不可行时才选用关联对象，因为这种做法通常会引入难以查找的bug。 11.理解objc_msgSend的作用。 消息由接受者、选择器及参数构成。给某对象发送消息（invoke a message），也就相当于在该对象上调用方法（calla method） 发给某对象的全部消息都要有动态消息派发系统（dynamic message dispatch system）来处理，该系统会查出对应的方法，并执行其代码。 12.理解消息转发机制。 若对象无法响应某个选择器中的消息，则进入消息转发过程。 通过运行期的动态方法解析机制，我们可以在需要用到某个方法时再将其加入类中。 对象可以把其无法解读的消息转交给其他对象来处理。 若经过上述两步还是没办法处理消息，则启动完整的消息转发机制。 13.使用方法调配技术Method Swizzling调试黑盒方法void method_exchangeImplementations(Method m1,Method m2) 在运行期，可以响雷中新增或替换选择器所对应的方法实现。 使用另一份实现来替换原有的方法实现，叫做方法调配，开发者可以用此技术向原有实现中添加新功能。 一般来说，只有调试程序的时候才需要在运行期修改方法实现，这种做法不宜滥用。 14.理解“类对象”的用意 每个实例都有一个指向Class对象的指针（isa），用意表明其类型，而这些Class对象则构成了类的继承体系（super_class指针）。 如果对象类型无法再编译期确定，那么久应该使用类型信息查询方法来探知。isMemberOfClass（特定类型的类），isKindOfClass（该类及其派生类） 尽量使用类型信息查询方法来确定对象类型，而不要直接比较类对象，因为某些对象可能实现了消息转发功能。 第三章 接口与API设计 15.使用前缀避免命名空间冲突，解决duplicate symbol问题。16.使用全能初始化方法，即带有特定参数的初始化方法。17.实现description方法用来调试程序。并且最好用字典的方式输出类的属性，条理清晰。18.尽量使用不可变对象。19.使用清晰而协调的命名方式。参考Objective C编程规范。20.为私有方法名添加前缀。21.理解OC的错误模型。OC在遇到极其严重的错误后，会抛出异常，程序会退出（crash），所以不用太考虑异常安全。如果不太严重的错误，可以通过设置返回nil/0，或者NSError。22.理解NSCopying协议。 实现NSCopying协议。 重写copyWithZone方法。 如果类中有可变属性，则在copyWithZone方法中同时需要对可变属性进行mutableCopy。举个例子： 1234567891011121314151617181920212223242526272829303132#import &lt;Foundation/Foundation.h&gt;@interface EOCPerson : NSObject&lt;NSCopying&gt;@property (nonatomic,copy)NSString * firstname;@property (nonatomic,copy)NSString * lastname;- (id)initWithFirstName:(NSString *)fisrtname lastName:(NSString *)lastname;@end#import \"EOCPerson.h\"@implementation EOCPerson&#123; NSMutableSet * _friends;&#125;- (id)initWithFirstName:(NSString *)fisrtname lastName:(NSString *)lastname&#123; if (self == [super init]) &#123; _firstname = firstname; _lastname = lastname; &#125; return self;&#125;- (id)copyWithZone:(NSZone *)zone&#123; EOCPerson *copy = [[[self class] allocWithZone:zone] initWithFirstName:_firstname lastName:_lastname]; copy-&gt;_friends = [_friends mutableCopy]; return copy;&#125;@end 要点： 自定义对象若想要进行copy操作，需实现NSCopying协议。 自定义对象若分为可变和不可变版本，则需实现NSCopying和NSMutableCopying协议。 复制对象时需要考虑使用浅拷贝还是深拷贝。一般应该尽量使用浅拷贝。 自定义对象若需要深拷贝，则可以新增一个专门执行深拷贝的方法。 第四章 协议与分类 23.通过委托与数据源协议进行对象间通信24.将类的实现代码分散到数个分类（category）之中。25.总是为第三方分类名称前加前缀。26.尽量不要在分类中声明属性（当然非要做也可）27.使用class-continuation分类（匿名分类）隐藏实现细节28.通过协议提供匿名对象。例如 id,id。任意一个遵守了上述协议的对象都可以赋值给这个属性。 第五章 内存管理 29.理解引用计数。30.以ARC简化引用计数。31.在dealloc方法中只释放引用并解除监听。32.编写“异常安全代码”时应留意内存管理问题。33.以弱引用避免循环引用。34.以“自动释放池”降低内存峰值。35.使用Zombie Object调试内存问题。36.不要使用retainCount。ARC下已废弃。 第六章 GCD 37.理解block。重点看一下block的内部结构那一节。 block中的invoke变量，是一个函数指针，类型为void(*)(void *,_)指向了block的实现代码（需要执行的函数）。 block中的descriptor是一个结构体指针。该结构体中包含了这个block的一些信息，如block的size。 block还会把从外部捕获的变量拷贝一份，放在descriptor变量的后面。拷贝的并不是对象本身，而是这些对象的指针变量。invoke函数把block对象本身作为参数传递进来，就是为了能 拿到block捕获的这些变量。 block被定义时是分配在栈内存中。所以需要copy一份，复制到堆内存中，就可以在外部使用。1234567891011121314151617181920//栈block：void(^block)(); if (/* condition */) &#123; block = ^()&#123; NSLog(@\"Block in Stack\"); &#125; &#125;else&#123; block = ^()&#123; NSLog(@\"Block in Stack still\"); &#125; &#125; block();//堆block：void(^block)(); if (/* condition */) &#123; block = [^()&#123; NSLog(@\"Block in Heap\"); &#125; copy]; &#125;else&#123; block = [^()&#123; NSLog(@\"Block in Heap\"); &#125; copy]; &#125; block();//全局block： void (^block)() = ^()&#123; NSLog(@\"I'm a global block\");&#125; 38.为常用的block创建typedef。39.用handler块来降低代码分散。常用于异步任务时。40.使用block时注意不要出现循环引用。41.多用dispatch queue，少用同步锁。例如涉及到数据的存取。 GCD以前，有两种实现锁的方式： 1.@synchronized(self){ … }.这种方式会降低代码执行效率，因为花括号内的代码都共用一个同步锁，且顺序执行。 2.使用NSLock。lock()方法和unlock()方法。也可以使用递归锁NSRecursiveLock,线程能够多次持有该锁，而不会出现死锁现象。 例子：属性的读取和设置中。 42.多用GCD，少用performeSelector. performSelector系列方法在内存管理方面容易有陷阱。编译器无法确定其将要执行的SEL具体是什么，因此无法通过ARC在编译期插入内存管理方法。 performSelector能够处理的SEL有点局限，选择器的返回类型和参数个数都有限制。 43.掌握GCD和OperationQueue操作队列的使用时机。 执行后台任务时，操作队列更有优势。 使用NSOperation和NSOperationQueue的好处： 取消某个操作。注意：可以取消的是队列中还没有执行的任务。 指定操作间的依赖关系。 通过KVO监测NSOperation对象的属性。 指定Operation的优先级。 重用operations。 44.通过Dispatch_group机制，根据系统资源状况来执行任务 dispatch_apply. 这个会阻塞当前线程。所以不能把主线程作为该方法执行的线程参数。 45.使用dispatch_once来执行只需要运行一次的线程安全代码。常用于单例模式。46.不要使用dispatch_get_current_queue 第七章 系统框架 47.熟悉系统框架。 Fundation 和 CoreFoundation。 无缝桥接，toll-free-bridging,可以将CoreFoundation中的C语言数据结构转换为Foundation中的对象，也可以反向转换。 48.多用块枚举，少用for循环。 for(int i=0;i&lt;max;i++){} NSEnumerator. allObjects() 和nextObject()方法。 快速遍历 fast enumeration. for in基于block的遍历方式- enumerateObjectesUsingBlock:(void(^)(id object,NSUInteger index,BOOL *stop))block…其他方法 49.对自定义内存管理语义的collection集合类使用无缝桥接。 __bridge __bridge_retained __bridge_transfer 1234567891011121314151617NSArray *nameArray = @[@\"g\",@\"c\",@\"d\"];//正向桥接：Foundation对象-&gt;CoreFoundation数据结构CFArrayRef aCFArray = (__bridge CFArrayRef)nameArray ;NSLog(@\"CFArray's count is %li\",CFArrayGetCount(aCFArray));CFArrayRef bCFArray = (__bridge_retained CFArrayRef)nameArray;//或者用bCFArray = CFBridgingRetain(nameArray);NSLog(@\"CFArray's count is %li\",CFArrayGetCount(bCFArray));CFRelease(bCFArray);NSArray *names = (NSArray *)(__bridge_transfer NSArray *)aCFArray;// //或者用// NSArray * names = CFBridgingRelease(aCFArray);//NSLog(@\"%@\",names); 50.构建缓存时使用NSCache而不是NSDictionary。 51.精简initialize和load的实现代码。 两个都是类的初始化方法。 1.load() 对于加入运行时的类class和分类category来说，当包含类和分类的程序库载入系统时，必定会调用+ (void)load方法，且只调用一次。 对于iOS系统，是在应用程序启动的时候。对于Mac OS X来说更自由，因为可以使用动态加载dynamic loading这种特性,等应用程序启动完成之后再去加载程序库。若分类和类中都定义了load方法，则先调用类的，再调用分类的。 load方法一般只用来调试程序，而不是在其中做什么操作。 2.initialize 对于每个类来说，该方法会在首次使用该类之前调用，且只调用一次。它是由运行时系统来调用，而不是由代码调用。 与load的区别： 惰性调用。只有当用到这个类时，才会被调用。如果某个类没有被使用，则不会被调用。而程序必须阻塞把所有类的load方法执行完才能继续。 执行方法时运行时系统的状态。initializer被执行时，runtime system是正常状态的。而load被执行时，runtime system是脆弱状态的。(这个脆弱状态是指最好不要在load方法中使用别的类) initialize方法遵循继承调用。即子类即使没有实现initialize方法，也会调用父类的initialize方法。而load方法则不会，子类若没有实现load方法，也不会去调用父类的load。 52.别忘了NSTimer会保留其目标对象。 NSTimer对象会引用其目标对象，直到计时器本身失效为止，调用invalidate方法可令计时器失效，另外，一次性的计时器在触发完任务之后也会失效。 反复执行任务的计时器，很容易引起循环引用。 可以扩充NSTimer的功能，用block来打破这种循环引用。必须创建分类，将相关实现代码加入其中。 123456789101112131415161718192021222324252627282930313233343536//分类文件.h/.m #import &lt;Foundation/Foundation.h&gt; @interface NSTimer (BlockTimer) + (NSTimer *)bt_scheduledTimerWithTimeInterval:(NSTimeInterval)interval block:(void(^)())block repeats:(BOOL)repeats; @end #import \"NSTimer+BlockTimer.h\" @implementation NSTimer (BlockTimer) + (NSTimer *)bt_scheduledTimerWithTimeInterval:(NSTimeInterval)interval block:(void(^)())block repeats:(BOOL)repeats&#123; return [self scheduledTimerWithTimeInterval:interval target:self selector:@selector(bt_doSomething:) userInfo:[block copy] repeats:repeats]; &#125; + (void)bt_doSomething:(NSTimer *)timer&#123; void(^block)() = timer.userInfo; if (block) &#123; block(); &#125; &#125; @end//在调用时 __weak typeof(self)weakSelf = self; _timer = [NSTimer bt_scheduledTimerWithTimeInterval:1 block:^&#123; //不需要再转成strong也可以啊！？ [weakSelf printName:@\"hello\"]; ViewController * strongSelf = weakSelf; [strongSelf printName:@\"world\"]; &#125; repeats:YES];","link":"/2016/03/23/Effective-Objective-C-2-0-要点/"},{"title":"Learn Swift - Section 4th 扩展、协议、泛型","text":"扩展 Extension扩展Extension就是向一个已有的类、结构体、枚举类型或者协议类型添加新功能（functionality）。这包括在没有权限获取原始源代码的情况下扩展类型的能力（即逆向建模）。扩展和 Objective-C 中的分类（categories）类似。（不过与 Objective-C 不同的是，Swift 的扩展没有名字。）Swift 中的扩展可以：- 添加计算型属性和计算型静态属性- 定义实例方法和类型方法- 提供新的构造器- 定义下标- 定义和使用新的嵌套类型- 使一个已有类型符合某个协议- 也可以对一个协议进行扩展123456789101112131415161718192021222324extension Int&#123; //转换成小时 var hours : Int&#123; return self/3600 &#125; var ago : Int&#123; return -self &#125; //x之前的时间 func ago(x:Int) -&gt; Int &#123; return self - x &#125;&#125;let currentTime = 72003.hours3.hours.ago3.ago + currentTime//5秒之前currentTime.ago(5)//1小时之前currentTime.hours.ago(1)currentTime.hours.ago(3600.hours)print(3.ago)协议 Protocol协议定义了一个蓝图，规定了用来实现某一特定工作或者功能所必需的方法和属性。类，结构体或枚举类型都可以遵循协议，并提供具体实现来完成协议定义的方法和功能。任意能够满足协议要求的类型被称为遵循(conform)这个协议。除了遵循协议的类型必须实现那些指定的规定以外，还可以对协议进行扩展，实现一些特殊的规定或者一些附加的功能，使得遵循的类型能够收益。1234567891011121314151617181920212223242526272829303132333435363738394041424344protocol SellProducts&#123; func sellProducts(product:String)&#125;class Person &#123; var name:String weak var delegate:Seller? lazy var someClosure:(Int,String)-&gt;String = &#123; //在闭包中将self修饰为无主引用。将delegate 修饰为 弱引用 [unowned self,weak delegate = self.delegate!]//捕获列表 (index:Int,strToProcess:String)-&gt;String in return \"\\(self.name),\\(self.delegate),\\(delegate)\" &#125; init(name:String,delegate:Seller?)&#123; self.name = name; self.delegate = delegate; &#125; func giveSellerProducts(product:String ) -&gt; Bool &#123; self.delegate?.sellProducts(product) return true &#125;&#125;class Seller : SellProducts&#123; var product:String? func sellProducts( product: String) &#123; self.product = product &#125;&#125;let seller = Seller()var person = Person (name: \"Hanliu\", delegate: seller)//刚开始seller是没有商品的，要等到Person给sellerprint(seller.product)//person告诉seller，帮我卖苹果person.giveSellerProducts(\"apple\")//现在seller手中就有了商品了print(seller.product!)person.someClosure(1,\"haha\")协议中的属性一定要指明读写状态1234567891011121314151617protocol SomeProtocol &#123; var mustBeSettable:Int&#123;get set&#125;//表示该属性是可读可写 var notNeededForSetable:String&#123;get&#125;//表示只读 static var someTypedProperty:String&#123;get set&#125;//类属性(当协议遵循者是class是，可以用class关键字)&#125;protocol FullyName &#123; var fullname:String&#123;get&#125;&#125;struct PersonName:FullyName &#123; var fullname: String var shortName :String&#125;let person = PersonName(fullname: \"Levi John\",shortName: \"LJ\")person.fullname协议本身并不实现任何功能，但是协议可以被作为类型使用。就是与String、Int这些类型的作用相同。- 作为函数、方法或构造器中的参数类型或返回值类型- 作为常量、变量或属性的类型- 作为数组、字典或其他容器中的元素的类型1234567891011121314151617181920protocol RandomGenerator &#123; func random()-&gt;Double&#125;class LinerGenerator:RandomGenerator &#123; func random() -&gt; Double &#123; return 11.0011 &#125;&#125;class Dice&#123; let slides:Int var generator:RandomGenerator//作为属性类型 init(slides:Int,generator:RandomGenerator)&#123;//作为参数类型 self.slides = slides self.generator = generator &#125; func roll() -&gt; Int &#123; return Int(self.generator.random() * Double(slides))+1 &#125;&#125;在扩展中遵循协议，增加协议成员（这种方法与直接在类后面遵循协议的效果相同）。123456789101112protocol TextRepresentable &#123; var textDescription :String&#123;get&#125;&#125;extension Dice:TextRepresentable&#123; var textDescription:String &#123; return \"\\(slides) - slides\" &#125;&#125;let dice = Dice(slides: 8, generator: LinerGenerator())dice.textDescription//现在Dice的所有实例都可以使用textDescription属性了。协议类型的集合1234567let sir = Dice(slides: 1, generator: LinerGenerator())let sime = Dice(slides: 2, generator: LinerGenerator())let arrayOfProtocolElements:[TextRepresentable] = [dice,sir,sime]for element in arrayOfProtocolElements&#123; print(element.textDescription)&#125;协议能够继承.123456789protocol TextGo:TextRepresentable&#123; var prettyTextDescription:String&#123;get&#125;&#125;extension Dice:TextGo&#123; var prettyTextDescription:String&#123; return textDescription + \"hello\"//可以使用上层协议的属性 &#125;&#125;类专属协议.在协议继承列表中的首位添加class关键字,然后这个协议就只能被类遵循，而不能被结构体或者枚举遵循。123protocol ClassOnlyProtocol:class&#123; var mylove:String&#123;get&#125;&#125;检查协议一致性使用is、as?、as!协议本身也可以被扩展12345extension TextRepresentable&#123;//TextRepresentable是个协议 var longTextDescription:String&#123; return \"\\(textDescription) + long\" &#125;&#125;为协议扩展添加限制条件 where扩展CollectionType协议，让其遵循者的元素必须遵循TextRepresentable协议123456789101112131415161718192021222324extension CollectionType where Generator.Element:TextRepresentable&#123; var textDescription:String&#123; let items = self.map&#123;$0.textDescription&#125; return \"A hamster named \\(items)\" &#125;&#125;struct Hamster &#123; var name: String var textDescription: String &#123; return \"a hamster named \\(name)\" &#125;&#125;extension Hamster: TextRepresentable &#123;&#125;//让Hamster遵循TextRepresentable协议let murrayTheHamster = Hamster(name: \"Murray\")let morganTheHamster = Hamster(name: \"Morgan\")let mauriceTheHamster = Hamster(name: \"Maurice\")let hamsters = [murrayTheHamster, morganTheHamster, mauriceTheHamster]因为Array遵循了`CollectionType`协议，而hamster又遵循了`TextRepresentable`协议，所以就满足了条件，此时 array可以使用`textDescription`属性print(hamsters.textDescription)结果：A hamster named [\"a hamster named Murray\", \"a hamster named Morgan\", \"a hamster named Maurice\"]泛型 Generics 泛型代码可以让你写出根据自我需求定义、适用于任何类型的，灵活且可重用的函数和类型。它的可以让你避免重复的代码，用一种清晰和抽象的方式来表达代码的意图。 泛型是 Swift 强大特征中的其中一个，许多 Swift 标准库是通过泛型代码构建出来的。事实上，泛型的使用贯穿了整本语言手册，只是你没有发现而已。例如，Swift 的数组和字典类型都是泛型集。你可以创建一个Int数组，也可创建一个String数组，或者甚至于可以是任何其他 Swift 的类型数据数组。同样的，你也可以创建存储任何指定类型的字典（dictionary），而且这些类型可以是没有限制的 泛型函数12345func swapTwoValues&lt;T&gt;(inout a:T,inout b:T)&#123; let tempValue = a a = b b = tempValue&#125; T 表示一个占位命名类型 尖括号表示它里面的T是由函数swapTwoValues定义的一个类型，swift不会去查找命名为T的实际类型 参数列表中的T没有实际类型，仅表示两个参数的类型需要相同 实现一个泛型版本的栈123456789101112struct Stack&lt;T&gt;&#123; var items = [T]() mutating func push(item:T)&#123; items.append(item) &#125; mutating func pop()&#123; items.removeLast() &#125;&#125;//泛型实例的创建,都必须指定T的类型var stack = Stack(items: [\"\"])var stack2 = Stack&lt;String&gt;() //扩展一个泛型类型:添加一个属性1234567extension Stack&#123; var topItem:T?&#123; return items.isEmpty ? nil : items[items.count - 1] &#125;&#125;stack2.topItem 关联类型（Associated Type） swift2.2貌似修改了。声明的时候用associatedtype 实现的时候用typealias123456789101112131415161718192021protocol Container&#123; associatedtype ItemType var count:Int&#123;get&#125; mutating func append(item:ItemType) subscript (i:Int)-&gt;ItemType&#123;get&#125;&#125;//让泛型Stack遵循Container协议extension Stack:Container&#123; //typealias ItemType = T //这一行也是可以去掉，因为swift通过类型推断可以判断出T的类型 mutating func append(item: T) &#123; return self.push(item)//或者：items.append(item) &#125; var count:Int&#123; return items.count &#125; subscript(i:Int)-&gt;T&#123; return items[i] &#125;&#125;","link":"/2016/04/28/Learn-Swift-Section-Four-扩展、协议、泛型/"},{"title":"Learn Swift - Section 3rd 类与结构体","text":"类与结构体的共同点： 定义属性用于存储值 定义方法用于提供功能 定义附属脚本用于访问值 定义构造器用于生成初始化值 通过扩展以增加默认实现的功能 实现协议以提供某种标准功能 与结构体相比，类还有如下的附加功能： 继承允许一个类继承另一个类的特征 类型转换允许在运行时检查和解释一个类实例的类型 解构器允许一个类实例释放任何其所被分配的资源 引用计数允许对一个类的多次引用 更多信息请参见继承，类型转换，析构过程，和自动引用计数。 注意 结构体总是通过被复制的方式在代码中传递，不使用引用计数。 1.值类型与引用类型值类型被赋予给一个变量、常量或者被传递给一个函数的时候，其值会被拷贝。 在之前的章节中，我们已经大量使用了值类型。实际上，在 Swift 中，所有的基本类型：整数（Integer）、浮点数（floating-point）、布尔值（Boolean）、字符串（string)、数组（array）和字典（dictionary），都是值类型，并且在底层都是以结构体的形式所实现。 在 Swift 中，所有的结构体和枚举类型都是值类型。这意味着它们的实例，以及实例中所包含的任何值类型属性，在代码中传递的时候都会被复制。 “与值类型不同，引用类型在被赋予到一个变量、常量或者被传递到一个函数时，其值不会被拷贝。因此，引用的是已存在的实例本身而不是其拷贝。” 1234567var marray = [\"lopl\",\"liu\",\"han\"]func modifyArray() &#123; var saray = marray saray.removeAtIndex(2)&#125;modifyArray()marray//并没有变，说明是值拷贝 2.将结构体实例赋值给一个常量，则无法修改结构体中的属性，即使属性是变量。123456789101112131415161718192021222324252627struct Cars &#123; var name = \"\"&#125;let car = Cars()car.name = \"Audi\"//而类则可以修改，因为类是引用类型。class CreateNewLife&#123; var name = \"\"&#125;class Animals &#123; var kind = \"\" let planet = \"Earth\" lazy var createNewLife = CreateNewLife()&#125;let life = CreateNewLife()let anAnimal = Animals()anAnimal.kind = \"Human\"print(anAnimal,life)if life === anAnimal &#123; print(\"same class\")&#125;else&#123; print(\"Different class\")&#125;print(anAnimal.createNewLife.name)//这时CreateNewLife实例才会被创建anAnimal.createNewLife.name = \"liven\"print(anAnimal.kind,anAnimal.createNewLife.name) 3.结构体和类中的属性定义-getter和setter12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758struct Point&#123; var x = 0.0,y = 0.0&#125;struct Size &#123; var width = 0.0,height = 0.0&#125;struct Rect &#123; var origin = Point() var size = Size() var center:Point&#123;//计算属性:即写了get或set的属性。如果只有get，就是只读属性 get&#123; let centerX = origin.x + size.width/2 let centerY = origin.y + size.height/2 return Point(x: centerX, y: centerY) &#125; set(newCenter)&#123; origin.x = newCenter.x - size.width/2 origin.y = newCenter.y - size.height/2 &#125; &#125; var arcPoint:Point&#123;//属性观察器didSet,willSet willSet(newValue)&#123;//会将新的值传入 print(\"will set arcPoint \\(newValue)\") &#125; didSet(oldValue)&#123;//会将旧的值传入 //arcPoint = Point(x: 8, y: 9) print(\"did set arcPoint \\(arcPoint) \\(oldValue)\") &#125; &#125; static var name = \"my rect\"//Type property类型属性 //值类型属性一般不能在它自己的实例方法中修改；如果非要修改，需要加关键字mutating mutating func bigger(x:Double,y:Double) &#123; size.width += x size.height += y &#125;&#125;Rect.nameRect.name = \"xxxx\"Rect.namevar rect = Rect(origin: Point(x: 10,y: 10), size: Size(width: 20,height: 30), arcPoint: Point(x: 1, y: 1))print(rect.arcPoint)rect.arcPoint = Point(x: 3, y: 4)print(rect.arcPoint)var rect2 = rectrect2.arcPoint = Point(x: 6, y: 6)print(rect.arcPoint,rect2.arcPoint)rect.bigger(20, y: 20)print(rect.size)class SomeClass &#123; class var overrideProperty:Int&#123;//get省略了。class关键字表示重写父类的getter实现 return 10 &#125;&#125; 4.方法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647struct LevelTraker &#123; static var highestUnlockedLevel = 1 static func unlockLevel(level:Int)&#123; if (level == highestUnlockedLevel + 1) &#123;highestUnlockedLevel = level&#125; &#125; static func levelIsUnlocked(level:Int)-&gt;Bool&#123; return level &lt;= highestUnlockedLevel &#125; var currentLevel = 1 mutating func advanceLevel(level:Int)-&gt;Bool&#123; if LevelTraker.levelIsUnlocked(level) &#123; currentLevel = level return true &#125;else&#123; return false &#125; &#125;&#125;class Player &#123; var traker = LevelTraker() var playerName:String func completeLevel(level:Int) -&gt;Bool&#123; LevelTraker.unlockLevel(level+1) if traker.advanceLevel(level+1)&#123; return true &#125;else&#123; print(\"Level \\(level) hasn't been unlocked\") return false &#125; &#125; init(name:String)&#123; playerName = name &#125;&#125;var level111 = LevelTraker()var level121 = LevelTraker()level121.currentLevel = 2print(level111.currentLevel, level121.currentLevel)var player = Player(name:\"han\")player.traker.currentLevelplayer.completeLevel(1)player.traker.currentLevelLevelTraker.highestUnlockedLevelplayer.completeLevel(5) 5.构造过程123456789101112131415161718class Cars&#123; var brand:String var usage:String //构造函数 init()&#123; brand = \"BMW\" usage = \"Family\" &#125; init(_brand:String,_usage:String)&#123; brand = _brand usage = _usage &#125;&#125;let audi = Cars(_brand: \"Audi\", _usage: \"Sports\")print(audi.brand,audi.usage)let car2 = Cars()print(car2.brand,car2.usage) 6.当属性有默认值，且没有构造方法时，结构体和类拥有默认构造方法。但是结构体可以有带属性参数的默认构造方法（逐一成员构造器），而类没有。12345678910111213struct People &#123; var name:String? var sex:String?&#125;class Books &#123; var type:String? var category:String? var available = true&#125;let p = People()let semdsd = People(name: \"han\", sex: \"famale\")let book = Books()//var book2 = Books(type:\"epub\",category:\"Computer\",available:true) 7.析构过程/** 析构器只适用于类类型，不能用于结构体。析构器用deinit关键字。*/1234567891011121314class Telephones &#123; var type:String? var category:String? var available = true init() &#123; // &#125; deinit&#123; //析构代码。。。 print(\"\\(type)\") available = false &#125;&#125; / 析构过程会在ARC回收实例时被系统调用，不需要手动调用。 / 8.类实例之间的循环强引用解决方式：1.使用weak关键字，弱引用2.使用unowned，无主引用 9.解决闭包引起的循环引用–定义捕获列表1234567891011121314151617181920212223242526272829303132333435363738394041424344protocol SellProducts&#123; func sellProducts(product:String)&#125;class Person &#123; var name:String weak var delegate:Seller? lazy var someClosure:(Int,String)-&gt;String = &#123; //在闭包中将self修饰为无主引用。将delegate 修饰为 弱引用 [unowned self,weak delegate = self.delegate!]//捕获列表 (index:Int,strToProcess:String)-&gt;String in return \"\\(self.name),\\(self.delegate),\\(delegate)\" &#125; init(name:String,delegate:Seller?)&#123; self.name = name; self.delegate = delegate; &#125; func giveSellerProducts(product:String ) -&gt; Bool &#123; self.delegate?.sellProducts(product) return true &#125;&#125;class Seller : SellProducts&#123; var product:String? func sellProducts( product: String) &#123; self.product = product &#125;&#125;let seller = Seller()var person = Person (name: \"Hanliu\", delegate: seller)//刚开始seller是没有商品的，要等到Person给sellerprint(seller.product)//person告诉seller，帮我卖苹果person.giveSellerProducts(\"apple\")//现在seller手中就有了商品了print(seller.product!)person.someClosure(1,\"haha\")","link":"/2016/04/26/Learn-Swift-Section-Three/"},{"title":"Learn Swift - Section 1st 基础知识","text":"import UIKit var str = “Hello, playground” //常量和变量let maxLoginCount = 10var currentLoginCount = 5 //类型标注var message = “welcome”//类型推断为Stringvar messageWithTypeAnnotation:String message = “welcome here”messageWithTypeAnnotation = “welcome go” print(“Big world (message)”)//(message) 字符串转义print(“Big world”, message)// let newString = “Big world “ + “(message) “ + messageprint(newString)//多行语句用分号let cat = “🐱”; print(cat) let a:Int32 = 10let uintb:UInt8 = 255 //类型别名typealias SLInt = UInt64let i:SLIntvar maxInt64 = SLInt.max //元组let HttpErrorCode = (404,”NotFound”)print(HttpErrorCode) typealias HttpStateCode = (Int32,String)var errorMsg = HttpErrorCodevar normal: HttpStateCode = (200,”OK”)print(normal) let (stateCode,stateMsg) = HttpErrorCodeprint(“HTTP code is (stateCode)”)//通过下标访问元组元素print(HttpErrorCode.1) //隐式解析可选类型 let possibleString:String? = “an optional string”let forcedString:String = possibleString! let possibleString2:String! = “an implicitly optional stirng”let forcedString2:String = possibleString2 //可选绑定if let bingStr = possibleString2{ print(bingStr)} //错误处理 func canThrowAnError() throws{ } func makeASanwich() -&gt; Bool { return false}func buyNewDishes() -&gt; Void { } do{ try canThrowAnError() makeASanwich()}catch Error.MissingNeededMetarail{ buyNewDishes()} //断言let num = 4assert(num&gt;0, “a大于0”) //空合运算符 ??let defaultColor:String = “red”var userDefinedColor:String? //userDefinedColor = “orange”var currentColorToUse = userDefinedColor ?? defaultColor//等价于var currentColorToUse2 = userDefinedColor != nil ? userDefinedColor! : defaultColor //区间运算符//1.闭区间 (a…b) 包含a和bfor index in (1…5){ print(index) print(“(index) 5 = (index 5)”)}//2.半开区间 (a..&lt;b)for index in (1..&lt;5){ print(index) print(“(index) 5 = (index 5)”)} //字符串 String//String是值类型for charactor in “You R A🐶”.characters{ print(charactor)}//独立的字符常量或变量let singleCharactor:Character = “!” //通过值类型为character的数组来创建字符串let characters:[Character] = [“c”,”a”,”t”,”🐱”]let catString = String(characters)print(catString) //插值运算 反斜杠\\let multiplier = 4print(“(multiplier) times 5.12 = (Double(multiplier) * 5.12)”)print(“\\r message”+” \\u{E9}”) //Unicodelet ccc1:Character = “\\u{65}”let ccc2:Character = “\\u{65}\\u{301}” print(message)message.startIndexmessage.endIndex//前一个indexmessage.endIndex.predecessor()//后一个indexmessage.startIndex.successor()//从starIndex开始 后面的第i个indexlet xx = message.startIndex.advancedBy(4)message.removeAtIndex(message.startIndex.advancedBy(4))print(message)//indices 获取字符串的全部索引 。空格不算。。。for index in message.characters.indices{ print(“(message[index])”)} message.insert(“u”, atIndex: xx) message = “http:”+messageprint(message)//前后缀var hasPrefix = message.hasPrefix(“http”)var hasSuffix = message.hasSuffix(“png”) //集合类型：数组Array 集合Set 字典Dictionary //不可变和可变/“如果创建一个Arrays、Sets或Dictionaries并且把它分配成一个变量，这个集合将会是可变的。这意味着我们可以在创建之后添加更多或移除已存在的数据项来改变这个集合的大小。如果我们把Arrays、Sets或Dictionaries分配成常量，那么它就是不可变的，它的大小不能被改变。” /let immutableArray = Intvar mutableArray = Int let strArray = [“world”] mutableArray.append(1)var array1:[String] = Array()array1.append(“hello”)array1.appendContentsOf(strArray)array1.insert(“gogogog”, atIndex: 1)array1.countarray1.isEmpty array1[0…1] = [“apple”,”pear”];array1//数组的遍历for item in array1{ print(item)} for (index,item) in array1.enumerate(){ print(item,array1[index])} //集合var asset = Set()asset.countasset.insert(“hash string”)asset.remove(“hash”)//set类型必须显式声明,具体元素类型可以省略let asset2:Set = [“a”]let asset3:Set = [“a”,”v”]asset2.hashValue == asset3.hashValueasset.hashValue == asset2.hashValue let asset4 = Set.init(arrayLiteral: “a”,”b”,”c”)let asset5 = Set.init(array1)//集合操作：交集、外集、合集,减集 asset3.intersect(asset4)asset3.exclusiveOr(asset4)asset3.union(asset4)asset3.subtract(asset4) asset3 == asset4asset3.isSubsetOf(asset4)asset3.isSupersetOf(asset3)asset3.isStrictSupersetOf(asset3)//是否是超集，并且不是同一集合asset3.isStrictSubsetOf(asset3)//是否是子集，并且不是同一集合 asset3.isDisjointWith(asset4)//判断集合是否不含有相同的值。false说明包含相同的值 //字典 Dictionaryvar dic1 = Dictionary()var dic2 = Int:Stringdic1.updateValue(“value”, forKey: 0)//updateValue方法返回值是该key的旧值dic1.updateValue(“newValue”, forKey: 0)print(dic1)dic1[1] = “ahao”dic1[2] = “dddd”print(dic1) for (key,value) in dic1{ print(key ,value)} print(dic1.keys.sort())print(dic1.values.sort()) //控制流程 //gamelet finalSqura = 25var board = Intboard[03] = +08; board[06] = +11; board[09] = +09; board[10] = +02board[14] = -10; board[19] = -11; board[22] = -02; board[24] = -08var square = 0var diceRoll = 0 gameLoop:while square != finalSqura{ //if ++diceRoll == 7 { diceRoll = 1 } switch square + diceRoll { case finalSqura: break gameLoop case let newSquare where newSquare &gt; finalSqura: coutinue gameLoop default: square += diceRoll square += board[square] }}print(“game over”) //检查API可用性if #available(iOS 9, *){ }else{ }func checkOSVersion() -&gt; NSString { //必须在函数体内使用；必须跟着else；必须能跳出else guard #available(OSX 10.11, *) else { return “10.10” } return “10.11”} checkOSVersion() //函数嵌套func stepForword(input:Int)-&gt;Int{ return input - 1}func stepBackword(input:Int)-&gt;Int{ return input + 1}func chooseStep(value:Int) -&gt; (Int)-&gt;Int { return value &gt; 0 ? stepForword : stepBackword}func xxxx(tempFunction:(Int)-&gt;Int) -&gt;Int { return 1}//如果我再加一个函数嵌套func nextStep(tempFunction:((Int)-&gt;Int)-&gt;Int) -&gt; Int{ return 0}let number = 3let myFunction = chooseStep(number)myFunction(number) let names = [“Chris”, “Alex”, “Ewa”, “Barry”, “Daniella”]func absendOrdesend(s1:String,s2:String) -&gt; Bool { return s1&gt;s2}//使用函数的返回值作为参数names.sort()names.sort(absendOrdesend)//闭包表达式 {(parameter:Type)-&gt;ReturnType in }Objective-C中的blockReturnType ^(parameter){ return } //使用闭包的返回值作为参数names.sort({(s1:String,s2:String) -&gt; Bool in return s1 &gt; s2}) //因为names数组参数类型确定，所以根据类型推断,省略参数类型和返回值类型names.sort({s1,s2 in return s1&gt;s2})names.sort({s1,s2 in s1&gt;s2})names.sort({$0&gt;$1})names.sort(&gt;)//根据String对&gt;这个符号的定义推断 //尾随闭包//先定义一个closurelet bigger = {(a:Int,b:Int)-&gt;Bool in return a&gt;b}//声明一个函数，参数是一个闭包func exchangeNumerWithClosure(bigger:(Int,Int)-&gt;Bool){ if bigger(2,3) { print(“bigger”) }else{ print(“lower”) }}//函数调用时//没有使用尾随闭包//exchangeNumerWithClosure({(a:Int,b:Int)-&gt;Bool in// return a&gt;b//}) //使用尾随闭包//exchangeNumerWithClosure(){(a:Int,b:Int)-&gt;Bool in return a&gt;b }exchangeNumerWithClosure(){(a:Int,b:Int) -&gt;Bool in a&gt;b}//同理，尾随闭包names.sort(){$0&gt;$1}names.sort{$0&gt;$1}//如果函数只需要闭包表达式一个参数，当您使用尾随闭包时,可以省略()","link":"/2016/04/26/Learn-Swift-Section-One/"},{"title":"Learn Swift - Section 2nd 集合类型和枚举","text":"Arra、Dictionary、Set和枚举 //Array的map()方法let digitNames = [ 0: “Zero”, 1: “One”, 2: “Two”, 3: “Three”, 4: “Four”, 5: “Five”, 6: “Six”, 7: “Seven”, 8: “Eight”, 9: “Nine”]let numbers = [132,11,87,90,49,87,22,29,5,10,87]//map方法会读取数组中的每一个元素，let strings = numbers.map { (element) -&gt; String in var output = “” var number = element while number &gt; 0 { output = digitNames[number % 10]! + output number /= 10 } return output}//把每个元素都+1let so = numbers.map{(element)-&gt;Int in return element + 1}let lo = numbers.flatMap{(element)-&gt;Int in return element + 3 }let split1 = numbers.split(70)let split2 = numbers.split(87)let split3 = numbers.split(87, maxSplit: 1, allowEmptySlices: true)let split4 = numbers.split(87, maxSplit: 6, allowEmptySlices: true)let split5 = numbers.split(87, maxSplit: 6, allowEmptySlices: false) //过滤出满足条件的子序列。条件由闭包定义numbers.filter { (element) -&gt; Bool in return element &gt; 50}numbers.filter{(element) in element &gt; 50}numbers.filter{ $0 &gt; 50} let scores = [“xiaoming”:66,”li”:89,”han”:78,”ming”:100,”xiag”:34]scores.filter { (name,score) in score &gt; 60} //“将闭包标注为@noescape使你能在闭包中隐式地引用self”func functionWithNoescapeClosure(@noescape closure:()-&gt;Void){ closure()}var completionHandlers:[() -&gt; Void] = []func functionWithEscapeClosure(completionHandler:()-&gt;Void){ completionHandler() completionHandlers.append(completionHandler)} class SomeClass { var x = 200 func doSomething(){ functionWithEscapeClosure({self.x = 100}) functionWithNoescapeClosure({x = 300})//隐式引用self } }let some = SomeClass()some.doSomething()print(some.x) completionHandlers.first?()print(some.x) //自动闭包 使用@autoclosure，就可以不用加闭包的{}var names = [“charis”,”levis”,”luos”,”deric”,”htome”]let customerProvider = {names.removeAtIndex(0)}//注意类型是()-&gt;Stringfunc customName(@autoclosure customerProvider:()-&gt;String) { print(“costomer’s name is (customerProvider())”)} customName(names.removeAtIndex(0))//闭包体不需要加{}，就好像是参数一样。 //枚举-一等公民 与类class一样enum Compose{ case North case South case West case East}//成员值的类型为枚举的名字Composelet directionToHead = Compose.East //带有关联值的枚举enum Barcode { case UPCA(Int,Int,Int)//关联了Int类型的值 case QRCode(String)//关联了String类型的值} var productorCode = Barcode.QRCode(“kasdjfiwoeklf”) productorCode = .UPCA(2,5,1) switch productorCode{ case let .UPCA(first,second,third): print(“(first) (second) (third)”) case var .QRCode(code): print(“code is (code)”)} //原始值 Raw Valuesenum ASCII:Character{//带有初始类型的枚举 case Tab = “\\t” case Return = “\\r” case changeLine = “\\n”} //关联值可以使枚举的嵌套成为可能.如果嵌套，则需要添加indirect关键字enum Add{ case Number(Int) indirect case Addition(Add,Add)}func evaluate(add:Add) -&gt; Int { switch add { case .Number(let i): return i case .Addition(let left, let right): return evaluate(left) + evaluate(right) }} let a = Add.Number(10)let b = Add.Number(2)let c = Add.Addition(a,b) evaluate(a)evaluate(c)","link":"/2016/04/26/Learn-Swift-Section-Two/"},{"title":"NSURLSession初探","text":"NSURLSession是Apple自iOS7.0之后加入到Cocoa SDK中，用以替代NSURLConnection。它拥有更简洁易懂的API方法。iOS中常用的网络库例如AFNetworking在3.0版本中就全部替换为了NSURLSession。之前项目中一直使用的AFNetworking2.x版本，也没有花时间去仔细研究NSURLSession，特此周末粗略的看了看，一些方法也是试了试。 NSURLSession继承结构： NSURLSession - session对象。 NSURLSessionConfiguration - 当初始化session对象时设置session的配置信息。 NSURLSessoinTask - task基类 NSURLSessionDataTask - 获取url内容，返回NSData对象。 NSURLSessionUploadTask - 上传文件的task，并取回对应url内容，返回NSData对象。 NSURLSessionDownloadTask - 获取url内容，并返回一个临时文件在沙盒中（tmp目录下）。 NSURLSession也提供了四组代理方法： NSURLSessionDelegate — Defines delegate methods to handle session-level events NSURLSessionTaskDelegate — Defines delegate methods to handle task-level events common to all task types NSURLSessionDataDelegate — Defines delegate methods to handle task-level events specific to data and upload tasks NSURLSessionDownloadDelegate — Defines delegate methods to handle task-level events specific to download tasks 首先来看看普通的sessoin请求方法。在completionHandler中返回的是NSData。 123456789NSURLSession *session = [NSURLSession sharedSession];NSURLSessionDataTask * dataTask = [session dataTaskWithRequest:[NSURLRequest requestWithURL:[NSURL URLWithString:url]] completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) &#123; self.fileName = response.suggestedFilename; [self saveToFile]; [self.fileHandler seekToEndOfFile]; [self.fileHandler writeData:data]; [self.fileHandler closeFile];&#125;];[dataTask resume];//开始任务。resume有继续、恢复、重新开始的意思，当处理断点续传时就能体会到此含义了。 再来看看download task的请求方式，上面提到过，download task最后返回的是一个临时文件，所以需要我们手动将其保存到其他沙盒目录中，就需要用到NSFileManager了。123456789NSURLSessionDownloadTask * downloadTask = [session downloadTaskWithRequest:[NSURLRequest requestWithURL:[NSURL URLWithString:url]] completionHandler:^(NSURL * _Nullable location, NSURLResponse * _Nullable response, NSError * _Nullable error) &#123; self.fileName = response.suggestedFilename; NSString * directory = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) lastObject]; NSString * filePath = [directory stringByAppendingPathComponent:self.fileName]; NSFileManager * fileManager = [NSFileManager defaultManager]; [fileManager moveItemAtPath:location.path toPath:filePath error:nil];&#125;]; [downloadTask resume]; 那有时候我们想取得下载进度信息，用block方式就不行了，所以就需要用到系统提供的代理方法了。这里我们用NSURLSessionDownloadDelegate.此时session的创建方式就是另一种方式，设置delegate为self。 12345NSURLSession * session = [NSURLSession sessionWithConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration] delegate:self delegateQueue:[NSOperationQueue mainQueue]];self.downloadTask = [session downloadTaskWithRequest:[NSURLRequest requestWithURL:[NSURL URLWithString:url]]];[self.downloadTask resume]; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#pragma mark - NSURLSessionDownloadDelegate/** * 下载完毕 * * @param location 文件临时地址 */- (void)URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTaskdidFinishDownloadingToURL:(NSURL *)location&#123; NSLog(@\"文件存放位置%@\",location.path);// [self.startOrPauseOfSession setTitle:@\"开始\" forState:UIControlStateNormal]; self.fileName = @\"QQ4.1.0.dmg\"; NSString * directory = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) lastObject]; NSString * filePath = [directory stringByAppendingPathComponent:self.fileName]; NSFileManager * fileManager = [NSFileManager defaultManager]; [fileManager moveItemAtPath:location.path toPath:filePath error:nil];&#125;/** * 每次写入沙盒完毕 * 在这里面监听下载进度，totalBytesWritten/totalBytesExpectedToWrite * * @param bytesWritten 这次写入的大小 * @param totalBytesWritten 已经写入沙盒的大小 * @param totalBytesExpectedToWrite 文件总大小 */- (void)URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTask didWriteData:(int64_t)bytesWritten totalBytesWritten:(int64_t)totalBytesWrittentotalBytesExpectedToWrite:(int64_t)totalBytesExpectedToWrite&#123; self.progressView.progress = (double)totalBytesWritten/totalBytesExpectedToWrite; self.progressLabel.text = [NSString stringWithFormat:@\"%.1f%%\",(double)totalBytesWritten/totalBytesExpectedToWrite * 100];&#125;/** * 恢复下载后调用， */- (void)URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTask didResumeAtOffset:(int64_t)fileOffsetexpectedTotalBytes:(int64_t)expectedTotalBytes&#123;&#125; 12345678910#pragma mark - PrivateMethod- (void)saveToFile&#123; NSString * cacheDirectory = [NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) lastObject]; NSLog(@\"%@\",cacheDirectory); NSString * filePath = [cacheDirectory stringByAppendingPathComponent:self.fileName]; NSFileManager * fileManager = [NSFileManager defaultManager]; [fileManager createFileAtPath:filePath contents:nil attributes:nil]; //创建操作数据的文件handler self.fileHandler = [NSFileHandle fileHandleForWritingAtPath:filePath];&#125; 更多信息请查看NSURLSession官方文档","link":"/2016/01/10/NSURLSession初探/"},{"title":"LearnSwift-小白学习map，reduce方法","text":"数组的map、reduce方法 map方法将遍历序列中每个元素123[1,2,3,4,5,6].map &#123; (i) -&gt; Int in return i * 2&#125; 简化版1[1,2,3,4,5,6].map(&#123;$0 * 2&#125;) reduce: i 这里是一个累加器（并不表示相加），保存了前一次运算的结果。1234[1,2,3,4,5,6].reduce(1) &#123; (i, element) -&gt; Int in print(i,element) return i * element&#125; 上面的reduce方法可以简化为1[1,2,3,4,5,6].reduce(1, combine: *) 下面来看看flatMap,该函数会忽略为nil的集合元素。123456789101112let persons: [[String: AnyObject]] = [[\"name\": \"Carl Saxon\", \"city\": \"New York, NY\", \"age\": 44], [\"name\": \"Travis Downing\", \"city\": \"El Segundo, CA\", \"age\": 34], [\"name\": \"Liz Parker\", \"city\": \"San Francisco, CA\", \"age\": 32], [\"name\": \"John Newden\", \"city\": \"New Jersey, NY\", \"age\": 21], [\"name\": \"Hector Simons\", \"city\": \"San Diego, CA\", \"age\": 37], [\"name\": \"Brian Neo\", \"age\": 27]] //注意这家伙没有 city 键值//找到住在CA的居民。func peopleFromState(state:String,persons:[[String:AnyObject]]) -&gt; Int&#123; return persons.flatMap &#123; $0[\"city\"]?.componentsSeparatedByString(\", \").last&#125;.filter &#123; $0 == state&#125;.count&#125;peopleFromState(\"CA\", persons: persons) 用reduce实现map、flatMap123456789func rmap(element:[Int],transform:(Int)-&gt;Int ) -&gt;[Int]&#123; return element.reduce([Int](), combine: &#123; (var accemulator:[Int], obj:Int) -&gt; [Int] in print(accemulator,obj) accemulator.append(transform(obj)) return accemulator &#125;)&#125;rmap([1,2,3,4,5,6], transform: &#123;$0 * 2&#125;) 1234567func rmap2(element:[Int],transform:(Int)-&gt;Int) -&gt; [Int] &#123; return element.reduce([Int](), combine: &#123;$0 + [transform($1)]&#125;)&#125;let array = rmap2([1,2,3,4,5,6], transform: &#123;$0 * 2&#125;)print(array)结果都是[2, 4, 6, 8, 10, 12] 理解 $0, $1$0,$1是一个常量，类型根据所在函数的参数类型决定。为何它们是这个类型呢？其所在函数是combine，那么$0和$1的类型都是由combine这个(函数/闭包/方法)的第二个参数类型决定的。所以我们来看看reduce函数的定义：1public func reduce&lt;T&gt;(initial: T, @noescape combine: (T, Self.Generator.Element) throws -&gt; T) rethrows $0代表第一个参数，其类型这里是[Int],$1代表的是combine内的第二个参数，所以其类型就是Int的。 用reduce实现filter123456789101112131415161718192021222324func rfilter(element:[Int],filter:(Int)-&gt;Bool)-&gt; [Int]&#123; return element.reduce([Int](), combine: &#123; (var acc:[Int], value:Int) -&gt; [Int] in if filter(value)&#123; acc.append(value) &#125; return acc &#125;)&#125;let xxc = rfilter([1,2,3,4,5,6], filter: &#123; $0 &gt; 3&#125;)print(xxc)func rfilter2(element:[Int],filter:(Int)-&gt;Bool)-&gt; [Int]&#123; return element.reduce([Int](), combine: &#123; guard filter($1) else&#123; return $0&#125; return $0 + [$1] &#125;)&#125;let oos = rfilter2([1,2,3,4,5,6], filter: &#123;$0 &gt; 3 &#125;)print(oos) 再看前面提过的问题：找到住在CA的居民。并且计算他们的平均年龄123456789101112131415161718func peopleFromState(state:String,persons:[[String:AnyObject]]) -&gt; (population:Int,averageAge:CGFloat)&#123; //return persons.flatMap &#123; $0[\"city\"]?.componentsSeparatedByString(\", \").last&#125;.filter &#123; $0 == state&#125;.count typealias Result = (population:Int,averageAge:CGFloat) let u = persons.reduce((populatoin:0,averageAge:0.0)) &#123; (var result:Result, dic:[String:AnyObject]) -&gt; Result in guard let locationStr = dic[\"city\"]?.componentsSeparatedByString(\", \").last,let personAge = dic[\"age\"] where locationStr == state else&#123; return result&#125; return (result.population + 1,result.averageAge + CGFloat(personAge as! NSNumber)) &#125; return (u.populatoin,u.averageAge / CGFloat(u.populatoin))&#125;let result = peopleFromState(\"CA\", persons: persons)result.population // 3result.averageAge // 34.333333334","link":"/2016/05/06/LearnSwift-小白学习map，reduce方法/"},{"title":"Category添加属性所想到的","text":"iOS中category和extension相辅相成，长得也很相似。category与extension的主要区别： Category：分类、类别 category主要用来增加类的方法，并且适用于子类。 category不能添加实例变量（这个并不是属性），可以添加readonly的属性。 如果要添加readwrite的属性的话，需要用到runtime方法。 Extension：扩展 可以增加被扩展类的属性和方法。 Extension可以理解为匿名类别。 定义的方法必须在implementation中实现。 下面主要看看category的使用：1.添加readonly属性 12345678@interface UITableViewCell (AccessoryView)///在Cell右侧添加的一个自定义label@property (nonatomic,strong,readonly)UILabel *accessoryLabel;@property (nonatomic,strong,readonly)UIImageView *accessoryImageView;@end .m文件中重写getter方法 123456789101112131415161718192021222324252627282930313233@implementation UITableViewCell (AccessoryView)- (UILabel *)accessoryLabel&#123; for (id obj in self.subviews) &#123; if ([obj class] == [UILabel class]) &#123; [obj removeFromSuperview];//因为accessoryLabel是添加在cell上的，而没有在cell.contentView上。 &#125; &#125; UILabel * accessoryLabel = [[UILabel alloc]initWithFrame:CGRectMake(kWidth-200, 0, 160, CGRectGetHeight(self.frame))]; accessoryLabel.textColor = [UIColor lightGrayColor]; accessoryLabel.font = [UIFont systemFontOfSize:12]; accessoryLabel.textAlignment = NSTextAlignmentRight; [self addSubview:accessoryLabel]; return accessoryLabel;&#125;- (UIImageView *)accessoryImageView&#123; for (id obj in self.subviews) &#123; if ([obj class] == [UIImageView class]) &#123; [obj removeFromSuperview]; &#125; &#125; UIImageView *accessoryImageView = [[UIImageView alloc]initWithFrame:CGRectMake(kWidth-100, 10, 60, 60)]; accessoryImageView.layer.cornerRadius = 30; accessoryImageView.layer.masksToBounds = YES; [self addSubview:accessoryImageView]; return accessoryImageView; &#125;@end 如果我们添加一个普通的属性@property (nonatomic,strong)NSString * name;,那么implementation中会报warning： 2.运行时添加属性： 12345@interface NSError (Message)@property (nonatomic,copy)NSString * errorMsg;@end .m 1234567891011121314static void * strKey = &amp;strKey;@implementation NSError (Message)- (void)setErrorMsg:(NSString *)errorMsg&#123; objc_setAssociatedObject(self, &amp; strKey, errorMsg, OBJC_ASSOCIATION_COPY_NONATOMIC);&#125;- (NSString *)errorMsg&#123; return objc_getAssociatedObject(self, &amp;strKey);&#125;@end 在实际使用中，大多数时候还是用的category较多。后面会给出一些常用的类的category。","link":"/2015/12/03/Category添加属性所想到的/"},{"title":"Block实现原理","text":"Block一直是iOS开发中常用的技巧，类似于C语言中的指针函数。多用于参数回调，异步加载等。下面就来探究以下block是如何实现的。这篇是记录根据网上的文章进行的实际操作。C函数的生成中间编译代码的编译方法是clang -rewrite-objc xxxx.c。由于编译文件中内容较多，这里我们只截取有关block的部分。 首先，看看没有block的C函数以及编译后的结果：12345#include &lt;stdio.h&gt;int main()&#123; return 0;&#125; 编译代码中的block：这里我们可以看到一个block的C实现。12345678#ifndef BLOCK_IMPL#define BLOCK_IMPLstruct __block_impl &#123; void *isa; int Flags; int Reserved; void *FuncPtr;&#125;; *isa说明block也可以作为对象使用（例如我们定义一个myBlock类型的block1），指针变量FunPtr应该就是指向了block代码块的函数首地址接着我们加一个block到.c文件中，并进行编译。12345678910111213#include &lt;stdio.h&gt;int main()&#123;int i = 10;void(^myBlock)(void) = ^(void)&#123; printf(\"hello world! %d\\n\",i);&#125;;myBlock();return 0;&#125; 编译后：12345678910111213141516171819202122232425262728293031struct __main_block_impl_0 &#123; struct __block_impl impl; struct __main_block_desc_0* Desc; int i; __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int _i, int flags=0) : i(_i) &#123; impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; &#125;&#125;;static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123; int i = __cself-&gt;i; // bound by copy printf(\"hello world! %d\\n\",i); &#125;static struct __main_block_desc_0 &#123; size_t reserved; size_t Block_size;&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0)&#125;;int main()&#123; int i = 10; void(*myBlock)(void) = (void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, i); ((void (*)(__block_impl *))((__block_impl *)myBlock)-&gt;FuncPtr)((__block_impl *)myBlock); return 0;&#125; 3.假如我们要修改函数中局部变量的值，则需要加上__block修饰符，后面我们来看看为什么这样才可以修改。1234567891011121314#include &lt;stdio.h&gt;int main()&#123;__block int i = 10;void(^myBlock)(void) = ^(void)&#123;i = 12; printf(\"hello world! %d\\n\",i);&#125;;myBlock();return 0;&#125; 编译后的cpp代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445struct __Block_byref_i_0 &#123; void *__isa;__Block_byref_i_0 *__forwarding; int __flags; int __size; int i;&#125;;struct __main_block_impl_0 &#123; struct __block_impl impl; struct __main_block_desc_0* Desc; __Block_byref_i_0 *i; // by ref __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, __Block_byref_i_0 *_i, int flags=0) : i(_i-&gt;__forwarding) &#123; impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; &#125;&#125;;static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123; __Block_byref_i_0 *i = __cself-&gt;i; // bound by ref (i-&gt;__forwarding-&gt;i) = 12; printf(\"hello world! %d\\n\",(i-&gt;__forwarding-&gt;i)); &#125;static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) &#123;_Block_object_assign((void*)&amp;dst-&gt;i, (void*)src-&gt;i, 8/*BLOCK_FIELD_IS_BYREF*/);&#125;static void __main_block_dispose_0(struct __main_block_impl_0*src) &#123;_Block_object_dispose((void*)src-&gt;i, 8/*BLOCK_FIELD_IS_BYREF*/);&#125;static struct __main_block_desc_0 &#123; size_t reserved; size_t Block_size; void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*); void (*dispose)(struct __main_block_impl_0*);&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0&#125;;int main()&#123; __attribute__((__blocks__(byref))) __Block_byref_i_0 i = &#123;(void*)0,(__Block_byref_i_0 *)&amp;i, 0, sizeof(__Block_byref_i_0), 10&#125;; void(*myBlock)(void) = (void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, (__Block_byref_i_0 *)&amp;i, 570425344); ((void (*)(__block_impl *))((__block_impl *)myBlock)-&gt;FuncPtr)((__block_impl *)myBlock); return 0;&#125;","link":"/2015/12/16/Block实现原理/"},{"title":"NS_ENUM与NSString","text":"NS_ENUM与NSString 在项目中经常会使用到枚举类型：NS_ENUM,enum,但是系统提供的枚举类型只能设置为NSInteger类型，不能保存对象类型入NSString。传统的用#define 方式，Switch case 转换方式，另外还发现了如下几种方式： 12typedef enum &#123;value1, value2, value3&#125; myValue;#define myValueString(enum) [@[@\"value1\",@\"value2\",@\"value3\"] objectAtIndex:enum] 12345678910111213141516171819202122typedef enum &#123; a, b, c &#125; FirstThreeAlpha;- (NSString*) convertToString:(FirstThreeAlpha) whichAlpha &#123; NSString *result = nil; switch(whichAlpha) &#123; case a: result = @\"a\"; break; case b: result = @\"b\"; break; case c: result = @\"c\"; break; default: result = @\"unknown\"; &#125; return result;&#125; 12345678910111213typedef NS_ENUM(NSInteger,CabinetOperationType)&#123; CabinetOperationTypeNothing = 0, CabinetOperationTypeAdd = 1, //加入酒柜 CabinetOperationTypeTake = 2, //从酒柜提酒 CabinetOperationTypeAddAndSend = 3 //加入酒柜付款并直接赠予某人 &#125;;NSString *const CabinetOperationTypeString[] = &#123; [CabinetOperationTypeNothing] = @\"\", [CabinetOperationTypeAdd] = @\"1\", [CabinetOperationTypeTake] = @\"2\", [CabinetOperationTypeAddAndSend] = @\"3\"&#125;; 此法和上面的定义NSString数组相似，但是是用了函数思想。123456789101112131415161718192021222324typedef enum &#123; UIImageOrientationUp = 0, // default orientation, set to 0 so that it always starts from 0 UIImageOrientationDown, // 180 deg rotation UIImageOrientationLeft, // 90 deg CCW UIImageOrientationRight, // 90 deg CW UIImageOrientationUpMirrored, // as above but image mirrored along other axis. horizontal flip UIImageOrientationDownMirrored, // horizontal flip UIImageOrientationLeftMirrored, // vertical flip UIImageOrientationRightMirrored, // vertical flip&#125; UIImageOrientation;NSString *stringWithUIImageOrientation(UIImageOrientation input) &#123; NSArray *arr = @[ @\"UIImageOrientationUp\", // default orientation @\"UIImageOrientationDown\", // 180 deg rotation @\"UIImageOrientationLeft\", // 90 deg CCW @\"UIImageOrientationRight\", // 90 deg CW @\"UIImageOrientationUpMirrored\", // as above but image mirrored along other axis. horizontal flip @\"UIImageOrientationDownMirrored\", // horizontal flip @\"UIImageOrientationLeftMirrored\", // vertical flip @\"UIImageOrientationRightMirrored\", // vertical flip ]; return (NSString *)[arr objectAtIndex:input];&#125; 综合众多方案得出，要熟练使用typedef、#define 就可以提高效率。更多可以参考stackoverflow：enum Values to NSString (iOS)","link":"/2016/01/07/NS-ENUM与NSString/"},{"title":"MVVM in Practice","text":"MVVM in Practice - RWDevCon Session - raywenderlich.com MVVM已经被谈论很多了，却一直没有深入理解和实践，本篇是在观看该视频后的小结。 该视频中讲解了MVC到MVVM的迁移重构和重点，并没有涉及到FRP，初学者可以很快进入MVVM中。 概念MVVM： Model-View-ViewModel。通过分离ViewController中逻辑代码到独立的ViewModel中，实现业务逻辑分离和VC瘦身。 重点：Data BindingiOS中的数据绑定方式： KVO Delegate Funtional Reactive Programming Property Observer 1234567 var str = \"Hello, playground\" &#123; didSet &#123; print(\"new str : \\(str)\") &#125;&#125;str = \"hello swift\" 实现一个Data Binding类:Box 123456789101112131415161718192021222324252627class Box&lt;T&gt; &#123; typealias Listener = (T) -&gt; Void var listener : Listener? var value:T &#123; didSet &#123; listener?(value) &#125; &#125; init(_ value:T) &#123; self.value = value &#125; func bind(listener:Listener?) &#123; self.listener = listener listener?(value) &#125;&#125;var bindedObj = Box(\"\")bindedObj.bind &#123; print(\"new value:\\($0)\")&#125;bindedObj.value = \"2017\" 可以看出是使用了closure来实现bingding的。同理，Cocoa中的其他类都可以写一个extension实现绑定。 提问环节（只给出回答中的重点内容） 为什么ViewModel使用的是class而不是struct？ Ash：说是因为他认为这个ViewModel中不仅是数据逻辑，还包含有其他功能逻辑代码。 为什么dispatchAfter中使用weak self，而viewController中使用unowned self？ Ash：通常来说，weak修饰的变量有可能是为nil的，而unowned修饰的变量你会保证它不是optional的。 MVVM的Benifits和Limitation Benifits: Breaks up code by responsibility Simplifies Testing Code reusablibity Limitation: Requires binding(or other workarounds) Potential for boilerplate code Sometimes feels like overkill Doesn’t cover every case 延伸阅读 ReactiveCocoa/RxSwift Getting Started With RxSwift and RxCocoa","link":"/2017/08/30/MVVM-in-Practice/"},{"title":"QRCode与Core Image","text":"网上已经有很多关于二维码方面的文章了，写这篇文章的目的是因为要记录一个关于保存二维码图片到相册的问题，顺便回顾一下iOS开发中使用二维码的历史。好了，废话少说，让我们开始吧！ 要讨论的问题在参考Building a QR Code Generator with Core Image Filters这篇文章，完成了二维码生成的栗子。二维码的扫描则是用了AVFoundation框架来编写的Github·HLQRCode。最后想把生成的二维码图片保存到相册中却没有成功。参考了网上的代码，使用了CIImag-&gt;CGImage-&gt;writeImageToAlbum的方式。代码如下：1234567891011121314151617181920CIContext * context = [CIContext contextWithOptions:nil];CGImageRef cgimg = [context createCGImage:self.qrcodeImg fromRect:[self.qrcodeImg extent] ];ALAssetsLibrary *library = [[ALAssetsLibrary alloc] init];[library writeImageToSavedPhotosAlbum:cgimg metadata:[self.qrcodeImg properties] completionBlock:^(NSURL *assetURL, NSError *error) &#123; if(error != NULL)&#123; msg = @\"保存图片失败\" ; &#125;else&#123; NSLog(@\"%@\",assetURL); msg = @\"保存图片成功\" ; &#125; UIAlertView *alert = [[UIAlertView alloc] initWithTitle:nil message:msg delegate:self cancelButtonTitle:@\"确定\" otherButtonTitles:nil]; [alert show];&#125;];但是这样无论怎么样都无法在相册中看到保存的二维码图片。还报错message &quot;BSXPCMessage received error for message: Connection interrupted&quot;。对比参考的代码都是一样的，却找不出原因。我就在文章评论中留言问了这个问题，后来一个朋友提出了解决方案，仔细一看顿时恍然大悟。解决方式及要点 1CIContext * context = [CIContext contextWithOptions:@&#123;kCIContextUseSoftwareRenderer:@YES&#125;]; 看到区别了吗？是的，多了一个option参数kCIContextUseSoftwareRenderer.然后在development doc中查看了关于contextWithOptions方法的描述：contextWithOptions:You can create a CPU-based context by providing the key kCIContextUseSoftwareRenderer. A CPU-based context supports larger input and output images than a GPU-based context. It also allows your app to perform processing in the background, such as when saving the rendered output to the Photo Library. GPU rendering is faster than CPU rendering, but the resulting image is not displayed on the device until after is it copied to CPU memory and converted to another image type, such as a UIImage object. @Apple Development Docdeveloper.apple.com/library/prerelease/ios/documentation/GraphicsImaging/Reference/QuartzCoreFramework/Classes/CIContext_Class/index.html#//apple_ref/occ/clm/CIContext/contextWithOptions: 顿时觉得自己当时好笨，都没有想到去查一下开发文档。o(╯□╰)o NSString *kCIContextOutputColorSpace; - A key for the color space to use for images before they are rendered to the context. 使用OpenGLES NSString *kCIContextWorkingColorSpace; - A key for the color space to use for image operations. 使用OpenGLES NSString *kCIContextUseSoftwareRenderer; - A key for enabling software renderer use. If the associated NSNumber object is YES, then the software renderer is required. 使用CPU NSString *kCIContextPriorityRequestLow; - A key for enabling low-priority GPU use. NSString *kCIContextWorkingFormat; - An option for the color format to use for intermediate results when rendering with the context. contextWithOptions方法默认是在GPU上处理图像。根据不同的参数设置不同的处理方式。以上这些其实不是很理解，囧。具体参考Context Options 二维码的历史在iOS7以前，iOS开发使用二维码都是使用第三方库。比较流行的就是ZXing和Zbar了。不说它们的实现原理了，遇到最多的问题就是与其他第三方库（比如支付宝SDK，百度地图SDK）继承在一起时出现duplicate symbol了。解决方法也很麻烦：修改源码，重新编译静态库.a文件。 不过现在很少用到二维码了，要用也要用系统自带的框架哟~！ 总结1.遇到问题先查看开发文档，再Google！2.研究问题要深入！后面学习一下Core Image的东西，还有与之的GPUImage库！ 参考文章Core Image Programming GuideBSXPCMessage received error for message: Connection interrupted","link":"/2016/03/05/QRCode的那些事儿/"},{"title":"Xcode8中NavigationBar插入背景出错的解决方法","text":"insertSubview是把backgroundView插入到UINavigationBar中，UINavigationBar作为其superview。每次跳转回来之后，会重新赋值（可能）所以我们要把backgroundView放入到UIBarBackground中。 以前写过一个导航栏中插入背景改变导航栏背景色的类。 1insertSubview(backgroundView!, at: 0) 在xcode8 的view hierarchay表现为： 但是现在出现的问题是返回到首页后，导航栏被背景view遮盖了 解决方法：1self.subviews[0].insertSubview(backgroundView!, at: 0)","link":"/2016/10/05/Xcode8中NavigationBar插入背景出错的解决方法/"},{"title":"SDWebImage4.0源码阅读","text":"参拜一下SDWebImage的源码。并不是说一定要读如何如何、只是觉得源码的阅读是一种很好的学习方式。无论从架构还是技术点方面。 目录 常见疑问(面试大全？) 磁盘目录位于哪里？ 最大并发数、超时时长？ 图片如何命名？ 如何识别图片类型? 所查找到的图片的来源? 所有下载的图片都将被写入缓存？磁盘呢？何时缓存的？ 磁盘缓存的时长？清理操作的时间点？ 磁盘清理的原则？ 下载图片时、会使用缓存协议么? 下载图片的URL必须是NSURL么？ 读取缓存以及读取磁盘的时候如何保证线程安全？ 相关知识点 NS_OPTIONS枚举与位运算 内联函数 准备工作 工作原理 业务层级 核心代码(正常读取下载图片) 最上层：UIView+WebCache 逻辑层：SDWebImageManager 业务层： 缓存&amp;&amp;磁盘操作(SDImageCache) 下载操作(SDWebImageDownloader) 一些启发 分层的接口API设计 线程安全 内联函数 精细的缓存管理原则 回调设计 常见疑问(面试大全？)虽然我更推荐阅读源码、可如果实在没时间。这一段只要花费几分钟。我还是比较喜欢把干货放在前面、方便伸手党(比如我)。不过也不能保证涵盖全部问题、欢迎留言。 磁盘目录位于哪里？ 缓存在磁盘沙盒目录下 Library/Caches二级目录为~/Library/Caches/default/com.hackemist.SDWebImageCache.default 12345678910111213141516171819202122232425- (instancetype)init &#123; return [self initWithNamespace:@&quot;default&quot;]; // ~Library/Caches/default&#125;- (nonnull instancetype)initWithNamespace:(nonnull NSString *)ns &#123; NSString *path = [self makeDiskCachePath:ns]; return [self initWithNamespace:ns diskCacheDirectory:path];&#125;- (nonnull instancetype)initWithNamespace:(nonnull NSString *)ns diskCacheDirectory:(nonnull NSString *)directory &#123; if ((self = [super init])) &#123; NSString *fullNamespace = [@&quot;com.hackemist.SDWebImageCache.&quot; stringByAppendingString:ns] // Init the disk cache if (directory != nil) &#123; _diskCachePath = [directory stringByAppendingPathComponent:fullNamespace]; &#125; else &#123; NSString *path = [self makeDiskCachePath:ns]; _diskCachePath = path; &#125;// _diskCachePath = ~/Library/Caches/default/com.hackemist.SDWebImageCache.default&#125; 你也可以通过[[SDImageCache sharedImageCache] addReadOnlyCachePath:bundledPath];来自定义一个路径。 但这个路径不会被存储使用、是给开发者自定义预装图片的路径。 最大并发数、超时时长？ 123_downloadQueue = [NSOperationQueue new];_downloadQueue.maxConcurrentOperationCount = 6;_downloadTimeout = 15.0; 图片如何命名？ 这里写入缓存和写入磁盘是不同的。写入缓存时、直接用图片url作为key 123//写入缓存NSUInteger cost = SDCacheCostForImage(image);[self.memCache setObject:image forKey:key cost:cost]; 写入磁盘时、用url的MD5编码作为key。可以防止文件名过长 12345678910111213141516- (nullable NSString *)cachedFileNameForKey:(nullable NSString *)key &#123; const char *str = key.UTF8String; if (str == NULL) &#123; str = &quot;&quot;; &#125; unsigned char r[CC_MD5_DIGEST_LENGTH]; CC_MD5(str, (CC_LONG)strlen(str), r); NSURL *keyURL = [NSURL URLWithString:key]; NSString *ext = keyURL ? keyURL.pathExtension : key.pathExtension; NSString *filename = [NSString stringWithFormat:@&quot;%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%@&quot;, r[0], r[1], r[2], r[3], r[4], r[5], r[6], r[7], r[8], r[9], r[10], r[11], r[12], r[13], r[14], r[15], ext.length == 0 ? @&quot;&quot; : [NSString stringWithFormat:@&quot;.%@&quot;, ext]]; return filename; //key == https://gss2.bdstatic.com/-fo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=034361ab922397ddc274905638ebd9d2/d31b0ef41bd5ad64dddebb.jpg; //filename == f029945f95894e152771806785bc4f18.jpg;&#125; 如何识别图片类型? 通过NSData数据的第一个字符进行判断。 1234567891011121314151617181920212223242526272829303132333435363738394041424344+ (SDImageFormat)sd_imageFormatForImageData:(nullable NSData *)data &#123; if (!data) &#123; return SDImageFormatUndefined; &#125; // File signatures table: http://www.garykessler.net/library/file_sigs.html uint8_t c; [data getBytes:&amp;c length:1]; switch (c) &#123; case 0xFF: return SDImageFormatJPEG; case 0x89: return SDImageFormatPNG; case 0x47: return SDImageFormatGIF; case 0x49: case 0x4D: return SDImageFormatTIFF; case 0x52: &#123; if (data.length &gt;= 12) &#123; //RIFF....WEBP NSString *testString = [[NSString alloc] initWithData:[data subdataWithRange:NSMakeRange(0, 12)] encoding:NSASCIIStringEncoding]; if ([testString hasPrefix:@&quot;RIFF&quot;] &amp;&amp; [testString hasSuffix:@&quot;WEBP&quot;]) &#123; return SDImageFormatWebP; &#125; &#125; break; &#125; case 0x00: &#123; if (data.length &gt;= 12) &#123; //....ftypheic ....ftypheix ....ftyphevc ....ftyphevx NSString *testString = [[NSString alloc] initWithData:[data subdataWithRange:NSMakeRange(4, 8)] encoding:NSASCIIStringEncoding]; if ([testString isEqualToString:@&quot;ftypheic&quot;] || [testString isEqualToString:@&quot;ftypheix&quot;] || [testString isEqualToString:@&quot;ftyphevc&quot;] || [testString isEqualToString:@&quot;ftyphevx&quot;]) &#123; return SDImageFormatHEIC; &#125; &#125; break; &#125; &#125; return SDImageFormatUndefined;&#125; 所查找到的图片的来源? 1234567891011121314typedef NS_ENUM(NSInteger, SDImageCacheType) &#123; /** * 从网上下载 */ SDImageCacheTypeNone, /** * 从磁盘获得 */ SDImageCacheTypeDisk, /** * 从内存获得 */ SDImageCacheTypeMemory&#125;; 所有下载的图片都将被写入缓存？磁盘呢？何时缓存的？ 磁盘不是强制写入。从枚举SDWebImageOptions可见 1234567typedef NS_OPTIONS(NSUInteger, SDWebImageOptions) &#123; /** * 禁用磁盘缓存 */ SDWebImageCacheMemoryOnly = 1 &lt;&lt; 2,&#125; 而Memory缓存应该是必须写入的(因为我并没找到哪里可以禁止)。缓存的时间点、有两个(开发者也可以主动缓存)、且都是由SDWebImageManager进行。其一是下载成功后、自动保存。或者开发者通过代理处理图片并返回后缓存 123456789101112131415- (nullable UIImage *)imageManager:(nonnull SDWebImageManager *)imageManager transformDownloadedImage:(nullable UIImage *)image withURL:(nullable NSURL *)imageURL;=========&gt;&gt;SDWebImageManager//获取转换用户后的图片UIImage *transformedImage = [self.delegate imageManager:self transformDownloadedImage:downloadedImage withURL:url];//用户处理成功if (transformedImage &amp;&amp; finished) &#123; BOOL imageWasTransformed = ![transformedImage isEqual:downloadedImage]; //用户处理的后若未生成新的图片、则保存下载的二进制文件。 //不然则由imageCache内部生成二进制文件保存 [self.imageCache storeImage:transformedImage imageData:(imageWasTransformed ? nil : downloadedData) forKey:key toDisk:cacheOnDisk completion:nil];&#125; 其二是当缓存中没有、但是从硬盘中查询到了图片。 12345678910111213141516@autoreleasepool &#123; //搜索硬盘 NSData *diskData = [self diskImageDataBySearchingAllPathsForKey:key]; UIImage *diskImage = [self diskImageForKey:key]; //缓存到内存、默认为YES if (diskImage &amp;&amp; self.config.shouldCacheImagesInMemory) &#123; NSUInteger cost = SDCacheCostForImage(diskImage); //使用NSChache缓存。 [self.memCache setObject:diskImage forKey:key cost:cost]; &#125; if (doneBlock) &#123; dispatch_async(dispatch_get_main_queue(), ^&#123; doneBlock(diskImage, diskData, SDImageCacheTypeDisk); &#125;); &#125;&#125; 磁盘缓存的时长？清理操作的时间点？ 默认为一周1static const NSInteger kDefaultCacheMaxCacheAge = 60 * 60 * 24 * 7; // 1 week 能够以时间清除磁盘的方法为 1- (void)deleteOldFilesWithCompletionBlock:(nullable SDWebImageNoParamsBlock)completionBlock; 调用的时机为 12345678[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(deleteOldFiles) name:UIApplicationWillTerminateNotification object:nil]; [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(backgroundDeleteOldFiles) name:UIApplicationDidEnterBackgroundNotification object:nil]; 也就是当程序退出到后台、或者被杀死的时候。这里、还有另外一个点。Long-Running Task任务 12345678910111213141516171819202122- (void)backgroundDeleteOldFiles &#123; Class UIApplicationClass = NSClassFromString(@&quot;UIApplication&quot;); if(!UIApplicationClass || ![UIApplicationClass respondsToSelector:@selector(sharedApplication)]) &#123; return; &#125; UIApplication *application = [UIApplication performSelector:@selector(sharedApplication)]; //后台任务标识--注册一个后台任务 __block UIBackgroundTaskIdentifier bgTask = [application beginBackgroundTaskWithExpirationHandler:^&#123; //超时（大概150秒？）自动结束后台任务 //结束后台任务 [application endBackgroundTask:bgTask]; bgTask = UIBackgroundTaskInvalid; &#125;]; [self deleteOldFilesWithCompletionBlock:^&#123; //结束后台任务 [application endBackgroundTask:bgTask]; bgTask = UIBackgroundTaskInvalid; &#125;];&#125; 正常程序在进入后台后、虽然可以继续执行任务。但是在时间很短内就会被挂起待机。Long-Running可以让系统为app再多分配一些时间来处理一些耗时任务。 磁盘清理的原则？ 首先、通过时间进行清理。（最后修改时间&gt;一周）然后、根据占据内存大小进行清理。（如果占据内存大于上限、则按时间排序、删除到上限的1/2。）这里我并没有看到使用频率优先级判断、所以应该是没有。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687- (void)deleteOldFilesWithCompletionBlock:(nullable SDWebImageNoParamsBlock)completionBlock &#123; //异步清理超时图片 dispatch_async(self.ioQueue, ^&#123; //获取磁盘目录 NSURL *diskCacheURL = [NSURL fileURLWithPath:self.diskCachePath isDirectory:YES]; //NSURLIsDirectoryKey 判断是否为目录 //NSURLContentModificationDateKey 判断最后修改时间 //NSURLTotalFileAllocatedSizeKey 判断文件大小 NSArray&lt;NSString *&gt; *resourceKeys = @[NSURLIsDirectoryKey, NSURLContentModificationDateKey, NSURLTotalFileAllocatedSizeKey]; //模具器--遍历磁盘路径下的文件 NSDirectoryEnumerator *fileEnumerator = [_fileManager enumeratorAtURL:diskCacheURL includingPropertiesForKeys:resourceKeys options:NSDirectoryEnumerationSkipsHiddenFiles errorHandler:NULL]; //计算一周前(需要释放)、的时间 NSDate *expirationDate = [NSDate dateWithTimeIntervalSinceNow:-self.config.maxCacheAge]; //保存缓存文件Dic NSMutableDictionary&lt;NSURL *, NSDictionary&lt;NSString *, id&gt; *&gt; *cacheFiles = [NSMutableDictionary dictionary]; //缓存总大小 NSUInteger currentCacheSize = 0; //需要删除的url路径 NSMutableArray&lt;NSURL *&gt; *urlsToDelete = [[NSMutableArray alloc] init]; //遍历磁盘文件枚举器 for (NSURL *fileURL in fileEnumerator) &#123; NSError *error; //获取每个文件所对应的三个参数（resourceKeys） NSDictionary&lt;NSString *, id&gt; *resourceValues = [fileURL resourceValuesForKeys:resourceKeys error:&amp;error]; // Skip directories and errors. if (error || !resourceValues || [resourceValues[NSURLIsDirectoryKey] boolValue]) &#123; //如果是文件夹则跳过 continue; &#125; // Remove files that are older than the expiration date; NSDate *modificationDate = resourceValues[NSURLContentModificationDateKey]; if ([[modificationDate laterDate:expirationDate] isEqualToDate:expirationDate]) &#123; //如果时间超过指定日期、加入删除数组。跳过 [urlsToDelete addObject:fileURL]; continue; &#125; //获取文件大小、并且把路径与大小存入字典。 // Store a reference to this file and account for its total size. NSNumber *totalAllocatedSize = resourceValues[NSURLTotalFileAllocatedSizeKey]; currentCacheSize += totalAllocatedSize.unsignedIntegerValue; cacheFiles[fileURL] = resourceValues; &#125; //遍历删除文件 for (NSURL *fileURL in urlsToDelete) &#123; [_fileManager removeItemAtURL:fileURL error:nil]; &#125; //如果剩余文件大小仍超过阈值 //优先删除最老的文件 if (self.config.maxCacheSize &gt; 0 &amp;&amp; currentCacheSize &gt; self.config.maxCacheSize) &#123; // Target half of our maximum cache size for this cleanup pass. const NSUInteger desiredCacheSize = self.config.maxCacheSize / 2; // 将剩余的文件按修改时间排序 NSArray&lt;NSURL *&gt; *sortedFiles = [cacheFiles keysSortedByValueWithOptions:NSSortConcurrent usingComparator:^NSComparisonResult(id obj1, id obj2) &#123; return [obj1[NSURLContentModificationDateKey] compare:obj2[NSURLContentModificationDateKey]]; &#125;]; // 删除文件 for (NSURL *fileURL in sortedFiles) &#123; if ([_fileManager removeItemAtURL:fileURL error:nil]) &#123; NSDictionary&lt;NSString *, id&gt; *resourceValues = cacheFiles[fileURL]; NSNumber *totalAllocatedSize = resourceValues[NSURLTotalFileAllocatedSizeKey]; currentCacheSize -= totalAllocatedSize.unsignedIntegerValue; //直到低于阈值的二分之一 if (currentCacheSize &lt; desiredCacheSize) &#123; break; &#125; &#125; &#125; &#125; //回调给主线程 if (completionBlock) &#123; dispatch_async(dispatch_get_main_queue(), ^&#123; completionBlock(); &#125;); &#125; &#125;);&#125; 下载图片时、会使用网络协议缓存逻辑么? 默认情况下不会、由以下代码可见。 1234NSURLRequestCachePolicy cachePolicy = options &amp; SDWebImageDownloaderUseNSURLCache ? NSURLRequestUseProtocolCachePolicy : NSURLRequestReloadIgnoringLocalCacheData; NSMutableURLRequest *request = [[NSMutableURLRequest alloc] initWithURL:url cachePolicy:cachePolicy timeoutInterval:timeoutInterval]; 除非将options配置成SDWebImageDownloaderUseNSURLCache、否则每次都会从原地址重新下载、而不是用网络协议的缓存逻辑。 下载图片的URL必须是NSURL么？ 不是、在SDWebImageManager中有过容错处理。所以即便你传入一个字符串、依旧可以正确的查找。 1234567if ([url isKindOfClass:NSString.class]) &#123; url = [NSURL URLWithString:(NSString *)url]; &#125; if (![url isKindOfClass:NSURL.class]) &#123; url = nil; &#125; 但是由于API暴露出的是(nullable NSURL *)、如果你传入字符串、会有黄色警告 读取缓存以及读取磁盘的时候如何保证线程安全？ 读取缓存读取缓存的时候是在主线程进行。由于使用NSCache进行存储、所以不需要担心单个value对象的线程安全。 读取磁盘磁盘的读取虽然创建了一个NSOperation对象、但据我所见这个对象只是用来标记该操作是否被取消、以及取消之后不再读取磁盘文件的作用。真正的磁盘缓存是在另一个IO专属线程中的一个串行队列下进行的。如果你搜索self.ioQueue还能发现、不只是读取磁盘内容。包括删除、写入等所有磁盘内容都是在这个IO线程进行、以保证线程安全。但计算大小、获取文件总数等操作。则是在主线程进行。 12345678910111213141516171819202122232425262728_ioQueue = dispatch_queue_create(&quot;com.hackemist.SDWebImageCache&quot;, DISPATCH_QUEUE_SERIAL);==========&gt;&gt;&gt;&gt;&gt;&lt;&lt;&lt;&lt;&lt;&lt;===========NSOperation *operation = [NSOperation new]; dispatch_async(self.ioQueue, ^&#123; if (operation.isCancelled) &#123; // do not call the completion if cancelled return; &#125; @autoreleasepool &#123; //搜索硬盘 NSData *diskData = [self diskImageDataBySearchingAllPathsForKey:key]; UIImage *diskImage = [self diskImageForKey:key]; //缓存到内存、默认为YES if (diskImage &amp;&amp; self.config.shouldCacheImagesInMemory) &#123; NSUInteger cost = SDCacheCostForImage(diskImage); //使用NSChache缓存。 [self.memCache setObject:diskImage forKey:key cost:cost]; &#125; if (doneBlock) &#123; dispatch_async(dispatch_get_main_queue(), ^&#123; doneBlock(diskImage, diskData, SDImageCacheTypeDisk); &#125;); &#125; &#125; &#125;); return operation; 相关知识点如果对一些知识点不了解、可能对代码理解造成困扰。列举一下。 NS_OPTIONS枚举与位运算 上文中的SDWebImageOptions便是一个位移枚举 123456789101112131415typedef NS_OPTIONS(NSUInteger, SDWebImageOptions) &#123; SDWebImageRetryFailed = 1 &lt;&lt; 0, SDWebImageLowPriority = 1 &lt;&lt; 1, SDWebImageCacheMemoryOnly = 1 &lt;&lt; 2, SDWebImageProgressiveDownload = 1 &lt;&lt; 3, SDWebImageRefreshCached = 1 &lt;&lt; 4, SDWebImageContinueInBackground = 1 &lt;&lt; 5, SDWebImageHandleCookies = 1 &lt;&lt; 6, SDWebImageAllowInvalidSSLCertificates = 1 &lt;&lt; 7, SDWebImageHighPriority = 1 &lt;&lt; 8, SDWebImageDelayPlaceholder = 1 &lt;&lt; 9, SDWebImageTransformAnimatedImage = 1 &lt;&lt; 10, SDWebImageAvoidAutoSetImage = 1 &lt;&lt; 11, SDWebImageScaleDownLargeImages = 1 &lt;&lt; 12&#125;; 和我们普通用的枚举 12345typedef NS_ENUM(NSInteger, SDImageCacheType) &#123; SDImageCacheTypeNone, SDImageCacheTypeDisk, SDImageCacheTypeMemory&#125;; 从表面看有两点不同： 枚举声明：NS_ENUM&amp;&amp; NS_OPTIONS其实从定义的效果上来讲、二者作用相同。更多的是语义化的角度。前者是普通枚举、后者是位移枚举。 枚举中的位运算符号&lt;&lt;.位运算中、有三种基本运算符号. 按位与”&amp;” 只有对应的两个二进位均为1时，结果位才为1，否则为0比如9&amp;5，其实就是1001&amp;0101=0001，因此9&amp;5=1&gt;二进制中，与1相&amp;就保持原位，与0相&amp;就为0 按位或”|” 只要对应的二个二进位有一个为1时，结果位就为1，否则为0。比如9|5，其实就是1001|0101=1101，因此9|5=13 左移”&lt;&lt;” 把整数a的各二进位全部左移n位，高位丢弃，低位补0。左移n位其实就是乘以2的n次方。例如1&lt;&lt;2 就是0001左移2为0100，因此1&lt;&lt;2=4 于是、在使用位移枚举的时候、我们就有了这种写法：1options:SDWebImageRetryFailed | SDWebImageCacheMemoryOnly]; 上面的意思是。这个操作是如果失败了需要重试、并且只写入缓存。其中 options=SDWebImageRetryFailed | SDWebImageCacheMemoryOnly也就是0b00000001| 0b00000100 = 0b00000101 十进制中 = 5. 在内部判断时候就有了如下写法：12//是否磁盘缓存BOOL cacheOnDisk = !(options &amp; SDWebImageCacheMemoryOnly); 等价于 0101 &amp; 0100 = 0100 结果为真。倘若 1BOOL lowPriority = !(options &amp; SDWebImageLowPriority); 等价于 0101 &amp; 0010 = 0000 结果为假。 内联函数 在写入缓存时、出现了这样一行代码 12NSUInteger cost = SDCacheCostForImage(diskImage);[self.memCache setObject:diskImage forKey:key cost:cost]; 其中SDCacheCostForImage指向一个静态内联函数 1234567FOUNDATION_STATIC_INLINE NSUInteger SDCacheCostForImage(UIImage *image) &#123;#if SD_MAC return image.size.height * image.size.width;#elif SD_UIKIT || SD_WATCH return image.size.height * image.size.width * image.scale * image.scale;#endif&#125; 其中FOUNDATION_STATIC_INLINE作为宏指向static inline、所以也等价于 1234567static __inline__ NSUInteger SDCacheCostForImage(UIImage *image) &#123;#if SD_MAC return image.size.height * image.size.width;#elif SD_UIKIT || SD_WATCH return image.size.height * image.size.width * image.scale * image.scale;#endif&#125; 用宏写方法、我们都用过。但是表达式形式的宏定义有一定的弊端。（比如参数检查、越界等等）。 内联函数完全可以取代表达式形式的宏定义。顺便谈谈为什么要用内联函数吧。 效率来看 函数之间调用，是内存地址之间的调用、当函数调用完毕之后还会返回原来函数执行的地址。函数调用将会有时间开销。 内联函数在汇编中没有call语句。取消了函数的参数压栈 相比表达式形式的宏定义 需要预编译.因为inline内联函数也是函数、不需要预编译。 调用时候会首先检查它的参数的类型、保证调用正确。 可以使用所在类的保护成员及私有成员。 需要注意的是 内联函数中尽量不要使用诸如循环语句等大量代码、可能会导致编译器放弃内联动作。 内联函数的定义须在调用之前。 准备工作随手下载了一个最新的 (4.2.3) GitHub1234567891011121314PODS:- SDWebImage (4.2.3):- SDWebImage/Core (= 4.2.3)- SDWebImage/Core (4.2.3)DEPENDENCIES:- SDWebImageSPEC CHECKSUMS:SDWebImage: 791bb72962b3492327ddcac4b1880bd1b5458431PODFILE CHECKSUM: 7fbc0b76fb4d0b0b2afa7d3a90b7bd68dea25abbCOCOAPODS: 1.3.1 工作原理引用GitHub上一个导图 1、外部API入口。通过UIImageView+WebCache 的 sd_setImageWithURL方法(等)作为入口来加载图片。 2、内部API汇总。通过UIView+WebCache的’sd_internalSetImageWithURL’对UIImageView、UIButton 、MKAnnotationView中图片的下载请求进行汇总。 3、开始加载图片。通过SDWebImageManager的loadImageWithURL对图片进行加载。 4、查找本地通过SDImageCache的queryCacheOperationForKey查找缓存中是否存在图片。如果不存在再通过diskImageDataBySearchingAllPathsForKey进行磁盘搜索。 5、返回本地图片给SDWebImageManager 6、下载图片如果本地查询不到对应图片、则通过SDImageDownloader的downloadImage进行图片下载。 7、下载完毕返回图片给SDWebImageManager 8、由UIView+WebCache通过storeImage将下载图片保存本地 9、返回图片给UIView+WebCache 10、设置图片其中。 业务层级 整个架构简单分为三层。 最上层：负责业务的接入、图片的插入 12345#import &quot;UIImageView+WebCache.h&quot;#import &quot;UIButton+WebCache.h&quot;#import &quot;UIImageView+HighlightedWebCache.h&quot;//以及其汇总的#import &quot;UIView+WebCache.h&quot; 逻辑层负责不同类型业务的分发。读取(或写入)缓存(或磁盘)、下载等具体逻辑处理。 1#import &quot;SDWebImageManager.h&quot; 业务层负责具体业务的实现 1234//缓存&amp;&amp;磁盘操作#import &quot;SDImageCache.h&quot;//下载操作#import &quot;SDWebImageDownloader.h&quot; 当然、还有其他的工具类。但主要的、就是上面几个。 核心代码（正常读取下载图片） 最上层：UIView+WebCache 所有的代码最终都会汇总到 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131#import &quot;UIView+WebCache.h&quot;/** * @param url 图片地址链接 * @param placeholder 占位图 * @param options 下载图片的枚举。包括优先级、是否写入硬盘等 * @param operationKey 一个记录当前对象正在加载操作的key、保证只有最新的操作在进行、默认为类名。 所以如果你想下载多个图片并且都展示一下、可以尝试自定义几个operationKey来操作。（我猜） * @param setImageBlock 给开发者自定义set图片的callback * @param progressBlock 下载进度callback * @param completedBlock 下载完成的callback（sd已经给你set好了、只是会把图片给你罢了） * @param context 一些额外的上下文字典。比如你可以搞一个专属的imageManager进来干活。 */- (void)sd_internalSetImageWithURL:(nullable NSURL *)url placeholderImage:(nullable UIImage *)placeholder options:(SDWebImageOptions)options operationKey:(nullable NSString *)operationKey setImageBlock:(nullable SDSetImageBlock)setImageBlock progress:(nullable SDWebImageDownloaderProgressBlock)progressBlock completed:(nullable SDExternalCompletionBlock)completedBlock context:(nullable NSDictionary *)context &#123; //以当前实例的class作为OperationKey NSString *validOperationKey = operationKey ?: NSStringFromClass([self class]); //清除当前OperationKey下正在进行的操作。节省无用功 [self sd_cancelImageLoadOperationWithKey:validOperationKey]; //给对象实例绑定imageURLKey = url objc_setAssociatedObject(self, &amp;imageURLKey, url, OBJC_ASSOCIATION_RETAIN_NONATOMIC); //是否先加载占位图 if (!(options &amp; SDWebImageDelayPlaceholder)) &#123; if ([context valueForKey:SDWebImageInternalSetImageGroupKey]) &#123; dispatch_group_t group = [context valueForKey:SDWebImageInternalSetImageGroupKey]; dispatch_group_enter(group); &#125; //到主线城更新UI dispatch_main_async_safe(^&#123; //set 占位图 [self sd_setImage:placeholder imageData:nil basedOnClassOrViaCustomSetImageBlock:setImageBlock]; &#125;); &#125; if (url) &#123; // 小菊花 if ([self sd_showActivityIndicatorView]) &#123; [self sd_addActivityIndicator]; &#125; // 允许开发者指定一个manager来进行操作 SDWebImageManager *manager; if ([context valueForKey:SDWebImageExternalCustomManagerKey]) &#123; manager = (SDWebImageManager *)[context valueForKey:SDWebImageExternalCustomManagerKey]; &#125; else &#123; manager = [SDWebImageManager sharedManager]; &#125; __weak __typeof(self)wself = self; id &lt;SDWebImageOperation&gt; operation = [manager loadImageWithURL:url options:options progress:progressBlock completed:^(UIImage *image, NSData *data, NSError *error, SDImageCacheType cacheType, BOOL finished, NSURL *imageURL) &#123; //图片下载||读取完成 __strong __typeof (wself) sself = wself; //小菊花 [sself sd_removeActivityIndicator]; if (!sself) &#123; return; &#125; BOOL shouldCallCompletedBlock = finished || (options &amp; SDWebImageAvoidAutoSetImage); //是否不插入图片 //1、有图片、但是主动配置 //2、没图片、设置了延迟加载占位图 BOOL shouldNotSetImage = ((image &amp;&amp; (options &amp; SDWebImageAvoidAutoSetImage)) || (!image &amp;&amp; !(options &amp; SDWebImageDelayPlaceholder))); SDWebImageNoParamsBlock callCompletedBlockClojure = ^&#123; // if (!sself) &#123; return; &#125; if (!shouldNotSetImage) &#123; [sself sd_setNeedsLayout]; &#125; if (completedBlock &amp;&amp; shouldCallCompletedBlock) &#123; //操作完成的回调 completedBlock(image, error, cacheType, url); &#125; &#125;; // case 1a: we got an image, but the SDWebImageAvoidAutoSetImage flag is set // OR // case 1b: we got no image and the SDWebImageDelayPlaceholder is not set if (shouldNotSetImage) &#123; //如果不显示图片、直接回调。 dispatch_main_async_safe(callCompletedBlockClojure); return; &#125; /**自动插入图片***/ UIImage *targetImage = nil; NSData *targetData = nil; if (image) &#123; // case 2a: we got an image and the SDWebImageAvoidAutoSetImage is not set targetImage = image; targetData = data; &#125; else if (options &amp; SDWebImageDelayPlaceholder) &#123; // case 2b: we got no image and the SDWebImageDelayPlaceholder flag is set targetImage = placeholder; targetData = nil; &#125; if ([context valueForKey:SDWebImageInternalSetImageGroupKey]) &#123; dispatch_group_t group = [context valueForKey:SDWebImageInternalSetImageGroupKey]; dispatch_group_enter(group); dispatch_main_async_safe(^&#123; [sself sd_setImage:targetImage imageData:targetData basedOnClassOrViaCustomSetImageBlock:setImageBlock]; &#125;); // ensure completion block is called after custom setImage process finish dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123; callCompletedBlockClojure(); &#125;); &#125; else &#123; dispatch_main_async_safe(^&#123; [sself sd_setImage:targetImage imageData:targetData basedOnClassOrViaCustomSetImageBlock:setImageBlock]; callCompletedBlockClojure(); &#125;); &#125; &#125;]; //在读取图片之前。向正在进行加载的HashMap中加入当前operation [self sd_setImageLoadOperation:operation forKey:validOperationKey]; &#125; else &#123; dispatch_main_async_safe(^&#123; [self sd_removeActivityIndicator]; if (completedBlock) &#123; NSError *error = [NSError errorWithDomain:SDWebImageErrorDomain code:-1 userInfo:@&#123;NSLocalizedDescriptionKey : @&quot;Trying to load a nil url&quot;&#125;]; completedBlock(nil, error, SDImageCacheTypeNone, url); &#125; &#125;); &#125;&#125; 一个简单的流程图 UIView+WebCache流程图 逻辑层：SDWebImageManager SDWebImage中最核心的类、调度这图片的下载(SDWebImageDownloader)以及缓存(SDImageCache)。 此外、SDWebImageManager并不依托于UIView+WebCache、完全可以单独使用。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169- (id &lt;SDWebImageOperation&gt;)loadImageWithURL:(nullable NSURL *)url options:(SDWebImageOptions)options progress:(nullable SDWebImageDownloaderProgressBlock)progressBlock completed:(nullable SDInternalCompletionBlock)completedBlock &#123; NSAssert(completedBlock != nil, @&quot;If you mean to prefetch the image, use -[SDWebImagePrefetcher prefetchURLs] instead&quot;); //所以、我们并不需要在外部把字符串变为NSURL。 if ([url isKindOfClass:NSString.class]) &#123; url = [NSURL URLWithString:(NSString *)url]; &#125; if (![url isKindOfClass:NSURL.class]) &#123; url = nil; &#125; //下载操作的对象 __block SDWebImageCombinedOperation *operation = [SDWebImageCombinedOperation new]; __weak SDWebImageCombinedOperation *weakOperation = operation; BOOL isFailedUrl = NO; if (url) &#123; @synchronized (self.failedURLs) &#123; //线程安全 isFailedUrl = [self.failedURLs containsObject:url]; &#125; &#125; //url为空 || (未设置失败重试 &amp;&amp; 这个url已经失败过) if (url.absoluteString.length == 0 || (!(options &amp; SDWebImageRetryFailed) &amp;&amp; isFailedUrl)) &#123; //发出一个获取失败的回调 [self callCompletionBlockForOperation:operation completion:completedBlock error:[NSError errorWithDomain:NSURLErrorDomain code:NSURLErrorFileDoesNotExist userInfo:nil] url:url]; return operation; &#125; //将操作添加到正在进行的操作数池 @synchronized (self.runningOperations) &#123; [self.runningOperations addObject:operation]; &#125; //默认就是url作为key、也可以自定义mananger的相关block NSString *key = [self cacheKeyForURL:url]; //通过key、查找本地图片 operation.cacheOperation = [self.imageCache queryCacheOperationForKey:key done:^(UIImage *cachedImage, NSData *cachedData, SDImageCacheType cacheType) &#123; if (operation.isCancelled) &#123; //操作被取消、移除操作池 [self safelyRemoveOperationFromRunning:operation]; return; &#125; //本地没有图片 || 刷新缓存 if ((!cachedImage || options &amp; SDWebImageRefreshCached) &amp;&amp; (![self.delegate respondsToSelector:@selector(imageManager:shouldDownloadImageForURL:)] || [self.delegate imageManager:self shouldDownloadImageForURL:url])) &#123; //有本地图片。但需要被刷新 if (cachedImage &amp;&amp; options &amp; SDWebImageRefreshCached) &#123; //先回调出去本地图片。再继续下载操作 [self callCompletionBlockForOperation:weakOperation completion:completedBlock image:cachedImage data:cachedData error:nil cacheType:cacheType finished:YES url:url]; &#125; //下面是根据调用者传进来的option，来匹配设置了哪些，就给downloaderOptions赋值哪些option SDWebImageDownloaderOptions downloaderOptions = 0; if (options &amp; SDWebImageLowPriority) downloaderOptions |= SDWebImageDownloaderLowPriority; if (options &amp; SDWebImageProgressiveDownload) downloaderOptions |= SDWebImageDownloaderProgressiveDownload; if (options &amp; SDWebImageRefreshCached) downloaderOptions |= SDWebImageDownloaderUseNSURLCache; if (options &amp; SDWebImageContinueInBackground) downloaderOptions |= SDWebImageDownloaderContinueInBackground; if (options &amp; SDWebImageHandleCookies) downloaderOptions |= SDWebImageDownloaderHandleCookies; if (options &amp; SDWebImageAllowInvalidSSLCertificates) downloaderOptions |= SDWebImageDownloaderAllowInvalidSSLCertificates; if (options &amp; SDWebImageHighPriority) downloaderOptions |= SDWebImageDownloaderHighPriority; if (options &amp; SDWebImageScaleDownLargeImages) downloaderOptions |= SDWebImageDownloaderScaleDownLargeImages; if (cachedImage &amp;&amp; options &amp; SDWebImageRefreshCached) &#123; // force progressive off if image already cached but forced refreshing downloaderOptions &amp;= ~SDWebImageDownloaderProgressiveDownload; // ignore image read from NSURLCache if image if cached but force refreshing downloaderOptions |= SDWebImageDownloaderIgnoreCachedResponse; &#125; //下载图片 SDWebImageDownloadToken *subOperationToken = [self.imageDownloader downloadImageWithURL:url options:downloaderOptions progress:progressBlock completed:^(UIImage *downloadedImage, NSData *downloadedData, NSError *error, BOOL finished) &#123; __strong __typeof(weakOperation) strongOperation = weakOperation; if (!strongOperation || strongOperation.isCancelled) &#123; // Do nothing if the operation was cancelled // See #699 for more details // if we would call the completedBlock, there could be a race condition between this block and another completedBlock for the same object, so if this one is called second, we will overwrite the new data &#125; else if (error) &#123; [self callCompletionBlockForOperation:strongOperation completion:completedBlock error:error url:url]; if ( error.code != NSURLErrorNotConnectedToInternet &amp;&amp; error.code != NSURLErrorCancelled &amp;&amp; error.code != NSURLErrorTimedOut &amp;&amp; error.code != NSURLErrorInternationalRoamingOff &amp;&amp; error.code != NSURLErrorDataNotAllowed &amp;&amp; error.code != NSURLErrorCannotFindHost &amp;&amp; error.code != NSURLErrorCannotConnectToHost &amp;&amp; error.code != NSURLErrorNetworkConnectionLost) &#123; @synchronized (self.failedURLs) &#123; //失败记录 [self.failedURLs addObject:url]; &#125; &#125; &#125; else &#123; if ((options &amp; SDWebImageRetryFailed)) &#123; //失败重新下载 @synchronized (self.failedURLs) &#123; //从失败记录移除 [self.failedURLs removeObject:url]; &#125; &#125; //是否磁盘缓存 BOOL cacheOnDisk = !(options &amp; SDWebImageCacheMemoryOnly); if (self != [SDWebImageManager sharedManager] &amp;&amp; self.cacheKeyFilter &amp;&amp; downloadedImage) &#123; //缩放 downloadedImage = [self scaledImageForKey:key image:downloadedImage]; &#125; if (options &amp; SDWebImageRefreshCached &amp;&amp; cachedImage &amp;&amp; !downloadedImage) &#123; //是否需要转换图片 //成功下载图片、自定义实现了图片处理的代理 &#125; else if (downloadedImage &amp;&amp; (!downloadedImage.images || (options &amp; SDWebImageTransformAnimatedImage)) &amp;&amp; [self.delegate respondsToSelector:@selector(imageManager:transformDownloadedImage:withURL:)]) &#123; dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^&#123; //获取转换用户后的图片 UIImage *transformedImage = [self.delegate imageManager:self transformDownloadedImage:downloadedImage withURL:url]; //用户处理成功 if (transformedImage &amp;&amp; finished) &#123; BOOL imageWasTransformed = ![transformedImage isEqual:downloadedImage]; //用户处理的后若未生成新的图片、则保存下载的二进制文件。 //不然则由imageCache内部生成二进制文件保存 [self.imageCache storeImage:transformedImage imageData:(imageWasTransformed ? nil : downloadedData) forKey:key toDisk:cacheOnDisk completion:nil]; &#125; //回调 [self callCompletionBlockForOperation:strongOperation completion:completedBlock image:transformedImage data:downloadedData error:nil cacheType:SDImageCacheTypeNone finished:finished url:url]; &#125;); &#125; else &#123; //下载成功且未自定义代理--默认保存 if (downloadedImage &amp;&amp; finished) &#123; [self.imageCache storeImage:downloadedImage imageData:downloadedData forKey:key toDisk:cacheOnDisk completion:nil]; &#125; [self callCompletionBlockForOperation:strongOperation completion:completedBlock image:downloadedImage data:downloadedData error:nil cacheType:SDImageCacheTypeNone finished:finished url:url]; &#125; &#125; if (finished) &#123; [self safelyRemoveOperationFromRunning:strongOperation]; &#125; &#125;]; @synchronized(operation) &#123; operation.cancelBlock = ^&#123; [self.imageDownloader cancel:subOperationToken]; __strong __typeof(weakOperation) strongOperation = weakOperation; [self safelyRemoveOperationFromRunning:strongOperation]; &#125;; &#125; &#125; else if (cachedImage) &#123; //本地有图片--回调、关闭当前操作 __strong __typeof(weakOperation) strongOperation = weakOperation; [self callCompletionBlockForOperation:strongOperation completion:completedBlock image:cachedImage data:cachedData error:nil cacheType:cacheType finished:YES url:url]; [self safelyRemoveOperationFromRunning:operation]; &#125; else &#123; //本地没有、也不下载--回调、关闭当前操作 __strong __typeof(weakOperation) strongOperation = weakOperation; [self callCompletionBlockForOperation:strongOperation completion:completedBlock image:nil data:nil error:nil cacheType:SDImageCacheTypeNone finished:YES url:url]; [self safelyRemoveOperationFromRunning:operation]; &#125; &#125;]; return operation;&#125; SDWebImageManager流程图 业务层: 缓存&amp;&amp;磁盘操作(SDImageCache)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146- (nullable NSOperation *)queryCacheOperationForKey:(nullable NSString *)key done:(nullable SDCacheQueryCompletedBlock)doneBlock &#123; if (!key) &#123; if (doneBlock) &#123; doneBlock(nil, nil, SDImageCacheTypeNone); &#125; return nil; &#125; // First check the in-memory cache... //搜索磁盘缓存 UIImage *image = [self imageFromMemoryCacheForKey:key]; if (image) &#123; NSData *diskData = nil; if (image.images) &#123; diskData = [self diskImageDataBySearchingAllPathsForKey:key]; &#125; if (doneBlock) &#123; doneBlock(image, diskData, SDImageCacheTypeMemory); &#125; return nil; &#125; NSOperation *operation = [NSOperation new]; dispatch_async(self.ioQueue, ^&#123; if (operation.isCancelled) &#123; // do not call the completion if cancelled return; &#125; @autoreleasepool &#123; //搜索硬盘 NSData *diskData = [self diskImageDataBySearchingAllPathsForKey:key]; UIImage *diskImage = [self diskImageForKey:key]; //缓存到内存、默认为YES if (diskImage &amp;&amp; self.config.shouldCacheImagesInMemory) &#123; NSUInteger cost = SDCacheCostForImage(diskImage); //使用NSChache缓存。 [self.memCache setObject:diskImage forKey:key cost:cost]; &#125; if (doneBlock) &#123; dispatch_async(dispatch_get_main_queue(), ^&#123; doneBlock(diskImage, diskData, SDImageCacheTypeDisk); &#125;); &#125; &#125; &#125;); return operation;&#125;//查询缓存- (nullable UIImage *)imageFromMemoryCacheForKey:(nullable NSString *)key &#123; //self.memCache 为NSCache实例 return [self.memCache objectForKey:key];&#125;//查询磁盘- (nullable UIImage *)diskImageForKey:(nullable NSString *)key &#123; NSData *data = [self diskImageDataBySearchingAllPathsForKey:key]; if (data) &#123; //图片解码、调整方向 UIImage *image = [[SDWebImageCodersManager sharedInstance] decodedImageWithData:data]; //调整图片缩放比例 @2x/@3x image = [self scaledImageForKey:key image:image]; //压缩图片 if (self.config.shouldDecompressImages) &#123; image = [[SDWebImageCodersManager sharedInstance] decompressedImageWithImage:image data:&amp;data options:@&#123;SDWebImageCoderScaleDownLargeImagesKey: @(NO)&#125;]; &#125; return image; &#125; else &#123; return nil; &#125;&#125;//写入缓存 &amp;&amp; 磁盘- (void)storeImage:(nullable UIImage *)image imageData:(nullable NSData *)imageData forKey:(nullable NSString *)key toDisk:(BOOL)toDisk completion:(nullable SDWebImageNoParamsBlock)completionBlock &#123; if (!image || !key) &#123; if (completionBlock) &#123; completionBlock(); &#125; return; &#125; // if memory cache is enabled if (self.config.shouldCacheImagesInMemory) &#123; //写入缓存 NSUInteger cost = SDCacheCostForImage(image); [self.memCache setObject:image forKey:key cost:cost]; &#125; if (toDisk) &#123; //写入磁盘 dispatch_async(self.ioQueue, ^&#123; @autoreleasepool &#123; NSData *data = imageData; if (!data &amp;&amp; image) &#123; // If we do not have any data to detect image format, check whether it contains alpha channel to use PNG or JPEG format SDImageFormat format; if (SDCGImageRefContainsAlpha(image.CGImage)) &#123; format = SDImageFormatPNG; &#125; else &#123; format = SDImageFormatJPEG; &#125; data = [[SDWebImageCodersManager sharedInstance] encodedDataWithImage:image format:format]; &#125; [self storeImageDataToDisk:data forKey:key]; &#125; if (completionBlock) &#123; dispatch_async(dispatch_get_main_queue(), ^&#123; completionBlock(); &#125;); &#125; &#125;); &#125; else &#123; if (completionBlock) &#123; completionBlock(); &#125; &#125;&#125;//正式写入磁盘- (void)storeImageDataToDisk:(nullable NSData *)imageData forKey:(nullable NSString *)key &#123; if (!imageData || !key) &#123; return; &#125; [self checkIfQueueIsIOQueue]; //如果文件中不存在磁盘缓存路径 则创建 if (![_fileManager fileExistsAtPath:_diskCachePath]) &#123; [_fileManager createDirectoryAtPath:_diskCachePath withIntermediateDirectories:YES attributes:nil error:NULL]; &#125; // get cache Path for image key 得到该key的缓存路径 NSString *cachePathForKey = [self defaultCachePathForKey:key]; // transform to NSUrl 将缓存路径转化为url NSURL *fileURL = [NSURL fileURLWithPath:cachePathForKey]; //将imageData存储起来 [_fileManager createFileAtPath:cachePathForKey contents:imageData attributes:nil]; // disable iCloud backup 如果调用者关闭icloud 关闭iCloud备份 if (self.config.shouldDisableiCloud) &#123; [fileURL setResourceValue:@YES forKey:NSURLIsExcludedFromBackupKey error:nil]; &#125;&#125; 由于此处只归纳正常读取下载流程的代码、所以其余关于图片过期&amp;&amp;释放流程的代码没有列出。后面会逐一进行归纳。 查找本地流程图 下载操作(SDWebImageDownloader)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117- (nullable SDWebImageDownloadToken *)downloadImageWithURL:(nullable NSURL *)url options:(SDWebImageDownloaderOptions)options progress:(nullable SDWebImageDownloaderProgressBlock)progressBlock completed:(nullable SDWebImageDownloaderCompletedBlock)completedBlock &#123; __weak SDWebImageDownloader *wself = self; return [self addProgressCallback:progressBlock completedBlock:completedBlock forURL:url createCallback:^SDWebImageDownloaderOperation *&#123; //创建下载operation __strong __typeof (wself) sself = wself; //超时时间 NSTimeInterval timeoutInterval = sself.downloadTimeout; if (timeoutInterval == 0.0) &#123; timeoutInterval = 15.0; &#125; // In order to prevent from potential duplicate caching (NSURLCache + SDImageCache) we disable the cache for image requests if told otherwise //创建下载策略 //SDWebImageDownloaderUseNSURLCache 则使用 NSURLRequestUseProtocolCachePolicy 缓存协议 //默认NSURLRequestReloadIgnoringLocalCacheData从原地址重新下载 NSURLRequestCachePolicy cachePolicy = options &amp; SDWebImageDownloaderUseNSURLCache ? NSURLRequestUseProtocolCachePolicy : NSURLRequestReloadIgnoringLocalCacheData; //创建下载请求 NSMutableURLRequest *request = [[NSMutableURLRequest alloc] initWithURL:url cachePolicy:cachePolicy timeoutInterval:timeoutInterval]; request.HTTPShouldHandleCookies = (options &amp; SDWebImageDownloaderHandleCookies); request.HTTPShouldUsePipelining = YES; if (sself.headersFilter) &#123; request.allHTTPHeaderFields = sself.headersFilter(url, [sself.HTTPHeaders copy]); &#125; else &#123; //默认 image/*;q=0.8 request.allHTTPHeaderFields = sself.HTTPHeaders; &#125; //创建下载操作 SDWebImageDownloaderOperation *operation = [[sself.operationClass alloc] initWithRequest:request inSession:sself.session options:options]; //是否解压 operation.shouldDecompressImages = sself.shouldDecompressImages; //证书 if (sself.urlCredential) &#123; operation.credential = sself.urlCredential; &#125; else if (sself.username &amp;&amp; sself.password) &#123; //默认 账号密码为空的通用证书 operation.credential = [NSURLCredential credentialWithUser:sself.username password:sself.password persistence:NSURLCredentialPersistenceForSession]; &#125; //优先级。默认都不是 if (options &amp; SDWebImageDownloaderHighPriority) &#123; operation.queuePriority = NSOperationQueuePriorityHigh; &#125; else if (options &amp; SDWebImageDownloaderLowPriority) &#123; operation.queuePriority = NSOperationQueuePriorityLow; &#125; //向下载队列 NSOperationQueue 中 添加本次下载操作 [sself.downloadQueue addOperation:operation]; //设置下载的顺序 是按照队列还是栈 if (sself.executionOrder == SDWebImageDownloaderLIFOExecutionOrder) &#123; // Emulate LIFO execution order by systematically adding new operations as last operation&apos;s dependency [sself.lastAddedOperation addDependency:operation]; sself.lastAddedOperation = operation; &#125; return operation; &#125;];&#125;//通过progressBlock&amp;&amp;completedBlock以及Url和SDWebImageDownloaderOperation对token进行包装- (nullable SDWebImageDownloadToken *)addProgressCallback:(SDWebImageDownloaderProgressBlock)progressBlock completedBlock:(SDWebImageDownloaderCompletedBlock)completedBlock forURL:(nullable NSURL *)url createCallback:(SDWebImageDownloaderOperation *(^)(void))createCallback &#123; // The URL will be used as the key to the callbacks dictionary so it cannot be nil. If it is nil immediately call the completed block with no image or data. if (url == nil) &#123; if (completedBlock != nil) &#123; completedBlock(nil, nil, nil, NO); &#125; return nil; &#125; __block SDWebImageDownloadToken *token = nil; dispatch_barrier_sync(self.barrierQueue, ^&#123; SDWebImageDownloaderOperation *operation = self.URLOperations[url]; if (!operation) &#123; operation = createCallback(); //将url作为key、对应的下载操作operation作为value保存。 self.URLOperations[url] = operation; __weak SDWebImageDownloaderOperation *woperation = operation; operation.completionBlock = ^&#123; dispatch_barrier_sync(self.barrierQueue, ^&#123; SDWebImageDownloaderOperation *soperation = woperation; if (!soperation) return; if (self.URLOperations[url] == soperation) &#123; //下载完成、移除操作 [self.URLOperations removeObjectForKey:url]; &#125;; &#125;); &#125;; &#125; //将成progressBlock以及completedBlock组装成SDCallbacksDictionary. id downloadOperationCancelToken = [operation addHandlersForProgress:progressBlock completed:completedBlock]; //生成下载任务标识。用于manager将来定位对应操作用 token = [SDWebImageDownloadToken new]; token.url = url; token.downloadOperationCancelToken = downloadOperationCancelToken; &#125;); return token;&#125; SDWebImageDownloaderOperation是具体下载操作、设计很多网络层的东西。将来可以单独开一篇、结合AFNetWorking没准会更好。 一些启发 分层的接口API设计。 12345#import &quot;UIImageView+WebCache.h&quot;#import &quot;UIButton+WebCache.h&quot;#import &quot;UIImageView+HighlightedWebCache.h&quot;//以及其汇总的#import &quot;UIView+WebCache.h&quot; 所有外层API与具体业务无关。使得SDWebImageManager可以脱离View层单独运作。 线程安全 123456789@synchronized (self.runningOperations) &#123; [self.runningOperations addObject:operation]; &#125;if (url) &#123; @synchronized (self.failedURLs) &#123; isFailedUrl = [self.failedURLs containsObject:url]; &#125;&#125;..... 所有可能引起资源抢夺的对象操作、全部有条件锁保护。但是由于内嵌异常处理代码的存在、条件锁的性能是所有锁中最差的。不知道为什么SD中使用这么多。 内联函数 更高效的短函数执行、替代表达式形式的宏定义。 精细的缓存管理原则 详参上文提到的《磁盘清理的原则？》 回调设计 SDWebImage中使用了两种、Block以及Delegate。 Block使用的很多、举两个例子。 123456789101112131415======&gt;#import &quot;UIView+WebCache.h&quot;- (void)sd_internalSetImageWithURL:(nullable NSURL *)url placeholderImage:(nullable UIImage *)placeholder options:(SDWebImageOptions)options operationKey:(nullable NSString *)operationKey setImageBlock:(nullable SDSetImageBlock)setImageBlock progress:(nullable SDWebImageDownloaderProgressBlock)progressBlock completed:(nullable SDExternalCompletionBlock)completedBlock context:(nullable NSDictionary *)context;======&gt;SDWebImageDownloader- (nullable SDWebImageDownloadToken *)downloadImageWithURL:(nullable NSURL *)url options:(SDWebImageDownloaderOptions)options progress:(nullable SDWebImageDownloaderProgressBlock)progressBlock completed:(nullable SDWebImageDownloaderCompletedBlock)completedBlock; 再来看代理 1234567891011121314@protocol SDWebImageManagerDelegate &lt;NSObject&gt;@optional/** * Controls which image should be downloaded when the image is not found in the cache. * * @param imageManager The current `SDWebImageManager` * @param imageURL The url of the image to be downloaded * * @return Return NO to prevent the downloading of the image on cache misses. If not implemented, YES is implied. */- (BOOL)imageManager:(nonnull SDWebImageManager *)imageManager shouldDownloadImageForURL:(nullable NSURL *)imageURL;- (nullable UIImage *)imageManager:(nonnull SDWebImageManager *)imageManager transformDownloadedImage:(nullable UIImage *)image withURL:(nullable NSURL *)imageURL; 不难看出、SDWebImage对回调的使用倾向于： Block单个图片的分类、单个图片的下载。每个操作任务中必现的progress以及completed。所以、有很强的个体绑定需要或者使用次数不多时、倾向使用block DelegateSDWebImageManager下载完成之后的自定义图片处理、是否下载某个url。这两个方法如果需要的话都是将会调用多次的。所以、用Delegate更好、可以将方法常驻。 同理UITableView的使用Delegate、是用为在滚动途中、代理方法需要被不断的执行。UIButton也是将会被多次点击。UIView的动画/GCD则可以使用Block、因为只执行一次、用完释放。所以、在日常使用中、我们也可以参考上述原则进行设计。 NSMapTable 用NSMapTable代替字典来存储当前正在进行的操作、并且将value设置为NSMapTableWeakMemory。防止对应value因为强引用不能自动释放。 暂时想到的就这些、更多问题欢迎留言。作者：kirito_song链接：https://www.jianshu.com/p/3b8a7ae966d3來源：简书著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","link":"/2018/04/24/SDWebImage4-0源码阅读/"},{"title":"UIButton设置文字图片居中、UIView相关方法以及UI切图的重要性","text":"又是一个老生常谈的问题，o(╯□╰)o。UIButton作为最最常用的控件，想必都是很熟悉的。如下图所示的控件中 如此设计在很多电商客户端中都有涉及，也没有什么难度。 但是我遇到的问题就是任凭如何设置边距，就是对不齐，其中还要考虑屏幕适配的问题。Orz…最后去工程里查看相应的图片大小，才发现每个图片的尺寸宽高都不同，很随意。 这搞半天，原来是图片尺寸的问题，想想这UI，唉！ UIButton设置文字图片居中 UIButton图片、文字居中的调整主要就是四个参数：（``） contentHorizontalAlignment:设置真个Button内容（包括imageView和titleLabel）的水平位置。 contentVerticalAlignment:设置整个Button内容（包括imageView和titleLabel）的垂直位置，这里用不到。 imageEdgeInsets:设置imageView的边距。 titleEdgeInsets:设置titleLabel的边距。 1234567891011121314typedef NS_ENUM(NSInteger, UIControlContentVerticalAlignment) &#123; UIControlContentVerticalAlignmentCenter = 0, UIControlContentVerticalAlignmentTop = 1, UIControlContentVerticalAlignmentBottom = 2, UIControlContentVerticalAlignmentFill = 3,&#125;;typedef NS_ENUM(NSInteger, UIControlContentHorizontalAlignment) &#123; UIControlContentHorizontalAlignmentCenter = 0, UIControlContentHorizontalAlignmentLeft = 1, UIControlContentHorizontalAlignmentRight = 2, UIControlContentHorizontalAlignmentFill = 3,&#125;; 在这里给出我用的通用方法，button高度为50为例：1.设置button的contentHorizontalAlignment为UIControlContentHorizontalAlignmentLeft,这样便于根据button大小计算。当然非要用center计算也可！2.设置imageView的Edge： kButtonImageViewEdgeInsets(btn) UIEdgeInsetsMake(0,(kOptionBtnWidth - btn.imageView.frame.size.width)/2, 20, 0);3.设置titleLabel的Edge： #define kButtonTitleEdgeInsets(btn) UIEdgeInsetsMake(30, (kOptionBtnWidth - btn.titleLabel.frame.size.width)/2-btn.titleLabel.frame.origin.x, 0, 20);。 只要传入相应的button就可以了，其中button的宽度由此得来#define kOptionBtnWidth (CGRectGetWidth(frame)/kOptionBtnCount)。 UIView的相关方法 直接采用上述设置button的方法是有条件的，即确定了当前Button的宽度。我们看到要计算button的宽度，得通过读取屏幕宽度得知。app中初始化UIView的方式通常有两种：1.xib/Storyboard，然后关联.h,.m文件。2.自定义UIView子类,通过initWithFrame方法设置。 当在UIView的子类中实现时，因为此时屏幕宽度已经通过初始化方法中得知，所以不需要再多设置。而通过xib/sb关联的子类初始化方法中，若打印self.frame，就是当前xib的宽度，而不是实际屏幕宽度。所以不能再初始化方法中设置button的属性。 第一步重写父类方法，下面两个任选其一。12- (void)updateConstraints;-需要重写父类的updateConstraints方法。- (void)layoutSubviews; 第二步对每个button调用layoutIfNeeded方法，让其立即刷新布局。 这个是没有调用layoutIfNeeded的情况： 以上。 参考文档UIView Class ReferenceUIView)","link":"/2016/03/31/UIButton设置文字图片居中-论UI切图的重要性/"},{"title":"Xib与之关联的自定义Class","text":"最近遇到了一个问题：点击【猜你喜欢】视图进入商品详情后，再返回到首页时，没有原先的数据了。 打开Reveal看了下层级关系，原来是被二次生成的界面覆盖了。再细看一下，上面的视图都被二次生成了。真是哔了狗了！ drawRect方法好吧，修改代码吧。因为这些视图都是在xib上创建好了，另外新建了与之对应的自定义类，所以都直接用的drawRect方法去初始化UI元素。1234- (void)drawRect:(CGRect)rect &#123; [self initSubViews];&#125; The default implementation of this method does nothing. Subclasses that use technologies such as Core Graphics and UIKit to draw their view’s content should override this method and implement their drawing code there. You do not need to override this method if your view sets its content in other ways. For example, you do not need to override this method if your view just displays a background color or if your view sets its content directly using the underlying layer object. If you subclass UIView directly, your implementation of this method does not need to call super. However, if you are subclassing a different view class, you should call super at some point in your implementation.This method is called when a view is first displayed or when an event occurs that invalidates a visible part of the view. You should never call this method directly yourself. To invalidate part of your view, and thus cause that portion to be redrawn, call the setNeedsDisplay or setNeedsDisplayInRect: method instead. @Apple Developdeveloper.apple.com/library/prerelease/ios/documentation/UIKit/Reference/UIView_Class/index.html#//apple_ref/swift/instm/UIView/c:objc(cs)UIView(im)drawRect: 这里就出现了问题。在每次重新返回到首页后，drawRect方法又被重新调用了一次，所以生成了新的视图覆盖了原来的视图，但是又没有请求数据，所以就看不到了。drawRect方法只被重新调用了一次，在这之后就不会再被调用。 因为为了解决这个问题，我就不用drawRect去初始化页面元素了，而是用了initWithCorder方法。注意因为视图是被直接创建在xib上的，并没有执行initWithFrame方法。 12345678- (instancetype)initWithCoder:(NSCoder *)aDecoder&#123; self = [super initWithCoder:aDecoder]; if (self) &#123; [self initSubViews]; &#125; return self;&#125; 总结1.尽量不要使用drawRect方法，性能下降厉害撒。2.已经在xib上创建的视图，与其关联的子类中initWithFrame方法不会被调用。","link":"/2016/03/04/Xib与之关联的自定义Class/"},{"title":"SDWebImage内部实现过程","text":"SDWebImage内部实现过程(新版本在各方法前加上了sd_前缀，以区分UIImageView+AFNetworking中的方法) 1.入口 setImageWithURL:placeholderImage:options:会先把 placeholderImage 显示，然后 SDWebImageManager 根据 URL 开始处理图片。 2.进入 SDWebImageManager-downloadWithURL:delegate:options:userInfo:，交给 SDImageCache 从缓存查找图片是否已经下载 queryDiskCacheForKey:delegate:userInfo:. 3.先从内存图片缓存查找是否有图片，如果内存中已经有图片缓存，SDImageCacheDelegate 回调 imageCache:didFindImage:forKey:userInfo: 到 SDWebImageManager。 4.SDWebImageManagerDelegate 回调 webImageManager:didFinishWithImage:到 UIImageView+WebCache 等前端展示图片。 5.如果内存缓存中没有，生成 NSInvocationOperation 添加到队列开始从硬盘查找图片是否已经缓存。 6.根据 URLKey 在硬盘缓存目录下尝试读取图片文件。这一步是在 NSOperation 进行的操作，所以回主线程进行结果回调 notifyDelegate:。 7.如果上一操作从硬盘读取到了图片，将图片添加到内存缓存中（如果空闲内存过小，会先清空内存缓存）。SDImageCacheDelegate 回调 imageCache:didFindImage:forKey:userInfo:。进而回调展示图片。 8.如果从硬盘缓存目录读取不到图片，说明所有缓存都不存在该图片，需要下载图片，回调 imageCache:didNotFindImageForKey:userInfo:。 9.共享或重新生成一个下载器 SDWebImageDownloader 开始下载图片。 10.图片下载由 NSURLConnection 来做，实现相关 delegate 来判断图片下载中、下载完成和下载失败。 11.connection:didReceiveData:中利用 ImageIO 做了按图片下载进度加载效果。 12.connectionDidFinishLoading:数据下载完成后交给 SDWebImageDecoder 做图片解码处理。 13.图片解码处理在一个 NSOperationQueue 完成，不会拖慢主线程 UI。如果有需要对下载的图片进行二次处理，最好也在这里完成，效率会好很多。 14.在主线程 notifyDelegateOnMainThreadWithInfo: 宣告解码完成，imageDecoder:didFinishDecodingImage:userInfo: 回调给 SDWebImageDownloader。 15.imageDownloader:didFinishWithImage: 回调给 SDWebImageManager 告知图片下载完成。 16.通知所有的 downloadDelegates 下载完成，回调给需要的地方展示图片。 17.将图片保存到 SDImageCache 中，内存缓存和硬盘缓存同时保存。写文件到硬盘也在以单独 NSInvocationOperation 完成，避免拖慢主线程。 18.SDImageCache 在初始化的时候会注册一些消息通知，在内存警告或退到后台的时候清理内存图片缓存，应用结束的时候清理过期图片。 19.SDWI 也提供了 UIButton+WebCache 和 MKAnnotationView+WebCache，方便使用。 20.SDWebImagePrefetcher 可以预先下载图片，方便后续使用。 从上面流程可以看出，当你调用setImageWithURL:方法的时候，他会自动去给你干这么多事，当你需要在某一具体时刻做事情的时候，你可以覆盖这些方法。比如在下载某个图片的过程中要响应一个事件，就覆盖这个方法： 覆盖方法，指哪打哪，这个方法是下载imagePath2的时候响应12345678910SDWebImageManager *manager = [SDWebImageManager sharedManager]; [manager downloadImageWithURL:imagePath2 options:SDWebImageRetryFailed progress:^(NSInteger receivedSize, NSInteger expectedSize) &#123; NSLog(@\"显示当前进度\"); &#125; completed:^(UIImage *image, NSError *error, SDImageCacheType cacheType, BOOL finished, NSURL *imageURL) &#123; NSLog(@\"下载完成\");&#125;]; 当服务器更新了某一张图片资源时，客户端需要重新加载，那么就可以设置SDWebImageOption为SDWebImageRefreshCached；附上全部的SDWebImageOptions：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172typedef NS_OPTIONS(NSUInteger, SDWebImageOptions) &#123; /** * By default, when a URL fail to be downloaded, the URL is blacklisted so the library won't keep trying. * This flag disable this blacklisting. */ SDWebImageRetryFailed = 1 &lt;&lt; 0, /** * By default, image downloads are started during UI interactions, this flags disable this feature, * leading to delayed download on UIScrollView deceleration for instance. */ SDWebImageLowPriority = 1 &lt;&lt; 1, /** * This flag disables on-disk caching */ SDWebImageCacheMemoryOnly = 1 &lt;&lt; 2, /** * This flag enables progressive download, the image is displayed progressively during download as a browser would do. * By default, the image is only displayed once completely downloaded. */ SDWebImageProgressiveDownload = 1 &lt;&lt; 3, /** * Even if the image is cached, respect the HTTP response cache control, and refresh the image from remote location if needed. * The disk caching will be handled by NSURLCache instead of SDWebImage leading to slight performance degradation. * This option helps deal with images changing behind the same request URL, e.g. Facebook graph api profile pics. * If a cached image is refreshed, the completion block is called once with the cached image and again with the final image. * * Use this flag only if you can't make your URLs static with embeded cache busting parameter. */ SDWebImageRefreshCached = 1 &lt;&lt; 4, /** * In iOS 4+, continue the download of the image if the app goes to background. This is achieved by asking the system for * extra time in background to let the request finish. If the background task expires the operation will be cancelled. */ SDWebImageContinueInBackground = 1 &lt;&lt; 5, /** * Handles cookies stored in NSHTTPCookieStore by setting * NSMutableURLRequest.HTTPShouldHandleCookies = YES; */ SDWebImageHandleCookies = 1 &lt;&lt; 6, /** * Enable to allow untrusted SSL ceriticates. * Useful for testing purposes. Use with caution in production. */ SDWebImageAllowInvalidSSLCertificates = 1 &lt;&lt; 7, /** * By default, image are loaded in the order they were queued. This flag move them to * the front of the queue and is loaded immediately instead of waiting for the current queue to be loaded (which * could take a while). */ SDWebImageHighPriority = 1 &lt;&lt; 8, /** * By default, placeholder images are loaded while the image is loading. This flag will delay the loading * of the placeholder image until after the image has finished loading. */ SDWebImageDelayPlaceholder = 1 &lt;&lt; 9, /** * We usually don't call transformDownloadedImage delegate method on animated images, * as most transformation code would mangle it. * Use this flag to transform them anyway. */ SDWebImageTransformAnimatedImage = 1 &lt;&lt; 10,&#125;;","link":"/2016/03/08/SDWebImage内部实现过程/"},{"title":"TableViewCell根据内容自适应高度的方法","text":"本文同时参考 http://blog.sunnyxx.com/2015/05/17/cell-height-calculation/ 一：根据cell内容手动计算cell高度 无论使用xib还是代码写控件，核心思想都是根据cell中content内容的高度来计算cell的高度。1.在获取到cell数据源的时候计算内容高度。可以设置一个size属性，用来记录。2.如果是xib，去掉autolayout3.在cellForRowAtIndexPath方法中填充cell数据的时候，根据内容高度，设置控件高度4.在heightForRowAtIndexpath方法中，设置每一个cell 的高度 二：Self sizing cell + autolayout Self sizing cell 是iOS8中添加一个新特性，用来自适应cell高度。同时打开以下参数：12self.tableView.estimatedRowHeight = 213;//添加估算高度，要不然自动算高失效？self.tableView.rowHeight = UITableViewAutomaticDimension; 三：UITableView+FDTemplateLayoutCell 使用的API:12345678#import &lt;UITableView+FDTemplateLayoutCell.h&gt; - (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath &#123; return [tableView fd_heightForCellWithIdentifier:@\"identifer\" cacheByIndexPath:indexPath configuration:^(id cell) &#123; // 配置 cell 的数据源，和 \"cellForRow\" 干的事一致，比如： cell.entity = self.feedEntities[indexPath.row]; &#125;]; &#125; https://github.com/forkingdog/UITableView-FDTemplateLayoutCell 下面给出第一种手动计算高度的代码思路：详细步骤： 12345678HLComment *comment = [HLComment new]; comment.floor = obj[@\"floor\"]; comment.commentId = obj[@\"id\"]; comment.content = obj[@\"content\"]; //计算content内容高度12345 NSDictionary *atrri = @&#123;NSFontAttributeName: [UIFont systemFontOfSize:15]&#125;; CGRect rect = [comment.content boundingRectWithSize:CGSizeMake(220, 1000) options:NSStringDrawingUsesLineFragmentOrigin attributes:atrri context:nil];comment.size = rect.size;//保存这个高度 //填充cell内容时，根据content高度来设置label高度12345678910111213- (void)fillCellWithModel:(HLItem *)item&#123; …. CGRect frame = _content.frame;//_content 是内容label frame.size = item.size; _content.frame = frame; …..&#125; 另外在heightForRowAtIndexPath 中添加一定的余量。123456789101112131415161718//自适应cell高度- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath&#123; //NSLog(@\"计算cell高度\");; if (indexPath.row == 0) &#123; return self.item.size.height+140; &#125; HLComment *item = _dataSource[indexPath.row-1]; return item.size.height+60;&#125;","link":"/2015/12/16/TableViewCell根据内容自适应高度的方法/"},{"title":"iOS中处理四舍五入的问题","text":"处理四舍五入主要使用下面这个方法：12345678910-(NSString *)notRounding:(float)price afterPoint:(int)position&#123; NSDecimalNumberHandler* roundingBehavior = [NSDecimalNumberHandler decimalNumberHandlerWithRoundingMode:NSRoundDown scale:position raiseOnExactness:NO raiseOnOverflow:NO raiseOnUnderflow:NO raiseOnDivideByZero:NO]; NSDecimalNumber *ouncesDecimal; NSDecimalNumber *roundedOunces; ouncesDecimal = [[NSDecimalNumber alloc] initWithFloat:price]; roundedOunces = [ouncesDecimal decimalNumberByRoundingAccordingToBehavior:roundingBehavior]; [ouncesDecimal release]; return [NSString stringWithFormat:@\"%@\",roundedOunces];&#125;介绍一下参数：price:需要处理的数字，position：保留小数点第几位，然后调用1234float s =0.126; NSString *sb = [self notRounding:s afterPoint:2]; NSLog(@\"sb = %@\",sb);输出结果为：sb = 0.12 接下来介绍NSDecimalNumberHandler初始化时的关键参数：decimalNumberHandlerWithRoundingMode：NSRoundDown，NSRoundDown代表的就是 只舍不入。scale的参数position代表保留小数点后几位。","link":"/2015/12/05/iOS中处理四舍五入的问题/"},{"title":"iOS 蓝牙4.0开发","text":"iOS 蓝牙4.0开发 背景：1.iOS的蓝牙不能用来传输文件。2.iOS与iOS设备之间进行数据通信，使用gameKit.framework3.iOS与其他非iOS设备进行数据通信，使用coreBluetooth.frameworkiOS中蓝牙的实现方案 iOS中提供了4个框架用于实现蓝牙连接GameKit.framework（用法简单）只能用于iOS设备之间的连接，多用于游戏（比如五子棋对战），从iOS7开始过期 MultipeerConnectivity.framework只能用于iOS设备之间的连接，从iOS7开始引入，主要用于文件共享（仅限于沙盒的文件） ExternalAccessory.framework可用于第三方蓝牙设备交互，但是蓝牙设备必须经过苹果MFi认证（国内较少） CoreBluetooth.framework（时下热门）可用于第三方蓝牙设备交互，必须要支持蓝牙4.0硬件至少是4s，系统至少是iOS6蓝牙4.0以低功耗著称，一般也叫BLE（BluetoothLowEnergy）目前应用比较多的案例：运动手坏、嵌入式设备、智能家居 下面具体介绍使用CoreBluetooth.framework的代码步骤： 12345678910111213141516171819202122232425//蓝牙系统库#import &lt;CoreBluetooth/CoreBluetooth.h&gt;//必须要由UUID来唯一标示对应的service和characteristic#define kServiceUUID @\"5C476471-1109-4EBE-A826-45B4F9D74FB9\"#define kCharacteristicHeartRateUUID @\"82C7AC0F-6113-4EC9-92D1-5EEF44571398\"#define kCharacteristicBodyLocationUUID @\"537B5FD6-1889-4041-9C35-F6949D1CA034\"@interface ViewController ()&lt;CBCentralManagerDelegate,CBPeripheralDelegate&gt;@property (nonatomic,strong)CBCentralManager * centralManager;@property (nonatomic,strong)CBPeripheral * peripheral;@end 创建中心角色1234567891011121314#import &lt;CoreBluetooth/CoreBluetooth.h&gt; - (void)viewDidLoad&#123; [super viewDidLoad]; //初始化蓝牙 central manager _centralManager = [[CBCentralManager alloc]initWithDelegate:self queue:dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0) options:nil]; &#125; 扫描外设1[manager scanForPeripheralsWithServices:nil options:@&#123;CBCentralManagerRestoredStateScanOptionsKey:@(YES)&#125;]; 连接外设12345678910111213- (void)centralManager:(CBCentralManager *)central didDiscoverPeripheral:(CBPeripheral *)peripheral advertisementData:(NSDictionary *)advertisementData RSSI:(NSNumber *)RSSI &#123; if([peripheral.name isEqualToString:BLE_SERVICE_NAME])&#123; [self connect:peripheral]; &#125;s); &#125; -(BOOL)connect:(CBPeripheral *)peripheral&#123; self.manager.delegate = self; [self.manager connectPeripheral:peripheral options:[NSDictionary dictionaryWithObject:[NSNumber numberWithBool:YES] forKey:CBConnectPeripheralOptionNotifyOnDisconnectionKey]];&#125; 扫描外设中的服务和特征1234567891011- (void)centralManager:(CBCentralManager *)central didConnectPeripheral:(CBPeripheral *)peripheral &#123; NSLog(@\"Did connect to peripheral: %@\", peripheral); _testPeripheral = peripheral; [peripheral setDelegate:self]; &lt;br&gt;//查找服务 [peripheral discoverServices:nil]; &#125; 发现服务：123456789101112131415161718192021222324252627282930- (void)peripheral:(CBPeripheral *)peripheral didDiscoverServices:(NSError *)error &#123; NSLog(@\"didDiscoverServices\"); if (error) &#123; NSLog(@\"Discovered services for %@ with error: %@\", peripheral.name, [error localizedDescription]); if ([self.delegate respondsToSelector:@selector(DidNotifyFailConnectService:withPeripheral:error:)]) [self.delegate DidNotifyFailConnectService:nil withPeripheral:nil error:nil]; return; &#125; for (CBService *service in peripheral.services) &#123; //发现服务 if ([service.UUID isEqual:[CBUUID UUIDWithString:UUIDSTR_ISSC_PROPRIETARY_SERVICE]]) &#123; NSLog(@\"Service found with UUID: %@\", service.UUID); &lt;br&gt;//查找特征 [peripheral discoverCharacteristics:nil forService:service]; break; &#125; &#125; &#125; 发现服务中的特征：12345678910111213141516171819202122- (void)peripheral:(CBPeripheral *)peripheral didDiscoverCharacteristicsForService:(CBService *)service error:(NSError *)error&#123; if (error) &#123; NSLog(@\"Discovered characteristics for %@ with error: %@\", service.UUID, [error localizedDescription]); [self error]; return; &#125; NSLog(@\"服务：%@\",service.UUID); for (CBCharacteristic *characteristic in service.characteristics) &#123; //发现特征 if ([characteristic.UUID isEqual:[CBUUID UUIDWithString:@\"xxxxxxx\"]]) &#123; NSLog(@\"监听：%@\",characteristic);&lt;br&gt;//监听特征 [self.peripheral setNotifyValue:YES forCharacteristic:characteristic]; &#125; &#125;&#125; 与外设进行数据交互读取数据：12345678910111213- (void)peripheral:(CBPeripheral *)peripheral didUpdateValueForCharacteristic:(CBCharacteristic *)characteristic error:(NSError *)error&#123; if (error) &#123; NSLog(@\"Error updating value for characteristic %@ error: %@\", characteristic.UUID, [error localizedDescription]); self.error_b = BluetoothError_System; [self error]; return; &#125; // NSLog(@\"收到的数据：%@\",characteristic.value); [self decodeData:characteristic.value];&#125;写数据：123NSData *d2 = [[PBABluetoothDecode sharedManager] HexStringToNSData:@\"0x02\"]; [self.peripheral writeValue:d2 forCharacteristic:characteristic type:CBCharacteristicWriteWithoutResponse];","link":"/2016/03/08/iOS-蓝牙4-0开发/"},{"title":"cocos2d-x + Lua接入iOS原生SDK的实现方案","text":"本文转载自cocos2d-x + Lua接入iOS原生SDK的实现方案-著作权归原作者所有 相信很多朋友在使用cocos2d-x+lua开发游戏时都遇到过接入iOS原生SDK的问题，比如常见的接应用内支付SDK，广告SDK或是一些社交平台SDK等等，我也没少接过这类SDK。这篇文章主要是对我做过项目中接入iOS原生SDK实现方案的一个总结，在这里分享给大家，希望对自己和大家的开发工作都有帮助。 在展开正文之前，先做几点说明： 1.我这里说的iOS原生SDK是指那些完全用Objective-C语言开发，为原生iOS程序设计的SDK。swift很好很强大，不过我还没用过，惭愧，不过语言终归只是表达方式而已，解决问题的思路都是一样的； 2.这里假设游戏的主要逻辑使用lua实现，对于主要逻辑使用C++实现的，用本文的思路一样可行，并且设计上更简单，接着往下看就知道了：） 3.本文以quick-cocos2d-x 2.1版本为例进行讲解，主要因为这个是我之前做项目用得最多的一个版本，-x新版本变动比较大，但是，还是那句话，解决问题的思路是相同的。 ——————-正式开始的分割线——————- 好了，我们正式开始。开门见山！ 解决这种接入问题，实际上最主要是解决不同语言交互的问题，一旦跨过语言交互的障碍，剩下的事情就so easy! 由于涉及到Lua,C++,Objective-C三种语言，这个问题表面上看起来错综复杂，但其实只要冷静地（=。=）梳理，我们便可以得到正确的思路。 因为我们游戏的逻辑主要是用Lua实现的（前面已经做过假设），而SDK是用Objective-C实现，所以这里我们需要解决Lua与Objective-C的交互问题，即最终希望达到的目标是，在Lua层面“调用”Objective-C的代码（注意这里的调用是加引号的，间接的调用），而当Objective-C层面收到SDK的回调，再通知Lua。我们知道，Lua并没有简单的方法直接和Objective-C交流，但是Lua可以通过Lua Binding和C/C++交流，而我们又知道，C++和Objective-C可以混编，即C++可以直接调用（这里调用没引号，是真的直接调用）Objective-C的代码。想到这里，思路就很明显了，我们可以使用C++为Lua和Objective-C的交互充当桥梁，进而实现Lua到Objective-C的交互。 根据上面的分析，我们可以用如下图表达我们的思路，我们这里将语言交互的过程分成了4个小部分： 整个语言交互的过程可以总结为：Lua调用Lua Binding的C++接口，C++接口调用混编的Objective-C接口，而Objective-C通过block形式的回调，将结果通知给C++，C++通过Lua的C API将最终结果返回给Lua。这样一趟下来，就完成了Lua与Objective-C的整个交互过程。 简单的说一下这4部分： 1.Lua Binding 将C/C++接口导出给Lua调用的方法，由于篇幅的原因这里就不展开了，具体可以参考Lua的文档，以及网上其他地方的文章。 2.混编 Objective-C的一大优点就是可以和C与C++混编使用，就像同一个语言一样共存在一个实现文件里面。具体混编规则也不说了，这里只提两个小细节： 一，在XCode下混编的实现文件后缀是.mm，而不能是.cpp或者是.m； 二，混编的实现文件引用头文件的地方，C++或者C的用#include，而Objective-C用#import，相互没有影响。 3.Block回调 Block是Objective-C一个非常棒的特性，更棒的是在Block里面还可以直接写C++代码：）具体想了解的可以看苹果官方文档。 其实在最初，我曾经尝试过使用发送通知的方式来实现Objective-C对C++的回调，即Objective-C收到SDK回调，给C++部分发送附带回调信息的通知，虽然cocos2d-x中有现成的NotificationCenter来帮助实现，但这种方式的一个显而易见的弊端是大大增加了C++代码和Objective-C代码的耦合度，Objective-C部分也要混编C++调用C++的NotificationCenter发通知，C++部分也要混编Objective-C代码，调用C++的NotificationCenter收通知，这种结构实在是有够烦躁的。 相比之下，使用Block回调就干净利落太多，Objective-C这边一切都是纯粹的，它并不需要知道自己要被C++调用还是Objective-C调用，也不需要花很多精力在返回回调上，只需要干好自己的本职工作，然后在适当的时候调用Block就一切搞定。 4.Lua C API Lua C API用于C/C++与Lua的交互，在cocos2d-x中这些C API已经被封装成了更加易用的C++ Class API。这里要提到的是，在用这套API调用Lua函数的时候，为了传参，需要参数入栈的操作，这个入栈的顺序影响到了Lua函数接受到参数的顺序，不过好在规则很简单：先入栈的参数排在前或者说是入栈顺序和实参顺序相同。举例，如果C++这边调用Lua函数func时，入栈的顺序是A，B，C，那么就是调用函数func(A,B,C) ——————-渐入佳境的分割线——————- 在整个语言交互的过程中，如果认为Lua是顶层，Objective-C是底层，那么在实际游戏中交互的过程就是一个自顶向下的过程，然而我们在实现各层级代码的时候，需要自底向上完成，因为在顶层Lua代码中的逻辑，是由底层Objective-C SDK的接口与功能决定的。即我们需要先根据SDK中原始的Objective-C的接口，做适合我们游戏Objective-C封装代理类，然后根据封装结果实现C++的bridge接口，最后再实现Lua的对应逻辑。 根据以上分析，从层级的角度，设计如下： 除过Lua的逻辑，我们最重要需要实现的两部分内容：C++ Bridge Class 和 Objective-C SDK Delegate Class。前者是起桥梁作用的接口类，原则上不做任何与游戏逻辑相关的数据处理，而后者负责封装原始的SDK接口，接收以及初步处理SDK回调数据。前者的实现依赖于后者的实现，而后者的实现又依赖于SDK。SDK取得的数据最终通过层层传递，交给Lua逻辑处理，最终保证对数据处理的游戏逻辑尽可能多的放到Lua层中。 这样设计的好处有很多，一方面，顶层的游戏逻辑变动，不影响下层多语言交互代码，另一方面，底层的SDK变动，如版本更新甚至更换，不影响上层游戏逻辑，多层次结构有效地降低了复杂度，隔离了变化，对于频繁的需求变更，这种结构也可以保证扩展的便利。 ——————-总结的分割线——————- 综上所述，解决接入iOS原生SDK的问题，主要需要4步： 根据SDK接口与功能实现Objective-C SDK Delegate Class； 根据Objective-C SDK Delegate Class实现对应的C++ Bridge Class； 根据C++ Bridge Class生成对应的Lua Binding代码； 写Lua层逻辑。 ——————-最后的分割线——————- 好了，最后，又到了激动人心的上代码的环节了：）下面就以某iOS第三方计费SDK为例，来说明下实现接入的步骤。 这个SDK只有一个头文件GameBilling.h，主要使用到的方法和Protocol如下：（为了避免篇幅过长等原因，把注释和不必要的代码都删掉了）。我用代码注释的方式说明了各方法的用途。 1234567891011121314 1 // 初始化计费SDK 2 + (GameBilling *)initializeGameBilling; 3 4 // 告诉SDK游戏屏幕的Orientation，以便SDK展示正确的UI 5 - (void)setDialogOrientationMask:(UIInterfaceOrientationMask)orientationMask; 6 7 // 确认付费，显示付费UI 8 - (void)doBillingWithUIAndBillingIndex:(NSString *)billingIndex isRepeated:(BOOL)isRepeated cpParam:(NSString*)cpParam; 9 10 // Delegate回调，告诉调用者付费是否成功等信息11 @protocol GameBillingDelegate&lt;NSObject&gt;12 @required13 - (void)onBillingResult:(BillingResultType)resultCode billingIndex:(NSString *)index message:(NSString *)message;14 @end 以上前两个方法用于初始化SDK，并且和游戏的逻辑没什么太大关系，所以我们把对他们的调用放在程序开始的位置，不必导出给Lua。第三个方法在用户确认付费时使用，需要导出给Lua，当用户在游戏界面做相应操作时候调用。最后的delegate的回调，我们用前面提到的Objective-C SDK Delegate Class来接收，并作初步处理，再用Block传给C++ Bridge Class. 好的，那我们先来完成Objective-C SDK Delegate Class。这里这个Objective-C做成了个简单的单例来使用，实际可能不需要这么做。 先完成头文件，这里命名为CMGCIAPiOS.h，如下： 12345678910111213141516171819202122 1 #import \"GameBilling.h\" 2 3 // 声明Block 4 typedef void (^BillingResultCallback)(BOOL success, NSString *index,NSString *message); 5 6 @interface CMGCIAPiOS : NSObject&lt;GameBillingDelegate&gt; 7 &#123; 8 GameBilling *_sdk; 9 NSString *_billingIndex;10 BillingResultCallback _callback;11 &#125;12 13 +(id)sharedInstance;14 15 -(void)setDialogOrientationMask:(UIInterfaceOrientationMask)orientationMask;16 17 -(void)doBillingWithUIAndBillingIndex:(NSString *)billingIndex 18 isRepeated:(BOOL)isRepeated 19 cpParam:(NSString*)cpParam20 resultCallback:(BillingResultCallback)callback;21 22 @end 应该很清楚，就不多做说明了。 下面是实现文件CMGCIAPiOS.m，如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071 1 #import \"CMGCIAPiOS.h\" 2 3 @implementation CMGCIAPiOS 4 5 static CMGCIAPiOS *_sharedInstance = nil; 6 7 + (id)sharedInstance 8 &#123; 9 @synchronized(self)10 &#123;11 if (_sharedInstance == nil)12 &#123;13 _sharedInstance = [[CMGCIAPiOS alloc] init];14 &#125;15 &#125;16 return _sharedInstance;17 &#125;18 19 -(id) init20 &#123;21 if( (self = [super init]) ) 22 &#123;23 _sdk = [GameBilling initializeGameBilling];24 _sdk.delegate = self;25 &#125;26 return self;27 &#125;28 29 -(void)setDialogOrientationMask:(UIInterfaceOrientationMask)orientationMask30 &#123;31 [_sdk setDialogOrientationMask:orientationMask];32 &#125;33 34 - (void)doBillingWithUIAndBillingIndex:(NSString *)billingIndex 35 isRepeated:(BOOL)isRepeated 36 cpParam:(NSString*)cpParam37 resultCallback:(BillingResultCallback)callback38 &#123;39 40 if (_callback != nil)41 &#123;42 [_callback release];43 _callback = nil;44 &#125;45 46 _callback = [callback copy]; // 注意要copy47 48 [_sdk doBillingWithUIAndBillingIndex:billingIndex 49 isRepeated:isRepeated 50 cpParam:cpParam];51 &#125;52 53 #pragma mark - GameBillingDelegate54 - (void)onBillingResult:(BillingResultType)resultCode55 billingIndex:(NSString *)index 56 message:(NSString *)message57 &#123;58 BOOL b = (resultCode == BillingResultType_PaySuccess || resultCode == BillingResultType_PaySuccess_Activated);59 NSLog(@\"billing = %@ %@ %@\", b ? @\"yes\":@\"no\", index, message);60 61 if (_callback != nil)62 &#123;63 _callback(b,index,message);64 65 // 调用完成就释放掉66 [_callback release];67 _callback = nil;68 &#125;69 &#125;70 71 @end 可以看到对提到的几个方法都做了封装，并且接收了回调。 下面是C++ Bridge Class部分，头文件CMGCIAP.h: 123456789101112131415161718192021222324 1 #include &lt;iostream&gt; 2 3 class CMGCIAP 4 &#123; 5 public: 6 CMGCIAP(); 7 ~CMGCIAP(); 8 9 public:10 static CMGCIAP *sharedInstance();11 12 bool init();13 14 void setDoBillingCallbackScriptHandler(int scriptHandler); // for lua callback15 16 void doBillingWithUI(const char* billingIndex,17 bool isRepeated,18 const char* cpParam);19 20 private:21 22 int m_doBillingCallbackScriptHandler;23 24 &#125;; 由于用cocos2d-x的tolua工具做Lua Binding的原因，我把设置Lua回调的方法单独提出来了，如下： 1 void setDoBillingCallbackScriptHandler(int scriptHandler);更好的做法是把这个scriptHandler放到下面这个函数中，这样接口就可以和Objective的保持一致了。 1 void doBillingWithUI(const char billingIndex,2 bool isRepeated,3 const char cpParam);不过也没关系，独立设置Lua回调函数也有更灵活的优点。 注意，C++ Bridge Class头文件一定保持“纯洁性”，做纯粹的C++文件，不能出现Objective-C的任何代码，否则就破坏了上面讲到的层次结构。 下面是实现文件CMGCIAP.mm: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071 1 #include \"CMGCIAP.h\" 2 #include \"cocos2d.h\" 3 #include \"script_support/CCScriptSupport.h\" 4 5 #import \"CMGCIAPiOS.h\" 6 #import &lt;Foundation/Foundation.h&gt; 7 #import &lt;UIKit/UIKit.h&gt; 8 9 USING_NS_CC;10 11 static CMGCIAP* s_sharedInstance = NULL;12 13 CMGCIAP::CMGCIAP()14 &#123;15 m_doBillingCallbackScriptHandler = 0;16 &#125;17 18 CMGCIAP::~CMGCIAP()19 &#123;20 21 &#125;22 23 CMGCIAP *CMGCIAP::sharedInstance()24 &#123;25 if (s_sharedInstance == NULL)26 &#123;27 s_sharedInstance = new CMGCIAP();28 &#125;29 30 return s_sharedInstance;31 &#125;32 33 // init方法封装了对SDK的初始化34 bool CMGCIAP::init()35 &#123;36 // 由于是竖屏的游戏，所以这里直接设置好了37 [[CMGCIAPiOS sharedInstance] setDialogOrientationMask:UIInterfaceOrientationMaskPortrait];38 39 return true;40 &#125;41 42 void CMGCIAP::setDoBillingCallbackScriptHandler(int scriptHandler)43 &#123;44 m_doBillingCallbackScriptHandler = scriptHandler;45 &#125;46 47 void CMGCIAP::doBillingWithUI(const char* billingIndex,48 bool isRepeated,49 const char* cpParam)50 &#123;51 52 NSString *billingIndexString = [NSString stringWithUTF8String:billingIndex];53 54 NSString *cpParamString = [NSString stringWithUTF8String:cpParam];55 56 [[CMGCIAPiOS sharedInstance] doBillingWithUIAndBillingIndex:billingIndexString57 isRepeated:isRepeated58 cpParam:cpParamString59 resultCallback:^(BOOL success, NSString *index,NSString *message)&#123;60 61 //通过Block将返回结果传给Lua，Objective-C到C++的无缝连接：）62 63 CCLuaStack *stack = CCLuaEngine::defaultEngine()-&gt;getLuaStack();64 stack-&gt;clean();65 stack-&gt;pushBoolean(success);66 stack-&gt;pushString([index UTF8String]);67 stack-&gt;pushString([message UTF8String]);68 stack-&gt;executeFunctionByHandler(m_doBillingCallbackScriptHandler, 3);69 70 &#125;];71 &#125; 好了，接下来只需要对C++ Bridge Class做Lua Binding，生成绑定文件，如果用tolua做绑定，绑定配置文件如下： 12345678910 1 class CMGCIAP 2 &#123; 3 static CMGCIAP *sharedInstance(); 4 5 void setDoBillingCallbackScriptHandler(LUA_FUNCTION nHandler); 6 7 void doBillingWithUI(const char* billingIndex, 8 bool isRepeated, 9 const char* cpParam);10 &#125; OK，到这里主要的编码工作就完成了，记得要在程序的适当位置做好Lua Binding初始化工作。 如果一切顺利，在以上工作完成后，在Lua里面已经可以直接调用SDK的接口了，接下来的事情就靠你们了：）","link":"/2017/09/21/cocos2d-x-Lua接入iOS原生SDK的实现方案/"},{"title":"iOS开发技术栈","text":"提醒自己： Objective-C• objective-c语言基础• library,framework的制作• Runtime编程• LLVM原理和调优 操作系统• iOS内存管理和调优• iOS的文件系统和沙盒机制• iOS多线程编程（Thread,GCD,NSOperation）• iOS网络和服务器编程（NSURLConnection,NSURLSession）• iOS系统的各种安全机制 网络编程• iOS网络发送机制调整和优化（NSURLSession）• Socket编程•网络传输中的各种保障•对传输协议的调整优化 数据库&amp;持久化方案• 常规持久化方案（Keychain,NSUserDefaults,Sqlite,CoreData）•数据库的使用和设计（Sqlite）•数据结构优化，Sql调优 图形图像编程• UIKit,Core Animation和Core Text的绘制• Core Graphics, Quartz 2D, Media Player, AV Foundation• OpenGL ES, GLKit, SpriteKit, SceneKit, Metal 数据结构 &amp; 算法•基本的算法和数据结构（排序搜索算法, 数组, 队列）•较复杂数据结构的灵活应用（二叉树, 图等）•复杂的专项算法（图像识别算法, 拓扑定位等等） 安全方案• 本地数据存储安全（Keychain）•授权和身份验证•传输安全（对称, 非对称, SSL）• App代码安全 业务能力•一般性业务功能需求分析及实现•重要业务模块的需求分析及实现•中小规模产品的架构，系统设计和实现•大规模产品或产品线的架构，系统设计和实现•平台级产品的架构，系统设计和实现","link":"/2016/12/12/iOS开发技术栈/"},{"title":"python代码运行在iOS工程中的方案","text":"一种Xcode工程内执行python脚本的方法，详见下文。 1.下载解压Python-iOS.zip文件，打开python-ios.xcworkspace。2.Command+R运行，此时在模拟器上会有app生成；并且Xcode的console中会有log打印3.可以点击Send Msg按钮，会有如下log 当然，也可以打开浏览器，输入127.0.0.1:8000 实现方法：1.主要集成了python基础库libPython和静态库liblibpython.a2.include python.h,以及python 函数的使用方式：红色框中server.py脚本被放到了其他线程执行，解决了卡住主线程的问题。 3.同时我也给出了一个在用户界面向本地服务器消息交互的例子，使用socket。 例子比较简单，实现了最基础的在用户界面与本地服务器通信的例子。并且不影响iOS相关代码的编写。 由于附件较大，上传到了Github。https://github.com/koalahl/PythonIniOS","link":"/2016/07/11/python代码运行在iOS工程中的方案/"},{"title":"iOS开发ARC内存管理技术要点","text":"本文转载自iOS开发ARC内存管理技术要点-著作权归原作者所有 “本文来源于我个人的ARC学习笔记，旨在通过简明扼要的方式总结出iOS开发中ARC(Automatic Reference Counting，自动引用计数)内存管理技术的要点，所以不会涉及全部细节。这篇文章不是一篇标准的ARC使用教程，并假定读者已经对ARC有了一定了解和使用经验。详细的关于ARC的信息请参见苹果的官方文档与网上的其他教程：）” 本文的主要内容： ARC的本质 ARC的开启与关闭 ARC的修饰符 ARC与Block ARC与Toll-Free Bridging ARC的本质ARC是编译器（时）特性，而不是运行时特性，更不是垃圾回收器(GC)。Automatic Reference Counting (ARC) is a compiler-level feature that simplifies the process of managing object lifetimes (memory management) in Cocoa applications. ARC只是相对于MRC（Manual Reference Counting或称为非ARC，下文中我们会一直使用MRC来指代非ARC的管理方式）的一次改进，但它和之前的技术本质上没有区别。具体信息可以参考ARC编译器官方文档。 ARC的开启与关闭不同于XCode4可以在创建工程时选择关闭ARC，XCode5在创建的工程是默认开启ARC，没有可以关闭ARC的选项。 如果需要对特定文件开启或关闭ARC，可以在工程选项中选择Targets -&gt; Compile Phases -&gt; Compile Sources，在里面找到对应文件，添加flag: 打开ARC：-fobjc-arc 关闭ARC：-fno-objc-arc如图： ARC的修饰符ARC主要提供了4种修饰符，他们分别是:__strong,__weak,__autoreleasing,__unsafe_unretained。 __strong 表示引用为强引用。对应在定义property时的”strong”。所有对象只有当没有任何一个强引用指向时，才会被释放。 注意：如果在声明引用时不加修饰符，那么引用将默认是强引用。当需要释放强引用指向的对象时，需要将强引用置nil。 __weak 表示引用为弱引用。对应在定义property时用的”weak”。弱引用不会影响对象的释放，即只要对象没有任何强引用指向，即使有100个弱引用对象指向也没用，该对象依然会被释放。不过好在，对象在被释放的同时，指向它的弱引用会自动被置nil，这个技术叫zeroing weak pointer。这样有效得防止无效指针、野指针的产生。__weak一般用在delegate关系中防止循环引用或者用来修饰指向由Interface Builder编辑与生成的UI控件。 __autoreleasing 表示在autorelease pool中自动释放对象的引用，和MRC时代autorelease的用法相同。定义property时不能使用这个修饰符，任何一个对象的property都不应该是autorelease型的。 一个常见的误解是，在ARC中没有autorelease，因为这样一个“自动释放”看起来好像有点多余。这个误解可能源自于将ARC的“自动”和autorelease“自动”的混淆。其实你只要看一下每个iOS App的main.m文件就能知道，autorelease不仅好好的存在着，并且变得更fashion了：不需要再手工被创建，也不需要再显式得调用[drain]方法释放内存池。 以下两行代码的意义是相同的。12NSString *str = [[[NSString alloc] initWithFormat:@\"hehe\"] autorelease]; // MRCNSString *__autoreleasing str = [[NSString alloc] initWithFormat:@\"hehe\"]; // ARC 这里关于autoreleasepool就不做展开了，详细地信息可以参考官方文档或者其他文章。 __autoreleasing在ARC中主要用在参数传递返回值（out-parameters）和引用传递参数（pass-by-reference）的情况下。 __autoreleasing is used to denote arguments that are passed by reference (id *) and are autoreleased on return. 比如常用的NSError的使用：12345NSError *__autoreleasing error; ￼if (![data writeToFile:filename options:NSDataWritingAtomic error:&amp;error]) ￼&#123; NSLog(@\"Error: %@\", error); &#125; （在上面的writeToFile方法中error参数的类型为(NSError __autoreleasing )） 注意，如果你的error定义为了strong型，那么，编译器会帮你隐式地做如下事情，保证最终传入函数的参数依然是个__autoreleasing类型的引用。 1234567NSError *error; NSError *__autoreleasing tempError = error; // 编译器添加 if (![data writeToFile:filename options:NSDataWritingAtomic error:&amp;tempError]) ￼&#123; error = tempError; // 编译器添加 NSLog(@\"Error: %@\", error); &#125; 所以为了提高效率，避免这种情况，我们一般在定义error的时候将其（老老实实地=。=）声明为__autoreleasing类型的： NSError *__autoreleasing error;在这里，加上__autoreleasing之后，相当于在MRC中对返回值error做了如下事情： *error = [[[NSError alloc] init] autorelease]; error指向的对象在创建出来后，被放入到了autoreleasing pool中，等待使用结束后的自动释放，函数外error的使用者并不需要关心error指向对象的释放。 另外一点，在ARC中，所有这种指针的指针 （NSError **）的函数参数如果不加修饰符，编译器会默认将他们认定为__autoreleasing类型。 比如下面的两段代码是等同的：12345678- (NSString *)doSomething:(NSNumber **)value&#123; // do something &#125;- (NSString *)doSomething:(NSNumber * __autoreleasing *)value&#123; // do something &#125; 除非你显式得给value声明了__strong，否则value默认就是__autoreleasing的。 最后一点，某些类的方法会隐式地使用自己的autorelease pool，在这种时候使用__autoreleasing类型要特别小心。 比如NSDictionary的[enumerateKeysAndObjectsUsingBlock]方法： 123456789101112- (void)loopThroughDictionary:(NSDictionary *)dict error:(NSError **)error&#123; [dict enumerateKeysAndObjectsUsingBlock:^(id key, id obj, BOOL *stop)&#123; // do stuff if (there is some error &amp;&amp; error != nil) &#123; *error = [NSError errorWithDomain:@\"MyError\" ￼code:1 userInfo:nil]; &#125;￼ &#125;];￼&#125; 会隐式地创建一个autorelease pool，上面代码实际类似于： 123456789101112131415- (void)loopThroughDictionary:(NSDictionary *)dict error:(NSError **)error&#123; [dict enumerateKeysAndObjectsUsingBlock:^(id key, id obj, BOOL *stop)&#123; @autoreleasepool // 被隐式创建 &#123; if (there is some error &amp;&amp; error != nil) &#123; *error = [NSError errorWithDomain:@\"MyError\" ￼code:1 userInfo:nil]; &#125;￼ &#125; &#125;]; // *error 在这里已经被dict的做枚举遍历时创建的autorelease pool释放掉了 ：( ￼&#125; 为了能够正常的使用*error，我们需要一个strong型的临时引用，在dict的枚举Block中是用这个临时引用，保证引用指向的对象不会在出了dict的枚举Block后被释放，正确的方式如下： 1234567891011121314151617- (void)loopThroughDictionary:(NSDictionary *)dict error:(NSError **)error&#123; __block NSError* tempError; // 加__block保证可以在Block内被修改 [dict enumerateKeysAndObjectsUsingBlock:^(id key, id obj, BOOL *stop) &#123; if (there is some error) &#123; *tempError = [NSError errorWithDomain:@\"MyError\" ￼code:1 userInfo:nil]; &#125; ￼ &#125;] if (error != nil) &#123; *error = tempError; &#125; ￼&#125; __unsafe_unretained ARC是在iOS 5引入的，而这个修饰符主要是为了在ARC刚发布时兼容iOS 4以及版本更低的设备，因为这些版本的设备没有weak pointer system，简单的理解这个系统就是我们上面讲weak时提到的，能够在weak引用指向对象被释放后，把引用值自动设为nil的系统。这个修饰符在定义property时对应的是”unsafe_unretained”，实际可以将它理解为MRC时代的assign：纯粹只是将引用指向对象，没有任何额外的操作，在指向对象被释放时依然原原本本地指向原来被释放的对象（所在的内存区域）。所以非常不安全。 现在可以完全忽略掉这个修饰符了，因为iOS 4早已退出历史舞台很多年。 *使用修饰符的正确姿势（方式=。=） 这可能是很多人都不知道的一个问题，包括之前的我，但却是一个特别要注意的问题。 苹果的文档中明确地写道：You should decorate variables correctly. When using qualifiers in an object variable declaration, the correct format is: ClassName * qualifier variableName; 按照这个说明，要定义一个weak型的NSString引用，它的写法应该是： NSString * __weak str = @&quot;hehe&quot;; // 正确！而不应该是：__weak NSString *str = @&quot;hehe&quot;; // 错误！我相信很多人都和我一样，从开始用ARC就一直用上面那种错误的写法。 那这里就有疑问了，既然文档说是错误的，为啥编译器不报错呢？文档又解释道：Other variants are technically incorrect but are “forgiven” by the compiler. To understand the issue, seehttp://cdecl.org/. 好吧，看来是苹果爸爸（=。=）考虑到很多人会用错，所以在编译器这边贴心地帮我们忽略并处理掉了这个错误：）虽然不报错，但是我们还是应该按照正确的方式去使用这些修饰符，如果你以前也常常用错误的写法，那看到这里记得以后不要这么写了，哪天编译器怒了，再不支持错误的写法，就要郁闷了。 栈中指针默认值为nil 无论是被strong，weak还是autoreleasing修饰，声明在栈中的指针默认值都会是nil。所有这类型的指针不用再初始化的时候置nil了。虽然好习惯是最重要的，但是这个特性更加降低了“野指针”出现的可能性。 在ARC中，以下代码会输出null而不是crash:)12345- (void)myMethod &#123; NSString *name; NSLog(@\"name: %@\", name);&#125; ARC与Block在MRC时代，Block会隐式地对进入其作用域内的对象（或者说被Block捕获的指针指向的对象）加retain，来确保Block使用到该对象时，能够正确的访问。 这件事情在下面代码展示的情况中要更加额外小心。 12345678910MyViewController *myController = [[MyViewController alloc] init…];// 隐式地调用[myController retain];造成循环引用myController.completionHandler = ^(NSInteger result) &#123; [myController dismissViewControllerAnimated:YES completion:nil];&#125;;[self presentViewController:myController animated:YES completion:^&#123; [myController release]; // 注意，这里调用[myController release];是在MRC中的一个常规写法，并不能解决上面循环引用的问题&#125;]; 在这段代码中，myController的completionHandler调用了myController的方法[dismissViewController…]，这时completionHandler会对myController做retain操作。而我们知道，myController对completionHandler也至少有一个retain（一般准确讲是copy），这时就出现了在内存管理中最糟糕的情况：循环引用！简单点说就是：myController retain了completionHandler，而completionHandler也retain了myController。循环引用导致了myController和completionHandler最终都不能被释放。我们在delegate关系中，对delegate指针用weak就是为了避免这种问题。 不过好在，编译器会及时地给我们一个警告，提醒我们可能会发生这类型的问题： 对这种情况，我们一般用如下方法解决：给要进入Block的指针加一个__block修饰符。 这个__block在MRC时代有两个作用： 说明变量可改说明指针指向的对象不做这个隐式的retain操作一个变量如果不加__block ，是不能在Block里面修改的，不过这里有一个例外：static的变量和全局变量不需要加__block就可以在Block中修改。 使用这种方法，我们对代码做出修改，解决了循环引用的问题：123456MyViewController * __block myController = [[MyViewController alloc] init…];// ...myController.completionHandler = ^(NSInteger result) &#123; [myController dismissViewControllerAnimated:YES completion:nil];&#125;;//之后正常的release或者retain 在ARC引入后，没有了retain和release等操作，情况也发生了改变：在任何情况下，__block修饰符的作用只有上面的第一条：说明变量可改。即使加上了__block修饰符，一个被block捕获的强引用也依然是一个强引用。这样在ARC下，如果我们还按照MRC下的写法，completionHandler对myController有一个强引用，而myController对completionHandler有一个强引用，这依然是循环引用，没有解决问题：（ 于是我们还需要对原代码做修改。简单的情况我们可以这样写：123456__block MyViewController * myController = [[MyViewController alloc] init…];// ...myController.completionHandler = ^(NSInteger result) &#123; [myController dismissViewControllerAnimated:YES completion:nil]; myController = nil; // 注意这里，保证了block结束myController强引用的解除&#125;; 在completionHandler之后将myController指针置nil，保证了completionHandler对myController强引用的解除，不过也同时解除了myController对myController对象的强引用。这种方法过于简单粗暴了，在大多数情况下，我们有更好的方法。 这个更好的方法就是使用weak。（或者为了考虑iOS4的兼容性用unsafe_unretained，具体用法和weak相同，考虑到现在iOS4设备可能已经绝迹了，这里就不讲这个方法了）（关于这个方法的本质我们后面会谈到） 为了保证completionHandler这个Block对myController没有强引用，我们可以定义一个临时的弱引用weakMyViewController来指向原myController的对象，并把这个弱引用传入到Block内，这样就保证了Block对myController持有的是一个弱引用，而不是一个强引用。如此，我们继续修改代码：123456MyViewController *myController = [[MyViewController alloc] init…];// ...MyViewController * __weak weakMyViewController = myController;myController.completionHandler = ^(NSInteger result) &#123; [weakMyViewController dismissViewControllerAnimated:YES completion:nil];&#125;; 这样循环引用的问题就解决了，但是却不幸地引入了一个新的问题：由于传入completionHandler的是一个弱引用，那么当myController指向的对象在completionHandler被调用前释放，那么completionHandler就不能正常的运作了。在一般的单线程环境中，这种问题出现的可能性不大，但是到了多线程环境，就很不好说了，所以我们需要继续完善这个方法。 为了保证在Block内能够访问到正确的myController，我们在block内新定义一个强引用strongMyController来指向weakMyController指向的对象，这样多了一个强引用，就能保证这个myController对象不会在completionHandler被调用前释放掉了。于是，我们对代码再次做出修改： 123456789101112131415MyViewController *myController = [[MyViewController alloc] init…];// ...MyViewController * __weak weakMyController = myController;myController.completionHandler = ^(NSInteger result) &#123; MyViewController *strongMyController = weakMyController; if (strongMyController) &#123; // ... [strongMyController dismissViewControllerAnimated:YES completion:nil]; // ... &#125; else &#123; // Probably nothing... &#125;&#125;; 到此，一个完善的解决方案就完成了：） 官方文档对这个问题的说明到这里就结束了，但是可能很多朋友会有疑问，不是说不希望Block对原myController对象增加强引用么，这里为啥堂而皇之地在Block内新定义了一个强引用，这个强引用不会造成循环引用么？理解这个问题的关键在于理解被Block捕获的引用和在Block内定义的引用的区别。为了搞得明白这个问题，这里需要了解一些Block的实现原理，但由于篇幅的缘故，本文在这里就不展开了，详细的内容可以参考其他的文章，这里特别推荐唐巧的文章和另外2位作者的博文：这个和这个，讲的都比较清楚。 这里假设大家已经对Block的实现原理有所了解了。我们就直入主题了！注意前方高能（=。=） 为了更清楚地说明问题，这里用一个简单的程序举例。比如我们有如下程序： 123456789101112131415161718#include &lt;stdio.h&gt;int main()&#123; int b = 10; int *a = &amp;b; void (^blockFunc)() = ^()&#123; int *c = a; &#125;; blockFunc(); return 1;&#125; 程序中，同为int型的指针，a是被Block捕获的变量，而c是在Block内定义的变量。我们用clang -rewrite-objc处理后，可以看到如下代码： 原main函数： 123456789101112int main()&#123; int b = 10; int *a = &amp;b; void (*blockFunc)() = (void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, a); ((void (*)(__block_impl *))((__block_impl *)blockFunc)-&gt;FuncPtr)((__block_impl *)blockFunc); return 1;&#125; Block的结构： 12345678910111213struct __main_block_impl_0 &#123; struct __block_impl impl; struct __main_block_desc_0* Desc; int *a; // 被捕获的引用 a 出现在了block的结构体里面 __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int *_a, int flags=0) : a(_a) &#123; impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; &#125;&#125;; 实际执行的函数： 1234567static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123; int *a = __cself-&gt;a; // bound by copy int *c = a; // 在block中声明的引用 c 在函数中声明，存在于函数栈上 &#125; 我们可以清楚得看到，a和c存在的位置完全不同，如果Block存在于堆上（在ARC下Block默认在堆上），那么a作为Block结构体的一个成员，也自然会存在于堆上，而c无论如何，永远位于Block内实际执行代码的函数栈内。这也导致了两个变量生命周期的完全不同：c在Block的函数运行完毕，即会被释放，而a呢，只有在Block被从堆上释放的时候才会释放。 回到我们的MyViewController的例子中，同上理，如果我们直接让Block捕获我们的myController引用，那么这个引用会被复制后（引用类型也会被复制）作为Block的成员变量存在于其所在的堆空间中，也就是为Block增加了一个指向myController对象的强引用，这就是造成循环引用的本质原因。对于MyViewController的例子，Block的结构体可以理解是这个样子：（准确的结构体肯定和以下这个有区别，但也肯定是如下这种形式：） 12345678910111213struct __main_block_impl_0 &#123; struct __block_impl impl; struct __main_block_desc_0* Desc; MyViewController * __strong myController; // 被捕获的强引用myController __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int *_a, int flags=0) : a(_a) &#123; impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; &#125;&#125;; 而反观我们给Block传入一个弱引用weakMyController，这时我们Block的结构： 12345678910111213struct __main_block_impl_0 &#123; struct __block_impl impl; struct __main_block_desc_0* Desc; MyViewController * __weak weakMyController; // 被捕获的弱引用weakMyController __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int *_a, int flags=0) : a(_a) &#123; impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; &#125;&#125;; 再看在Block内声明的强引用strongMyController，它虽然是强引用，但存在于函数栈中，在函数执行期间，它一直存在，所以myController对象也一直存在，但是当函数执行完毕，strongMyController即被销毁，于是它对myController对象的强引用也被解除，这时Block对myController对象就不存在强引用关系了！加入了strongMyController的函数大体会是这个样子： 1234567static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123; MyViewController * __strong strongMyController = __cself-&gt;weakMyController; // .... &#125; 综上所述，在ARC下（在MRC下会略有不同），Block捕获的引用和Block内声明的引用无论是存在空间与生命周期都是截然不同的，也正是这种不同，造成了我们对他们使用方式的区别。 以上就解释了之前提到的所有问题，希望大家能看明白：） 好的，最后再提一点，在ARC中，对Block捕获对象的内存管理已经简化了很多，由于没有了retain和release等操作，实际只需要考虑循环引用的问题就行了。比如下面这种，是没有内存泄露的问题的： 123456789TestObject *aObject = [[TestObject alloc] init]; aObject.name = @\"hehe\";self.aBlock = ^()&#123; NSLog(@\"aObject's name = %@\",aObject.name); &#125;; 我们上面提到的解决方案，只是针对Block产生循环引用的问题，而不是说所有的Block捕获引用都要这么处理，一定要注意！ ARC与Toll-Free BridgingThere are a number of data types in the Core Foundation framework and the Foundation framework that can be used interchangeably. This capability, called toll-free bridging, means that you can use the same data type as the parameter to a Core Foundation function call or as the receiver of an Objective-C message. Toll-Free Briding保证了在程序中，可以方便和谐的使用Core Foundation类型的对象和Objective-C类型的对象。详细的内容可参考官方文档。以下是官方文档中给出的一些例子： 12345678910111213NSLocale *gbNSLocale = [[NSLocale alloc] initWithLocaleIdentifier:@\"en_GB\"];CFLocaleRef gbCFLocale = (CFLocaleRef) gbNSLocale;CFStringRef cfIdentifier = CFLocaleGetIdentifier (gbCFLocale);NSLog(@\"cfIdentifier: %@\", (NSString *)cfIdentifier);// logs: \"cfIdentifier: en_GB\"CFRelease((CFLocaleRef) gbNSLocale); CFLocaleRef myCFLocale = CFLocaleCopyCurrent();NSLocale * myNSLocale = (NSLocale *) myCFLocale;[myNSLocale autorelease];NSString *nsIdentifier = [myNSLocale localeIdentifier];CFShow((CFStringRef) [@\"nsIdentifier: \" stringByAppendingString:nsIdentifier]);// logs identifier for current locale 在MRC时代，由于Objective-C类型的对象和Core Foundation类型的对象都是相同的release和retain操作规则，所以Toll-Free Bridging的使用比较简单，但是自从ARC加入后，Objective-C类型的对象内存管理规则改变了，而Core Foundation依然是之前的机制，换句话说，Core Foundation不支持ARC。 这个时候就必须要要考虑一个问题了，在做Core Foundation与Objective-C类型转换的时候，用哪一种规则来管理对象的内存。显然，对于同一个对象，我们不能够同时用两种规则来管理，所以这里就必须要确定一件事情：哪些对象用Objective-C（也就是ARC）的规则，哪些对象用Core Foundation的规则（也就是MRC）的规则。或者说要确定对象类型转换了之后，内存管理的ownership的改变。 If you cast between Objective-C and Core Foundation-style objects, you need to tell the compiler about the ownership semantics of the object using either a cast (defined in objc/runtime.h) or a Core Foundation-style macro (defined inNSObject.h) 于是苹果在引入ARC之后对Toll-Free Bridging的操作也加入了对应的方法与修饰符，用来指明用哪种规则管理内存，或者说是内存管理权的归属。 这些方法和修饰符分别是： __bridge（修饰符） 只是声明类型转变，但是不做内存管理规则的转变。 比如： CFStringRef s1 = (__bridge CFStringRef) [[NSString alloc] initWithFormat:@&quot;Hello, %@!&quot;, name];只是做了NSString到CFStringRef的转化，但管理规则未变，依然要用Objective-C类型的ARC来管理s1，你不能用CFRelease()去释放s1。 __bridge_retained（修饰符） or CFBridgingRetain（函数） 表示将指针类型转变的同时，将内存管理的责任由原来的Objective-C交给Core Foundation来处理，也就是，将ARC转变为MRC。 比如，还是上面那个例子12345NSString *s1 = [[NSString alloc] initWithFormat:@\"Hello, %@!\", name];￼CFStringRef s2 = (__bridge_retained CFStringRef)s1;￼// do something with s2//...￼CFRelease(s2); // 注意要在使用结束后加这个 我们在第二行做了转化，这时内存管理规则由ARC变为了MRC，我们需要手动的来管理s2的内存，而对于s1，我们即使将其置为nil，也不能释放内存。 等同的，我们的程序也可以写成：123456NSString *s1 = [[NSString alloc] initWithFormat:@\"Hello, %@!\", name];￼CFStringRef s2 = (CFStringRef)CFBridgingRetain(s1);￼// do something with s2//...￼CFRelease(s2); // 注意要在使用结束后加这个__bridge_transfer（修饰符） or CFBridgingRelease（函数） 这个修饰符和函数的功能和上面那个__bridge_retained相反，它表示将管理的责任由Core Foundation转交给Objective-C，即将管理方式由MRC转变为ARC。 比如：1234CFStringRef result = CFURLCreateStringByAddingPercentEscapes(. . .);￼NSString *s = (__bridge_transfer NSString *)result;//or NSString *s = (NSString *)CFBridgingRelease(result);￼return s; 这里我们将result的管理责任交给了ARC来处理，我们就不需要再显式地将CFRelease()了。 对了，这里你可能会注意到一个细节，和ARC中那个4个主要的修饰符（__strong,__weak,…）不同，这里修饰符的位置是放在类型前面的，虽然官方文档中没有说明，但看官方的头文件可以知道。小伙伴们，记得别把位置写错哦：）呼~ 好了，以上就是本篇文章的主要内容。这次采用了新的排版，感觉比以前有条理得多，希望的大家看的舒服。 文章中如果有任何错误或者问题，可以在下面留言或者给我发信，期待你们的回复。 感谢大家的收看。","link":"/2017/09/21/iOS开发ARC内存管理技术要点/"},{"title":"Objc Runtime 再次实践","text":"好久不用，再次使用runtime重写代码。就用高性能添加图片圆角来再一次实践一下runtime的基本用法。 runtime使用场景： category添加关联属性 MethodSwizzle替换/交换系统方法 平常使用cornerRadius和maskToBounds组合设置圆角 category添加关联属性废话不多说，直接上代码创建一个NSError的category，添加一个errorMsg的属性。因为category本身不能添加属性，这里是使用runtime动态添加关联属性 MethodSwizzle交换系统方法创建一个UIImageView的category，在分类中交换（exchange，注意这里不是替换replace）系统的setImage: 方法. 我们要交换一个类的系统方法，那么首先想想在哪个方法中交换最合适呢？我们知道app在启动之后，会进行类注册，调用类的+load()方法，且只调用一次。（注意与+initialize的区别）第51条:load与initialize的区别所以我们在分类中重写load方法中添加交换方法。 首先我们借用AFNetworking中AFURLSessionManager中定义的swizzle的内联函数123456789101112static inline void hl_swizzleSelector(Class theClass, SEL originalSelector, SEL swizzledSelector) &#123; Method originalMethod = class_getInstanceMethod(theClass, originalSelector); Method swizzledMethod = class_getInstanceMethod(theClass, swizzledSelector); method_exchangeImplementations(originalMethod, swizzledMethod);&#125;static inline BOOL hl_addMethod(Class theClass, SEL selector, Method method) &#123; /* YES if the method was added successfully, otherwise NO (for example, the class already contains a method implementation with that name) */ return class_addMethod(theClass, selector, method_getImplementation(method), method_getTypeEncoding(method));&#125;然后在+load方法中添加如下代码：1hl_swizzleSelector([self class], @selector(setImage:), @selector(hl_setImage:)); /* 这里参考的是AFURLSessionManager中的方式来添加方法，但是实际上在这个情况下是永远返回NO的 原因：因为我们是在UIImageView的category中添加了hl_setImage:，所以在UIImageView中已经存在了该方法，再调用class_addMethod就会返回NO。 因此下面这些代码如果写在category中是不需要的了。*/123456Method hlSetImageMethod = class_getInstanceMethod([self class],@selector(hl_setImage:));BOOL result = hl_addMethod([self class],@selector(hl_setImage:), hlSetImageMethod);NSLog(@\"%d\",result);if (result) &#123;&#125; 测试一下代码：123456789101112131415UIImageView * v = [[UIImageView alloc]initWithFrame:CGRectMake(0, 0, 240, 240)];v.center = self.view.center;[self.view addSubview:v];UIImage * image = [UIImage imageNamed:@\"IMG_0730.jpg\"];//会产生混合图层v.layer.cornerRadius = v.frame.size.width / 2;v.layer.masksToBounds = YES;//采用UIGraphicImageContext重绘后,解决混合图层问题[v setImage:[image hl_imageByCroppingForSize:CGSizeMake(240, 240) fillColor:[UIColor whiteColor]]];//使用Method swizzle交换setImage和hl_setImage:之后：v.image = image; 其中的性能问题我们在UIImage+HLAdd分类中使用UIGraphicImageContext来重新绘图，这肯定是要耗时的操作。12345CFTimeInterval start = CACurrentMediaTime();...//绘图...NSLog(@\"%f\",CACurrentMediaTime() - start); 12016-11-22 17:53:42.614 iOS-Kick-On[47630:2598373] 0.003525 大概耗时在0.003~0.006之间，以纳秒进行运算的cpu来说，还是一个稍微耗时的操作，因为我们可以把它放在后台线程来做，然后采用回调来获取返回的image12345678910dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; UIImage * result = [self hl_imageByCroppingCorner:radius forSize:targetSize fillColor:[UIColor whiteColor]]; dispatch_async(dispatch_get_main_queue(), ^&#123; if (completion) &#123; completion(result); &#125; &#125;);&#125;); 本篇文章代码","link":"/2016/11/22/OBJC-RUNTIME-再次实践/"},{"title":"《程序员的自我修养》读书笔记-温故知新","text":"基础篇回顾一下两个基础：内存线程 内存早期的计算机，程序直接运行在物理内存上。那么久存在一个问题：如何尽可能的将有限的物理内存分配给多个程序使用。内存使用存在的问题： 1.地址空间不足 2.内存使用效率低 3.程序运行的地址不确定-重定位问题。那么针对这三个问题，利用中间层,让程序间接的访问物理地址，来解决以上几个问题。- 分段：（segment）将程序需要的地址空间映射到一段虚拟空间上。以此将程序间隔离。此方法解决第一个和第三个问题。- 分页：（paging）将地址空间人为分为固定大小的页（page）。一般为4KB大小。虚拟内存的实现需要依靠硬件支持。通常采用MMU(Memory Management Unit)来进行page mapping，将CPU使用的虚拟地址映射为实际的物理地址。线程 线程结构：线程ID、指令指针PC、线程内栈和寄存器 现在基本都是多线程。 线程的访问权限。 线程私有 线程间共享 - 局部变量 全局变量 - 函数的参数 堆上的数据 - TLS数据 函数中的静态变量 程序代码 打开的文件。线程A打开的文件可以由线程B读写 线程安全 单指令操作称为原子的Atomic。简单情况下可保证线程安全，但是在复杂的数据结构中，就有可能不能保证。此时需要更加通用的手段：锁 同步与锁。但是还是有可能出现问题，原因来自于CPU执行指令的换序（CPU有可能将后面的代码先执行）。 barrier阻塞机制。barrier指令会阻止CPU将barrier指令之前的指令交换到barrier之后，反之亦然。","link":"/2016/05/10/《程序员的自我修养》读书笔记-温故知新/"},{"title":"《iOS开发进阶》阅读笔记（一）内存管理释疑","text":"ARC ARC能够解决iOS开发中90%的内存管理问题，但是另外还有10%的内存管理是需要手动管理的，主要就是与底层Core Foundation对象交互的部分，因为底层Core Foundation对象由于不在ARC的管理下。 使用ARC需要额外注意的两个问题： 1.过度使用block产生的循环引用问题。 2.底层Core Foundation对象需要手动进行内存管理。 Core Foundation对象的内存管理 底层的Core Foundation对象的创建，大多数以XxxCreateWithXxx这样的方式创建，例如： 12//创建一个CFStringRef对象 CFStringRef str = CFStringCreateWithCString(kCFAllocatorDefault,\"hello world\",kCFStringEncodingUTF8); 或者123456789//设置字间距+ (NSAttributedString *)setLabelAttributeString:(NSString*)labelText withCharactorSpace:(CGFloat)charactorSpace&#123; NSMutableAttributedString * string =[[NSMutableAttributedString alloc]initWithString:labelText]; long number = charactorSpace; CFNumberRef num = CFNumberCreate(kCFAllocatorDefault,kCFNumberSInt8Type,&amp;number); [string addAttribute:(id)kCTKernAttributeName value:(__bridge id)num range:NSMakeRange(0,[string length])]; CFRelease(num); return string;&#125; 对于这种对象的修改和释放，需要相应的使用CFRetain和CFRelease。除此之外，还有另外一个问题需要解决。在ARC下，我们有时需要将一个Core Foundation对象转换成Objective-C对象，这个时候我们需要告诉编译器，转换过程中的引用计数如何调整。这就引入了与bridge相关的关键字： __bridge:只做类型转换，不修改相关对象的引用计数，原来的Core Foundation对象在不用时，需要调用CFRelease方法。 __bridge_retained:类型转换后，将相关对象的引用计数+1，原来的Core Foundation对象在不用时，需要调用CFRelease方法。 __bridge_transfer:类型转换后，将该对象的引用计数交给ARC管理，Core Foundation对象在不用时，不再需要调用CFRelease方法。 我们根据业务逻辑，合理使用上面三种转换关键字，就可以解决Core Foundation对象与Objc对象相互转换的问题了。","link":"/2015/12/12/《iOS开发进阶》阅读笔记（一）内存管理释疑/"},{"title":"iOS自动打包脚本","text":"使用Xcodebuild和xcrun命令生成。具体参数可以自己配置。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#!/bin/bash#Author hanliu#Global declarationSCHEMENAME=\"hongmeng\"#if use git#BRANCHNAME = masterDATE=`date \"+%Y%m%d\"`SOURCEPATH=$(CD \"$(dirname $0)\" &amp;&amp; pwd)BUILDPATH=$(dirname $(dirname $SOURCEPATH))/AutoBuildIPABUILDAPPPATH=$BUILDPATH/Build/Products/Debug-iphoneosIPAPATH=$(dirname $(dirname $SOURCEPATH))/IPAIPANAME=$SCHEMENAME_$DATE.ipaecho \"DATE is \" $DATEecho \"SOURCEPATH:\"$SOURCEPATHecho \"BUILDPATH:\"$BUILDPATHecho \"IPAPATH:\"$IPAPATHecho \"Press any key to continue!\"read -p \"press any \" cif $c;then xcodebuild -listelse echo \"ddd\"fi##Information about project \"xxxxx\":# Targets:# xxxxxx## Build Configurations:# Debug# Release## If no build configuration is specified and -scheme is not passed then \"Release\" is used.## Schemes:# xxxxxx##不指定configuration，打包为debug模式#xcodebuild -workspace hongmeng.xcworkspace -scheme hongmeng -configuration Debug clean build -derivedDataPath $BUILDPATHxcodebuild -workspace $SCHEMENAME.xcworkspace -scheme $SCHEMENAME -configuration Debug clean build -derivedDataPath $BUILDPATHif [ -e $BUILDPATH ]; then echo \"xcodebuild Successful!\"else echo \"xcodebuild failure!\" exit 1fi#打包ipa#xcrun -sdk iphoneos PackageApplication -v AutoBuildIPA/Build/Products/Debug-iphoneos/$SCHEMENAME.app -o $BUILDPATH/$SCHEMENAME_$DATE.ipaxcrun -sdk iphoneos PackageApplication -v $BUILDAPPPATH/$SCHEMENAME.app -o $IPAPATH/$IPANAMEif [ -e $IPAPATH/$IPANAME ]; then echo \"\\n--------------\\n\\n\" echo \"Congratulations! Build Successful!\" open $IPAPATHelse echo \"Build failure!\"fi","link":"/2016/11/30/iOS自动打包脚本/"},{"title":"一次iOS EXC_BAD_ACCESS 的分析解决过程","text":"游戏客户端在断线重连后需要调用SDK方法清空消息缓存数据，但是因为游戏在后台停留时间较长，部分内存被释放，导致出现EXC_BAD_ACCESS。 网上大部分关于EXC_BAD_ACCESS的文章都是写了如何检测，并没有说明如何处理这种问题。当然本文也是基于特定场景下解决了该问题。 什么是EXC_BAD_ACCESS？EXC_BAD_ACCESS简单的讲就是使用了已经被释放的内存，导致crash。 写Demo测试ClassA(单例对象) ， 一个 strong 的NSMutableArray *marr 吧。 @property (nonatomic, strong) NSMutableArray *marr; 1、场景：app1退到后台，使用其他app，经过几分钟后，重新进入app1，会调用 [[ClassA sharedIndstance] clean]。clean方法：123- (void)clean &#123; [self.marr removeAllObjects];&#125;2、分析：A1：ClassA单例对象被释放但是每次不是又[ClassA sharedIndstance] 了吗？A2：marr 属性被释放，这种怎么讲，单例没释放，反而里面的属性被释放？？经测试，原因为分析1. [ClassA sharedIndstance] 并不能重新init，即使能init，那也是新的内存对象了。3、测试过程：1. 新建单例类SingeTonClass，并在xcode设置为MRC.2. 初始化然后手动release，再初始化。￼￼￼又尝试了这种方式初始化：如果再dealloc之后重新以 alloc方式初始化，则并非以前的对象了，无意义。￼￼那么到此为止，可能看起来就暂时没办法解决了。冲突点：此类必须使用单例，因为工程里面全部用的这种方式；然后断线重连后必须调用clean方法。4、最后如何解决？ 其实也还是采用分析1的方式，重新初始化单例类[ClassA sharedIndstance]。 为何？问题发生的场景。 因为游戏本身断线重连后要清空缓存消息，相当于重新初始化一次单例类。之前一直在意重新初始化后并非原对象，没有考虑问题发生的场景。 那么重新初始化sharedIndstance时，需要先把原来的单例销毁，方法:￼ 自此，问题解决。","link":"/2018/02/08/一次iOS-EXC-BAD-ACCESS-的分析解决过程/"},{"title":"《iOS开发进阶》阅读笔记（二）——开发技巧","text":"收起键盘 在UIViewController中收起键盘，处了调用相应控件的resignFirstResponder方法外，还有另外三种方法： 重载UIViewController的touchBegin方法，然后在里面执行[self.view endEditing:YES];,这样单击UIViewController的任意地方，就可以收起键盘； 直接执行[[UIApplicatoin sharedApplication] sendAction:@selector(resignFirstResponder) to:nil from:nil forEvent:nil];,用于在获得当前UIViewController比较困难的时候使用。 直接执行[[[UIApplicatoin sharedApplication] keyWindow] endEditing:YES];。 NSJSONSerialization比NSKeyedArchiver更好 在选择持久化方案时，系统提供的NSJSONSerialization比NSKeyedArchiver在效率和体积上都更优，更详细的测试参考：https://github.com/randomsequence/NSSerialisationTests; 设置应用内的系统控件语言 在工程的info.plist文件中增加如下内容：12345&lt;key&gt;CFBundleLocalizations&lt;/key&gt;&lt;array&gt; &lt;string&gt;zh_CN&lt;/string&gt; &lt;string&gt;en&lt;/string&gt;&lt;/array&gt; 巧用系统的截屏功能 iOS7以后，apple提供的系统的截屏API：- (UIView *)snapshotViewAfterScreenUpdates:(BOOL)afterUpdates来实现截屏功能。而对于iOS7以前的系统，可以用过代码来实现截屏功能： 123456789+ (UIImage *)captureImageFromView:(UIView *)view&#123; CGRect screenRect = [view bounds]; UIGraphicsBeginImageContext(screenRect.size); CGContextRef ctx = UIGraphicsGetCurrentContext(); [view.layer renderInContext:ctx]; UIImage *image = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); return image;&#125; Javascript文件设置调整 Javascript的js后缀的文件默认被拖动到工程中后，是在编译列表中，而不是资源列表中。需要手动调整期位置，否则它就不能打包到ipa文件中。 注：xcode7已经修改此问题，如下图： 忽略编译警告 在Build Phase中对应的文件中添加 -w参数。 定制NSLog12345#ifdef DEBUG#define NSLog(args,...) NSLog(@\"-%d%s:%@\",__LINE__,__FUNCTION__,[NSString stringWithFormat:(args), ##__VA_ARGS__])#else#define NSLog(...)#endif 导航栏上的一些设置1234567去掉导航栏阴影黑线。setBackGroundImage中也可以直接使用[UIImage new]UINavigationBar *navBar = self.navigationController.navigationBar;[navBar setBackgroundImage:[UIImage imageNamed:@&quot;white_backgroud&quot;] forBarPosition:UIBarPositionAny barMetrics:UIBarMetricsDefault];[navBar setShadowImage:[UIImage new]];去掉searchBar的阴影[self.searchBar setBackgroundImage:[UIImage new]];","link":"/2015/12/13/《iOS开发进阶》阅读笔记（二）——开发技巧/"},{"title":"关于CoreData和SQLite多线程访问时的线程安全问题","text":"数据库读取操作一般都是多线程访问的。在对数据进行读取时，我们要保证其当前状态不能被修改，即读取时加锁，否则就会出现数据错误混乱。IOS中常用的两种数据持久化存储方式：CoreData和SQLite，两者都需要设置线程安全，在这里以FMDB来解释对SQLite的线程安全访问。 一:FMDB的线程安全：（以读取图片为例） 1.没有线程安全的执行方式：123456789101112131415161718192021222324252627282930313233343536373839404142434445//************** 数据库保存图片 ******************// FMDatabase *database = [FMDatabase databaseWithPath:[self getDatabasePath]]; //打开数据库 [database open]; NSString *sql = @\"create table if not exists Test (id integer primary key autoincrement,name text,image blob);\"; //创建表 [database executeUpdate:sql]; //把UIImage对象转化为NSData NSData *data = UIImagePNGRepresentation([UIImage imageNamed:@\"user_browse\"]); //写入数据 sql = @\"insert into Test (name,image) values (?,?)\"; [database executeUpdate:sql,@\"张三\",data]; //读取显示 sql = @\"select * from Test;\"; FMResultSet *resultSet = [database executeQuery:sql]; while (resultSet.next) &#123; //[resultSet dataForColumn:@\"image\"]; NSData *imageData = [resultSet dataForColumnIndex:2]; UIImageView *imageView = [[UIImageView alloc] initWithFrame:CGRectMake(0, 0, 300, 300)]; imageView.image = [UIImage imageWithData:imageData]; [self.view addSubview:imageView]; &#125;2，使用线程队列1234567891011121314151617181920212223242526272829303132333435363738394041424344//************** 数据库线程安全 ***********// FMDatabaseQueue *queue = [[FMDatabaseQueue alloc] initWithPath:[self getDatabasePath]]; [queue inDatabase:^(FMDatabase *db) &#123; //线程安全的 __block NSString *sql = @\"create table if not exists Test (id integer primary key autoincrement,name text,image blob);\"; //创建表 [database executeUpdate:sql]; &#125;]; //插入数据 [queue inDatabase:^(FMDatabase *db) &#123; //写入数据 sql = @\"insert into Test (name,image) values (?,?)\"; [database executeUpdate:sql,@\"张三\",data]; &#125;]; //读取 [queue inDatabase:^(FMDatabase *db) &#123; //读取显示 sql = @\"select * from Test;\"; FMResultSet *resultSet = [database executeQuery:sql]; while (resultSet.next) &#123; //[resultSet dataForColumn:@\"image\"]; NSData *imageData = [resultSet dataForColumnIndex:2]; UIImageView *imageView = [[UIImageView alloc] initWithFrame:CGRectMake(0, 0, 300, 300)]; imageView.image = [UIImage imageWithData:imageData]; [self.view addSubview:imageView]; &#125; &#125;]; 分析一下线程安全下的FMDB的实现：在当使用FMDBDatabaseQueue创建数据库时，会使用GCD创建一个线程队列：12345。。。 _queue = dispatch_queue_create([[NSString stringWithFormat:@\"fmdb.%@\", self] UTF8String], NULL); dispatch_queue_set_specific(_queue, kDispatchQueueSpecificKey, (__bridge void *)self, NULL); _openFlags = openFlags;。。。 然后在读取时调用[queue inDatabase:^(FMDatabase *db)方法，在block中会锁定当前数据库12345dispatch_sync(_queue, ^() &#123; FMDatabase *db = [self database]; block(db); ……&#125; 我们可以看到实际上这里是对整个数据库进行加锁，以此来保证线程安全的。 二、CoreData的线程安全 1.没有线程安全的coredata数据读取： NSManagedObjectContext对象的创建：_managedObjectContext = [[NSManagedObjectContext alloc] init]; 插入数据操作：（AppDetailModal为数据模型） context 为返回的 _managedObjectContext1AppDetailModal *newapp = [NSEntityDescription insertNewObjectForEntityForName:TableName inManagedObjectContext:context]; 其他查询、更新、删除操作//获取Entity1NSEntityDescription *entity = [NSEntityDescription entityForName:TableName inManagedObjectContext:context]; 2.线程安全的coreData操作： 首先创建并行的NSManagedObjectContext对象1NSManagedObjectContext* context=[[NSManagedObjectContext alloc] initWithConcurrencyType:NSPrivateQueueConcurrencyType]; 然后在执行读取操作时使用一下两个方法： -(void)performBlock:(void (^)(void))block -(void)performBlockAndWait:(void (^)(void))block 12345[context performBlock:^&#123; //要执行的读取操作 &#125;];","link":"/2015/12/14/关于CoreData和SQLite多线程访问时的线程安全问题/"},{"title":"如何做一个圆形的音量旋钮","text":"最近在Medium上浏览一些国外的iOS开发相关的文章，看到感兴趣的便实践一番，记录下来。一来算是学习swift，另一方面则是为了拓宽技术面。 这篇文章来自Karthik Keyan Balan的How to create a circular seek bar in iOS主要展示了一个圆形的类似音量旋钮的UI控件，用swift实现。如下图， 如何画出圆形旋钮 使用CAShapeLayer，并将其path设置为自定义的贝塞尔曲线的path。 1234567891011121314151617181920212223lazy var seekerBarLayer = CAShapeLayer()...private func addSeekerBar() &#123; let center = CGPointMake(self.bounds.size.width/2, self.bounds.size.height/2) //弧度 let sAngle = degreeToRadian(Double(startAngle)) let eAngle = degreeToRadian(Double(endAngle)) let path = UIBezierPath(arcCenter: center, radius: (self.bounds.size.width - 18)/2, startAngle:CGFloat(sAngle) , endAngle:CGFloat(eAngle) , clockwise: true) seekerBarLayer.path = path.CGPath; seekerBarLayer.lineWidth = 4.0 seekerBarLayer.lineCap = kCALineCapRound seekerBarLayer.strokeColor = seekBarColor.CGColor seekerBarLayer.fillColor = UIColor.clearColor().CGColor if seekerBarLayer.superlayer == nil &#123; self.layer.addSublayer(seekerBarLayer) &#125; &#125; 根据touch位置移动旋钮位置 重载touch相关的三个方法，重点是在continueTrackingWithTouch方法中，根据touch的坐标计算按钮需要移动的位置的moveToPoint方法。 获取touch位置 计算旋钮对应的坐标 获取touch位置 12345678910111213141516171819202122232425262728293031//MARK: Touch Eventoverride func beginTrackingWithTouch(touch: UITouch, withEvent event: UIEvent?) -&gt; Bool &#123; let point = touch.locationInView(self) let rect = CGRectInset(self.thumbButton.frame, -20, -20) let canBegin = CGRectContainsPoint(rect, point) if canBegin &#123; UIView.animateWithDuration(0.2, delay: 0.0, options: .CurveEaseIn, animations: &#123; () -&gt; Void in self.thumbButton.transform = CGAffineTransformMakeScale(1.2, 1.2) &#125;, completion: nil) &#125; return canBegin&#125;override func continueTrackingWithTouch(touch: UITouch, withEvent event: UIEvent?) -&gt; Bool &#123; if #available(iOS 9,*)&#123; guard let coalescedTouches = event?.coalescedTouchesForTouch(touch) else&#123; return moveToPoint(touch.locationInView(self)) &#125; let result = true for cTouch in coalescedTouches&#123; let result = moveToPoint(cTouch.locationInView(self)) if result == false &#123;break&#125; &#125; return result &#125; return true&#125;override func endTrackingWithTouch(touch: UITouch?, withEvent event: UIEvent?) &#123; thumbMoveDidComplete()&#125; 计算旋钮对应的坐标 1234567891011121314151617181920212223242526272829303132func moveToPoint(point:CGPoint) -&gt;Bool&#123; var degree = degreeForLocation(point) func moveToClosestEdge(degree:Double)&#123; let startDistance = fabs(CGFloat(degree) - startAngle) let endDistance = fabs(CGFloat(degree) - endAngle) if startDistance &lt; endDistance&#123; currentAngle = startAngle &#125;else&#123; currentAngle = endAngle &#125; &#125; if startAngle &gt; endAngle &#123; if degree &lt; Double(startAngle) &amp;&amp; degree &gt; Double(endAngle)&#123; moveToClosestEdge(degree) thumbMoveDidComplete() return false &#125; &#125; else &#123; if degree &gt; Double(endAngle) || degree &lt; Double(startAngle)&#123; moveToClosestEdge(degree) thumbMoveDidComplete() return false &#125; &#125; currentAngle = CGFloat(degree) return true&#125; 手动发送action由于这个控件是继承自UIControl的，正如其他继承与UIControl的控件一样，我们可以自定义一个控件的状态事件。例如valueChanged、TouchUpInside、TouchOutSide。这里我们需要的是控件的位置信息，所以当endTouch的时候发送一个valueChanged事件：1self.sendActionsForControlEvents(.ValueChanged) 其中有一个小细节，当点击到按钮时，会有一个变大的动画效果，其实也是用到了一个基本的拉伸效果：123UIView.animateWithDuration(0.2, delay: 0.0, options: .CurveEaseIn, animations: &#123; () -&gt; Void in self.thumbButton.transform = CGAffineTransformMakeScale(1.2, 1.2) &#125;, completion: nil) 总结 利用CAShapeLayer+贝塞尔曲线画出UI。 根据角度计算弧度，并导出按钮对应的坐标点。 touch事件的处理。- 手动发送action。 参考代码：CircularSeek On GitHub","link":"/2016/01/17/如何做一个圆形的音量旋钮/"},{"title":"《程序员的自我修养》读书笔记-编译和链接","text":"一个HelloWorld.c程序是如何被处理，得到一个a.out可执行程序的呢？$gcc HelloWorld.c命令，得到a.out$./a.out 执行 该过程可分为四个步骤：预处理（Preprocess）或者叫预编译、编译（Compile）、汇编（Assembly）和链接（Linking）。 预编译 预编译的命令$gcc -E HelloWorld.c -o HelloWorld.i。预编译中的主要规则： 将所有的#define删除，展开所有的宏定义 处理所有的条件预编译指令，比如#if,#ifdef,#endif,#elif,#else. 处理#include指令，将被包含的文件插入到该预编译指令的位置。这个过程是递归进行的 删除所有的注释//和/**/. 添加行号和文件名标识。 保留所有的#pragma编译器指令，因为编译器要使用它。 编译 编译器 ：cc1程序编译过程就是把预处理完的.i文件进行一系列的词法分析、语法分析、语义分析以及代码优化后产生相应的汇编代码编译的命令$gcc -S HelloWorld.c -o HelloWorld.s。 汇编 汇编器 as汇编过程将汇编代码转换成机器代码。根据汇编指令和机器代码的对照表一一翻译。汇编的命令$gcc -c HelloWorld.c -o HelloWorld.o。 链接 链接器 ld从图中可以看出，链接器主要是把代码的.o文件与静态库链接在一起。","link":"/2016/05/10/《程序员的自我修养》读书笔记-编译和链接/"},{"title":"如何在swift项目中创建Objective-C Bridging header","text":"在swift工程中，有时候我们也需要使用OBJC代码写的第三方库或者工具类等，这时就需要创建objc文件到swift的桥接header。现在有两种方法创建Objective-C Bridging Header: Create Objective-C File as HeaderGo to File &gt; New &gt; File and Select Objective-C: 然后一直next，最后出现如下图时，点击yes： 这种方式会创建出.h和.m文件。 Create Objective-C Header File DirectlyGo to File &gt; New &gt; File and Select Objective-C Header File: 最后，两种方法创建的.h文件中import你将使用的类。1#import \"xxxx\" 一般在项目中我们使用第二种方法。","link":"/2015/12/30/如何在swift项目中创建Objective-C-Bridging-header/"},{"title":"修改UIBarButtonItem标题文字大小、颜色、阴影等","text":"修改UIBarButtonItem的标题文字大小、颜色、阴影等有时候我们需要设置一下导航栏右侧按钮标题的大小、颜色等等，但是UIBarButtonItem没有直接提供相关方法。通过查看UIbarButtonItem官方文档，总结出有以下两种方法第一种：使用initWithCustomView方法创建UIBarButtonItem。第二种：通过KVC来修改相关属性。 那么先看看第一种方法：1234567891011UIButton * edit = [UIButton buttonWithType:UIButtonTypeCustom];edit.frame = CGRectMake(0, 0, 80, 30);[edit setTitle:@\"批量管理\" forState:UIControlStateNormal];[edit setTitleColor:[UIColor blackColor] forState:UIControlStateNormal];[edit addTarget:self action:@selector(edit) forControlEvents:UIControlEventTouchUpInside];edit.titleLabel.font = [UIFont systemFontOfSize:13];edit.titleLabel.textAlignment = NSTextAlignmentRight;UIBarButtonItem * rightBtn = [[UIBarButtonItem alloc]initWithCustomView:edit];[rightBtn setTintColor:COLOR(black)];self.navigationItem.rightBarButtonItem = rightBtn; 这种方法比较简便，能够快速理解。 第二种方法：12345678UIBarButtonItem * submitComment = [[UIBarButtonItem alloc] initWithTitle:@\"提交评价\" style:UIBarButtonItemStylePlain target:self action:@selector(submitComment:)];submitComment.tintColor = [UIColor darkGrayColor];[[UIBarButtonItem appearance] setTitleTextAttributes: [NSDictionary dictionaryWithObjectsAndKeys:[UIFont boldSystemFontOfSize:15], NSFontAttributeName, nil] forState:UIControlStateNormal]; Also,可以使用如下方法：1234[[UIBarButtonItem appearanceWhenContainedIn:[UINavigationController class], nil] setTitleTextAttributes:[NSDictionary dictionaryWithObjectsAndKeys: [UIFont boldSystemFontOfSize:15], NSFontAttributeName, nil] forState:UIControlStateNormal]; 其中对于这些key需要看一下，常用的几个key已经被NSFontAttributeName, NSForegroundColorAttributeName, NSShadowAttributeName代替:123456789101112/* Keys for text attributes dictionaries. These keys are superseded by the corresponding attribute name keys (NSFontAttributeName, NSForegroundColorAttributeName, NSShadowAttributeName) in NSAttributedString.h. */// Key to the font in the text attributes dictionary. A UIFont instance is expected. Use a font with size 0.0 to get the default font size for the situation.UIKIT_EXTERN NSString *const UITextAttributeFont NS_DEPRECATED_IOS(5_0, 7_0, \"Use NSFontAttributeName\") __TVOS_PROHIBITED;// Key to the text color in the text attributes dictionary. A UIColor instance is expected.UIKIT_EXTERN NSString *const UITextAttributeTextColor NS_DEPRECATED_IOS(5_0, 7_0, \"Use NSForegroundColorAttributeName\") __TVOS_PROHIBITED;// Key to the text shadow color in the text attributes dictionary. A UIColor instance is expected.UIKIT_EXTERN NSString *const UITextAttributeTextShadowColor NS_DEPRECATED_IOS(5_0, 7_0, \"Use NSShadowAttributeName with an NSShadow instance as the value\") __TVOS_PROHIBITED;// Key to the offset used for the text shadow in the text attributes dictionary. An NSValue instance wrapping a UIOffset struct is expected.UIKIT_EXTERN NSString *const UITextAttributeTextShadowOffset NS_DEPRECATED_IOS(5_0, 7_0, \"Use NSShadowAttributeName with an NSShadow instance as the value\") __TVOS_PROHIBITED; 12345678910111213141516171819202122232425262728/************************ Attributes ************************/// Predefined character attributes for text. If the key is not in the dictionary, then use the default values as described below.UIKIT_EXTERN NSString * const NSFontAttributeName NS_AVAILABLE(10_0, 6_0); // UIFont, default Helvetica(Neue) 12UIKIT_EXTERN NSString * const NSParagraphStyleAttributeName NS_AVAILABLE(10_0, 6_0); // NSParagraphStyle, default defaultParagraphStyleUIKIT_EXTERN NSString * const NSForegroundColorAttributeName NS_AVAILABLE(10_0, 6_0); // UIColor, default blackColorUIKIT_EXTERN NSString * const NSBackgroundColorAttributeName NS_AVAILABLE(10_0, 6_0); // UIColor, default nil: no backgroundUIKIT_EXTERN NSString * const NSLigatureAttributeName NS_AVAILABLE(10_0, 6_0); // NSNumber containing integer, default 1: default ligatures, 0: no ligaturesUIKIT_EXTERN NSString * const NSKernAttributeName NS_AVAILABLE(10_0, 6_0); // NSNumber containing floating point value, in points; amount to modify default kerning. 0 means kerning is disabled.UIKIT_EXTERN NSString * const NSStrikethroughStyleAttributeName NS_AVAILABLE(10_0, 6_0); // NSNumber containing integer, default 0: no strikethroughUIKIT_EXTERN NSString * const NSUnderlineStyleAttributeName NS_AVAILABLE(10_0, 6_0); // NSNumber containing integer, default 0: no underlineUIKIT_EXTERN NSString * const NSStrokeColorAttributeName NS_AVAILABLE(10_0, 6_0); // UIColor, default nil: same as foreground colorUIKIT_EXTERN NSString * const NSStrokeWidthAttributeName NS_AVAILABLE(10_0, 6_0); // NSNumber containing floating point value, in percent of font point size, default 0: no stroke; positive for stroke alone, negative for stroke and fill (a typical value for outlined text would be 3.0)UIKIT_EXTERN NSString * const NSShadowAttributeName NS_AVAILABLE(10_0, 6_0); // NSShadow, default nil: no shadowUIKIT_EXTERN NSString *const NSTextEffectAttributeName NS_AVAILABLE(10_10, 7_0); // NSString, default nil: no text effectUIKIT_EXTERN NSString * const NSAttachmentAttributeName NS_AVAILABLE(10_0, 7_0); // NSTextAttachment, default nilUIKIT_EXTERN NSString * const NSLinkAttributeName NS_AVAILABLE(10_0, 7_0); // NSURL (preferred) or NSStringUIKIT_EXTERN NSString * const NSBaselineOffsetAttributeName NS_AVAILABLE(10_0, 7_0); // NSNumber containing floating point value, in points; offset from baseline, default 0UIKIT_EXTERN NSString * const NSUnderlineColorAttributeName NS_AVAILABLE(10_0, 7_0); // UIColor, default nil: same as foreground colorUIKIT_EXTERN NSString * const NSStrikethroughColorAttributeName NS_AVAILABLE(10_0, 7_0); // UIColor, default nil: same as foreground colorUIKIT_EXTERN NSString * const NSObliquenessAttributeName NS_AVAILABLE(10_0, 7_0); // NSNumber containing floating point value; skew to be applied to glyphs, default 0: no skewUIKIT_EXTERN NSString * const NSExpansionAttributeName NS_AVAILABLE(10_0, 7_0); // NSNumber containing floating point value; log of expansion factor to be applied to glyphs, default 0: no expansionUIKIT_EXTERN NSString * const NSWritingDirectionAttributeName NS_AVAILABLE(10_6, 7_0); // NSArray of NSNumbers representing the nested levels of writing direction overrides as defined by Unicode LRE, RLE, LRO, and RLO characters. The control characters can be obtained by masking NSWritingDirection and NSTextWritingDirection values. LRE: NSWritingDirectionLeftToRight|NSWritingDirectionEmbedding, RLE: NSWritingDirectionRightToLeft|NSWritingDirectionEmbedding, LRO: NSWritingDirectionLeftToRight|NSWritingDirectionOverride, RLO: NSWritingDirectionRightToLeft|NSWritingDirectionOverride,UIKIT_EXTERN NSString * const NSVerticalGlyphFormAttributeName NS_AVAILABLE(10_7, 6_0); // An NSNumber containing an integer value. 0 means horizontal text. 1 indicates vertical text. If not specified, it could follow higher-level vertical orientation settings. Currently on iOS, it's always horizontal. The behavior for any other value is undefined.","link":"/2015/12/29/修改UIBarButtonItem标题文字大小、颜色、阴影等/"},{"title":"理解Objective-C中的消息发送","text":"消息发送首先来看看怎么理解发送消息的含义：面对着 Cocoa 中大量 API，只知道简单的查文档和调用。还记得初学 Objective-C 时把[receiver message]当成简单的方法调用，而无视了“发送消息”这句话的深刻含义。于是[receiver message]会被编译器转化为： objc_msgSend(receiver, selector)如果消息含有参数，则为： objc_msgSend(receiver, selector, arg1, arg2, ...)如果消息的接收者能够找到对应的selector，那么就相当于直接执行了接收者这个对象的特定方法；否则，消息要么被转发，或是临时向接收者动态添加这个selector对应的实现内容，要么就干脆玩完崩溃掉。现在可以看出[receiver message]真的不是一个简简单单的方法调用。因为这只是在编译阶段确定了要向接收者发送message这条消息，而receive将要如何响应这条消息，那就要看运行时发生的情况来决定了。Objective-C 的 Runtime 铸就了它动态语言的特性，这些深层次的知识虽然平时写代码用的少一些，但是却是每个 Objc 程序员需要了解的。Objc Runtime使得C具有了面向对象能力，在程序运行时创建，检查，修改类、对象和它们的方法。可以使用runtime的一系列方法实现。C语言中的动态方法由于Objective-C是C语言的超集，所以最好先理解C语言的函数调用方式。C语言使用“静态绑定（static binding）”，也就是说，在编译器就能决定运行时所应调用的函数。示例代码：123456789101112131415161718#import &lt;stdio.h&gt;void printHello() &#123; printf(\"Hello,world\\n\");&#125;void printGoodBye() &#123; printf(\"GoodBye,world\\n\");&#125;void doThings(int type) &#123; if(type == 0)&#123; printHello(); &#125;else&#123; printGoodBye(); &#125; return 0;&#125;编译器在编译代码的时候就知道程序中有printHello,printGoodBye两个函数了，函数地址也硬编码在指令之中。1234567891011121314151617181920#import &lt;stdio.h&gt;void printHello() &#123; printf(\"Hello,world\\n\");&#125;void printGoodBye() &#123; printf(\"GoodBye,world\\n\");&#125;void doThings(int type) &#123; void (*func)(); if(type == 0)&#123; func = printHello; &#125;else&#123; func = printGoodBye; &#125; func(); return 0;&#125;这样就是动态绑定（dynamic binding）了，因为索要调用的函数直到运行期才能确定。顺便附上OC中一个类的底层数据结构mac电脑上的路径/usr/include/objc/runtime.h12345678910111213141516 struct objc_class &#123; Class isa OBJC_ISA_AVAILABILITY; //isa指针指向Meta Class，因为Objc的类的本身也是一个Object，为了处理这个关系，r untime就创造了Meta Class，当给类发送[NSObject alloc]这样消息时，实际上是把这个消息发给了Class Object #if !__OBJC2__ Class super_class OBJC2_UNAVAILABLE; // 父类 const char *name OBJC2_UNAVAILABLE; // 类名 long version OBJC2_UNAVAILABLE; // 类的版本信息，默认为0 long info OBJC2_UNAVAILABLE; // 类信息，供运行期使用的一些位标识 long instance_size OBJC2_UNAVAILABLE; // 该类的实例变量大小 struct objc_ivar_list *ivars OBJC2_UNAVAILABLE; // 该类的成员变量链表 struct objc_method_list **methodLists OBJC2_UNAVAILABLE; // 方法定义的链表 struct objc_cache *cache OBJC2_UNAVAILABLE; // 方法缓存，对象接到一个消息会根据isa指针查找消息对象，这时会在method Lists中遍历，如果cache了，常用的方法调用时就能够提高调用的效率。 struct objc_protocol_list *protocols OBJC2_UNAVAILABLE; // 协议链表 #endif&#125; OBJC2_UNAVAILABLE;OC中一个类的对象实例的数据结构（/usr/include/objc/objc.h），就是定义了一个12345678910111213typedef struct objc_class *Class;/// Represents an instance of a class.struct objc_object &#123; Class isa OBJC_ISA_AVAILABILITY;&#125;;/// A pointer to an instance of a class.typedef struct objc_object *id;向object发送消息时，Runtime库会根据object的isa指针找到这个实例object所属于的类，然后在类的方法列表以及父类方法列表寻找对应的方法运行。id是一个objc_object结构类型的指针，这个类型的对象能够转换成任何一种对象。然后再来看看消息发送的函数：objc_msgSend函数在引言中已经对objc_msgSend进行了一点介绍，看起来像是objc_msgSend返回了数据，其实objc_msgSend从不返回数据而是你的方法被调用后返回了数据。下面详细叙述下消息发送步骤：1.检测这个 selector 是不是要忽略的。比如 Mac OS X 开发，有了垃圾回收就不理会 retain,release 这些函数了。2.检测这个 target 是不是 nil 对象。ObjC 的特性是允许对一个 nil 对象执行任何一个方法不会 Crash，因为会被忽略掉。3.如果上面两个都过了，那就开始查找这个类的 IMP，先从 cache 里面找，完了 找得到就跳到对应的函数去执行。4.如果 cache 找不到就找一下方法分发表。5.如果分发表找不到就到超类的分发表去找，一直找，直到找到NSObject类为止。6.如果还找不到就要开始进入动态方法解析了，后面会提到。这么一想，调用一个方法似乎需要很多步骤。不过objc_msgSend会将匹配结果缓存在fast map快速映射表里面，每个类都有这样一块缓存。当然这种fast path 还是不如静态绑定的函数调用那样迅速，不过只要把Selector缓存起来，也就不会慢很多，实际上，这并不是瓶颈。消息转发机制 当一个对象接收到无法解读的消息时，就会启动消息转发（message forwording）机制。coder可经由此过程告诉对象应该如何处理位置消息。例如给某一个对象实例发送了一个该对象不存在的方法，最后就会crash掉。-[NSCFDictionary indexOfObject:]: unrecognized selector sent to instance 0x10773929356消息转发分为两大阶段。 第一阶段先询问接受对象所属的类是否能够动态添加方法，以处理这个unknown selector，这叫做动态方法解析（dynamic method resolution）. 第二阶段设计完整的消息转发机制（full forwording mechanism）。如果在运行期，系统已经把第一阶段执行完了，那么接受者自己就无法再以动态添加方法的方式来响应包含该unknown selector的消息了。此时，运行期系统会请求接受者以其他手段来处理与消息相关的方法调用。这里又分为两小步： 2.1 首先，接受者查看是否有其他对象能处理这条消息，若有，则运行时系统会将消息转给那个对象，一切如常。 2.2 若没有可替代的接受者（replacement receiver），则启动完整的消息转发机制，运行时系统会把与消息有关的全部细节都封装到NSInvocation对象中，再给接受者最后一次机会，令其设法解决当前还未处理的消息。 a.动态方法解析12+ (Bool)resolveInstanceMethod:(SEL)Selector+ (Bool)resolveClassMethod:(SEL)Selector b.消息转发给可替代接受者，尝试找到一个能响应该消息的对象（replacement receiver）1- (id)forwardingTargetForSelector:(SEL)Selector c.下一步，构造NSInvocation对象1234//尝试获得一个方法签名- (id)methodSignatureForSelector:(SEL)selector //将上一步获取到的方法签名包装成 Invocation 传入，如何处理就在这里面了，并返回非ni- (id)forwardInvocation:(NSInvocation *)invocation 总结 消息由接受者、选择器及参数构成。给某对象发送消息（invoke a message），也就相当于在该对象上调用方法（calla method） 发给某对象的全部消息都要有动态消息派发系统（dynamic message dispatch system）来处理，该系统会查出对应的方法，并执行其代码。 若对象无法响应某个选择器中的消息，则进入消息转发过程。 通过运行期的动态方法解析机制，我们可以在需要用到某个方法时再将其加入类中。 对象可以把其无法解读的消息转交给其他对象来处理。 若经过上述两步还是没办法处理消息，则启动完整的消息转发机制。 详情可参考 Objective-C Runtime","link":"/2015/12/16/理解Objective-C中的消息发送/"},{"title":"浅谈iOS中的userAgent","text":"User-Agent（用户代理）字符串是Web浏览器用于声明自身型号版本并随HTTP请求发送给Web服务器的字符串，在Web服务器上可以获取到该字符串。 在公司产品中，在userAgent中增加了NetType字段，用于标识客户端当前的网络环境。 NetType/WIFI NetType/3Gweb服务器端根据NetType类型加载不同分辨率的商品图片。我们只有两种，WIFI下高清图，非WIFI低分辨率图。 获取WebView的userAgentiOS客户端中获取webView的userAgent的方法：1NSMutableString *userAgent = [NSMutableString stringWithString:[[UIWebView new] stringByEvaluatingJavaScriptFromString:@\"navigator.userAgent\"]];根据需要添加不同的标识到新的userAgent中,这里添加一个WMall标识。123NSString *newUagent = [NSString stringWithFormat:@\"%@ WMall/%@\", userAgent, [SystemInfo appShortVersion]];NSDictionary *dictionnary = [[NSDictionary alloc] initWithObjectsAndKeys:newUagent, @\"UserAgent\", nil];[[NSUserDefaults standardUserDefaults] registerDefaults:dictionnary];newUagent 为Mozilla/5.0 (iPhone; CPU iPhone OS 9_3 like Mac OS X) AppleWebKit/601.1.46 (KHTML, like Gecko) Mobile/13E230 WMall/3.0根据网络类型设置不同的NetType标识 iOS中判断网络状态一般用AFNetWorking中的方法：在appDelegate的application didFinishLaunchingWithOptions方法中启动网络状态监听：12[[AFNetworkReachabilityManager sharedManager] startMonitoring];[[AFNetworkActivityIndicatorManager sharedManager] setEnabled:YES]; 然后在基类BaseViewController中监听网络更新通知1[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(networkReachabilityStatusDidChange:) name:AFNetworkingReachabilityDidChangeNotification object:nil]; 12345678910111213141516171819202122- (void)networkReachabilityStatusDidChange:(NSNotification *)notify&#123; NSLog(@\"网络变化通知：%@\",notify.userInfo[AFNetworkingReachabilityNotificationStatusItem]); AFNetworkReachabilityStatus status = [notify.userInfo[AFNetworkingReachabilityNotificationStatusItem] integerValue]; NSString *net = nil; switch (status) &#123; case AFNetworkReachabilityStatusNotReachable: net = @\"无网络\"; break; case AFNetworkReachabilityStatusReachableViaWiFi: net = @\"WIFI\"; [self changeUserAgentWithType:@\"WIFI\"]; break; case AFNetworkReachabilityStatusReachableViaWWAN: net = @\"2G/3G/4G\"; [self changeUserAgentWithType:@\"3G\"]; break; default: net = @\"xxx\"; break; &#125; [Error showError:[NSString stringWithFormat:@\"当前网络状态%@\",net]];&#125; 注意先判断userAgent中是否存在NetType12345678910111213141516171819202122//更新NetType- (void)changeUserAgentWithType:(NSString *)type&#123; NSMutableString *userAgent = [NSMutableString stringWithString:[[UIWebView new] stringByEvaluatingJavaScriptFromString:@\"navigator.userAgent\"]]; NSString *newUagent = nil; NSString *temp = nil; if ([userAgent containsString:@\"NetType\"]) &#123; if ([userAgent containsString:@\"WIFI\"]) &#123; temp = @\"WIFI\"; &#125;else if([userAgent containsString:@\"3G\"])&#123; temp = @\"3G\"; &#125; newUagent = [userAgent stringByReplacingOccurrencesOfString:temp withString:type]; &#125;else&#123; newUagent = [NSString stringWithFormat:@\"%@ NetType/%@\", userAgent, type]; &#125; NSDictionary *dictionnary = [[NSDictionary alloc] initWithObjectsAndKeys:newUagent, @\"UserAgent\", nil]; NSLog(@\"new useragent:%@\",newUagent); [[NSUserDefaults standardUserDefaults] registerDefaults:dictionnary];&#125; newUagent 为Mozilla/5.0 (iPhone; CPU iPhone OS 9_3 like Mac OS X) AppleWebKit/601.1.46 (KHTML, like Gecko) Mobile/13E230 WMall/3.0 NetType/WIFI 参考微信6.0内嵌浏览器User-Agent字符串增加了NetType字段获取 UIWebview 的 Useragent，以及附加自定义字段到 Useragent","link":"/2016/04/10/浅谈iOS中的userAgent/"},{"title":"常用排序算法","text":"在此总结一下常用排序算法的代码实现 #include &lt;iostream&gt;using namespace std;typedef int ElemType; /*1、插入排序（1）直接插入排序算法算法思想：将等排序列划分为有序与无序两部分，然后再依次将无序部分插入到已经有序的部分，最后 就可以形成有序序列。操作步骤如下：1）查找出元素L（i）在表中的插入位置K；2）将表中的第K个元素之前的元素依次后移一个位置；3）将L（i）复制到L（K）。 */时间复杂度为：O(n^2) 1234567891011121314151617181920void InsertSort(ElemType arr[], int length)&#123; int i, j; ElemType guard; // 哨兵 for (i = 1; i &lt; length; ++i) &#123; if (arr[i]() &lt; arr[i-1]()) // 在无序部分寻找一个元素，使之插入到有序部分后仍然有序 &#123; guard = arr[i]();// 复制到“哨兵” // 将第i个元素之前的元素依次后移一个位置 for (j = i - 1; arr[j]() &gt; guard; j--) &#123; arr[j + 1]() = arr[j](); &#125; arr[j + 1]() = guard; // 复制到插入位置 &#125; &#125;&#125; 2、折半插入排序 使用于排序表为顺序存储的线性表 在查找插入位置时，采用折半查找 算法思想是： 1）设置折半查找范围； 2）折半查找 3）移动元素 4）插入元素 5）继续操作1）、2）、3）、4）步，直到表成有序。 123456789101112131415161718192021222324252627282930313233void BinaryInsertSort(ElemType arr[], int length)&#123; int i, j, low, high, mid; ElemType tmp; for ( i = 1; i &lt; length; ++i ) &#123; tmp = arr[i](); // 复制到哨兵 // 设置折半查找范围 low = 0; high = i; while (low &lt;= high) // 折半查找 &#123; mid = (low + high) / 2; if (arr[mid]() &gt; tmp) // 在左半部分查找 &#123; high = mid - 1; &#125; else &#123; low = mid + 1; // 在右半部分查找 &#125; &#125; // 移动元素 for ( j = i - 1; j &gt;= high + 1; --j ) &#123; arr[j + 1]() = arr[j](); &#125; arr[j + 1]() = tmp; &#125;&#125; /*3、希尔(Shell)排序 基本思想： 先将待排序的表分割成若干个形若L[i, i+d, i+2d, …, i+kd]的“特殊”子表，分别进行直接插入排序， 当整个表已呈“基本有序”时，再对全体记录进行一次直接插入排序。 算法过程： 1）先取一个小于n的步长d1,把表中全部记录分成d1个组，所有距离为d1的倍数的记录放在同一组中，在各 组中进行直接插入排序； 2）然后取第二个步长d2 \\&lt; d1, 重复步骤1 3）直到dk = 1，再进行最后一次直接插入排序*/ 12345678910111213141516171819202122232425void ShellSort(ElemType arr[], int length)&#123; int i, j, dk = length / 2; ElemType tmp; while (dk &gt;= 1)// 控制步长 &#123; for (i = dk; i &lt; length; ++i) &#123; if (arr[i]() &lt; arr[i - dk]()) &#123; tmp = arr[i](); // 暂存 // 后移 for (j = i - dk; j &gt;= 0 &amp;&amp; tmp &lt; arr[j](); j -= dk) &#123; arr[j + dk]() = arr[j](); &#125; arr[j + dk]() = tmp; &#125; &#125; dk /= 2; &#125;&#125; *4、冒泡排序算法 基本思想： 假设待排序的表长为n， 从后向前或从前向后两两比较相邻元素的值，若为逆序，则交换之，直到序列比较完。 这样一回就称为一趟冒泡。这样值较大的元素往下“沉”，而值较小的元素入上“浮”。 时间复杂度为O(n^2)*/ 123456789101112131415161718void BubbleSort(ElemType arr[], int length)&#123;int i, j,k; ElemType tmp; for (k = 0; k &lt; length; ++i)// 趟次总共循环length次 &#123; for (i = 0; i &lt; length - 1; ++i)//两两比较 &#123; j = i + 1; if (arr[j]() &gt; arr[i]()) &#123; tmp = arr[i](); arr[i]() = arr[j](); arr[j]() = tmp; &#125; &#125; &#125;&#125; /*5、快速排序算法 基本思想：基于分治法，在待排序的n个元素中任取一个元素pivot作为基准，通过一趟排序将待排序表划分为独立的 两部分L[1..k-1]和L[k+1 .. n],使得第一部分中的所有元素值都小于pivot，而第二部分中的所有元素值都大于pivot， 则基准元素放在了其最终位置L（K）上，这个过程为一趟快速排序。而后分别递归地对两个子表重复上述过程，直到每 部分内只有一个元素或为空为止，即所有元素都放在了其最终位置上。*/ 12345678910111213141516171819202122232425262728293031323334353637int Partition(ElemType arr[], int left, int right)&#123; ElemType pivot = arr[left]; // 以当前表中第一个元素为枢轴值 while (left \\&lt; right) &#123; // 从右向左找一个比枢轴值小的元素的位置 while (left \\&lt; right &amp;&amp; arr[right]() \\&gt;= pivot) &#123; --right; &#125; arr[left]() = arr[right](); // 将比枢轴值小的元素移动到左端 // 从左向右查找比枢轴值大的元素的位置 while (left \\&lt; right &amp;&amp; arr[left]() \\&lt;= pivot) &#123; ++left; &#125; arr[right]() = arr[left]();// 将比枢轴值大的元素移动到右端 &#125; arr[left]() = pivot; // 将枢轴元素放在最终位置 return left;&#125;void QuickSort(ElemType arr[], int left, int right)&#123; if (left \\&lt; right) &#123; int pivotPos = Partition(arr, left, right); // 划分 QuickSort(arr, left, pivotPos - 1); // 快速排序左半部分 QuickSort(arr, pivotPos + 1, right); // 快速排序右半部分 &#125;&#125; /*6、简单选择排序算法 基本思想： 假设排序表为L[1…n],第i趟排序从表中选择关键字最小的元素与Li交换，第一趟排序可以确定一个元素的 最终位置，这样经过n-1趟排序就可以使得整个排序表有序。*/ 12345678910111213141516171819202122232425void SelectSort(ElemType arr[], int length)&#123; int i, j, min; ElemType tmp; for (i = 0; i \\&lt; length - 1; ++i) // 需要n-1趟 &#123; min = i; for (j = i + 1; j \\&lt; length; ++j) &#123; if (arr[j]() \\&lt; arr[min]()) // 每一趟选择元素值最小的下标 &#123; min = j; &#125; &#125; if (min != i) // 如果第i趟的Li元素值该趟找到的最小元素值，则交换，以使Li值最小 &#123; tmp = arr[i](); arr[i]() = arr[min](); arr[min]() = tmp; &#125; &#125;&#125; /*7、堆排序算法 堆的定义如下：n个关键字序列号L1..n称为堆，仅当该序列满足：1）L(i) \\&lt;= L(2i)且L(i) \\&lt;= L(2i+1) 或 2)L(i) >= L(2i)且L(i) >= L(2i+1)满足第一种情况的堆，称为小根堆（小顶堆）；满足第二种情况的堆，称为大根堆（大顶堆）。*/ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071void HeapAdjust(ElemType \\*a,int i,int size) //调整堆&#123; int lchild = 2 \\* i; //i的左孩子节点序号 int rchild = 2 \\* i + 1; //i的右孩子节点序号 int max = i; //临时变量 if(i \\&lt;= size / 2) //如果i是叶节点就不用进行调整&#123;if (lchild \\&lt;= size &amp;&amp; a[lchild]() \\&gt; a[max]())&#123;max = lchild; // 左孩子比双亲值还大，需要调整&#125;if (rchild \\&lt;= size &amp;&amp; a[rchild]() \\&gt; a[max]())&#123;max = rchild;// 右孩子比双亲值还大，需要调整&#125;if (max != i) // 需要调整&#123;ElemType tmp = a[max]();a[max]() = a[i]();a[i]() = tmp;HeapAdjust(a, max, size); //避免调整之后以max为父节点的子树不是堆&#125;&#125;&#125;void BuildHeap(ElemType \\*a,int size) //建立堆&#123; for (int i = size / 2; i \\&gt;= 0; i--) //非叶节点最大序号值为size/2 &#123; HeapAdjust(a, i, size); &#125;&#125;void HeapSort(ElemType \\*a, int size) //堆排序&#123; BuildHeap(a,size);for(int i = size - 1; i \\&gt;= 0; i--)&#123;swap(a[0](), a[i]()); //交换堆顶和最后一个元素，即每次将剩余元素中的最大者放到最后面BuildHeap(a, i-1); //将余下元素重新建立为大顶堆HeapAdjust(a,1,i-1); //重新调整堆顶节点成为大顶堆&#125;&#125;void Display(ElemType arr[], int length)&#123; for ( int i = 0; i \\&lt; length; ++i ) &#123; cout \\&lt;\\&lt; arr[i] \\&lt;\\&lt; \" \"; &#125; cout \\&lt;\\&lt; endl;&#125;int main()&#123; ElemType arr[] = &#123;2, 1, 5, 3, 4, 0, 6, 9, -1, 4, 12&#125;;//InsertSort(arr, sizeof(arr) / sizeof(ElemType));//BinaryInsertSort(arr, sizeof(arr) / sizeof(ElemType));//ShellSort(arr, sizeof(arr) / sizeof(ElemType));//BubbleSort(arr, sizeof(arr) / sizeof(ElemType));//QuickSort(arr, 0, sizeof(arr) / sizeof(ElemType) - 1);HeapSort(arr, sizeof(arr) / sizeof(ElemType));Display(arr, sizeof(arr) / sizeof(ElemType));return 0;&#125;","link":"/2015/11/30/常用排序算法/"},{"title":"移动IM开发要点","text":"个人对于IM开发中客户端与服务器之间的连接比较感兴趣，网搜一篇好文，记录下来。转载于 移动IM开发那些事 通讯方式选择IM通讯方式无非两种选择:设备直连(P2P)和通过服务器中转。P2PP2P多见于局域网内聊天工具，典型的应用有:飞鸽传书，天网Maze(你懂的)等。这类软件在启动后一般做两件事情 进行UDP广播:发送自己信息和接受同局域网内其他端信息 开启TCP监听:等待其他端进行连接详细的流程可以参考飞鸽传书源码。但是这种方式在有种种限制和不便:一方面它只适合在线的点对点消息传输，对离线，群组等业务支持不够。另一方面由于 NAT 的存在，使得不同局域网内机器互联难度大大上升，在某些网络类型(对称NAT)下无法建立连接。服务器中转几乎所有互联网IM产品都采用服务器中转这种方式进行消息传输，相对于P2P的方式，它有如下的优点: 能够支持更多P2P无法支持或支持不好的业务，如离线消息，群组，聊天室服务 方便业务逻辑的拓展和新旧版本的兼容当然它也有自己的问题:服务器架构复杂，并发要求高。网络连接方式IM主流网络连接方式有两种: 基于TCP的长连接 基于HTTP短连接PULL的方式后者常见于WEB IM系统(当然现在很多WEB IM都是基于WebSocket实现)，它的优点是实现简单，方便开发上手，问题是流量大，服务器负载较大，消息及时性无法很好地保证，对大规模的用户量支持不够，比较适合小型的IM系统,如小网站的客户系统。基于TCP长连接则能够更好地支持大批量用户，问题是客户端和服务器的实现比较复杂。当然也还有一些变种，如下行使用MQTT进行服务器通知/消息的下发，上行使用HTTP短连接进行指令和消息的上传。这种方式能够保证下行消息/指令的及时性，但是在弱网络下上行慢的问题还是比较严重。早期的来往就是基于这种方式。协议选择 IM协议选择原则一般是:易于拓展，方便覆盖各种业务逻辑，同时又比较节约流量。后一点的需求在移动端IM上尤其重要。 常见的协议有: XMPP SIP MQTT 私有协议 XMPP协议的优点在于:协议开源，可拓展性强，在各个端(包括服务器)有各种语言的实现，开发者接入方便。但是缺点也是不少:XML表现力弱，有太多冗余信息，流量大，实际使用时有大量天坑。 SIP协议多用于VOIP相关的模块，是一种文本协议，由于我并没有实际用过，所以不做评论，但从它是文本协议这一点几乎可以断定它的流量不会小。 MQTT的优点是协议简单，流量少，但是它并不是一个专门为IM设计的协议，多使用于推送。 而市面上几乎所有主流IM APP都是是使用私有协议，一个被良好设计的私有协议一般有如下优点:高效，节约流量(一般使用二进制协议)，安全性高，难以破解。缺点则是在开发初期没有现有样列可以参考，对于设计者的要求比较高。 一个好的协议需要满足如下条件:高效，简洁，可读性好，节约流量，易于拓展，同时又能够匹配当前团队的技术堆栈。基于如上原则，我们可以推出:如果团队小，团队技术在IM上积累不够可以考虑使用XMPP或者MQTT+HTTP短连接的实现。反之可以考虑自己设计和实现私有协议。 私有协议的设计 序列化选择移动互联网相对于有线网络最大特点是:带宽低，延迟高，丢包率高和稳定性差，流量费用高。所以在私有协议的序列化上一般使用二进制协议，而不是文本协议。常见的二进制序列化库有protobuf和MessagePack，当然你也可以自己实现自己的二进制协议序列化和反序列的过程，比如蘑菇街的TeamTalk。但是前面二者无论是可拓展性还是可读性都完爆TeamTalk(TeamTalk连Variant都不支持，一个int传输时固定占用4个字节)，所以大部分情况下还是不推荐自己去实现二进制协议的序列化和反序列化过程。协议格式设计 基于TCP的应用层协议一般都分为包头和包体(如HTTP)，IM协议也不例外。包头一般用于表示每个请求/反馈的公共部分，如包长，请求类型，返回码等。而包头则填充不同请求/反馈对应的信息。 一个最简单的包头可以定义为 1234567struct PackHeader&#123; int32_t length_; //包长度 int32_t serial_; //包序列号 int32_t command_; //包请求类型 int32_t code_; //返回码&#125;; 以心跳包为例，假设当前的serial为1，心跳包的command为10，那么使用MessagePack做序列化时:length=4，serial=1，command=10，code=0，每个字段各占一个字节，包体为空，仅需要4个字节。 当然这是最简单的一个例子，面对真正的业务逻辑时，包体里面会需要塞入更多地信息，这个需要开发根据自己的业务逻辑总结公共部分,如为了兼容加入的协议版本号,为了负载均衡加入的模块id等。 其他问题上面就是一个IM系统大致的选型过程:通讯方式，连接方式，协议选择，协议设计。但是实际开发过程中还有大量的问题需要处理。 协议加密为了保证协议不容易被破解，市面上几乎所有主流IM都会对协议进行加密传输。常见的流程和HTTPS加密相似:建立连接后，客户端和服务器进行进行协商，最终客户端获得一个当前Sessino的秘钥，后续的数据传输都通过这个秘钥进行加解密。一般出于效率的考虑都会采用流式加密，如RC4。而前期协商过程则推荐使用RSA等非对称加密以增加破解难度。 快速连接(登录)对iOS APP而言，因为没有真后台的存在，APP每次启动基本都需要一次重连登录(短时间内切换除外)，所以如何快速重连重登就非常重要。常见的优化思路如下: 本地缓存服务器IP并定期刷新。移动网络调优可以参考《iOS移动网络调优那些事》。 合并部分请求。如加密和登录操作可以合并为同一个操作，这样就可以减少一次不必要的网络请求来回的时间。 简化登录后的同步请求，部分同步请求可以推迟到UI操作时进行，如群成员信息刷新。 连接保持一般APP实现连接保持的方式无非是采用应用层的心跳，通过心跳包的超时和其他条件(网络切换)来执行重连操作。那么问题来了:为什么要使用应用层心跳和如何设计应用层心跳。 众所周知TCP协议是有KEEPALIVE这个设置选项，设置为KEEPALIVE后，客户端每隔N秒(默认是7200s)会向服务器发送一个发送心跳包。但实际操作中我们更多的时是使用应用层心跳。原因如下: KEEPALIVE对服务器负载压力比较大(服务器大大是这么说的…) socks代理对KEEPALIVE并不支持 部分复杂情况下KEEPALIVE会失效，如路由器挂掉，网线(移动端没有网线…)直接被拔除 移动端在实际操作时为了节约流量和电量一般会在心跳包上做一些小优化 精简心跳包，保证一个心跳包大小在10字节之内 心跳包只在空闲时发送 根据APP前后台状态调整心跳包间隔 (主要是安卓) 消息可达在移动网络下，丢包，网络重连等情况非常之多，为了保证消息的可达，一般需要做消息回执和重发机制。参考易信，每条消息会最多会有3次重发，超时时间为15秒，同时在发送之前会检测当前连接状态，如果当前连接并没有正确建立，缓存消息且定时检查(每隔2秒检查一次，检查15次)。所以一条消息在最差的情况下会有2分钟左右的重试时间，以保证消息的可达。 因为重发的存在，接受端偶尔会收到重复消息，这种情况下就需要接收端进行去重。通用的做法是每条消息都带上自己唯一的message id(一般是uuid)。 文件上传优化IM消息(包括SNS模块)内包含大量的文件上传的需求，如何优化文件的上传就成了一个比较大的主题。常见有下面这些优化思路: 将上传流程提前:音频提供边录边传。朋友圈的图片进行预上传，选择图片后用户一般会进行文本输入，在这段时间内后台就可以默默将选好的图片进行上传。 提供闪电上传的方式:服务器根据MD5进行文件去重。 优化和上传服务器的连接(参考快速连接)，提供连接重用的功能。 文件分块上传:因为移动网络丢包严重，将文件分块上传可以使得一个分组包含合理数量的TCP包，使得重试概率下降，重试代价变小，更容易上传到服务器。 在分包的前提下支持上传的pipeline，避免不必要的网络等待时间。 支持断点续传 总结此处是软文，请全选阅读:一个大型IM系统涉及到东西实在太多，如果IM模块只是APP的附属功能，并不推荐自己去从头实现IM模块或者使用XMPP这种有天坑的开源实现，直接使用市面上的第三方SDK即可，比如我们的云信。毕竟，我们，是，专业的！~~~~","link":"/2016/02/28/移动IM开发要点/"},{"title":"知乎上某人的iOS面试题","text":"这是前年在知乎上总结回答MrPeak的问题，现在搬运到自己的blog中。知乎链接：http://www.zhihu.com/question/19604641 ###1.什么是arc？（arc是为了解决什么问题诞生的？）首先解释ARC: automatic reference counting自动引用计数。ARC几个要点：在对象被创建时 retain count +1，在对象被release时 retain count -1.当retain count 为0 时，销毁对象。程序中加autoreleasepoo的对象会由系统自动加上autorelease方法，如果该对象引用计数为0，则销毁。那么ARC是为了解决什么问题诞生的呢？这个得追溯到MRC手动内存管理时代说起。MRC下内存管理的缺点： 当我们要释放一个堆内存时，首先要确定指向这个堆空间的指针都被release了。（避免提前释放） 释放指针指向的堆空间，首先要确定哪些指针指向同一个堆，这些指针只能释放一次。（MRC下即谁创建，谁释放，避免重复释放） 模块化操作时，对象可能被多个模块创建和使用，不能确定最后由谁去释放。 多线程操作时，不确定哪个线程最后使用完毕 ###2.请解释以下keywords的区别： assign vs weak, __block vs __weakassign适用于基本数据类型，weak是适用于NSObject对象，并且是一个弱引用。assign其实也可以用来修饰对象，那么我们为什么不用它呢？因为被assign修饰的对象在释放之后，指针的地址还是存在的，也就是说指针并没有被置为nil。如果在后续的内存分配中，刚好分到了这块地址，程序就会崩溃掉。而weak修饰的对象在释放之后，指针地址会被置为nil。所以现在一般弱引用就是用weak。 首先__block是用来修饰一个变量，这个变量就可以在block中被修改（参考block实现原理）__block：使用 block修饰的变量在block代码快中会被retain（ARC下，MRC下不会retain）`weak` ：使用 weak修饰的变量不会在block代码块中被retain同时，在ARC下，要避免block出现循环引用 ``weak typedof(self)weakSelf = self``; ###3.block在arc和非arc下含义一样吗？是不一样的。在MRC中 block variable 在block中使用是不會retain的,但是ARC中 block則是會Retain的。取而代之的是用 `weak或是__unsafe_unretained` 來更精確的描述weak reference的目的其中前者只能在iOS5之後可以使用，但是比較好 (該物件release之後，此pointer會自動設成nil)而後者是ARC的環境下為了相容4.x的解決方案。所以上面的範例中123__block MyClass* temp = …; // MRC環境下使用__weak MyClass* temp = …; // ARC但只支援iOS5.0以上的版本__unsafe_retained MyClass* temp = …; //ARC且可以相容4.x以後的版本 ###4.使用nonatomic一定是线程安全的吗？（）不是的。atomic原子操作，系统会为setter方法加锁。 具体使用 @synchronized(self){//code }nonatomic不会为setter方法加锁。atomic：线程安全，需要消耗大量系统资源来为属性加锁nonatomic：非线程安全，适合内存较小的移动设备 ###5.描述一个你遇到过的retain cycle例子。block中的循环引用：一个viewController123456@property (nonatomic,strong)HttpRequestHandler * handler;@property (nonatomic,strong)NSData *data;_handler = [httpRequestHandler sharedManager];[ downloadData:^(id responseData)&#123; _data = responseData;&#125;]; self 拥有_handler, _handler 拥有block, block拥有self（因为使用了self的_data属性，block会copy 一份self）解决方法：1234__weak typedof(self)weakSelf = self[ downloadData:^(id responseData)&#123; weakSelf.data = responseData;&#125;]; 6.+(void)load; +(void)initialize；有什么用处？在Objective-C中，runtime会自动调用每个类的两个方法。+load会在类初始加载时调用，+initialize会在第一次调用类的类方法或实例方法之前被调用。这两个方法是可选的，且只有在实现了它们时才会被调用。共同点：两个方法都只会被调用一次。 7.为什么其他语言里叫函数调用， objective c里则是给对象发消息（或者谈下对runtime的理解）先来看看怎么理解发送消息的含义： 曾经觉得Objc特别方便上手，面对着 Cocoa 中大量 API，只知道简单的查文档和调用。还记得初学 Objective-C 时把[receiver message]当成简单的方法调用，而无视了“发送消息”这句话的深刻含义。于是[receiver message]会被编译器转化为：objc_msgSend(receiver, selector)如果消息含有参数，则为：objc_msgSend(receiver, selector, arg1, arg2, ...) 如果消息的接收者能够找到对应的selector，那么就相当于直接执行了接收者这个对象的特定方法；否则，消息要么被转发，或是临时向接收者动态添加这个selector对应的实现内容，要么就干脆玩完崩溃掉。 现在可以看出[receiver message]真的不是一个简简单单的方法调用。因为这只是在编译阶段确定了要向接收者发送message这条消息，而receive将要如何响应这条消息，那就要看运行时发生的情况来决定了。 Objective-C 的 Runtime 铸就了它动态语言的特性，这些深层次的知识虽然平时写代码用的少一些，但是却是每个 Objc 程序员需要了解的。 Objc Runtime使得C具有了面向对象能力，在程序运行时创建，检查，修改类、对象和它们的方法。可以使用runtime的一系列方法实现。 顺便附上OC中一个类的数据结构 /usr/include/objc/runtime.h12345678910111213141516 struct objc_class &#123;Class isa OBJC_ISA_AVAILABILITY; //isa指针指向Meta Class，因为Objc的类的本身也是一个Object，为了处理这个关系，r untime就创造了Meta Class，当给类发送[NSObject alloc]这样消息时，实际上是把这个消息发给了Class Object#if !__OBJC2__Class super_class OBJC2_UNAVAILABLE; // 父类const char *name OBJC2_UNAVAILABLE; // 类名long version OBJC2_UNAVAILABLE; // 类的版本信息，默认为0long info OBJC2_UNAVAILABLE; // 类信息，供运行期使用的一些位标识long instance_size OBJC2_UNAVAILABLE; // 该类的实例变量大小struct objc_ivar_list *ivars OBJC2_UNAVAILABLE; // 该类的成员变量链表struct objc_method_list **methodLists OBJC2_UNAVAILABLE; // 方法定义的链表struct objc_cache *cache OBJC2_UNAVAILABLE; // 方法缓存，对象接到一个消息会根据isa指针查找消息对象，这时会在method Lists中遍历，如果cache了，常用的方法调用时就能够提高调用的效率。struct objc_protocol_list *protocols OBJC2_UNAVAILABLE; // 协议链表#endif&#125; OBJC2_UNAVAILABLE; OC中一个类的对象实例的数据结构（/usr/include/objc/objc.h）:12345678910111213typedef struct objc_class *Class;/// Represents an instance of a class.struct objc_object &#123; Class isa OBJC_ISA_AVAILABILITY;&#125;;/// A pointer to an instance of a class.typedef struct objc_object *id; 向object发送消息时，Runtime库会根据object的isa指针找到这个实例object所属于的类，然后在类的方法列表以及父类方法列表寻找对应的方法运行。id是一个objc_object结构类型的指针，这个类型的对象能够转换成任何一种对象。 然后再来看看消息发送的函数：objc_msgSend函数 在引言中已经对objc_msgSend进行了一点介绍，看起来像是objc_msgSend返回了数据，其实objc_msgSend从不返回数据而是你的方法被调用后返回了数据。下面详细叙述下消息发送步骤： 检测这个 selector 是不是要忽略的。比如 Mac OS X 开发，有了垃圾回收就不理会 retain,release 这些函数了。检测这个 target 是不是 nil 对象。ObjC 的特性是允许对一个 nil 对象执行任何一个方法不会 Crash，因为会被忽略掉。如果上面两个都过了，那就开始查找这个类的 IMP，先从 cache 里面找，完了找得到就跳到对应的函数去执行。如果 cache 找不到就找一下方法分发表。如果分发表找不到就到超类的分发表去找，一直找，直到找到NSObject类为止。如果还找不到就要开始进入动态方法解析了，后面会提到。 后面还有：动态方法解析resolveThisMethodDynamically消息转发forwardingTargetForSelector 详情可参考 http://www.jianshu.com/p/620022378e97 ###8.什么是method swizzling?Method Swizzling 原理（方法交换？） 在Objective-C中调用一个方法，其实是向一个对象发送消息，查找消息的唯一依据是selector的名字。利用Objective-C的动态特性，可以实现在运行时偷换selector对应的方法实现，达到给方法挂钩的目的。每个类都有一个方法列表，存放着selector的名字和方法实现的映射关系。IMP有点类似函数指针，指向具体的Method实现。 我们可以利用 method_exchangeImplementations 来交换2个方法中的IMP， 我们可以利用 class_replaceMethod 来修改类， 我们可以利用 method_setImplementation 来直接设置某个方法的IMP，……归根结底，都是偷换了selector的IMP，如下图所示： 详情：http://blog.csdn.net/yiyaaixuexi/article/details/9374411 ###9.UIView和CALayer是啥关系？ 1.UIView是iOS系统中界面元素的基础，所有的界面元素都继承自它。它本身完全是由CoreAnimation来实现的 （Mac下似乎不是这样）。它真正的绘图部分，是由一个叫CALayer（Core Animation Layer）的类来管理。 UIView本身，更像是一个CALayer的管理器，访问它的跟绘图和跟坐标有关的属性，例如frame，bounds等 等，实际上内部都是在访问它所包含的CALayer的相关属性。 2.UIView有个layer属性，可以返回它的主CALayer实例，UIView有一个layerClass方法，返回主layer所使用的 类，UIView的子类，可以通过重载这个方法，来让UIView使用不同的CALayer来显示，例如通过123- (class) layerClass &#123; return ([CAEAGLLayer class]);&#125; 使某个UIView的子类使用GL来进行绘制。 3.UIView的CALayer类似UIView的子View树形结构，也可以向它的layer上添加子layer，来完成某些特殊的表 示。例如下面的代码12345grayCover = [[CALayer alloc] init];grayCover.backgroundColor = [[[UIColor blackColor] colorWithAlphaComponent:0.2] CGColor];[self.layer addSubLayer: grayCover]; 会在目标View上敷上一层黑色的透明薄膜。 4.UIView的layer树形在系统内部，被系统维护着三份copy（这段理解有点吃不准）。 逻辑树，就是代码里可以操纵的，例如更改layer的属性等等就在这一份。 动画树，这是一个中间层，系统正在这一层上更改属性，进行各种渲染操作。 显示树，这棵树的内容是当前正被显示在屏幕上的内容。 这三棵树的逻辑结构都是一样的，区别只有各自的属性。 ###10. 如何高性能的给UIImageView加个圆角？（不准说layer.cornerRadius!） 我觉得应该是使用Quartz2D直接绘制图片,得把这个看看。步骤： a、创建目标大小(cropWidth，cropHeight)的画布。 b、使用UIImage的drawInRect方法进行绘制的时候，指定rect为(-x，-y，width，height)。 c、从画布中得到裁剪后的图像。1234567891011121314151617- (UIImage*)cropImageWithRect:(CGRect)cropRect&#123; CGRect drawRect = CGRectMake(-cropRect.origin.x , -cropRect.origin.y, self.size.width * self.scale, self.size.height * self.scale); UIGraphicsBeginImageContext(cropRect.size); CGContextRef context = UIGraphicsGetCurrentContext(); CGContextClearRect(context, CGRectMake(0, 0, cropRect.size.width, cropRect.size.height)); [self drawInRect:drawRect]; UIImage *image = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); return image;&#125;@end ###11. 使用drawRect有什么影响？（这个可深可浅，你至少得用过。。）drawRect方法依赖Core Graphics框架来进行自定义的绘制，但这种方法主要的缺点就是它处理touch事件的方式：每次按钮被点击后，都会用setNeddsDisplay进行强制重绘；而且不止一次，每次单点事件触发两次执行。这样的话从性能的角度来说，对CPU和内存来说都是欠佳的。特别是如果在我们的界面上有多个这样的UIButton实例。 ###12. ASIHttpRequest或者SDWebImage里面给UIImageView加载图片的逻辑是什么样的？详见SDWebImage的实现流程 http://www.cnblogs.com/6duxz/p/4159572.html ###13. 麻烦你设计个简单的图片内存缓存器（移除策略是一定要说的）图片的内存缓存，可以考虑将图片数据保存到一个数据模型中。所以在程序运行时这个模型都存在内存中。移除策略：释放数据模型对象。 ###14. 讲讲你用Instrument优化动画性能的经历吧（别问我什么是Instrument）可以参考iOS App性能优化 ###15. loadView是干嘛用的？当你访问一个ViewController的view属性时，如果此时view的值是nil，那么，ViewController就会自动调用loadView这个方法。这个方法就会加载或者创建一个view对象，赋值给view属性。loadView默认做的事情是：如果此ViewController存在一个对应的nib文件，那么就加载这个nib。否则，就创建一个UIView对象。 如果你用Interface Builder来创建界面，那么不应该重载这个方法。 如果你想自己创建view对象，那么可以重载这个方法。此时你需要自己给view属性赋值。你自定义的方法不应该调用super。如果你需要对view做一些其他的定制操作，在viewDidLoad里面去做。 ========================================= 根据上面的文档可以知道，有两种情况： 1、如果你用了nib文件，重载这个方法就没有太大意义。因为loadView的作用就是加载nib。如果你重载了这个方法不调用super，那么nib文件就不会被加载。如果调用了super，那么view已经加载完了，你需要做的其他事情在viewDidLoad里面做更合适。 2、如果你没有用nib，这个方法默认就是创建一个空的view对象。如果你想自己控制view对象的创建，例如创建一个特殊尺寸的view，那么可以重载这个方法，自己创建一个UIView对象，然后指定 self.view = myView; 但这种情况也没有必要调用super，因为反正你也不需要在super方法里面创建的view对象。如果调用了super，那么就是浪费了一些资源而已参考：http://www.cnblogs.com/dyllove98/archive/2013/06/06/3123005.html ###16. viewWillLayoutSubView你总是知道的。横竖屏切换的时候，系统会响应一些函数，其中 viewWillLayoutSubviews 和 viewDidLayoutSubviews。 1234567891011121314- (void)viewWillLayoutSubviews&#123; [self _shouldRotateToOrientation:(UIDeviceOrientation)[UIApplication sharedApplication].statusBarOrientation];&#125;- (void)_shouldRotateToOrientation:(UIDeviceOrientation)orientation &#123; if (orientation == UIDeviceOrientationPortrait ||orientation == UIDeviceOrientationPortraitUpsideDown) &#123; // 竖屏&#125;else &#123; // 横屏 &#125;&#125; 通过上述一个函数就知道横竖屏切换的接口了。注意：viewWillLayoutSubviews只能用在ViewController里面，在view里面没有响应。 ###17. GCD里面有哪几种Queue？你自己建立过串行queue吗？背后的线程模型是什么样的？1.主队列 dispatch_main_queue(); 串行 ，更新UI2.全局队列 dispatch_global_queue(); 并行，四个优先级：background，low，default，high3.自定义队列 dispatch_queue_t queue ; 可以自定义是并行：DISPATCH_QUEUE_CONCURRENT或者串行DISPATCH_QUEUE_SERIAL ###18. 用过coredata或者sqlite吗？读写是分线程的吗？遇到过死锁没？咋解决的？参考：CoreData与SQLite的线程安全 ###19. http的post和get啥区别？（区别挺多的，麻烦多说点）1.GET请求的数据会附在URL之后（就是把数据放置在HTTP协议头中），以?分割URL和传输数据，参数之间以&amp;相连，如：login.action?name=hyddd&amp;password=idontknow&amp;verify=%E4%BD%A0%E5%A5%BD。如果数据是英文字母/数字，原样发送，如果是空格，转换为+，如果是中文/其他字符，则直接把字符串用BASE64加密，得出如：%E4%BD%A0%E5%A5%BD，其中％XX中的XX为该符号以16进制表示的ASCII。 POST把提交的数据则放置在是HTTP包的包体中。 2.”GET方式提交的数据最多只能是1024字节，理论上POST没有限制，可传较大量的数据，IIS4中最大为80KB，IIS5中为100KB”？？！ 以上这句是我从其他文章转过来的，其实这样说是错误的，不准确的： (1).首先是”GET方式提交的数据最多只能是1024字节”，因为GET是通过URL提交数据，那么GET可提交的数据量就跟URL的长度有直接关系了。而实际上，URL不存在参数上限的问题，HTTP协议规范没有对URL长度进行限制。这个限制是特定的浏览器及服务器对它的限制。IE对URL长度的限制是2083字节(2K+35)。对于其他浏览器，如Netscape、FireFox等，理论上没有长度限制，其限制取决于操作系统的支持。 注意这是限制是整个URL长度，而不仅仅是你的参数值数据长度。[见参考资料5] (2).理论上讲，POST是没有大小限制的，HTTP协议规范也没有进行大小限制，说“POST数据量存在80K/100K的大小限制”是不准确的，POST数据是没有限制的，起限制作用的是服务器的处理程序的处理能力。 3.在ASP中，服务端获取GET请求参数用Request.QueryString，获取POST请求参数用Request.Form。在JSP中，用request.getParameter(\\”XXXX\\”)来获取，虽然jsp中也有request.getQueryString()方法，但使用起来比较麻烦，比如：传一个test.jsp?name=hyddd&amp;password=hyddd，用request.getQueryString()得到的是：name=hyddd&amp;password=hyddd。在PHP中，可以用$_GET和$_POST分别获取GET和POST中的数据，而$_REQUEST则可以获取GET和POST两种请求中的数据。值得注意的是，JSP中使用request和PHP中使用$_REQUEST都会有隐患，这个下次再写个文章总结。 4.POST的安全性要比GET的安全性高。注意：这里所说的安全性和上面GET提到的“安全”不是同个概念。上面“安全”的含义仅仅是不作数据修改，而这里安全的含义是真正的Security的含义，比如：通过GET提交数据，用户名和密码将明文出现在URL上，因为(1)登录页面有可能被浏览器缓存，(2)其他人查看浏览器的历史纪录，那么别人就可以拿到你的账号和密码了，除此之外，使用GET提交数据还可能会造成Cross-site request forgery攻击。 总结一下，Get是向服务器发索取数据的一种请求，而Post是向服务器提交数据的一种请求，在FORM（表单）中，Method默认为”GET”，实质上，GET和POST只是发送机制不同，并不是一个取一个发！ ###20. 我知道你大学毕业过后就没接触过算法数据结构了，但是请你一定告诉我什么是Binary search tree? search的时间复杂度是多少？Binary search tree:二叉搜索树。主要由四个方法：（用C语言实现或者Python）1.search：时间复杂度为O(h)，h为树的高度 2.traversal：时间复杂度为O(n)，n为树的总结点数。 3.insert：时间复杂度为O(h)，h为树的高度。 4.delete：最坏情况下，时间复杂度为O(h)+指针的移动开销。 可以看到，二叉搜索树的dictionary operation的时间复杂度与树的高度h相关。所以需要尽可能的降低树的高度，由此引出平衡二叉树Balanced binary tree。它要求左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。这样就可以将搜索树的高度尽量减小。常用算法有红黑树、AVL、Treap、伸展树等。","link":"/2017/09/15/知乎上某人的iOS面试题/"},{"title":"一起唱，团结就是力量","text":"两个人来到河边，想要渡河，于是同乘一条船。一人船尾，一人船艏，各自拿起一对桨奋力地划着。可是过了老半天也不见小船驶向对岸，两人转头一看，原来各自把自己的位置当成船艏了，朝着相反的方向划去了。他们互相指责对方的过失，到了太阳落山依然还停留在原地。","link":"/2016/11/18/一起唱，团结就是力量/"},{"title":"腾讯SNG某部门iOS面试经历","text":"腾讯SNG面试，算是积攒一次面试经验了。可以看出，高级工程师不仅要会用一些常用库，还要懂得它们的原理。 1.APP性能优化：内存泄露检测、卡顿检测,自己做应该怎么做？内存泄露检测： 1. Instruments工具：Leaks，Allocation. 2. MLeakFinder工具。MLeaksFinder：精准 iOS 内存泄露检测工具iOS内存泄漏自动检测工具PLeakSniffer卡顿检测： 1. 开发阶段可以用CADisplayLink，添加到runloop中. 2. 线上监测，除了用第三方SDK之外，可以使用 “在子线程添加observer监测主线程”的方式.微信读书 iOS 性能优化总结卡顿检测的实现代码可以在这里找到：检测iOS的APP性能的一些方法开源工具：- FBRetainCycleDetector- MLeaksFinder- PLCrashreporter2.AsycDisplayKit 原理。 AsyncDisplayKit是 Facebook 推出的用于保持界面流畅性的框架，其原理大致如下：UI 线程中一旦出现繁重的任务就会导致界面卡顿，这类任务通常分为3类：排版，绘制，UI对象操作。排版通常包括计算视图大小、计算文本高度、重新计算子式图的排版等操作。 绘制一般有文本绘制 (例如 CoreText)、图片绘制 (例如预先解压)、元素绘制 (Quartz)等操作。UI对象操作通常包括 UIView/CALayer 等 UI 对象的创建、设置属性和销毁。 其中前两类操作可以通过各种方法扔到后台线程执行，而最后一类操作只能在主线程完成，并且有时后面的操作需要依赖前面操作的结果 （例如TextView创建时可能需要提前计算出文本的大小）。ASDK 所做的，就是尽量将能放入后台的任务放入后台，不能的则尽量推迟 (例如视图的创建、属性的调整)。为此，ASDK 创建了一个名为 ASDisplayNode 的对象，并在内部封装了 UIView/CALayer，它具有和 UIView/CALayer 相似的属性，例如 frame、backgroundColor等。所有这些属性都可以在后台线程更改，开发者可以只通过 Node 来操作其内部的 UIView/CALayer，这样就可以将排版和绘制放入了后台线程。但是无论怎么操作，这些属性总需要在某个时刻同步到主线程的 UIView/CALayer 去。 ASDK 仿照 QuartzCore/UIKit 框架的模式，实现了一套类似的界面更新的机制：即在主线程的 RunLoop 中添加一个 Observer，监听了 kCFRunLoopBeforeWaiting 和 kCFRunLoopExit 事件，在收到回调时，遍历所有之前放入队列的待处理的任务，然后一一执行。 具体的代码可以看这里：_ASAsyncTransactionGroup。 3.Crash ，Bug收集 SDK的原理，自己做应该怎么做？ 注册NSSetUncaughtExceptionHandler，包括两种： HandleException SignalHandler 漫谈iOS Crash收集框架 iOS崩溃捕获以及收集原理 4.Core animation 动画与UIView动画的区别,动画执行过程中是否响应事件？ UIView animation 由CPU执行，Core Animation由GPU执行。 CALayer本身不能响应事件，UIView是在CAlayer之上，增加了触摸响应,手势识别等事件响应。 Core Animation is not executed on the CPU. Their commands are more offloaded to the GPU and used to create the graphics that are shown on the screen, powered by the GPU hardware. Core Graphics is entirely done on the CPU, and cannot be performed on the GPU. Because it is an entirely CPU-bound operation, it is sometimes slower on older devices (e.g. the iPad 2 or the iPad 3rd Generation). This is something you need to keep in mind when using it in your apps. But, the good thing about Core Graphics is you can combine it with Core Animation. Advanced Graphics with Core Animation Core Animation does the rest, handing most of the actual drawing work off to the onboard graphics hardware to accelerate the rendering. This automatic graphics acceleration results in high frame rates and smooth animations without burdening the CPU and slowing down your app. Core Animation Programming Guide 动画执行过程中是否响应事件？12345678910111213- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123; NSLog(@\"%s\",__func__); UITouch *touch = [touches anyObject]; CGPoint point = [touch locationInView:self.view]; if (CGRectContainsPoint(self.colorLayer.presentationLayer.frame, point)) &#123; [self startAnimation]; &#125; if (CGRectContainsPoint(self.myView.frame, point)) &#123; [self startUIViewAnimation:nil]; &#125;&#125; 经过测试，CALayer是可以响应touch事件的,而UIView的block animation在执行过程中不能响应其自身的触摸事件。 注意CALayer在动画执行过程中要是用presentationLayer属性才能获取到中间状态的layerCore Animation 的removedOnCompletion 属性默认是YES，即动画结束之后会移除动画，CALayer会回到原来的状态 可以查看Core Animation Programming Guide 的显式动画一章。 另外附一篇有意思的文章 UIDynamics, UIKit or OpenGL? 3 Types of iOS Animations for the Star Wars,值得一读。 5.Https概念，iOS中设置https。略6.100W数据中找到最大的1W个数，使用什么数据结构？ 最小堆 先拿10000个数建堆，然后一次添加剩余元素，如果大于堆顶的数（10000中最小的），将这个数替换堆顶，并调整结构使之仍然是一个最小堆，这样，遍历完后，堆中的10000个数就是所需的最大的10000个。建堆时间复杂度是O（mlogm），算法的时间复杂度为O（nmlogm）（n为10亿，m为10000）。 优化的方法：可以把所有10亿个数据分组存放，比如分别放在1000个文件中。这样处理就可以分别在每个文件的10^6个数据中找出最大的10000个数，合并到一起在再找出最终的结果。 海量数据处理 - 10亿个数中找出最大的10000个数（top K问题） 7.音视频开发，没做过，然后提到简历上的二维码扫描库 - AVFoundation。影响二维码扫描速度的难点是什么？我回答是二维码图像的清晰度，面试官还提到了二维码图像的角度，该如何优化。对于AVFoundation来说，有两个因素：1. 图像分辨率 AVCaptureSession 可以设置 sessionPreset 属性，这个决定了视频输入每一帧图像质量的大小。 AVCaptureSessionPreset320x240 AVCaptureSessionPreset352x288 AVCaptureSessionPreset640x480 AVCaptureSessionPreset960x540 AVCaptureSessionPreset1280x720 AVCaptureSessionPreset1920x10802. 扫描范围 AVCaptureMetadataOutput 的 rectOfInterest 属性来配置解析范围8.离屏渲染问题的本质是什么？ 首先离屏渲染指的是在GPU在当前屏幕缓冲区以外开辟一个缓冲区进行渲染操作. 当使用圆角，阴影，遮罩的时候，图层属性的混合体被指定为在未预合成之前(下一个HSync信号开始前)不能直接在屏幕中绘制，所以就需要屏幕外渲染。 具体参考这篇文章：iOS-离屏渲染详解 总结： 本次面试问题侧重于实际项目，很多东西之前有看过，但都忘了大概，用到但没有深入研究是一大劣势。 所以说多多面试还是有帮助的😆！ 面试必看文章：iOS 保持界面流畅的技巧iOS 应用稳定性监测和指标问题 iOS 性能监控方案（上篇）iOS 性能监控方案（下篇）","link":"/2017/09/05/腾讯SNG某部门iOS面试经历/"},{"title":"深入理解iOS Rendering Process","text":"前言iOS 最早名为 iPhone OS，是Apple公司专门为其硬件设备开发的操作系统，最初于 2007 年随第一代 iPhone 推出，后扩展为支持 Apple 公司旗下的其他硬件设备，如 iPod、iPad 等。作为一名 iOS Developer，相信大多数人都有写出过造成 iOS 设备卡顿的代码经历，相应的也有过想方设法优化卡顿代码的经验。本文将从 OpenGL 的角度结合 Apple 官方给出的部分资料，介绍 iOS Rendering Process 的概念及其整个底层渲染管道的各个流程。相信在理解了 iOS Rendering Process 的底层各个阶段之后，我们可以在平日的开发工作之中写出性能更高的代码，在解决帧率不足的显示卡顿问题时也可以多一些思路~ 索引iOS Rendering Process 概念iOS Rendering 技术框架OpenGL 主要渲染步骤OpenGL Render PipelineCore Animation PipelineCommit TransactionAnimation全文总结扩展阅读 iOS Rendering Process 概念iOS Rendering Process 译为 iOS 渲染流程，本文特指 iOS 设备从设置将要显示的图元数据到最终在设备屏幕成像的整个过程。在开始剖析 iOS Rendering Process 之前，我们需要对 iOS 的渲染概念有一个基本的认知： 基于平铺的渲染iOS 设备的屏幕分为 N * N 像素的图块，每个图块都适合于 SoC 缓存，几何体在图块内被大量拆分，只有在所有几何体全部提交之后才可以进行光栅化（Rasterization）。Note: 这里的光栅化指将屏幕上面被大量拆分出来的几何体渲染为像素点的过程。 iOS Rendering 技术框架事实上 iOS 渲染相关的层级划分大概如下： UIKit嘛~ 作为一名 iOS Developer 来说，应该对 UIKit 都不陌生，我们日常开发中使用的用户交互组件都来自于 UIKit Framework，我们通过设置 UIKit 组件的 Layout 以及 BackgroundColor 等属性来完成日常的界面绘画工作。其实 UIKit Framework 自身并不具备在屏幕成像的能力，它主要负责对用户操作事件的响应，事件响应的传递大体是经过逐层的视图树遍历实现的。那么我们日常写的 UIKit 组件为什么可以呈现在 iOS 设备的屏幕上呢？ Core AnimationCore Animation 其实是一个令人误解的命名。你可能认为它只是用来做动画的，但实际上它是从一个叫做Layer Kit这么一个不怎么和动画有关的名字演变而来的，所以做动画仅仅是 Core Animation 特性的冰山一角。Core Animation 本质上可以理解为是一个复合引擎，旨在尽可能快的组合屏幕上不同的显示内容。这些显示内容被分解成独立的图层，即 CALayer，CALayer 才是你所能在屏幕上看见的一切的基础。其实很多同学都应该知道 CALayer，UIKit 中需要在屏幕呈现的组件内部都有一个对应的 CALayer，也就是所谓的 Backing Layer。正是因为一一对应，所以 CALayer 也是树形结构的，我们称之为图层树。视图的职责就是创建并管理这个图层，以确保当子视图在层级关系中添加或者被移除的时候，他们关联的图层也同样对应在层级关系树当中有相同的操作。但是为什么 iOS 要基于 UIView 和 CALayer 提供两个平行的层级关系呢？为什么不用一个简单的层级关系来处理所有事情呢？原因在于要做职责分离，这样也能避免很多重复代码。在 iOS 和 Mac OS X 两个平台上，事件和用户交互有很多地方的不同，基于多点触控的用户界面和基于鼠标键盘的交互有着本质的区别，这就是为什么 iOS 有 UIKit 和 UIView，而 Mac OS X 有 AppKit 和 NSView 的原因。他们功能上很相似，但是在实现上有着显著的区别。Note: 实际上，这里并不是两个层级关系，而是四个，每一个都扮演不同的角色，除了视图树和图层树之外，还存在呈现树和渲染树。 OpenGL ES &amp; Core Graphics OpenGL ESOpenGL ES简称 GLES，即 OpenGL for Embedded Systems，是 OpenGL 的子集，通常面向图形硬件加速处理单元（GPU）渲染 2D 和 3D 计算机图形，例如视频游戏使用的计算机图形。OpenGL ES 专为智能手机，平板电脑，视频游戏机和 PDA 等嵌入式系统而设计 。OpenGL ES 是“历史上应用最广泛的 3D 图形 API”。 Core GraphicsCore GraphicsFramework 基于 Quartz 高级绘图引擎。它提供了具有无与伦比的输出保真度的低级别轻量级 2D 渲染。您可以使用此框架来处理基于路径的绘图，转换，颜色管理，离屏渲染，图案，渐变和阴影，图像数据管理，图像创建和图像遮罩以及 PDF 文档创建，显示和分析。Note: 在 Mac OS X 中，Core Graphics 还包括用于处理显示硬件，低级用户输入事件和窗口系统的服务。 Graphics HardwareGraphics Hardware译为图形硬件，iOS 设备中也有自己的图形硬件设备，也就是我们经常提及的 GPU。图形处理单元（GPU）是一种专用电子电路，旨在快速操作和改变存储器，以加速在用于输出到显示设备的帧缓冲器中创建图像。GPU 被用于嵌入式系统，手机，个人电脑，工作站和游戏控制台。现代 GPU 在处理计算机图形和图像方面非常高效，并且 GPU 的高度并行结构使其在大块数据并行处理的算法中比通用 CPU 更有效。 OpenGL 主要渲染步骤OpenGL全称 Open Graphics Library，译为开放图形库，是用于渲染 2D 和 3D 矢量图形的跨语言，跨平台的应用程序编程接口（API）。OpenGL 可以直接访问 GPU，以实现硬件加速渲染。 一个用来渲染图像的 OpenGL 程序主要可以大致分为以下几个步骤：设置图元数据着色器-shader 计算图元数据（位置·颜色·其他）光栅化-rasterization 渲染为像素fragment shader，决定最终成像其他操作（显示·隐藏·融合）Note: 其实还有一些非必要的步骤，与本文主题不相关，这里点到为止。我们日常开发时使用 UIKit 布局视图控件，设置透明度等等都属于设置图元数据这步，这也是我们日常开发中可以影响 OpenGL 渲染的主要步骤。 OpenGL Render Pipeline如果有同学看过 WWDC 的一些演讲稿或者接触过一些 OpenGL 知识，应该对 Render Pipeline 这个专业术语并不陌生。不过 Render Pipeline 实在是一个初次见面不太容易理解的词，它译为渲染管道，也有译为渲染管线的…其实 Render Pipeline 指的是从应用程序数据转换到最终渲染的图像之间的一系列数据处理过程。好比我们上文中提到的 OpenGL 主要渲染步骤一样，我们开发应用程序时在设置图元数据这步为视图控件的设定布局，背景颜色，透明度以及阴影等等数据。下面以 OpenGL 4.5 的 Render Pipeline 为例介绍一下：这些图元数据流入 OpenGL 中，传入顶点着色器（vetex shader），然后顶点着色器对其进行着色器内部的处理后流出。之后可能进入细分着色阶段（tessellation shading stage），其中又有可能分为细分控制着色器和细分赋值着色器两部分处理，还可能会进入几何着色阶段（geometry shading stage），数据从中传递。最后都会走片元着色阶段（fragment shading stage）。Note: 图元数据是以 copy 的形式流入 shader 的，shader 一般会以特殊的类似全局变量的形式接收数据。OpenGL 在最终成像之前还会经历一个阶段名为计算着色阶段（compute shaing stage），这个阶段 OpenGL 会计算最重要在屏幕中成像的像素位置以及颜色，如果在之前提交代码时用到了 CALayer 会引起blending的显示效果（例如 Shadow）或者视图颜色或内容图片的 alpha 通道开启，都将会加大这个阶段 OpenGL 的工作量。 Core Animation Pipeline上文说到了 iOS 设备之所以可以成像不是因为 UIKit 而是因为 LayerKit，即 Core Animation。Core Animation 图层，即 CALayer 中包含一个属性 contents，我们可以通过给这个属性赋值来控制 CALayer 成像的内容。这个属性的类型定义为 id，在程序编译时不论我们给 contents 赋予任何类型的值，都是可以编译通过的。但实践中，如果 contents 赋值类型不是 CGImage，那么你将会得到一个空白图层。Note: 造成 contents 属性的奇怪表现的原因是 Mac OS X 的历史包袱，它之所以被定义为 id 类型是因为在 Mac OS X 中这个属性对 CGImage 和 NSImage 类型的值都起作用。但是在 iOS 中，如果你赋予一个 UIImage 属性的值，仅仅会得到一个空白图层。说完 Core Animation 的 contents 属性，下面介绍一下 iOS 中 Core Animation Pipeline：在 Application 中布局 UIKit 视图控件间接的关联 Core Animation 图层Core Animation 图层相关的数据提交到 iOS Render Server，即 OpenGL ES &amp; Core GraphicsRender Server 将与 GPU 通信把数据经过处理之后传递给 GPUGPU 调用 iOS 当前设备渲染相关的图形设备 DisplayNote: 由于 iOS 设备目前的显示屏最大支持60 FPS的刷新率，所以每个处理间隔为 16.67 ms。可以看到从 Commit Transaction 之后我们的图元数据就将会在下一次 RunLoop 时被 Application 发送给底层的 Render Server，底层 Render Server 直接面向 GPU 经过一些列的数据处理将处理完毕的数据传递给 GPU，然后 GPU 负责渲染工作，根据当前 iOS 设备的屏幕计算图像像素位置以及像素 alpha 通道混色计算等等最终在当前 iOS 设备的显示屏中呈现图像。嘛~ 由于 Core Animation Pipeline 中 Render Server 包含 OpenGL ES &amp; Core Graphics，其中 OpenGL ES 的渲染可以参考上文 OpenGL Render Pipeline 理解。 Commit TransactionCore Animation Pipeline 的整个管线中 iOS 常规开发一般可以影响到的范围也就仅仅是在 Application 中布局 UIKit 视图控件间接的关联 Core Animation 图层这一级，即Commit Transaction 之前的一些操作。那么在 Commit Transaction 之前我们一般要做的事情有哪些？Layout，构建视图Display，绘制视图Prepare，额外的 Core Animation 工作Commit，打包图层并将它们发送到 Render Server Layout在 Layout 阶段我们能做的是把 constraint 写的尽量高效，iOS 的 Layout Constraint 类似于 Android 的 Relative Layout。Note: Emmmmm… 据观察 iOS 的 Layout Constraint 在书写时应该尽量少的依赖于视图树中同层级的兄弟视图节点，它会拖慢整个视图树的 Layout 计算过程。这个阶段的 Layout 计算工作是在 CPU 完成的，包括 layoutSubviews 方法的重载，addSubview: 方法填充子视图等 Display其实这里的 Display 仅仅是我们设置 iOS 设备要最终成像的图元数据而已，重载视图 drawRect: 方法可以自定义 UIView 的显示，其原理是在 drawRect: 方法内部绘制 bitmap。Note: 重载 drawRect: 方法绘制 bitmap 过程使用 CPU 和 内存。所以重载 drawRect: 使用不当会造成 CPU 负载过重，App 内存飙升等问题。 Prepare这个步骤属于附加步骤，一般处理图像的解码 &amp; 转换等操作。 CommitCommit 步骤指打包图层并将它们发送到 Render Server。Note: Commit 操作会递归执行，由于图层和视图一样是以树形结构存在的，当图层树过于复杂时 Commit 操作的开销也会非常大。 CATransactionCATransaction 是 Core Animation 中用于将多个图层树操作分配到渲染树的原子更新中的机制，对图层树的每个修改都必须是事务的一部分。CATransaction 类没有属性或者实例方法，并且也不能用 +alloc 和 -init 方法创建它，我们只能用类方法 +begin 和 +commit 分别来入栈或者出栈。事实上任何可动画化的图层属性都会被添加到栈顶的事务，你可以通过 +setAnimationDuration: 方法设置当前事务的动画时间，或者通过 +animationDuration 方法来获取时长值（默认 0.25 秒）。Core Animation 在每个 RunLoop 周期中自动开始一次新的事务，即使你不显式地使用 [CATransaction begin] 开始一次事务，在一个特定 RunLoop 循环中的任何属性的变化都会被收集起来，然后做一次 0.25 秒的动画（CALayer 隐式动画）。Note: CATransaction 支持嵌套。 Animation对于 App 用户交互体验提升最明显的工作莫过于使用动画了，那么 iOS 是如何处理动画的渲染过程的呢？日常开发中如果不是特别复杂的动画我们一般会使用 UIView Animation 实现，iOS 将 UIView Animation 的处理过程分为以下三个阶段：调用 animateWithDuration:animations: 方法在 Animation Block 中进行 Layout，Display，Prepare，CommitRender Server 根据 Animation 逐帧渲染Note: 原理是 animateWithDuration:animations: 内部使用了 CATransaction 来将整个 Animation Block 中的代码作为原子操作 commit 给了 RunLoop。 基于 CATransaction 实现链式动画事实上大多数的动画交互都是有动画执行顺序的，尽管 UIView Animation 很强大，但是在写一些顺序动画时使用 UIView Animation 只能在 + (void)animateWithDuration:delay:options:animations:completion: 方法的 completion block 中层级嵌套，写成一坨一坨 block 堆砌而成的代码，实在是难以阅读更别提后期维护了。在得知 UIView Animation 使用了 CATransaction 时，我们不禁会想到这个 completion block 是不是也是基于 CATransaction 实现的呢？Bingo！CATransaction 中有 +completionBlock 以及 +setCompletionBlock: 方法可以对应于 UIView Animation 的 completion block 的书写。Note: 我的一个开源库LSAnimator - 可多链式动画库在动画顺序链接时也用到了 CATransaction。 全文总结结合上下文不难梳理出一个iOS 最基本的完整渲染经过（Rendering pass）。 性能检测思路基于整篇文章的内容归纳一下我们在日常的开发工作中遇到性能问题时检测问题代码的思路：文章写得比较用心（是我个人的原创文章，转载请注明https://lision.me/），如果发现错误会优先在我的个人博客 中更新。如果有任何问题欢迎在我的微博 @Lision 联系我~希望我的文章可以为你带来价值~ 扩展阅读WWDC2014-Advanced Graphics and Animations for iOS AppsiOS 保持界面流畅的技巧iOS-Core-Animation-Advanced-Techniques 本文转载自Lision’s Blog | ELSEWHERE作者：Lision’s Blog | ELSEWHERE链接：https://lision.me/ios-rendering-process/著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","link":"/2018/04/20/深入理解iOS-Rendering-Process/"},{"title":"老司机 iOS 周报 #15","text":"老司机 iOS 周报，只为你呈现有价值的信息。你也可以为这个项目出一份力，如果发现有价值的信息、文章、工具等可以到 Issues 里提给我们，我们会尽快处理。记得写上推荐的理由哦。有建议和意见也欢迎到 Issues 提出。 ###文章🐢 🌟 深入浅出 GCD 系列文章这是 cocoa-chen 阅读 GCD 源码后分享的系列文章。该系列文章以常用的 5 个 GCD API 为切入点，从『使用场景』到『原理深究』再到『总结』循序渐进十分细致地阐述了 GCD 是怎么实现这些 API 来管理维护线程池的。系列文章一共有 6 篇，大家可以各取所需： 深入浅出 GCD 之基础篇 深入浅出 GCD 之 dispatch_queue 深入浅出 GCD 之 dispatch_semaphore 深入浅出 GCD 之 dispatch_group 深入浅出 GCD 之 dispatch_once 深入浅出 GCD 之 dispatch_source 🐢 深入理解 Swift 派发机制(英文原文)2016 年的一篇文章，主要内容是讲关于 Swift 各种类型的方法派发机制，以及 NSObject 与 Swift 原生类型的差异等等，读完这篇文章我才第一次对于 Swift 的派发机制有了比较清晰全面的认识，虽然有一小部分内容已经过时了，但还是强烈推荐大家看一下。 🐎 iOS App 连续闪退时如何上报 crash 日志如果是我们自己开发一套 crash 日志收集系统的话，可能就会发现在 App 启动阶段就连续闪退的场景下往往无法正确上报崩溃日志。Peak 从『如何检测连续闪退』和『如何在闪退后继续上传日志』两方面分析和解决了这个痛点。另外，微信读书团队以前也分享过类似的方案——iOS 启动连续闪退保护方案，并且该方案额外集成了自修复系统。 🐎 How To Keep Learning After 50 and Other Ways to Hack Your Brain at any Age这篇文章通过介绍了“神经可塑性”（Neuroplastcity）理论，论证了活到老、学到老是有科学依据的。不仅如此，该文还提出年龄逐渐变大之后如何“hack”自己的大脑来让自己更有效的学习的方法。有趣的是，文章为了讨论这个话题，还邀请了 25 名年长的艺术家、教练和程序员来参与调查，他们中几乎所有都在持续的学习，尤其是其中还有从 Fortran 一路写到 Swift 的程序员，可以说是相当资深了。作为焦虑的准中年程序员，这篇文章对我的触动可谓是很大的。除了内容本身值得思考之外，文风读起来就像《老人与海》那样充满力量感。值得收藏！ 🐢 Behind-the scenes improvements in Swift 4.1掌握编程语言的设计与实现一直以来都处于技术圈鄙视链的顶端，相信绝大多数程序员都曾经跃跃欲试。如果你是对 Swift 语言的实现原理感兴趣的同学，一定不要错过这篇文章。文章标题看上去好像也就是列举一下 Swift4.1 一些改进，但实际上是针对 Swift 语言设计上面临的诸多问题和解决方案进行了深入讨论，包括但不限于为什么 protocol 中默认实现的方法不能返回 self，OC 类桥接到 Swift 中都发生了什么，以及泛型参数支持中父子关系如何实现等等。看完后对于”为什么 4.1 的编译速度好像变快了？”以及”Swift 的 ABI 什么时候才能稳定？”这两个经典问题，你应该会有自己的答案。 🐕 ✨✨工程师如何在工作中提升自己？美团点评技术团队刘丁对工程师发展的一些思考和总结，写的很全面。文章第一部分阐述了一些学习的原则；二部分分析了作者在工作中碰到和看到的一些典型困惑；第三部分剖析架构师的能力模型，让大家对目标所需能力有一个比较清晰的认知。 🐎 如何快速成长为技术大牛技术人员天天写业务代码还加班，如何才能成为技术大牛？，文章列出了一些典型的误区及正确做法：Do more、Do better、Do exercise。 🐎 Swift Tip: Local Computed Variables本文介绍了一种通过在函数体内部声明计算属性从而实现局部代码复用的编码方法，不过也仅仅是代码复用，性能方面木有任何提升，类似于一个局部函数，感兴趣的同学可以了解一下。 🐕 读 SnapKit 和 Masonry 自动布局框架源码介绍了主流 AutoLayout 布局框架 SnapKit 和 Masonry 源码结构。SnapKit 的设计思路很好理解，也有值得学习的设计经验。如果自己先尝试读读源码再看这篇文章会比较好理解。 🐢 11 Tips for Working on the iPadMacStories 整理了 11 条指南和小窍门，帮你提高 iPad 在 iOS 11 下的生产力。从外接键盘推荐和快捷键到手势和 Siri，全都是 Federico Viticci 日常使用 iPad Pro 的小技巧。 🐕 iOS 中制作原型动画的一些方式介绍了两种动画原型的制作方式。利用 Xcode 的 playground 和 PaintCode。在我看来这两种方式其实都有缺点。playground 编译速度太慢并且调参还是用代码。效果基本靠蒙。PaintCode 适用范围太局限。基本都是绘制路径。现在最强的的原型工具应该是 Principle。 🐎 fastlane 发布 CI aplha 版本alpha 版本发布了。其实关于公司的自动化也是老生常谈的问题了。体验比较好的自动化配置在我看来是，Slack + Xcode server + Fastlane + Phabricator + Arcanist + Trello(jira)。有兴趣的同学可以研究一下。 ###工具IBM Watson Services for Core MLWatson Services 是 IBM 的人工智能实验室提供对外的 AI 服务，包含了聊天对话/视觉识别/语音处理/语言翻译等多方面能力，而 IBM Watson Services for Core ML 是 IBM 与苹果合作的，将 Watson Services 的 AI 能力与苹果的 CoreML 相结合移动端 AI 服务，以 SDK 的形式接入移动端，方便开发者快速构建具有 AI 能力的 App。 苹果产品购买时机建议苹果更新其产品的时候往往是该产品的最佳购买时机，如果错过了，那么可以在这个网站上找到购买建议，网站会根据该产品距离上次更新的时长，以及历史以来的平均更新周期给出指导，并收集了产品相关的最新传闻给与你作为参考。 ###内推奇志信息科技: 杭州/广州 iOS 工程师我（@没故事的卓同学）现在的公司，Swift 开发，应用支持从 iOS 10 开始，杭州和广州都有研发团队，无人机应用方向。iOS、Android、前端、UI 都招，感兴趣的朋友欢迎简历投到 hr@kiwiinc.net 。 上海享物说网络科技有限公司：上海 iOS 工程师我 (@EyreFree) 现在所在的公司，位于上海宜山路地铁站附近，主营内容为二手互送社区，Swift 开发，应用支持从 iOS 9 开始。除 iOS 职位以外，还有 Web 前端 / Android 工程师等岗位空缺，求三年左右经验的大佬，三餐供应，住宿补贴。感兴趣的朋友欢迎简历投到 eyrefree@eyrefree.org。 ###专栏onevcat 的小专栏：开发笔记簿记录了喵神日常开发时遇到的问题和解决方案，同时也会收藏一些学习时记录的笔记，随想等。定价 ¥99，因为至少会有一两年的长期更新，所以这个价格是非常良心的。而且目前已经更新了 9 篇，涉及的范围也比较广，值得订阅！ ###福利周报读者专属 Reveal 50 元优惠券我们和 Price Tag 的合作，给读者送一个小福利，点击上面链接可以领取 Reveal 14 优惠券。领取后到这里可以使用：购买链接 。 关注我们我们开通了公众号，每期发布时公众号会推送消息，欢迎关注。 作者：老司机iOS周报链接：https://juejin.im/post/5ad437596fb9a028d567933a来源：掘金著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","link":"/2018/04/16/老司机-iOS-周报-15/"},{"title":"老司机 iOS 周报 #1","text":"老司机 iOS 周报，只为你呈现有价值的信息。有建议或者有信息推荐可以到我们 github 下面提 issue。 ###新闻致广大用户关于 iPhone 电池及性能的说明苹果对电池老化会导致 iPhone 性能下降做的沟通说明。表示 从来没有、也永远不会通过任何手段，来有意缩短任何 Apple 产品的使用寿命，更不会降低用户体验来迫使大家升级设备。为了安抚大家的不满，苹果将更换电池的费用下调了 390 元，从 608 元降到 218 元。不过这个降价不是永久性的，只持续到 18 年 12 月。Swift 快要可以和 Python 无缝交互了这是 Chris Lattner 大神到 Google 之后的第一个提案，让 Swift 可以和 Python 无缝交互，Chris 每次提案基本上都会带上 Demo，这一次也不例外，只用了不到一千行代码就把交互逻辑给实现了出来🤷‍♂️，大家可以直接下载这个 playground 试一下用 Swift 写 Python 是什么感觉。另外 Chris 还提出使用一套 DynamicMemberProtocol 去优化了 Python 交互的语法， 与 Python 的交互都是依赖于字符串，画风大概是这样的 let a = np.call(member: “arange”, args: 15).call(member: “reshape”, args: 3, 5)，如果实现了 DynamicMemberProtocol 的话，就可以在 Swift 里像 Python 代码一样调用 Python 的方法 np.arange(15).reshape(3, 5)，编译器不会给遵循了这个协议的对象做静态检查，但这本质上只是一个语法糖，编译时还是会转化为前者的格式去调用。 苹果宣布收购 BuddybuildBuddybuild 是著名的自动化 CI 托管服务平台，苹果收购后 Buddybuild 公司将会加入 Xcode 团队。期待 Xcode 对 CI 的支持将会更进一步。 Swift Weekly Brief 宣布停更Jesse Squires 宣布停止更新 Swift Weekly，一直以来这个 News Letter 都是我了解 Swift 开发进度最主要的途径，现在要停更了，确实很可惜。Jesse 提到停止更新的理由，主要是因为当初开始 Swift Weekly 的时候，Swift 刚刚开源，对于功能和设计的讨论非常非常多，并且 Mailing List 这种形式让人很难找到有价值的内容，所以这样一个 News Letter 在当时是非常有意义的。但现在 Swift 已经逐渐成熟，社区里的讨论变得越来越深入，而且 Swift 最近还从 Mailing List 迁移到了论坛上，相关资讯的获取已经变得越来越方便了，Swift Weekly 的存在价值也已经大不如前了，所以才打算停止更新。但停更只是个人意义上的停更，Jesse 欢迎社区的人接手过去继续更新，并且在原文介绍了一系列接手的注意事项。 Apple 更新 App Store Review Guidelines，增加 VPN 和 loot boxes 等条款Apple 于 2017.12.21 更新了其 App Store Review Guidelines. 主要变化集中在以下几个方面： 新上架 App 引入 pre-order 机制 虚拟物品抽奖必须公布各项概率(loot boxes) VPN 类应用如需在特定地区发布，必须提供相应许可信息 符合特定前提下，允许通过模板生成的 App 上架发布 LiberiOS jailbreak for iOS 11 officially released, includes support for the iPhone XLiberiOS 正式发布 iOS 11.0 - 11.1.2 的越狱工具，包括对 iPhone X 的支持。 ###文章iOS 知识小集国内知名开发者 @南峰子 把过去微博上发出来的 iOS 开发知识整理了出来，发在了 GitHub 上，据介绍这一系列的微博已经有 1000w 的阅读量了！！！ Swift Tips跟前面 iOS Tips 小集类似的项目，不同的是这个项目里讲的是一些 Swift 的小 Tips，里面 #7，#22 等技巧我都有实际用于项目中，推荐大家看一下。 Weak Arraysobjc.io 在这篇博客里简单介绍了在 Swift 中自定义弱引用数组的一种实现方式。 When and how to use Value and Reference Types in Swift全面介绍了 Swift 中的值类型和引用类型的使用区别。 Building an enum based analytics system in swift使用 enum 和 protocol 构建安全、高效、灵活的 Swift 事件统计系统。 Measuring Swift compile times in Xcode 9对 Xcode 进行一些配置看看哪些 Swift 代码拖慢了你的编译速度。 ###工具App Host一个轻量级的包托管网站，app-host 主要用于 iOS 和 Android 的包管理，作用类似于fir.im，不同之处是可以自由部署在内网，方便了公司项目保密。并且代码开源也可以方便根据各自需求进行定制化开发。 XcodeGenXcodeGen 是一个根据已有的代码文件 / 目录和简单的配置文件来生成 Xcode project 的开源工具，快速生成模板工程、将 .xcodeproj 从 Git 追踪中忽略、方便地和他人分享自己的工程配置等，无限可能，等你尝试。 ###代码WCDB SwiftWCDB 是微信团队开源的 SQLite 数据库，近日放出 WCDB Swift 的 1.0 正式版，WCDB Swift 使用纯 Swift 编写，几乎不包含 Cocoa 的代码，且与 ObjC 版保持完全一致的功能。其基于 Swift 4.0 的 Codable 协议实现模型绑定，通过建立 Swift 类型与数据库表之间的映射关系，使得开发者可以通过类对象直接操作数据库。虽然项目没有实际使用于微信中，但这只是第一步嘛，并且文章最后还表示测试用例的代码覆盖率已经达到了 91.34% 了🤑，所以大家真的可以考虑在项目中使用。 Task automation in Swift with SakeiOS 还没有使用 Swift 语言编写的自动化工具，目前流行的都是采用 bash、ruby 编写的。于是作者尝试利用 Swift 写了 Sake。这个项目目前还处于早期。 Fluid SliderRamotion 出品的滑动控件。微信跳一跳可以直接更改分数，POST 请求没有校验v2ex 上也有获得微信小游戏跳一跳源码的讨论。 ###书Swift 进阶Swift 经典书籍《Swift 进阶》更新了 Swift 4 的相关内容。 本期编辑@没故事的卓同学，@四娘，@mmoaay，@享耳先森，@EyreFree 作者：老司机iOS周报链接：https://juejin.im/post/5a5207bf6fb9a01c9c1ed94c来源：掘金著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","link":"/2018/01/08/老司机-iOS-周报-1/"},{"title":"简记 - 记录你的生活","text":"简记 —— 记录你的生活最简单的文字记录app，带给你清新，简约的气息。 没什么特点的文字编辑app。 ———我是分割线———–特点：(⊙v⊙)嗯，就是简单。 文集分类管理日记。快速创建日记。分享给好友啦。 联系邮箱: hanangellove@icloud.com","link":"/2017/03/11/简记-记录你的生活/"}],"tags":[{"name":"Effective-Ojective C 2.0","slug":"Effective-Ojective-C-2-0","link":"/tags/Effective-Ojective-C-2-0/"},{"name":"LearnSwift","slug":"LearnSwift","link":"/tags/LearnSwift/"},{"name":"NSURLSession","slug":"NSURLSession","link":"/tags/NSURLSession/"},{"name":"category","slug":"category","link":"/tags/category/"},{"name":"block","slug":"block","link":"/tags/block/"},{"name":"NS_ENUM","slug":"NS-ENUM","link":"/tags/NS-ENUM/"},{"name":"NSString","slug":"NSString","link":"/tags/NSString/"},{"name":"iOS","slug":"iOS","link":"/tags/iOS/"},{"name":"swift","slug":"swift","link":"/tags/swift/"},{"name":"MVVM","slug":"MVVM","link":"/tags/MVVM/"},{"name":"QRCode","slug":"QRCode","link":"/tags/QRCode/"},{"name":"AVFoundation","slug":"AVFoundation","link":"/tags/AVFoundation/"},{"name":"CoreImage","slug":"CoreImage","link":"/tags/CoreImage/"},{"name":"Xcode8","slug":"Xcode8","link":"/tags/Xcode8/"},{"name":"NavigationBar","slug":"NavigationBar","link":"/tags/NavigationBar/"},{"name":"SDWebImage","slug":"SDWebImage","link":"/tags/SDWebImage/"},{"name":"UIView","slug":"UIView","link":"/tags/UIView/"},{"name":"UIButton","slug":"UIButton","link":"/tags/UIButton/"},{"name":"xib","slug":"xib","link":"/tags/xib/"},{"name":"drawRect","slug":"drawRect","link":"/tags/drawRect/"},{"name":"tableViewCell","slug":"tableViewCell","link":"/tags/tableViewCell/"},{"name":"cell高度","slug":"cell高度","link":"/tags/cell高度/"},{"name":"skills","slug":"skills","link":"/tags/skills/"},{"name":"蓝牙","slug":"蓝牙","link":"/tags/蓝牙/"},{"name":"CoreBluetooth","slug":"CoreBluetooth","link":"/tags/CoreBluetooth/"},{"name":"SDK","slug":"SDK","link":"/tags/SDK/"},{"name":"Lua","slug":"Lua","link":"/tags/Lua/"},{"name":"cocos2d","slug":"cocos2d","link":"/tags/cocos2d/"},{"name":"python","slug":"python","link":"/tags/python/"},{"name":"ARC","slug":"ARC","link":"/tags/ARC/"},{"name":"内存管理","slug":"内存管理","link":"/tags/内存管理/"},{"name":"runtime","slug":"runtime","link":"/tags/runtime/"},{"name":"内存","slug":"内存","link":"/tags/内存/"},{"name":"《iOS开发进阶》阅读笔记","slug":"《iOS开发进阶》阅读笔记","link":"/tags/《iOS开发进阶》阅读笔记/"},{"name":"shell","slug":"shell","link":"/tags/shell/"},{"name":"EXC_BAD_ACCESS","slug":"EXC-BAD-ACCESS","link":"/tags/EXC-BAD-ACCESS/"},{"name":"CoreData","slug":"CoreData","link":"/tags/CoreData/"},{"name":"SQLite","slug":"SQLite","link":"/tags/SQLite/"},{"name":"编译","slug":"编译","link":"/tags/编译/"},{"name":"链接","slug":"链接","link":"/tags/链接/"},{"name":"Objc Bridging Header","slug":"Objc-Bridging-Header","link":"/tags/Objc-Bridging-Header/"},{"name":"UIBarButtonItem","slug":"UIBarButtonItem","link":"/tags/UIBarButtonItem/"},{"name":"Runtime","slug":"Runtime","link":"/tags/Runtime/"},{"name":"userAgent","slug":"userAgent","link":"/tags/userAgent/"},{"name":"算法","slug":"算法","link":"/tags/算法/"},{"name":"IM","slug":"IM","link":"/tags/IM/"},{"name":"xmpp","slug":"xmpp","link":"/tags/xmpp/"},{"name":"知乎","slug":"知乎","link":"/tags/知乎/"},{"name":"腾讯","slug":"腾讯","link":"/tags/腾讯/"},{"name":"Rendering","slug":"Rendering","link":"/tags/Rendering/"},{"name":"OpenGL","slug":"OpenGL","link":"/tags/OpenGL/"},{"name":"简记","slug":"简记","link":"/tags/简记/"}],"categories":[{"name":"iOS","slug":"iOS","link":"/categories/iOS/"},{"name":"Swift","slug":"Swift","link":"/categories/Swift/"},{"name":"sourcecode","slug":"sourcecode","link":"/categories/sourcecode/"},{"name":"程序员的自我修养","slug":"程序员的自我修养","link":"/categories/程序员的自我修养/"},{"name":"algorithm","slug":"algorithm","link":"/categories/algorithm/"},{"name":"iOSInterview","slug":"iOSInterview","link":"/categories/iOSInterview/"},{"name":"生活","slug":"生活","link":"/categories/生活/"},{"name":"graphic","slug":"graphic","link":"/categories/graphic/"},{"name":"swiftOldDriver","slug":"swiftOldDriver","link":"/categories/swiftOldDriver/"},{"name":"app","slug":"app","link":"/categories/app/"}]}