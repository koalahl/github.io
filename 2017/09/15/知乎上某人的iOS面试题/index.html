<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>知乎上某人的iOS面试题 | 寒流‘s Blog | 编程与生活</title>

  
  <meta name="author" content="Han Liu">
  

  
  <meta name="description" content="Think in Different">
  

  
  
  <meta name="keywords" content="">
  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  <meta property="og:title" content="知乎上某人的iOS面试题"/>

  <meta property="og:site_name" content="寒流‘s Blog"/>

  
  <meta property="og:image" content="/favicon.ico"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="寒流‘s Blog" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
</head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">寒流‘s Blog</a>
    </h1>
    <p class="site-description">编程与生活</p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/">首页</a></li>
      
        <li><a href="/categories">分类</a></li>
      
        <li><a href="/iOSInterview">iOS面试题</a></li>
      
        <li><a href="/archives">文章</a></li>
      
        <li><a href="/link">链接</a></li>
      
        <li><a href="/about">关于</a></li>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    <article>

  
    
    <h3 class="article-title"><span>知乎上某人的iOS面试题</span></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2017/09/15/知乎上某人的iOS面试题/" rel="bookmark">
        <time class="entry-date published" datetime="2017-09-15T02:21:00.000Z">
          2017-09-15
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>这是前年在知乎上总结回答MrPeak的问题，现在搬运到自己的blog中。<br>知乎链接：<a href="http://www.zhihu.com/question/19604641" target="_blank" rel="noopener">http://www.zhihu.com/question/19604641</a></p>
<a id="more"></a>
<p>###1.什么是arc？（arc是为了解决什么问题诞生的？）<br>首先解释ARC: automatic reference counting自动引用计数。<br>ARC几个要点：<br>在对象被创建时 retain count +1，在对象被release时 retain count -1.当retain count 为0 时，销毁对象。程序中加autoreleasepoo的对象会由系统自动加上autorelease方法，如果该对象引用计数为0，则销毁。那么ARC是为了解决什么问题诞生的呢？这个得追溯到MRC手动内存管理时代说起。<br>MRC下内存管理的缺点：</p>
<ol>
<li>当我们要释放一个堆内存时，首先要确定指向这个堆空间的指针都被release了。（避免提前释放）</li>
<li>释放指针指向的堆空间，首先要确定哪些指针指向同一个堆，这些指针只能释放一次。（MRC下即谁创建，谁释放，避免重复释放）</li>
<li>模块化操作时，对象可能被多个模块创建和使用，不能确定最后由谁去释放。</li>
<li>多线程操作时，不确定哪个线程最后使用完毕</li>
</ol>
<p>###2.请解释以下keywords的区别： <code>assign</code> vs <code>weak</code>, <code>__block</code> vs <code>__weak</code><br>assign适用于基本数据类型，weak是适用于NSObject对象，并且是一个弱引用。<br>assign其实也可以用来修饰对象，那么我们为什么不用它呢？因为被assign修饰的对象在释放之后，指针的地址还是存在的，也就是说指针并没有被置为nil。如果在后续的内存分配中，刚好分到了这块地址，程序就会崩溃掉。而weak修饰的对象在释放之后，指针地址会被置为nil。所以现在一般弱引用就是用weak。</p>
<p>首先<code>__block</code>是用来修饰一个变量，这个变量就可以在block中被修改（参考block实现原理）<br><code>__block</code>：使用 <strong>block修饰的变量在block代码快中会被retain（ARC下，MRC下不会retain）<br>`</strong>weak` ：使用 <strong>weak修饰的变量不会在block代码块中被retain<br>同时，在ARC下，要避免block出现循环引用 ``</strong>weak typedof(self)weakSelf = self``;</p>
<p>###3.<strong>block在arc和非arc下含义一样吗？<br>是不一样的。<br>在MRC中 </strong>block variable 在block中使用是不會retain的,但是ARC中 <strong>block則是會Retain的。<br>取而代之的是用 `</strong>weak<code>或是</code>__unsafe_unretained` 來更精確的描述weak reference的目的其中前者只能在iOS5之後可以使用，但是比較好 (該物件release之後，此pointer會自動設成nil)而後者是ARC的環境下為了相容4.x的解決方案。所以上面的範例中<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">__block MyClass* temp = …;    <span class="comment">// MRC環境下使用</span></span><br><span class="line">__<span class="keyword">weak</span> MyClass* temp = …;    <span class="comment">// ARC但只支援iOS5.0以上的版本</span></span><br><span class="line">__unsafe_retained MyClass* temp = …;  <span class="comment">//ARC且可以相容4.x以後的版本</span></span><br></pre></td></tr></table></figure></p>
<p>###4.使用nonatomic一定是线程安全的吗？（）<br>不是的。<br>atomic原子操作，系统会为setter方法加锁。 具体使用 @synchronized(self){//code }<br>nonatomic不会为setter方法加锁。<br>atomic：线程安全，需要消耗大量系统资源来为属性加锁<br>nonatomic：非线程安全，适合内存较小的移动设备</p>
<p>###5.描述一个你遇到过的retain cycle例子。<br>block中的循环引用：一个viewController<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">strong</span>)HttpRequestHandler * handler;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">strong</span>)<span class="built_in">NSData</span> 		    *data;</span><br><span class="line">_handler = [httpRequestHandler sharedManager];</span><br><span class="line">[ downloadData:^(<span class="keyword">id</span> responseData)&#123;</span><br><span class="line">	_data = responseData;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure></p>
<p>self 拥有_handler, _handler 拥有block, block拥有self（因为使用了self的_data属性，block会copy 一份self）<br>解决方法：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">__<span class="keyword">weak</span> typedof(<span class="keyword">self</span>)weakSelf = <span class="keyword">self</span></span><br><span class="line">[ downloadData:^(<span class="keyword">id</span> responseData)&#123;</span><br><span class="line">	weakSelf.data = responseData;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure></p>
<p></p><h3>6.+(void)load; +(void)initialize；有什么用处？</h3><br>在Objective-C中，runtime会自动调用每个类的两个方法。+load会在类初始加载时调用，+initialize会在第一次调用类的类方法或实例方法之前被调用。这两个方法是可选的，且只有在实现了它们时才会被调用。<br>共同点：两个方法都只会被调用一次。<p></p>
<p></p><h3>7.为什么其他语言里叫函数调用， objective c里则是给对象发消息（或者谈下对runtime的理解）</h3><br>先来看看怎么理解发送消息的含义：<p></p>
<p>曾经觉得Objc特别方便上手，面对着 Cocoa 中大量 API，只知道简单的查文档和调用。还记得初学 Objective-C 时把[receiver message]当成简单的方法调用，而无视了“发送消息”这句话的深刻含义。于是[receiver message]会被编译器转化为：<br><code>objc_msgSend(receiver, selector)</code><br>如果消息含有参数，则为：<br><code>objc_msgSend(receiver, selector, arg1, arg2, ...)</code></p>
<p>如果消息的接收者能够找到对应的selector，那么就相当于直接执行了接收者这个对象的特定方法；否则，消息要么被转发，或是临时向接收者动态添加这个selector对应的实现内容，要么就干脆玩完崩溃掉。</p>
<p>现在可以看出[receiver message]真的不是一个简简单单的方法调用。因为这只是在编译阶段确定了要向接收者发送message这条消息，而receive将要如何响应这条消息，那就要看运行时发生的情况来决定了。</p>
<p>Objective-C 的 Runtime 铸就了它动态语言的特性，这些深层次的知识虽然平时写代码用的少一些，但是却是每个 Objc 程序员需要了解的。</p>
<p>Objc Runtime使得C具有了面向对象能力，在程序运行时创建，检查，修改类、对象和它们的方法。可以使用runtime的一系列方法实现。</p>
<p>顺便附上OC中一个类的数据结构 /usr/include/objc/runtime.h<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">struct</span> objc_class &#123;</span><br><span class="line">Class isa OBJC_ISA_AVAILABILITY; <span class="comment">//isa指针指向Meta Class，因为Objc的类的本身也是一个Object，为了处理这个关系，r		untime就创造了Meta Class，当给类发送[NSObject alloc]这样消息时，实际上是把这个消息发给了Class Object</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#if !__OBJC2__</span></span><br><span class="line">Class super_class OBJC2_UNAVAILABLE; <span class="comment">// 父类</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *name OBJC2_UNAVAILABLE; <span class="comment">// 类名</span></span><br><span class="line"><span class="keyword">long</span> version OBJC2_UNAVAILABLE; <span class="comment">// 类的版本信息，默认为0</span></span><br><span class="line"><span class="keyword">long</span> info OBJC2_UNAVAILABLE; <span class="comment">// 类信息，供运行期使用的一些位标识</span></span><br><span class="line"><span class="keyword">long</span> instance_size OBJC2_UNAVAILABLE; <span class="comment">// 该类的实例变量大小</span></span><br><span class="line"><span class="keyword">struct</span> objc_ivar_list *ivars OBJC2_UNAVAILABLE; <span class="comment">// 该类的成员变量链表</span></span><br><span class="line"><span class="keyword">struct</span> objc_method_list **methodLists OBJC2_UNAVAILABLE; <span class="comment">// 方法定义的链表</span></span><br><span class="line"><span class="keyword">struct</span> objc_cache *cache OBJC2_UNAVAILABLE; <span class="comment">// 方法缓存，对象接到一个消息会根据isa指针查找消息对象，这时会在method		Lists中遍历，如果cache了，常用的方法调用时就能够提高调用的效率。</span></span><br><span class="line"><span class="keyword">struct</span> objc_protocol_list *protocols OBJC2_UNAVAILABLE; <span class="comment">// 协议链表</span></span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line"></span><br><span class="line">&#125; OBJC2_UNAVAILABLE;</span><br></pre></td></tr></table></figure></p>
<p>OC中一个类的对象实例的数据结构（/usr/include/objc/objc.h）:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_class *Class;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Represents an instance of a class.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> objc_object &#123;</span><br><span class="line"></span><br><span class="line">    Class isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// A pointer to an instance of a class.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_object *<span class="keyword">id</span>;</span><br></pre></td></tr></table></figure></p>
<p>向object发送消息时，Runtime库会根据object的isa指针找到这个实例object所属于的类，然后在类的方法列表以及父类方法列表寻找对应的方法运行。id是一个objc_object结构类型的指针，这个类型的对象能够转换成任何一种对象。</p>
<p>然后再来看看消息发送的函数：objc_msgSend函数</p>
<p>在引言中已经对objc_msgSend进行了一点介绍，看起来像是objc_msgSend返回了数据，其实objc_msgSend从不返回数据而是你的方法被调用后返回了数据。下面详细叙述下消息发送步骤：</p>
<p>检测这个 selector 是不是要忽略的。比如 Mac OS X 开发，有了垃圾回收就不理会 retain,release 这些函数了。<br>检测这个 target 是不是 nil 对象。ObjC 的特性是允许对一个 nil 对象执行任何一个方法不会 Crash，因为会被忽略掉。<br>如果上面两个都过了，那就开始查找这个类的 IMP，先从 cache 里面找，完了找得到就跳到对应的函数去执行。<br>如果 cache 找不到就找一下方法分发表。<br>如果分发表找不到就到超类的分发表去找，一直找，直到找到NSObject类为止。<br>如果还找不到就要开始进入动态方法解析了，后面会提到。</p>
<p>后面还有：<br>动态方法解析resolveThisMethodDynamically<br>消息转发forwardingTargetForSelector</p>
<p>详情可参考 <a href="http://www.jianshu.com/p/620022378e97" target="_blank" rel="noopener">http://www.jianshu.com/p/620022378e97</a></p>
<p>###8.什么是method swizzling?<br>Method Swizzling 原理（方法交换？）</p>
<p>在Objective-C中调用一个方法，其实是向一个对象发送消息，查找消息的唯一依据是selector的名字。利用Objective-C的动态特性，可以实现在运行时偷换selector对应的方法实现，达到给方法挂钩的目的。<br>每个类都有一个方法列表，存放着selector的名字和方法实现的映射关系。IMP有点类似函数指针，指向具体的Method实现。</p>
<p><img src="http://img.blog.csdn.net/20150413222619384" alt="方法指向"></p>
<p>我们可以利用 method_exchangeImplementations 来交换2个方法中的IMP，</p>
<p>我们可以利用 class_replaceMethod 来修改类，</p>
<p>我们可以利用 method_setImplementation 来直接设置某个方法的IMP，<br>……<br>归根结底，都是偷换了selector的IMP，如下图所示：<br><img src="http://img.blog.csdn.net/20150413222534550" alt="方法交换"></p>
<p>详情：<a href="http://blog.csdn.net/yiyaaixuexi/article/details/9374411" target="_blank" rel="noopener">http://blog.csdn.net/yiyaaixuexi/article/details/9374411</a></p>
<p>###9.UIView和CALayer是啥关系？</p>
<p> 1.UIView是iOS系统中界面元素的基础，所有的界面元素都继承自它。它本身完全是由CoreAnimation来实现的    （Mac下似乎不是这样）。它真正的绘图部分，是由一个叫CALayer（Core Animation Layer）的类来管理。    UIView本身，更像是一个CALayer的管理器，访问它的跟绘图和跟坐标有关的属性，例如frame，bounds等    等，实际上内部都是在访问它所包含的CALayer的相关属性。</p>
<p>2.UIView有个layer属性，可以返回它的主CALayer实例，UIView有一个layerClass方法，返回主layer所使用的    类，UIView的子类，可以通过重载这个方法，来让UIView使用不同的CALayer来显示，例如通过<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">class</span>) layerClass &#123;</span><br><span class="line">		 <span class="keyword">return</span> ([<span class="built_in">CAEAGLLayer</span> <span class="keyword">class</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使某个UIView的子类使用GL来进行绘制。</p>
<p>3.UIView的CALayer类似UIView的子View树形结构，也可以向它的layer上添加子layer，来完成某些特殊的表    示。例如下面的代码<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">grayCover = [[<span class="built_in">CALayer</span> alloc] init];</span><br><span class="line"></span><br><span class="line">grayCover.backgroundColor = [[[<span class="built_in">UIColor</span> blackColor] colorWithAlphaComponent:<span class="number">0.2</span>] <span class="built_in">CGColor</span>];</span><br><span class="line"></span><br><span class="line">[<span class="keyword">self</span>.layer addSubLayer: grayCover];</span><br></pre></td></tr></table></figure></p>
<p>会在目标View上敷上一层黑色的透明薄膜。</p>
<p>4.UIView的layer树形在系统内部，被系统维护着三份copy（这段理解有点吃不准）。</p>
<ol>
<li>逻辑树，就是代码里可以操纵的，例如更改layer的属性等等就在这一份。</li>
<li>动画树，这是一个中间层，系统正在这一层上更改属性，进行各种渲染操作。</li>
<li>显示树，这棵树的内容是当前正被显示在屏幕上的内容。</li>
</ol>
<p>这三棵树的逻辑结构都是一样的，区别只有各自的属性。</p>
<p>###10. 如何高性能的给UIImageView加个圆角？（不准说layer.cornerRadius!）</p>
<p>我觉得应该是使用Quartz2D直接绘制图片,得把这个看看。<br>步骤：<br>　　a、创建目标大小(cropWidth，cropHeight)的画布。</p>
<p>　　b、使用UIImage的drawInRect方法进行绘制的时候，指定rect为(-x，-y，width，height)。</p>
<p>　　c、从画布中得到裁剪后的图像。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">UIImage</span>*)cropImageWithRect:(<span class="built_in">CGRect</span>)cropRect</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">CGRect</span> drawRect = <span class="built_in">CGRectMake</span>(-cropRect.origin.x , -cropRect.origin.y, <span class="keyword">self</span>.size.width * <span class="keyword">self</span>.scale, <span class="keyword">self</span>.size.height * <span class="keyword">self</span>.scale);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">UIGraphicsBeginImageContext</span>(cropRect.size);</span><br><span class="line">    <span class="built_in">CGContextRef</span> context = <span class="built_in">UIGraphicsGetCurrentContext</span>();</span><br><span class="line">    <span class="built_in">CGContextClearRect</span>(context, <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, cropRect.size.width, cropRect.size.height));</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span> drawInRect:drawRect];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">UIImage</span> *image = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();</span><br><span class="line">    <span class="built_in">UIGraphicsEndImageContext</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> image;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p>
<p>###11. 使用drawRect有什么影响？（这个可深可浅，你至少得用过。。）<br>drawRect方法依赖Core Graphics框架来进行自定义的绘制，但这种方法主要的缺点就是它处理touch事件的方式：每次按钮被点击后，都会用setNeddsDisplay进行强制重绘；而且不止一次，每次单点事件触发两次执行。这样的话从性能的角度来说，对CPU和内存来说都是欠佳的。特别是如果在我们的界面上有多个这样的UIButton实例。</p>
<p>###12. ASIHttpRequest或者SDWebImage里面给UIImageView加载图片的逻辑是什么样的？<br>详见SDWebImage的实现流程 <a href="http://www.cnblogs.com/6duxz/p/4159572.html" target="_blank" rel="noopener">http://www.cnblogs.com/6duxz/p/4159572.html</a></p>
<p>###13. 麻烦你设计个简单的图片内存缓存器（移除策略是一定要说的）<br>图片的内存缓存，可以考虑将图片数据保存到一个数据模型中。所以在程序运行时这个模型都存在内存中。<br>移除策略：释放数据模型对象。</p>
<p>###14. 讲讲你用Instrument优化动画性能的经历吧（别问我什么是Instrument）<br>可以参考<a href="http://www.hrchen.com/2013/05/performance-with-instruments/" target="_blank" rel="noopener">iOS App性能优化</a></p>
<p>###15. loadView是干嘛用的？<br>当你访问一个ViewController的view属性时，如果此时view的值是nil，那么，ViewController就会自动调用loadView这个方法。这个方法就会加载或者创建一个view对象，赋值给view属性。<br>loadView默认做的事情是：如果此ViewController存在一个对应的nib文件，那么就加载这个nib。否则，就创建一个UIView对象。</p>
<p>如果你用Interface Builder来创建界面，那么不应该重载这个方法。</p>
<p>如果你想自己创建view对象，那么可以重载这个方法。此时你需要自己给view属性赋值。你自定义的方法不应该调用super。如果你需要对view做一些其他的定制操作，在viewDidLoad里面去做。</p>
<p>=========================================</p>
<p>根据上面的文档可以知道，有两种情况：</p>
<p>1、如果你用了nib文件，重载这个方法就没有太大意义。因为loadView的作用就是加载nib。如果你重载了这个方法不调用super，那么nib文件就不会被加载。如果调用了super，那么view已经加载完了，你需要做的其他事情在viewDidLoad里面做更合适。</p>
<p>2、如果你没有用nib，这个方法默认就是创建一个空的view对象。如果你想自己控制view对象的创建，例如创建一个特殊尺寸的view，那么可以重载这个方法，自己创建一个UIView对象，然后指定 self.view = myView; 但这种情况也没有必要调用super，因为反正你也不需要在super方法里面创建的view对象。如果调用了super，那么就是浪费了一些资源而已<br>参考：<a href="http://www.cnblogs.com/dyllove98/archive/2013/06/06/3123005.html" target="_blank" rel="noopener">http://www.cnblogs.com/dyllove98/archive/2013/06/06/3123005.html</a></p>
<p>###16. viewWillLayoutSubView你总是知道的。<br>横竖屏切换的时候，系统会响应一些函数，其中 viewWillLayoutSubviews 和 viewDidLayoutSubviews。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewWillLayoutSubviews</span><br><span class="line">&#123;</span><br><span class="line">     [<span class="keyword">self</span> _shouldRotateToOrientation:(<span class="built_in">UIDeviceOrientation</span>)[<span class="built_in">UIApplication</span> sharedApplication].statusBarOrientation];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)_shouldRotateToOrientation:(<span class="built_in">UIDeviceOrientation</span>)orientation &#123;</span><br><span class="line">		<span class="keyword">if</span> (orientation == <span class="built_in">UIDeviceOrientationPortrait</span> ||orientation ==</span><br><span class="line">				<span class="built_in">UIDeviceOrientationPortraitUpsideDown</span>) &#123;</span><br><span class="line">          <span class="comment">// 竖屏</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// 横屏</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过上述一个函数就知道横竖屏切换的接口了。<br>注意：viewWillLayoutSubviews只能用在ViewController里面，在view里面没有响应。</p>
<p>###17. GCD里面有哪几种Queue？你自己建立过串行queue吗？背后的线程模型是什么样的？<br>1.主队列 dispatch_main_queue(); 串行 ，更新UI<br>2.全局队列 dispatch_global_queue(); 并行，四个优先级：background，low，default，high<br>3.自定义队列 dispatch_queue_t queue ; 可以自定义是并行：DISPATCH_QUEUE_CONCURRENT或者串行DISPATCH_QUEUE_SERIAL</p>
<p>###18. 用过coredata或者sqlite吗？读写是分线程的吗？遇到过死锁没？咋解决的？<br>参考：<a href="http://www.jianshu.com/p/95db3fc4deb3" target="_blank" rel="noopener">CoreData与SQLite的线程安全</a></p>
<p>###19. http的post和get啥区别？（区别挺多的，麻烦多说点）<br>1.GET请求的数据会附在URL之后（就是把数据放置在HTTP协议头中），以?分割URL和传输数据，参数之间以&amp;相连，如：login.action?name=hyddd&amp;password=idontknow&amp;verify=%E4%BD%A0%E5%A5%BD。如果数据是英文字母/数字，原样发送，如果是空格，转换为+，如果是中文/其他字符，则直接把字符串用BASE64加密，得出如：%E4%BD%A0%E5%A5%BD，其中％XX中的XX为该符号以16进制表示的ASCII。<br>　　POST把提交的数据则放置在是HTTP包的包体中。</p>
<p>2.”GET方式提交的数据最多只能是1024字节，理论上POST没有限制，可传较大量的数据，IIS4中最大为80KB，IIS5中为100KB”？？！</p>
<p>　　以上这句是我从其他文章转过来的，其实这样说是错误的，不准确的：</p>
<p>　　(1).首先是”GET方式提交的数据最多只能是1024字节”，因为GET是通过URL提交数据，那么GET可提交的数据量就跟URL的长度有直接关系了。而实际上，URL不存在参数上限的问题，HTTP协议规范没有对URL长度进行限制。这个限制是特定的浏览器及服务器对它的限制。IE对URL长度的限制是2083字节(2K+35)。对于其他浏览器，如Netscape、FireFox等，理论上没有长度限制，其限制取决于操作系统的支持。</p>
<p>　　注意这是限制是整个URL长度，而不仅仅是你的参数值数据长度。[见参考资料5]</p>
<p>　　(2).理论上讲，POST是没有大小限制的，HTTP协议规范也没有进行大小限制，说“POST数据量存在80K/100K的大小限制”是不准确的，POST数据是没有限制的，起限制作用的是服务器的处理程序的处理能力。</p>
<p>3.在ASP中，服务端获取GET请求参数用Request.QueryString，获取POST请求参数用Request.Form。在JSP中，用request.getParameter(\”XXXX\”)来获取，虽然jsp中也有request.getQueryString()方法，但使用起来比较麻烦，比如：传一个test.jsp?name=hyddd&amp;password=hyddd，用request.getQueryString()得到的是：name=hyddd&amp;password=hyddd。在PHP中，可以用$_GET和$_POST分别获取GET和POST中的数据，而$_REQUEST则可以获取GET和POST两种请求中的数据。值得注意的是，JSP中使用request和PHP中使用$_REQUEST都会有隐患，这个下次再写个文章总结。</p>
<p>4.POST的安全性要比GET的安全性高。注意：这里所说的安全性和上面GET提到的“安全”不是同个概念。上面“安全”的含义仅仅是不作数据修改，而这里安全的含义是真正的Security的含义，比如：通过GET提交数据，用户名和密码将明文出现在URL上，因为(1)登录页面有可能被浏览器缓存，(2)其他人查看浏览器的历史纪录，那么别人就可以拿到你的账号和密码了，除此之外，使用GET提交数据还可能会造成Cross-site request forgery攻击。</p>
<p>总结一下，Get是向服务器发索取数据的一种请求，而Post是向服务器提交数据的一种请求，在FORM（表单）中，Method默认为”GET”，实质上，GET和POST只是发送机制不同，并不是一个取一个发！</p>
<p>###20. 我知道你大学毕业过后就没接触过算法数据结构了，但是请你一定告诉我什么是Binary search tree? search的时间复杂度是多少？<br>Binary search tree:二叉搜索树。<br>主要由四个方法：（用C语言实现或者Python）<br>1.search：时间复杂度为O(h)，h为树的高度</p>
<p>2.traversal：时间复杂度为O(n)，n为树的总结点数。</p>
<p>3.insert：时间复杂度为O(h)，h为树的高度。</p>
<p>4.delete：最坏情况下，时间复杂度为O(h)+指针的移动开销。</p>
<p>可以看到，二叉搜索树的dictionary operation的时间复杂度与树的高度h相关。所以需要尽可能的降低树的高度，由此引出平衡二叉树Balanced binary tree。它要求左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。这样就可以将搜索树的高度尽量减小。常用算法有红黑树、AVL、Treap、伸展树等。</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    

    </div>

    
  </div>
</article>

  
	<section id="comments" class="comment">
	  <div id="disqus_thread">
	  <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
	  </div>
	</section>

	<script type="text/javascript">
	var disqus_shortname = 'hanangellove';
	(function(){
	  var dsq = document.createElement('script');
	  dsq.type = 'text/javascript';
	  dsq.async = true;
	  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
	  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	}());
	(function(){
	  var dsq = document.createElement('script');
	  dsq.type = 'text/javascript';
	  dsq.async = true;
	  dsq.src = '//' + disqus_shortname + '.disqus.com/count.js';
	  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	}());
	</script>





    </main>

    <footer class="site-footer">
  <p class="site-info">
    <!--
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    </br>
  -->
    
    &copy; 2018 Han Liu
    
  </p>
</footer>
    
  </div>
</div>
</body>
</html>