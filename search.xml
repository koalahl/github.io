<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[简记 - 记录你的生活]]></title>
      <url>http://koalahl.github.io/2017/03/11/%E7%AE%80%E8%AE%B0-%E8%AE%B0%E5%BD%95%E4%BD%A0%E7%9A%84%E7%94%9F%E6%B4%BB/</url>
      <content type="html"><![CDATA[<p>简记 —— 记录你的生活</p>
<p>最简单的文字记录app，带给你清新，简约的气息。</p>
<p>没什么特点的文字编辑app。</p>
<a id="more"></a>
<p>———我是分割线———–<br>特点：<br>(⊙v⊙)嗯，就是简单。</p>
<p>文集分类管理日记。<br>快速创建日记。<br>分享给好友啦。</p>
<p><img src="http://oh51ob42d.bkt.clouddn.com/mynotes-launchpage.png" alt="简记"><br><img src="http://oh51ob42d.bkt.clouddn.com/mynotes-mainpage.png" alt="简记"><br><img src="http://oh51ob42d.bkt.clouddn.com/mynotes-homepage.png" alt="简记"></p>
<p>联系邮箱: hanangellove@gmail.com</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Markdown语法参考]]></title>
      <url>http://koalahl.github.io/2017/01/01/Markdown%E8%AF%AD%E6%B3%95%E5%8F%82%E8%80%83/</url>
      <content type="html"><![CDATA[<p>&lt;&lt; <a href="http://wowubuntu.com" target="_blank" rel="external">访问 Wow!Ubuntu</a></p>
<p><strong>NOTE:</strong> This is Simplelified  Chinese Edition Document of Markdown Syntax. If you are seeking for English Edition Document. Please refer to <a href="http://daringfireball.net/projects/markdown/syntax" target="_blank" rel="external">Markdown: Syntax</a>.</p>
<p><strong>声明：</strong> 这份文档派生(fork)于<a href="http://markdown.tw/" target="_blank" rel="external">繁体中文版</a>，在此基础上进行了繁体转简体工作，并进行了适当的润色。此文档用 Markdown 语法编写，你可以到这里<a href="http://gitcafe.com/riku/Markdown-Syntax-CN/blob/master/syntax.md" target="_blank" rel="external">查看它的源文件</a>。「繁体中文版的原始文件可以<a href="https://github.com/othree/markdown-syntax-zhtw/blob/master/syntax.md" target="_blank" rel="external">查看这里</a> 。」–By @<a href="http://twitter.com/riku" target="_blank" rel="external">riku</a></p>
<p><strong>注：</strong> 本项目托管于 <a href="http://gitcafe.com/riku/Markdown-Syntax-CN/" target="_blank" rel="external">GitCafe</a>上，请通过”派生”和”合并请求”来帮忙改进本项目。</p>
<h1 id="Markdown_语法说明_(简体中文版)_/_(点击查看快速入门)">Markdown 语法说明 (简体中文版) / (<a href="./basic.html">点击查看快速入门</a>)</h1><ul>
<li><a href="#overview">概述</a><ul>
<li><a href="#philosophy">宗旨</a></li>
<li><a href="#html">兼容 HTML</a></li>
<li><a href="#autoescape">特殊字符自动转换</a></li>
</ul>
</li>
<li><a href="#block">区块元素</a><ul>
<li><a href="#p">段落和换行</a></li>
<li><a href="#header">标题</a></li>
<li><a href="#blockquote">区块引用</a></li>
<li><a href="#list">列表</a></li>
<li><a href="#precode">代码区块</a></li>
<li><a href="#hr">分隔线</a></li>
</ul>
</li>
<li><a href="#span">区段元素</a><ul>
<li><a href="#link">链接</a></li>
<li><a href="#em">强调</a></li>
<li><a href="#code">代码</a></li>
<li><a href="#img">图片</a></li>
</ul>
</li>
<li><a href="#misc">其它</a><ul>
<li><a href="#backslash">反斜杠</a></li>
<li><a href="#autolink">自动链接</a></li>
</ul>
</li>
<li><a href="#acknowledgement">感谢</a></li>
<li><a href="#editor">Markdown 免费编辑器</a></li>
</ul>
<hr>
<a id="more"></a>
<h2 id="overview">概述</h2>

<h3 id="philosophy">宗旨</h3>

<p>Markdown 的目标是实现「易读易写」。</p>
<p>可读性，无论如何，都是最重要的。一份使用 Markdown 格式撰写的文件应该可以直接以纯文本发布，并且看起来不会像是由许多标签或是格式指令所构成。Markdown 语法受到一些既有 text-to-HTML 格式的影响，包括 <a href="http://docutils.sourceforge.net/mirror/setext.html" target="_blank" rel="external">Setext</a>、<a href="http://www.aaronsw.com/2002/atx/" target="_blank" rel="external">atx</a>、<a href="http://textism.com/tools/textile/" target="_blank" rel="external">Textile</a>、<a href="http://docutils.sourceforge.net/rst.html" target="_blank" rel="external">reStructuredText</a>、<a href="http://www.triptico.com/software/grutatxt.html" target="_blank" rel="external">Grutatext</a> 和 <a href="http://ettext.taint.org/doc/" target="_blank" rel="external">EtText</a>，而最大灵感来源其实是纯文本电子邮件的格式。</p>
<p>总之， Markdown 的语法全由一些符号所组成，这些符号经过精挑细选，其作用一目了然。比如：在文字两旁加上星号，看起来就像*强调*。Markdown 的列表看起来，嗯，就是列表。Markdown 的区块引用看起来就真的像是引用一段文字，就像你曾在电子邮件中见过的那样。</p>
<h3 id="html">兼容 HTML</h3>

<p>Markdown 语法的目标是：成为一种适用于网络的<em>书写</em>语言。</p>
<p>Markdown 并不是想取代 HTML的地位，甚至接近它。它的语法种类很少，只对应 HTML 标记的一小部分。Markdown 的构想<em>不是</em>要使得 HTML 文档更容易书写。在我看来， HTML 已经很容易写了。Markdown 的理念是，能让文档更容易读、写和随意改。HTML 是一种<em>发布</em>的格式，Markdown 是一种<em>书写</em>的格式。就这样，Markdown 的格式语法只涵盖纯文本可以涵盖的范围。</p>
<p>不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。不需要额外标注这是 HTML 或是 Markdown；只要直接加标签就可以了。</p>
<p>要制约的只有一些 HTML 区块元素――比如 <code>&lt;div&gt;</code>、<code>&lt;table&gt;</code>、<code>&lt;pre&gt;</code>、<code>&lt;p&gt;</code> 等标签，必须在前后加上空行与其它内容区隔开，还要求它们的开始标签与结尾标签不能用制表符或空格来缩进。Markdown 的生成器有足够智能，不会在 HTML 区块标签外加上不必要的 <code>&lt;p&gt;</code> 标签。</p>
<p>例子如下，在 Markdown 文件里加上一段 HTML 表格：</p>
<pre><code>这是一个普通段落。

<span class="tag">&lt;<span class="title">table</span>&gt;</span>
    <span class="tag">&lt;<span class="title">tr</span>&gt;</span>
        <span class="tag">&lt;<span class="title">td</span>&gt;</span>Foo<span class="tag">&lt;/<span class="title">td</span>&gt;</span>
    <span class="tag">&lt;/<span class="title">tr</span>&gt;</span>
<span class="tag">&lt;/<span class="title">table</span>&gt;</span>

这是另一个普通段落。
</code></pre><p>请注意，在 HTML 区块标签间的 Markdown 格式语法将不会被处理。比如，你在 HTML 区块内使用 Markdown 样式的<code>*强调*</code>会没有效果。</p>
<p>HTML 的区段（行内）标签如 <code>&lt;span&gt;</code>、<code>&lt;cite&gt;</code>、<code>&lt;del&gt;</code> 可以在 Markdown 的段落、列表或是标题里随意使用。依照个人习惯，甚至可以不用 Markdown 格式，而直接采用 HTML 标签来格式化。举例说明：如果比较喜欢 HTML 的 <code>&lt;a&gt;</code> 或 <code>&lt;img&gt;</code> 标签，可以直接使用这些标签，而不用 Markdown 提供的链接或是图像标签语法。</p>
<p>和处在 HTML 区块标签间不同，Markdown 语法在 HTML 区段标签间是有效的。</p>
<h3 id="autoescape">特殊字符自动转换</h3>

<p>在 HTML 文件中，有两个字符需要特殊处理： <code>&lt;</code> 和 <code>&amp;</code> 。 <code>&lt;</code> 符号用于起始标签，<code>&amp;</code> 符号则用于标记 HTML 实体，如果你只是想要显示这些字符的原型，你必须要使用实体的形式，像是 <code>&amp;lt;</code> 和 <code>&amp;amp;</code>。</p>
<p><code>&amp;</code> 字符尤其让网络文档编写者受折磨，如果你要打「<code>AT&amp;T</code>」 ，你必须要写成「<code>AT&amp;amp;T</code>」。而网址中的 <code>&amp;</code> 字符也要转换。比如你要链接到：</p>
<pre><code><span class="string">http:</span><span class="comment">//images.google.com/images?num=30&amp;q=larry+bird</span>
</code></pre><p>你必须要把网址转换写为：</p>
<pre><code><span class="string">http:</span><span class="comment">//images.google.com/images?num=30&amp;amp;q=larry+bird</span>
</code></pre><p>才能放到链接标签的 <code>href</code> 属性里。不用说也知道这很容易忽略，这也可能是 HTML 标准检验所检查到的错误中，数量最多的。</p>
<p>Markdown 让你可以自然地书写字符，需要转换的由它来处理好了。如果你使用的 <code>&amp;</code> 字符是 HTML 字符实体的一部分，它会保留原状，否则它会被转换成 <code>&amp;amp</code>;。</p>
<p>所以你如果要在文档中插入一个版权符号 <code>©</code>，你可以这样写：</p>
<pre><code>&amp;<span class="keyword">copy</span>;
</code></pre><p>Markdown 会保留它不动。而若你写：</p>
<pre><code><span class="built_in">AT</span>&amp;T
</code></pre><p>Markdown 就会将它转为：</p>
<pre><code>AT&amp;amp<span class="comment">;T</span>
</code></pre><p>类似的状况也会发生在 <code>&lt;</code> 符号上，因为 Markdown 允许 <a href="#html">兼容 HTML</a> ，如果你是把 <code>&lt;</code> 符号作为 HTML 标签的定界符使用，那 Markdown 也不会对它做任何转换，但是如果你写：</p>
<pre><code><span class="number">4</span> &lt; <span class="number">5</span>
</code></pre><p>Markdown 将会把它转换为：</p>
<pre><code><span class="number">4</span> &amp;lt; <span class="number">5</span>
</code></pre><p>不过需要注意的是，code 范围内，不论是行内还是区块， <code>&lt;</code> 和 <code>&amp;</code> 两个符号都<em>一定</em>会被转换成 HTML 实体，这项特性让你可以很容易地用 Markdown 写 HTML code （和 HTML 相对而言， HTML 语法中，你要把所有的 <code>&lt;</code> 和 <code>&amp;</code> 都转换为 HTML 实体，才能在 HTML 文件里面写出 HTML code。）</p>
<hr>
<h2 id="block">区块元素</h2>


<h3 id="p">段落和换行</h3>

<p>一个 Markdown 段落是由一个或多个连续的文本行组成，它的前后要有一个以上的空行（空行的定义是显示上看起来像是空的，便会被视为空行。比方说，若某一行只包含空格和制表符，则该行也会被视为空行）。普通段落不该用空格或制表符来缩进。</p>
<p>「由一个或多个连续的文本行组成」这句话其实暗示了 Markdown 允许段落内的强迫换行（插入换行符），这个特性和其他大部分的 text-to-HTML 格式不一样（包括 Movable Type 的「Convert Line Breaks」选项），其它的格式会把每个换行符都转成 <code>&lt;br /&gt;</code> 标签。</p>
<p>如果你<em>确实</em>想要依赖 Markdown 来插入 <code>&lt;br /&gt;</code> 标签的话，在插入处先按入两个以上的空格然后回车。</p>
<p>的确，需要多费点事（多加空格）来产生 <code>&lt;br /&gt;</code> ，但是简单地「每个换行都转换为 <code>&lt;br /&gt;</code>」的方法在 Markdown 中并不适合， Markdown 中 email 式的 <a href="#blockquote">区块引用</a> 和多段落的 <a href="#list">列表</a> 在使用换行来排版的时候，不但更好用，还更方便阅读。</p>
<h3 id="header">标题</h3>

<p>Markdown 支持两种标题的语法，类 <a href="http://docutils.sourceforge.net/mirror/setext.html" target="_blank" rel="external">Setext</a> 和类 <a href="http://www.aaronsw.com/2002/atx/" target="_blank" rel="external">atx</a> 形式。</p>
<p>类 Setext 形式是用底线的形式，利用 <code>=</code> （最高阶标题）和 <code>-</code> （第二阶标题），例如：</p>
<pre><code><span class="header">This is an H1
=============</span>

<span class="header">This is an H2
-------------</span>
</code></pre><p>任何数量的 <code>=</code> 和 <code>-</code> 都可以有效果。</p>
<p>类 Atx 形式则是在行首插入 1 到 6 个 <code>#</code> ，对应到标题 1 到 6 阶，例如：</p>
<pre><code><span class="preprocessor"># 这是 H1</span>

<span class="preprocessor">## 这是 H2</span>

<span class="preprocessor">###### 这是 H6</span>
</code></pre><p>你可以选择性地「闭合」类 atx 样式的标题，这纯粹只是美观用的，若是觉得这样看起来比较舒适，你就可以在行尾加上 <code>#</code>，而行尾的 <code>#</code> 数量也不用和开头一样（行首的井字符数量决定标题的阶数）：</p>
<pre><code><span class="preprocessor"># 这是 H1 #</span>

<span class="preprocessor">## 这是 H2 ##</span>

<span class="preprocessor">### 这是 H3 ######</span>
</code></pre><h3 id="blockquote">区块引用 Blockquotes</h3>

<p>Markdown 标记区块引用是使用类似 email 中用 <code>&gt;</code> 的引用方式。如果你还熟悉在 email 信件中的引言部分，你就知道怎么在 Markdown 文件中建立一个区块引用，那会看起来像是你自己先断好行，然后在每行的最前面加上 <code>&gt;</code> ：</p>
<pre><code>&gt; This is a blockquote with two paragraphs. Lo<span class="comment">rem ipsum dolor sit amet,</span>
&gt; consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.
&gt; Vestibulum enim wisi, viverra nec, fringilla <span class="flow">in</span>, laoreet vitae, risus.
&gt;
&gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse
&gt; id sem consectetuer libero luctus adipiscing.
</code></pre><p>Markdown 也允许你偷懒只在整个段落的第一行最前面加上 <code>&gt;</code> ：</p>
<pre><code>&gt; This is a blockquote with two paragraphs. Lo<span class="comment">rem ipsum dolor sit amet,</span>
consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.
Vestibulum enim wisi, viverra nec, fringilla <span class="flow">in</span>, laoreet vitae, risus.

&gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse
id sem consectetuer libero luctus adipiscing.
</code></pre><p>区块引用可以嵌套（例如：引用内的引用），只要根据层次加上不同数量的 <code>&gt;</code> ：</p>
<pre><code>&gt; This <span class="keyword">is</span> <span class="keyword">the</span> <span class="keyword">first</span> level <span class="keyword">of</span> quoting.
&gt;
&gt; &gt; This <span class="keyword">is</span> nested blockquote.
&gt;
&gt; Back <span class="keyword">to</span> <span class="keyword">the</span> <span class="keyword">first</span> level.
</code></pre><p>引用的区块内也可以使用其他的 Markdown 语法，包括标题、列表、代码区块等：</p>
<pre><code>&gt; <span class="comment">## 这是一个标题。</span>
&gt;
&gt; <span class="number">1</span>.   这是第一行列表项。
&gt; <span class="number">2</span>.   这是第二行列表项。
&gt;
&gt; 给出一些例子代码：
&gt;
&gt;     <span class="built_in">return</span> shell_<span class="built_in">exec</span>(<span class="string">"echo <span class="variable">$input</span> | <span class="variable">$markdown_script</span>"</span>);
</code></pre><p>任何像样的文本编辑器都能轻松地建立 email 型的引用。例如在 BBEdit 中，你可以选取文字后然后从选单中选择<em>增加引用阶层</em>。</p>
<h3 id="list">列表</h3>

<p>Markdown 支持有序列表和无序列表。</p>
<p>无序列表使用星号、加号或是减号作为列表标记：</p>
<pre><code><span class="bullet">*   </span>Red
<span class="bullet">*   </span>Green
<span class="bullet">*   </span>Blue
</code></pre><p>效果就是</p>
<ul>
<li>red</li>
<li>green</li>
<li>blue</li>
</ul>
<p>等同于：</p>
<pre><code><span class="bullet">+   </span>Red
<span class="bullet">+   </span>Green
<span class="bullet">+   </span>Blue
</code></pre><p>也等同于：</p>
<pre><code>-<span class="ruby">   <span class="constant">Red</span>
</span>-<span class="ruby">   <span class="constant">Green</span>
</span>-<span class="ruby">   <span class="constant">Blue</span></span>
</code></pre><p>有序列表则使用数字接着一个英文句点：</p>
<pre><code><span class="number">1.</span>  Bird
<span class="number">2.</span>  McHale
<span class="number">3.</span>  Parish
</code></pre><p>很重要的一点是，你在列表标记上使用的数字并不会影响输出的 HTML 结果，上面的列表所产生的 HTML 标记为：</p>
<pre><code><span class="tag">&lt;<span class="title">ol</span>&gt;</span>
<span class="tag">&lt;<span class="title">li</span>&gt;</span>Bird<span class="tag">&lt;/<span class="title">li</span>&gt;</span>
<span class="tag">&lt;<span class="title">li</span>&gt;</span>McHale<span class="tag">&lt;/<span class="title">li</span>&gt;</span>
<span class="tag">&lt;<span class="title">li</span>&gt;</span>Parish<span class="tag">&lt;/<span class="title">li</span>&gt;</span>
<span class="tag">&lt;/<span class="title">ol</span>&gt;</span>
</code></pre><p>如果你的列表标记写成：</p>
<pre><code><span class="number">1.</span>  Bird
<span class="number">1.</span>  McHale
<span class="number">1.</span>  Parish
</code></pre><p>或甚至是：</p>
<pre><code><span class="number">3.</span> Bird
<span class="number">1.</span> McHale
<span class="number">8.</span> Parish
</code></pre><p>你都会得到完全相同的 HTML 输出。重点在于，你可以让 Markdown 文件的列表数字和输出的结果相同，或是你懒一点，你可以完全不用在意数字的正确性。</p>
<p>如果你使用懒惰的写法，建议第一个项目最好还是从 1. 开始，因为 Markdown 未来可能会支持有序列表的 start 属性。</p>
<p>列表项目标记通常是放在最左边，但是其实也可以缩进，最多 3 个空格，项目标记后面则一定要接着至少一个空格或制表符。</p>
<p>要让列表看起来更漂亮，你可以把内容用固定的缩进整理好：</p>
<pre><code>*   Lo<span class="comment">rem ipsum dolor sit amet, consectetuer adipiscing elit.</span>
    Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi,
    viverra nec, fringilla <span class="flow">in</span>, laoreet vitae, risus.
*   Donec sit amet nisl. Aliquam semper ipsum sit amet velit.
    Suspendisse id sem consectetuer libero luctus adipiscing.
</code></pre><p>但是如果你懒，那也行：</p>
<pre><code>*   Lo<span class="comment">rem ipsum dolor sit amet, consectetuer adipiscing elit.</span>
Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi,
viverra nec, fringilla <span class="flow">in</span>, laoreet vitae, risus.
*   Donec sit amet nisl. Aliquam semper ipsum sit amet velit.
Suspendisse id sem consectetuer libero luctus adipiscing.
</code></pre><p>如果列表项目间用空行分开，在输出 HTML 时 Markdown 就会将项目内容用 <code>&lt;p&gt;</code><br>标签包起来，举例来说：</p>
<pre><code><span class="bullet">*   </span>Bird
<span class="bullet">*   </span>Magic
</code></pre><p>会被转换为：</p>
<pre><code><span class="tag">&lt;<span class="title">ul</span>&gt;</span>
<span class="tag">&lt;<span class="title">li</span>&gt;</span>Bird<span class="tag">&lt;/<span class="title">li</span>&gt;</span>
<span class="tag">&lt;<span class="title">li</span>&gt;</span>Magic<span class="tag">&lt;/<span class="title">li</span>&gt;</span>
<span class="tag">&lt;/<span class="title">ul</span>&gt;</span>
</code></pre><p>但是这个：</p>
<pre><code><span class="bullet">*   </span>Bird

<span class="bullet">*   </span>Magic
</code></pre><p>会被转换为：</p>
<pre><code><span class="tag">&lt;<span class="title">ul</span>&gt;</span>
<span class="tag">&lt;<span class="title">li</span>&gt;</span><span class="tag">&lt;<span class="title">p</span>&gt;</span>Bird<span class="tag">&lt;/<span class="title">p</span>&gt;</span><span class="tag">&lt;/<span class="title">li</span>&gt;</span>
<span class="tag">&lt;<span class="title">li</span>&gt;</span><span class="tag">&lt;<span class="title">p</span>&gt;</span>Magic<span class="tag">&lt;/<span class="title">p</span>&gt;</span><span class="tag">&lt;/<span class="title">li</span>&gt;</span>
<span class="tag">&lt;/<span class="title">ul</span>&gt;</span>
</code></pre><p>列表项目可以包含多个段落，每个项目下的段落都必须缩进 4 个空格或是 1 个制表符：</p>
<pre><code><span class="number">1</span>.  This is a list item with two paragraphs. Lo<span class="comment">rem ipsum dolor</span>
    sit amet, consectetuer adipiscing elit. Aliquam hendrerit
    mi posuere lectus.

    Vestibulum enim wisi, viverra nec, fringilla <span class="flow">in</span>, laoreet
    vitae, risus. Donec sit amet nisl. Aliquam semper ipsum
    sit amet velit.

<span class="number">2</span>.  Suspendisse id sem consectetuer libero luctus adipiscing.
</code></pre><p>如果你每行都有缩进，看起来会看好很多，当然，再次地，如果你很懒惰，Markdown 也允许：</p>
<pre><code>*   This <span class="keyword">is</span> a <span class="type">list</span> <span class="property">item</span> <span class="keyword">with</span> two <span class="property">paragraphs</span>.

    This <span class="keyword">is</span> <span class="keyword">the</span> <span class="keyword">second</span> <span class="property">paragraph</span> <span class="keyword">in</span> <span class="keyword">the</span> <span class="type">list</span> <span class="property">item</span>. You're
only required <span class="keyword">to</span> indent <span class="keyword">the</span> <span class="keyword">first</span> line. Lorem ipsum dolor
sit amet, consectetuer adipiscing elit.

*   Another <span class="property">item</span> <span class="keyword">in</span> <span class="keyword">the</span> same <span class="type">list</span>.
</code></pre><p>如果要在列表项目内放进引用，那 <code>&gt;</code> 就需要缩进：</p>
<pre><code>*   A <span class="type">list</span> <span class="property">item</span> <span class="keyword">with</span> a blockquote:

    &gt; This <span class="keyword">is</span> a blockquote
    &gt; inside a <span class="type">list</span> <span class="property">item</span>.
</code></pre><p>如果要放代码区块的话，该区块就需要缩进<em>两次</em>，也就是 8 个空格或是 2 个制表符：</p>
<pre><code><span class="keyword">*</span>   一列表项包含一个列表区块：

        <span class="variable">&lt;代码写在这&gt;</span>
</code></pre><p>当然，项目列表很可能会不小心产生，像是下面这样的写法：</p>
<pre><code><span class="number">1986</span>. What <span class="tag">a</span> great season.
</code></pre><p>换句话说，也就是在行首出现<em>数字-句点-空白</em>，要避免这样的状况，你可以在句点前面加上反斜杠。</p>
<pre><code><span class="number">1986</span>\. What <span class="tag">a</span> great season.
</code></pre><h3 id="precode">代码区块</h3>

<p>和程序相关的写作或是标签语言原始码通常会有已经排版好的代码区块，通常这些区块我们并不希望它以一般段落文件的方式去排版，而是照原来的样子显示，Markdown 会用 <code>&lt;pre&gt;</code> 和 <code>&lt;code&gt;</code> 标签来把代码区块包起来。</p>
<p>要在 Markdown 中建立代码区块很简单，只要简单地缩进 4 个空格或是 1 个制表符就可以，例如，下面的输入：</p>
<pre><code>这是一个普通段落：

    这是一个代码区块。
</code></pre><p>Markdown 会转换成：</p>
<pre><code><span class="tag">&lt;<span class="title">p</span>&gt;</span>这是一个普通段落：<span class="tag">&lt;/<span class="title">p</span>&gt;</span>

<span class="tag">&lt;<span class="title">pre</span>&gt;</span><span class="tag">&lt;<span class="title">code</span>&gt;</span>这是一个代码区块。
<span class="tag">&lt;/<span class="title">code</span>&gt;</span><span class="tag">&lt;/<span class="title">pre</span>&gt;</span>
</code></pre><p>这个每行一阶的缩进（4 个空格或是 1 个制表符），都会被移除，例如：</p>
<pre><code>Here <span class="keyword">is</span> an example <span class="keyword">of</span> <span class="constant">AppleScript</span>:

    <span class="keyword">tell</span> <span class="type">application</span> <span class="string">"Foo"</span>
        <span class="command">beep</span>
    <span class="keyword">end</span> <span class="keyword">tell</span>
</code></pre><p>会被转换为：</p>
<pre><code>&lt;p&gt;Here <span class="keyword">is</span> an example <span class="keyword">of</span> <span class="constant">AppleScript</span>:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;<span class="keyword">tell</span> <span class="type">application</span> <span class="string">"Foo"</span>
    <span class="command">beep</span>
<span class="keyword">end</span> <span class="keyword">tell</span>
&lt;/code&gt;&lt;/pre&gt;
</code></pre><p>一个代码区块会一直持续到没有缩进的那一行（或是文件结尾）。</p>
<p>在代码区块里面， <code>&amp;</code> 、 <code>&lt;</code> 和 <code>&gt;</code> 会自动转成 HTML 实体，这样的方式让你非常容易使用 Markdown 插入范例用的 HTML 原始码，只需要复制贴上，再加上缩进就可以了，剩下的 Markdown 都会帮你处理，例如：</p>
<pre><code>&lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"footer"</span>&gt;
    &amp;<span class="keyword">copy</span>; <span class="number">2004</span> Foo Corporation
&lt;/<span class="keyword">div</span>&gt;
</code></pre><p>会被转换为：</p>
<pre><code>&lt;<span class="keyword">pre</span>&gt;&lt;code&gt;&amp;<span class="keyword">lt</span>;div class=<span class="string">"footer"</span>&amp;gt;
    &amp;amp;<span class="built_in">copy</span>; <span class="number">2004</span> Foo Corporation
&amp;<span class="keyword">lt</span>;/div&amp;gt;
&lt;/code&gt;&lt;/<span class="keyword">pre</span>&gt;
</code></pre><p>代码区块中，一般的 Markdown 语法不会被转换，像是星号便只是星号，这表示你可以很容易地以 Markdown 语法撰写 Markdown 语法相关的文件。</p>
<h3 id="hr">分隔线</h3>

<p>你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：</p>
<pre><code><span class="keyword">*</span> <span class="keyword">*</span> <span class="keyword">*</span>

<span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span>

<span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span><span class="keyword">*</span>

- - -

---------------------------------------
</code></pre><hr>
<h2 id="span">区段元素</h2>

<h3 id="link">链接</h3>

<p>Markdown 支持两种形式的链接语法： <em>行内式</em>和<em>参考式</em>两种形式。</p>
<p>不管是哪一种，链接文字都是用 [方括号] 来标记。</p>
<p>要建立一个<em>行内式</em>的链接，只要在方块括号后面紧接着圆括号并插入网址链接即可，如果你还想要加上链接的 title 文字，只要在网址后面，用双引号把 title 文字包起来即可，例如：</p>
<pre><code>This is [<span class="link_label">an example</span>](<span class="link_url">http://example.com/ "Title"</span>) inline link.

[<span class="link_label">This link</span>](<span class="link_url">http://example.net/</span>) has no title attribute.
</code></pre><p>会产生：</p>
<pre><code><span class="tag">&lt;<span class="title">p</span>&gt;</span>This is <span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"http://example.com/"</span> <span class="attribute">title</span>=<span class="value">"Title"</span>&gt;</span>
an example<span class="tag">&lt;/<span class="title">a</span>&gt;</span> inline link.<span class="tag">&lt;/<span class="title">p</span>&gt;</span>

<span class="tag">&lt;<span class="title">p</span>&gt;</span><span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"http://example.net/"</span>&gt;</span>This link<span class="tag">&lt;/<span class="title">a</span>&gt;</span> has no
title attribute.<span class="tag">&lt;/<span class="title">p</span>&gt;</span>
</code></pre><p>如果你是要链接到同样主机的资源，你可以使用相对路径：</p>
<pre><code>See my [<span class="link_label">About</span>](<span class="link_url">/about/</span>) page for details.
</code></pre><p><em>参考式</em>的链接是在链接文字的括号后面再接上另一个方括号，而在第二个方括号里面要填入用以辨识链接的标记：</p>
<pre><code>This is [<span class="link_label">an example</span>][<span class="link_reference">id</span>] reference-style link.
</code></pre><p>你也可以选择性地在两个方括号中间加上一个空格：</p>
<pre><code>This <span class="keyword">is</span> [an example] [<span class="property">id</span>] <span class="keyword">reference</span>-style link.
</code></pre><p>接着，在文件的任意处，你可以把这个标记的链接内容定义出来：</p>
<pre><code>[<span class="link_reference">id</span>]:<span class="link_url"> http://example.com/  "Optional Title Here"</span>
</code></pre><p>链接内容定义的形式为：</p>
<ul>
<li>方括号（前面可以选择性地加上至多三个空格来缩进），里面输入链接文字</li>
<li>接着一个冒号</li>
<li>接着一个以上的空格或制表符</li>
<li>接着链接的网址</li>
<li>选择性地接着 title 内容，可以用单引号、双引号或是括弧包着</li>
</ul>
<p>下面这三种链接的定义都是相同：</p>
<pre><code>[<span class="link_reference">foo</span>]:<span class="link_url"> http://example.com/  "Optional Title Here"</span>
[<span class="link_reference">foo</span>]:<span class="link_url"> http://example.com/  'Optional Title Here'</span>
[<span class="link_reference">foo</span>]:<span class="link_url"> http://example.com/  (Optional Title Here)</span>
</code></pre><p><strong>请注意：</strong>有一个已知的问题是 Markdown.pl 1.0.1 会忽略单引号包起来的链接 title。</p>
<p>链接网址也可以用尖括号包起来：</p>
<pre><code>[<span class="link_reference">id</span>]:<span class="link_url"> &lt;http://example.com/&gt;  "Optional Title Here"</span>
</code></pre><p>你也可以把 title 属性放到下一行，也可以加一些缩进，若网址太长的话，这样会比较好看：</p>
<pre><code>[id]<span class="symbol">:</span> <span class="symbol">http:</span>/<span class="regexp">/example.com/longish</span><span class="regexp">/path/to</span><span class="regexp">/resource/here</span>
    <span class="string">"Optional Title Here"</span>
</code></pre><p>网址定义只有在产生链接的时候用到，并不会直接出现在文件之中。</p>
<p>链接辨别标签可以有字母、数字、空白和标点符号，但是并<em>不</em>区分大小写，因此下面两个链接是一样的：</p>
<pre><code>[<span class="link_label">link text</span>][<span class="link_reference">a</span>]
[<span class="link_label">link text</span>][<span class="link_reference">A</span>]
</code></pre><p><em>隐式链接标记</em>功能让你可以省略指定链接标记，这种情形下，链接标记会视为等同于链接文字，要用隐式链接标记只要在链接文字后面加上一个空的方括号，如果你要让 “Google” 链接到 google.com，你可以简化成：</p>
<pre><code>[<span class="link_label">Google</span>][<span class="link_reference"></span>]
</code></pre><p>然后定义链接内容：</p>
<pre><code>[<span class="link_reference">Google</span>]:<span class="link_url"> http://google.com/</span>
</code></pre><p>由于链接文字可能包含空白，所以这种简化型的标记内也许包含多个单词：</p>
<pre><code>Visit [<span class="link_label">Daring Fireball</span>][<span class="link_reference"></span>] for more information.
</code></pre><p>然后接着定义链接：</p>
<pre><code>[<span class="link_reference">Daring Fireball</span>]:<span class="link_url"> http://daringfireball.net/</span>
</code></pre><p>链接的定义可以放在文件中的任何一个地方，我比较偏好直接放在链接出现段落的后面，你也可以把它放在文件最后面，就像是注解一样。</p>
<p>下面是一个参考式链接的范例：</p>
<pre><code><span class="name">I</span> <span class="atom">get</span> <span class="number">10</span> <span class="atom">times</span> <span class="atom">more</span> <span class="atom">traffic</span> <span class="atom">from</span> [<span class="name">Google</span>] [<span class="number">1</span>] <span class="atom">than</span> <span class="atom">from</span>
[<span class="name">Yahoo</span>] [<span class="number">2</span>] <span class="atom">or</span> [<span class="name">MSN</span>] [<span class="number">3</span>].

  [<span class="number">1</span>]: <span class="atom">http</span>://<span class="atom">google</span>.<span class="atom">com</span>/        <span class="string">"Google"</span>
  [<span class="number">2</span>]: <span class="atom">http</span>://<span class="atom">search</span>.<span class="atom">yahoo</span>.<span class="atom">com</span>/  <span class="string">"Yahoo Search"</span>
  [<span class="number">3</span>]: <span class="atom">http</span>://<span class="atom">search</span>.<span class="atom">msn</span>.<span class="atom">com</span>/    <span class="string">"MSN Search"</span>
</code></pre><p>如果改成用链接名称的方式写：</p>
<pre><code>I get 10 times more traffic from [<span class="link_label">Google</span>][<span class="link_reference"></span>] than from
[<span class="link_label">Yahoo</span>][<span class="link_reference"></span>] or [<span class="link_label">MSN</span>][<span class="link_reference"></span>].

  [google]: http://google.com/        "Google"
  [yahoo]:  http://search.yahoo.com/  "Yahoo Search"
  [msn]:    http://search.msn.com/    "MSN Search"
</code></pre><p>上面两种写法都会产生下面的 HTML。</p>
<pre><code>&lt;p&gt;I <span class="built_in">get</span> <span class="number">10</span> times more traffic <span class="built_in">from</span> &lt;<span class="operator">a</span> href=<span class="string">"http://google.com/"</span>
title=<span class="string">"Google"</span>&gt;Google&lt;/<span class="operator">a</span>&gt; than <span class="built_in">from</span>
&lt;<span class="operator">a</span> href=<span class="string">"http://search.yahoo.com/"</span> title=<span class="string">"Yahoo Search"</span>&gt;Yahoo&lt;/<span class="operator">a</span>&gt;
<span class="operator">or</span> &lt;<span class="operator">a</span> href=<span class="string">"http://search.msn.com/"</span> title=<span class="string">"MSN Search"</span>&gt;MSN&lt;/<span class="operator">a</span>&gt;.&lt;/p&gt;
</code></pre><p>下面是用行内式写的同样一段内容的 Markdown 文件，提供作为比较之用：</p>
<pre><code>I get 10 times more traffic from [<span class="link_label">Google</span>](<span class="link_url">http://google.com/ "Google"</span>)
than from [<span class="link_label">Yahoo</span>](<span class="link_url">http://search.yahoo.com/ "Yahoo Search"</span>) or
[<span class="link_label">MSN</span>](<span class="link_url">http://search.msn.com/ "MSN Search"</span>).
</code></pre><p>参考式的链接其实重点不在于它比较好写，而是它比较好读，比较一下上面的范例，使用参考式的文章本身只有 81 个字符，但是用行内形式的却会增加到 176 个字元，如果是用纯 HTML 格式来写，会有 234 个字元，在 HTML 格式中，标签比文本还要多。</p>
<p>使用 Markdown 的参考式链接，可以让文件更像是浏览器最后产生的结果，让你可以把一些标记相关的元数据移到段落文字之外，你就可以增加链接而不让文章的阅读感觉被打断。</p>
<h3 id="em">强调</h3>

<p>Markdown 使用星号（<code>*</code>）和底线（<code>_</code>）作为标记强调字词的符号，被 <code>*</code> 或 <code>_</code> 包围的字词会被转成用 <code>&lt;em&gt;</code> 标签包围，用两个 <code>*</code> 或 <code>_</code> 包起来的话，则会被转成 <code>&lt;strong&gt;</code>，例如：</p>
<pre><code><span class="keyword">*</span>single asterisks<span class="keyword">*</span>

_single underscores_

<span class="keyword">*</span><span class="keyword">*</span>double asterisks<span class="keyword">*</span><span class="keyword">*</span>

__double underscores__
</code></pre><p>会转成：</p>
<pre><code><span class="tag">&lt;<span class="title">em</span>&gt;</span>single asterisks<span class="tag">&lt;/<span class="title">em</span>&gt;</span>

<span class="tag">&lt;<span class="title">em</span>&gt;</span>single underscores<span class="tag">&lt;/<span class="title">em</span>&gt;</span>

<span class="tag">&lt;<span class="title">strong</span>&gt;</span>double asterisks<span class="tag">&lt;/<span class="title">strong</span>&gt;</span>

<span class="tag">&lt;<span class="title">strong</span>&gt;</span>double underscores<span class="tag">&lt;/<span class="title">strong</span>&gt;</span>
</code></pre><p>你可以随便用你喜欢的样式，唯一的限制是，你用什么符号开启标签，就要用什么符号结束。</p>
<p>强调也可以直接插在文字中间：</p>
<pre><code>un<span class="keyword">*</span>frigging<span class="keyword">*</span>believable
</code></pre><p>但是<strong>如果你的 <code>*</code> 和 <code>_</code> 两边都有空白的话，它们就只会被当成普通的符号</strong>。</p>
<p>如果要在文字前后直接插入普通的星号或底线，你可以用反斜线：</p>
<pre><code><span class="string">\*this</span> text <span class="keyword">is</span> surrounded <span class="keyword">by</span> literal asterisks<span class="string">\*</span>
</code></pre><h3 id="code">代码</h3>

<p>如果要标记一小段行内代码，你可以用反引号把它包起来（<code>` </code>），例如：</p>
<pre><code><span class="keyword">Use</span> the `printf()` <span class="function"><span class="keyword">function</span>.</span>
</code></pre><p>会产生：</p>
<pre><code><span class="tag">&lt;<span class="title">p</span>&gt;</span>Use the <span class="tag">&lt;<span class="title">code</span>&gt;</span>printf()<span class="tag">&lt;/<span class="title">code</span>&gt;</span> function.<span class="tag">&lt;/<span class="title">p</span>&gt;</span>
</code></pre><p>如果要在代码区段内插入反引号，你可以用多个反引号来开启和结束代码区段：</p>
<pre><code><span class="escape">``</span>There is <span class="literal">a</span> literal backtick (<span class="escape">`)</span> here.<span class="escape">``</span>
</code></pre><p>这段语法会产生：</p>
<pre><code><span class="tag">&lt;<span class="title">p</span>&gt;</span><span class="tag">&lt;<span class="title">code</span>&gt;</span>There is a literal backtick (`) here.<span class="tag">&lt;/<span class="title">code</span>&gt;</span><span class="tag">&lt;/<span class="title">p</span>&gt;</span>
</code></pre><p>代码区段的起始和结束端都可以放入一个空白，起始端后面一个，结束端前面一个，这样你就可以在区段的一开始就插入反引号：</p>
<pre><code>A single backtick <span class="keyword">in</span> <span class="tag">a</span> <span class="tag">code</span> <span class="tag">span</span>: `` ` ``

A backtick-delimited string <span class="keyword">in</span> <span class="tag">a</span> <span class="tag">code</span> <span class="tag">span</span>: `` `foo` ``
</code></pre><p>会产生：</p>
<pre><code>&lt;p&gt;A single backtick <span class="keyword">in</span> <span class="tag">a</span> <span class="tag">code</span> <span class="tag">span</span>: &lt;code&gt;`&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;A backtick-delimited string <span class="keyword">in</span> <span class="tag">a</span> <span class="tag">code</span> <span class="tag">span</span>: &lt;code&gt;`foo`&lt;/code&gt;&lt;/p&gt;
</code></pre><p>在代码区段内，<code>&amp;</code> 和尖括号<strong>都</strong>会被自动地转成 HTML 实体，这使得插入 HTML 原始码变得很容易，Markdown 会把下面这段：</p>
<pre><code>Please don't <span class="operator"><span class="keyword">use</span> <span class="keyword">any</span> <span class="string">`&lt;blink&gt;`</span> tags.</span>
</code></pre><p>转为：</p>
<pre><code><span class="variable">&lt;p&gt;</span>Please don't use <span class="literal">any</span> <span class="variable">&lt;code&gt;</span>&amp;lt;blink&amp;gt;<span class="variable">&lt;/code&gt;</span> tags.<span class="variable">&lt;/p&gt;</span>
</code></pre><p>你也可以这样写：</p>
<pre><code>`<span class="javascript">&amp;#<span class="number">8212</span>;</span>` <span class="keyword">is</span> the decimal-encoded equivalent <span class="keyword">of</span> `<span class="javascript">&amp;mdash;</span>`.
</code></pre><p>以产生：</p>
<pre><code><span class="variable">&lt;p&gt;</span><span class="variable">&lt;code&gt;</span>&amp;amp;<span class="comment">#8212;&lt;/code&gt; is the decimal-encoded</span>
equivalent of <span class="variable">&lt;code&gt;</span>&amp;amp;mdash;<span class="variable">&lt;/code&gt;</span>.<span class="variable">&lt;/p&gt;</span>
</code></pre><h3 id="img">图片</h3>

<p>很明显地，要在纯文字应用中设计一个「自然」的语法来插入图片是有一定难度的。</p>
<p>Markdown 使用一种和链接很相似的语法来标记图片，同样也允许两种样式： <em>行内式</em>和<em>参考式</em>。</p>
<p>行内式的图片语法看起来像是：</p>
<pre><code>![<span class="link_label">Alt text</span>](<span class="link_url">/path/to/img.jpg</span>)

![<span class="link_label">Alt text</span>](<span class="link_url">/path/to/img.jpg "Optional title"</span>)
</code></pre><p>详细叙述如下：</p>
<ul>
<li>一个惊叹号 <code>!</code></li>
<li>接着一个方括号，里面放上图片的替代文字</li>
<li>接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上<br>选择性的 ‘title’ 文字。</li>
</ul>
<p>参考式的图片语法则长得像这样：</p>
<pre><code>![<span class="link_label">Alt text</span>][<span class="link_reference">id</span>]
</code></pre><p>「id」是图片参考的名称，图片参考的定义方式则和链接参考一样：</p>
<pre><code>[<span class="property">id</span>]: url/<span class="keyword">to</span>/image  <span class="string">"Optional title attribute"</span>
</code></pre><p>到目前为止， Markdown 还没有办法指定图片的宽高，如果你需要的话，你可以使用普通的 <code>&lt;img&gt;</code> 标签。</p>
<hr>
<h2 id="misc">其它</h2>

<h3 id="autolink">自动链接</h3>

<p>Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用尖括号包起来， Markdown 就会自动把它转成链接。一般网址的链接文字就和链接地址一样，例如：</p>
<pre><code>&lt;<span class="string">http:</span><span class="comment">//example.com/&gt;</span>
</code></pre><p>Markdown 会转为：</p>
<pre><code>&lt;<span class="tag">a</span> href=<span class="string">"http://example.com/"</span>&gt;http:<span class="comment">//example.com/&lt;/a&gt;</span>
</code></pre><p>邮址的自动链接也很类似，只是 Markdown 会先做一个编码转换的过程，把文字字符转成 16 进位码的 HTML 实体，这样的格式可以糊弄一些不好的邮址收集机器人，例如：</p>
<pre><code><span class="tag">&lt;address@example.com&gt;</span>
</code></pre><p>Markdown 会转成：</p>
<pre><code>&lt;a href=<span class="string">"&amp;#x6D;&amp;#x61;i&amp;#x6C;&amp;#x74;&amp;#x6F;:&amp;#x61;&amp;#x64;&amp;#x64;&amp;#x72;&amp;#x65;
&amp;#115;&amp;#115;&amp;#64;&amp;#101;&amp;#120;&amp;#x61;&amp;#109;&amp;#x70;&amp;#x6C;e&amp;#x2E;&amp;#99;&amp;#111;
&amp;#109;"</span>&gt;&amp;<span class="title">#x61</span>;&amp;<span class="title">#x64</span>;&amp;<span class="title">#x64</span>;&amp;<span class="title">#x72</span>;&amp;<span class="title">#x65</span>;&amp;<span class="title">#115</span>;&amp;<span class="title">#115</span>;&amp;<span class="title">#64</span>;&amp;<span class="title">#101</span>;&amp;<span class="title">#120</span>;&amp;<span class="title">#x61</span>;
&amp;<span class="title">#109</span>;&amp;<span class="title">#x70</span>;&amp;<span class="title">#x6</span>C;e&amp;<span class="title">#x2</span>E;&amp;<span class="title">#99</span>;&amp;<span class="title">#111</span>;&amp;<span class="title">#109</span>;&lt;/a&gt;
</code></pre><p>在浏览器里面，这段字串（其实是 <code>&lt;a href=&quot;mailto:address@example.com&quot;&gt;address@example.com&lt;/a&gt;</code>）会变成一个可以点击的「address@example.com」链接。</p>
<p>（这种作法虽然可以糊弄不少的机器人，但并不能全部挡下来，不过总比什么都不做好些。不管怎样，公开你的信箱终究会引来广告信件的。）</p>
<h3 id="backslash">反斜杠</h3>

<p>Markdown 可以利用反斜杠来插入一些在语法中有其它意义的符号，例如：如果你想要用星号加在文字旁边的方式来做出强调效果（但不用 <code>&lt;em&gt;</code> 标签），你可以在星号的前面加上反斜杠：</p>
<pre><code>\<span class="keyword">*</span>literal asterisks\<span class="keyword">*</span>
</code></pre><p>Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：</p>
<pre><code>\   反斜线
`   反引号
<span class="bullet">*   </span>星号
_   底线
{}  花括号
[]  方括号
()  括弧
<span class="header">#   井字号</span>
<span class="bullet">+   </span>加号
<span class="bullet">-   </span>减号
.   英文句点
!   惊叹号
</code></pre><h2 id="acknowledgement">感谢</h2>

<p>感谢 <a href="https://twitter.com/#!/leafy7382" target="_blank" rel="external">leafy7382</a> 协助翻译，<a href="http://iamhlb.com/" target="_blank" rel="external">hlb</a>、<a href="http://twitter.com/randylien" target="_blank" rel="external">Randylien</a> 帮忙润稿，<a href="https://twitter.com/#!/ethantw" target="_blank" rel="external">ethantw</a> 的<a href="http://ethantw.net/projects/han/" target="_blank" rel="external">汉字标准格式・CSS Reset</a>， <a href="http://kidwm.net/" target="_blank" rel="external">WM</a> 回报文字错误。</p>
<p>感谢 <a href="https://github.com/fenprace" target="_blank" rel="external">fenprace</a>，<a href="https://github.com/addv" target="_blank" rel="external">addv</a>。</p>
<hr>
<h2 id="editor">Markdown 免费编辑器</h2>

<p>Windows 平台</p>
<ul>
<li><a href="http://markdownpad.com/" target="_blank" rel="external">MarkdownPad</a></li>
<li><a href="http://code52.org/DownmarkerWPF/" target="_blank" rel="external">MarkPad</a></li>
</ul>
<p>Linux 平台</p>
<ul>
<li><a href="http://sourceforge.net/p/retext/home/ReText/" target="_blank" rel="external">ReText</a></li>
</ul>
<p>Mac 平台</p>
<ul>
<li><a href="http://mouapp.com/" target="_blank" rel="external">Mou</a></li>
</ul>
<p>在线编辑器</p>
<ul>
<li><a href="http://markable.in/" target="_blank" rel="external">Markable.in</a></li>
<li><a href="http://dillinger.io/" target="_blank" rel="external">Dillinger.io</a></li>
</ul>
<p>浏览器插件</p>
<ul>
<li><a href="https://chrome.google.com/webstore/detail/oknndfeeopgpibecfjljjfanledpbkog" target="_blank" rel="external">MaDe</a> (Chrome)</li>
</ul>
<p>高级应用</p>
<ul>
<li><a href="http://www.sublimetext.com/2" target="_blank" rel="external">Sublime Text 2</a> + <a href="http://ttscoff.github.com/MarkdownEditing/" target="_blank" rel="external">MarkdownEditing</a> / <a href="http://lucifr.com/2012/07/12/markdownediting-for-sublime-text-2/" target="_blank" rel="external">教程</a></li>
</ul>
<p>*** 如有更好的 Markdown 免费编辑器推荐，请到<a href="https://gitcafe.com/riku/Markdown-Syntax-CN/tickets/1" target="_blank" rel="external">这里反馈</a>，谢谢！</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[iOS开发技术栈]]></title>
      <url>http://koalahl.github.io/2016/12/12/iOS%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF%E6%A0%88/</url>
      <content type="html"><![CDATA[<p>提醒自己：</p>
<p></p><h3 id="objc">Objective-C</h3><br>• objective-c语言基础<br>• library,framework的制作<br>• Runtime编程<br>• LLVM原理和调优<p></p>
<a id="more"></a>
<p></p><h3 id="OS">操作系统</h3><br>• iOS内存管理和调优<br>• iOS的文件系统和沙盒机制<br>• iOS多线程编程（Thread,GCD,NSOperation）<br>• iOS网络和服务器编程（NSURLConnection,NSURLSession）<br>• iOS系统的各种安全机制<p></p>
<p></p><h3 id="netpro">网络编程</h3><br>• iOS网络发送机制调整和优化（NSURLSession）<br>• Socket编程<br>•网络传输中的各种保障<br>•对传输协议的调整优化<p></p>
<p></p><h3 id="sql">数据库&amp;持久化方案</h3><br>• 常规持久化方案（Keychain,NSUserDefaults,Sqlite,CoreData）<br>•数据库的使用和设计（Sqlite）<br>•数据结构优化，Sql调优<p></p>
<p></p><h3 id="graphic">图形图像编程</h3><br>• UIKit,Core Animation和Core Text的绘制<br>• Core Graphics, Quartz 2D, Media Player, AV Foundation<br>• OpenGL ES, GLKit, SpriteKit, SceneKit, Metal<p></p>
<p></p><h3 id="alog">数据结构 &amp; 算法</h3><br>•基本的算法和数据结构（排序搜索算法, 数组, 队列）<br>•较复杂数据结构的灵活应用（二叉树, 图等）<br>•复杂的专项算法（图像识别算法, 拓扑定位等等）<p></p>
<p></p><h3 id="safe">安全方案</h3><br>• 本地数据存储安全（Keychain）<br>•授权和身份验证<br>•传输安全（对称, 非对称, SSL）<br>• App代码安全<p></p>
<p></p><h3 id="bussiness">业务能力</h3><br>•一般性业务功能需求分析及实现<br>•重要业务模块的需求分析及实现<br>•中小规模产品的架构，系统设计和实现<br>•大规模产品或产品线的架构，系统设计和实现<br>•平台级产品的架构，系统设计和实现<p></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[iOS使用flow.ci进行持续集成]]></title>
      <url>http://koalahl.github.io/2016/12/07/iOS%E4%BD%BF%E7%94%A8flow-ci%E8%BF%9B%E8%A1%8C%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/</url>
      <content type="html"><![CDATA[<a id="more"></a>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[iOS自动打包脚本]]></title>
      <url>http://koalahl.github.io/2016/11/30/iOS%E8%87%AA%E5%8A%A8%E6%89%93%E5%8C%85%E8%84%9A%E6%9C%AC/</url>
      <content type="html"><![CDATA[<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash&#10;#Author hanliu&#10;&#10;#Global declaration&#10;SCHEMENAME=&#34;hongmeng&#34;&#10;#if use git&#10;#BRANCHNAME = master&#10;&#10;DATE=`date &#34;+%Y%m%d&#34;`&#10;SOURCEPATH=$(CD &#34;$(dirname $0)&#34; &#38;&#38; pwd)&#10;BUILDPATH=$(dirname $(dirname $SOURCEPATH))/AutoBuildIPA&#10;BUILDAPPPATH=$BUILDPATH/Build/Products/Debug-iphoneos&#10;IPAPATH=$(dirname $(dirname $SOURCEPATH))/IPA&#10;IPANAME=$SCHEMENAME_$DATE.ipa&#10;&#10;echo &#34;DATE is &#34; $DATE&#10;echo &#34;SOURCEPATH:&#34;$SOURCEPATH&#10;echo &#34;BUILDPATH:&#34;$BUILDPATH&#10;echo &#34;IPAPATH:&#34;$IPAPATH&#10;&#10;echo &#34;Press any key to continue!&#34;&#10;read -p &#34;press any &#34; c&#10;if $c;then&#10;    xcodebuild -list&#10;else&#10;    echo &#34;ddd&#34;&#10;fi&#10;#&#10;#Information about project &#34;xxxxx&#34;:&#10;#    Targets:&#10;#        xxxxxx&#10;#&#10;#    Build Configurations:&#10;#        Debug&#10;#        Release&#10;#&#10;#    If no build configuration is specified and -scheme is not passed then &#34;Release&#34; is used.&#10;#&#10;#    Schemes:&#10;#        xxxxxx&#10;#&#10;&#10;#&#19981;&#25351;&#23450;configuration&#65292;&#25171;&#21253;&#20026;debug&#27169;&#24335;&#10;#xcodebuild -workspace hongmeng.xcworkspace -scheme hongmeng -configuration Debug clean build -derivedDataPath $BUILDPATH&#10;&#10;xcodebuild -workspace $SCHEMENAME.xcworkspace -scheme $SCHEMENAME -configuration Debug clean build -derivedDataPath $BUILDPATH&#10;if [ -e $BUILDPATH ]; then&#10;    echo &#34;xcodebuild Successful!&#34;&#10;else&#10;    echo &#34;xcodebuild failure!&#34;&#10;    exit 1&#10;fi&#10;&#10;&#10;#&#25171;&#21253;ipa&#10;#xcrun  -sdk iphoneos PackageApplication -v AutoBuildIPA/Build/Products/Debug-iphoneos/$SCHEMENAME.app -o $BUILDPATH/$SCHEMENAME_$DATE.ipa&#10;xcrun  -sdk iphoneos PackageApplication -v $BUILDAPPPATH/$SCHEMENAME.app -o $IPAPATH/$IPANAME&#10;&#10;if [ -e $IPAPATH/$IPANAME ]; then&#10;    echo &#34;\n--------------\n\n&#34;&#10;    echo &#34;Congratulations! Build Successful!&#34;&#10;    open $IPAPATH&#10;else&#10;    echo &#34;Build failure!&#34;&#10;fi</span><br></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Objc Runtime 再次实践]]></title>
      <url>http://koalahl.github.io/2016/11/22/OBJC-RUNTIME-%E5%86%8D%E6%AC%A1%E5%AE%9E%E8%B7%B5/</url>
      <content type="html"><![CDATA[<p>好久不用，再次使用runtime重写代码。就用高性能添加图片圆角来再一次实践一下runtime的基本用法。</p>
<p>runtime使用场景：</p>
<ul>
<li>category添加关联属性</li>
<li>MethodSwizzle替换/交换系统方法</li>
</ul>
<p>平常使用cornerRadius和maskToBounds组合设置圆角</p>
<div align="center"><br>    <img src="http://oh51ob42d.bkt.clouddn.com/blended layer.png" width="225" height="408" alt="girl"><br></div>

<a id="more"></a>
<p></p><h2 id="category">category添加关联属性</h2><br>废话不多说，直接上代码<br>创建一个<code>NSError</code>的category，添加一个<code>errorMsg</code>的属性。因为category本身不能添加属性，这里是使用runtime动态添加关联属性<p></p>
<p><img src="http://oh51ob42d.bkt.clouddn.com/NSError+Msg_h.png" alt="NSError+Msg_h"></p>
<p><img src="http://oh51ob42d.bkt.clouddn.com/NSError+Msg_m.png" alt="NSError+Msg_m"></p>
<p></p><h2 id="methodSwizzle">MethodSwizzle交换系统方法</h2><br>创建一个<code>UIImageView</code>的category，在分类中交换（exchange，注意这里不是替换replace）系统的<code>setImage:</code> 方法.<p></p>
<p>我们要交换一个类的系统方法，那么首先想想在哪个方法中交换最合适呢？<br>我们知道app在启动之后，会进行类注册，调用类的<code>+load()</code>方法，且只调用一次。（注意与<code>+initialize</code>的区别）<a href="http://polomana.com/2016/03/23/Effective-Objective-C-2-0-要点/" target="_blank" rel="external">第51条:load与initialize的区别</a>所以我们在分类中重写<code>load</code>方法中添加交换方法。</p>
<p>首先我们借用AFNetworking中AFURLSessionManager中定义的swizzle的内联函数<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> hl_swizzleSelector(Class theClass, SEL originalSelector, SEL swizzledSelector) &#123;</span><br><span class="line">    Method originalMethod = class_getInstanceMethod(theClass, originalSelector);</span><br><span class="line">    Method swizzledMethod = class_getInstanceMethod(theClass, swizzledSelector);</span><br><span class="line">    method_exchangeImplementations(originalMethod, swizzledMethod);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="built_in">BOOL</span> hl_addMethod(Class theClass, SEL selector, Method method) &#123;</span><br><span class="line">    <span class="comment">/*</span><br><span class="line">    YES if the method was added successfully, otherwise NO (for example, the class already contains a method implementation with that name)</span><br><span class="line">    */</span></span><br><span class="line">    <span class="keyword">return</span> class_addMethod(theClass, selector,  method_getImplementation(method),  method_getTypeEncoding(method));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>然后在<code>+load</code>方法中添加如下代码：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hl_swizzleSelector([<span class="keyword">self</span> class], <span class="keyword">@selector</span>(setImage:), <span class="keyword">@selector</span>(hl_setImage:));</span><br></pre></td></tr></table></figure></p>
<p>/* 这里参考的是AFURLSessionManager中的方式来添加方法，但是实际上在这个情况下是永远返回NO的</p>
<ul>
<li>原因：因为我们是在UIImageView的category中添加了hl_setImage:，所以在UIImageView中已经存在了该方法，再调用class_addMethod就会返回NO。</li>
<li>因此下面这些代码如果写在category中是不需要的了。<br>*/<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Method hlSetImageMethod = class_getInstanceMethod([<span class="keyword">self</span> class],<span class="keyword">@selector</span>(hl_setImage:));</span><br><span class="line"></span><br><span class="line"><span class="built_in">BOOL</span> result = hl_addMethod([<span class="keyword">self</span> class],<span class="keyword">@selector</span>(hl_setImage:), hlSetImageMethod);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%d"</span>,result);</span><br><span class="line"><span class="keyword">if</span> (result) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>测试一下代码：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIImageView</span> * v = [[<span class="built_in">UIImageView</span> alloc]initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">240</span>, <span class="number">240</span>)];</span><br><span class="line">v<span class="variable">.center</span> = <span class="keyword">self</span><span class="variable">.view</span><span class="variable">.center</span>;</span><br><span class="line">[<span class="keyword">self</span><span class="variable">.view</span> addSubview:v];</span><br><span class="line"></span><br><span class="line"><span class="built_in">UIImage</span> * image = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"IMG_0730.jpg"</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//会产生混合图层</span></span><br><span class="line">v<span class="variable">.layer</span><span class="variable">.cornerRadius</span> = v<span class="variable">.frame</span><span class="variable">.size</span><span class="variable">.width</span> / <span class="number">2</span>;</span><br><span class="line">v<span class="variable">.layer</span><span class="variable">.masksToBounds</span> = <span class="literal">YES</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//采用UIGraphicImageContext重绘后,解决混合图层问题</span></span><br><span class="line">[v setImage:[image hl_imageByCroppingForSize:<span class="built_in">CGSizeMake</span>(<span class="number">240</span>, <span class="number">240</span>) fillColor:[<span class="built_in">UIColor</span> whiteColor]]];</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用Method swizzle交换setImage和hl_setImage:之后：</span></span><br><span class="line">v<span class="variable">.image</span> = image;</span><br></pre></td></tr></table></figure></p>
<div align="center"><br>    <img src="http://oh51ob42d.bkt.clouddn.com/No blended layer.png" width="225" height="408" alt="girls"><br></div>


<p></p><h2 id="性能">其中的性能问题</h2><br>我们在UIImage+HLAdd分类中使用UIGraphicImageContext来重新绘图，这肯定是要耗时的操作。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CFTimeInterval</span> start = <span class="built_in">CACurrentMediaTime</span>();</span><br><span class="line">...</span><br><span class="line"><span class="comment">//绘图</span></span><br><span class="line">...</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%f"</span>,<span class="built_in">CACurrentMediaTime</span>() - start);</span><br></pre></td></tr></table></figure><p></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2016</span>-<span class="number">11</span>-<span class="number">22</span> <span class="number">17</span>:<span class="number">53</span>:<span class="number">42.614</span> iOS-Kick-On[<span class="number">47630</span>:<span class="number">2598373</span>] <span class="number">0.003525</span></span><br></pre></td></tr></table></figure>
<p>大概耗时在0.003~0.006之间，以纳秒进行运算的cpu来说，还是一个稍微耗时的操作，因为我们可以把它放在后台线程来做，然后采用回调来获取返回的image<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">UIImage</span> * result = [<span class="keyword">self</span> hl_imageByCroppingCorner:radius forSize:targetSize fillColor:[<span class="built_in">UIColor</span> whiteColor]];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        <span class="keyword">if</span> (completion) &#123;</span><br><span class="line">            completion(result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p><a href="https://github.com/koalahl/UIImageViewHack" target="_blank" rel="external">本篇文章代码</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[一起唱，团结就是力量]]></title>
      <url>http://koalahl.github.io/2016/11/18/%E4%B8%80%E8%B5%B7%E5%94%B1%EF%BC%8C%E5%9B%A2%E7%BB%93%E5%B0%B1%E6%98%AF%E5%8A%9B%E9%87%8F/</url>
      <content type="html"><![CDATA[<p>两个人来到河边，想要渡河，于是同乘一条船。一人船尾，一人船艏，各自拿起一对桨奋力地划着。可是过了老半天也不见小船驶向对岸，两人转头一看，原来各自把自己的位置当成船艏了，朝着相反的方向划去了。他们互相指责对方的过失，到了太阳落山依然还停留在原地。</p>
<a id="more"></a>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Xcode8中NavigationBar插入背景出错的解决方法]]></title>
      <url>http://koalahl.github.io/2016/10/05/Xcode8%E4%B8%ADNavigationBar%E6%8F%92%E5%85%A5%E8%83%8C%E6%99%AF%E5%87%BA%E9%94%99%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>以前写过一个导航栏中插入背景改变导航栏背景色的类。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insertSubview(backgroundView!, at: <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>在xcode8 的view hierarchay表现为：<br><img src="/img/background1.png" alt="xcode8"></p>
<p>但是现在出现的问题是返回到首页后，导航栏被背景view遮盖了</p>
<p><img src="/img/background2.png" alt="xcode8"></p>
<p>解决方法：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.subviews[<span class="number">0</span>].insertSubview(backgroundView!, at: <span class="number">0</span>)</span><br></pre></td></tr></table></figure></p>
<p>分析：<br>insertSubview是把backgroundView插入到UINavigationBar中，UINavigationBar作为其superview。每次跳转回来之后，会重新赋值（可能）<br>所以我们要把backgroundView放入到UIBarBackground中。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[python代码运行在iOS工程中的方案]]></title>
      <url>http://koalahl.github.io/2016/07/11/python%E4%BB%A3%E7%A0%81%E8%BF%90%E8%A1%8C%E5%9C%A8iOS%E5%B7%A5%E7%A8%8B%E4%B8%AD%E7%9A%84%E6%96%B9%E6%A1%88/</url>
      <content type="html"><![CDATA[<p>一种Xcode工程内执行python脚本的方法，详见下文。</p>
<p>1.下载解压Python-iOS.zip文件，打开python-ios.xcworkspace。<br>2.Command+R运行，此时在模拟器上会有app生成；并且Xcode的console中会有log打印<br>3.可以点击Send Msg按钮，会有如下log</p>
<p>当然，也可以打开浏览器，输入127.0.0.1:8000</p>
<p>实现方法：<br>1.主要集成了python基础库libPython和静态库liblibpython.a<br><img src="/img/python lib.png" alt="python lib"><br>2.include python.h,以及python 函数的使用方式：<br><img src="/img/python env init.png" alt="python env init"><br>红色框中server.py脚本被放到了其他线程执行，解决了卡住主线程的问题。</p>
<p>3.同时我也给出了一个在用户界面向本地服务器消息交互的例子，使用socket。<br><img src="/img/socket.png" alt="socket"></p>
<p>例子比较简单，实现了最基础的在用户界面与本地服务器通信的例子。并且不影响iOS相关代码的编写。</p>
<p>由于附件较大，上传到了Github。<a href="https://github.com/koalahl/PythonIniOS。" target="_blank" rel="external">https://github.com/koalahl/PythonIniOS。</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[《程序员的自我修养》读书笔记-编译和链接]]></title>
      <url>http://koalahl.github.io/2016/05/10/%E3%80%8A%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%BC%96%E8%AF%91%E5%92%8C%E9%93%BE%E6%8E%A5/</url>
      <content type="html"><![CDATA[<p>一个HelloWorld.c程序是如何被处理，得到一个a.out可执行程序的呢？<br><code>$gcc HelloWorld.c</code>命令，得到a.out<br><code>$./a.out</code> 执行</p>
<p>该过程可分为四个步骤：预处理（Preprocess）或者叫预编译、编译（Compile）、汇编（Assembly）和链接（Linking）。</p>
<p><img src="/img/gcc compile process.jpeg" alt=""></p>
<h3 id="preprocess">预编译</h3>

<p>预编译的命令<code>$gcc -E HelloWorld.c -o HelloWorld.i</code>。<br>预编译中的主要规则：</p>
<ul>
<li>将所有的<code>#define</code>删除，展开所有的宏定义</li>
<li>处理所有的条件预编译指令，比如<code>#if</code>,<code>#ifdef</code>,<code>#endif</code>,<code>#elif</code>,<code>#else</code>.</li>
<li>处理<code>#include</code>指令，将被包含的文件插入到该预编译指令的位置。这个过程是递归进行的</li>
<li>删除所有的注释<code>//</code>和<code>/**/</code>.</li>
<li>添加行号和文件名标识。</li>
<li>保留所有的<code>#pragma</code>编译器指令，因为编译器要使用它。</li>
</ul>
<h3 id="compile">编译</h3>

<p>编译器 ：cc1程序<br>编译过程就是把预处理完的.i文件进行一系列的词法分析、语法分析、语义分析以及代码优化后产生相应的汇编代码<br>编译的命令<code>$gcc -S HelloWorld.c -o HelloWorld.s</code>。</p>
<p><img src="/img/compile process.png" alt="编译过程"></p>
<h3 id="assembly">汇编</h3>

<p>汇编器 as<br>汇编过程将汇编代码转换成机器代码。根据汇编指令和机器代码的对照表一一翻译。<br>汇编的命令<code>$gcc -c HelloWorld.c -o HelloWorld.o</code>。</p>
<h3 id="linking">链接</h3>

<p>链接器 ld<br>从图中可以看出，链接器主要是把代码的.o文件与静态库链接在一起。</p>
<a id="more"></a>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[《程序员的自我修养》读书笔记-温故知新]]></title>
      <url>http://koalahl.github.io/2016/05/10/%E3%80%8A%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B8%A9%E6%95%85%E7%9F%A5%E6%96%B0/</url>
      <content type="html"><![CDATA[<p>基础篇回顾一下两个基础：<br>内存<br>线程</p>
<h2 id="memory">内存</h2><br>早期的计算机，程序直接运行在物理内存上。那么久存在一个问题：如何尽可能的将有限的物理内存分配给多个程序使用。<br><a id="more"></a><br>内存使用存在的问题：<br>  1.地址空间不足<br>  2.内存使用效率低<br>  3.程序运行的地址不确定-重定位问题。<br><br>那么针对这三个问题，利用<code>中间层</code>,让程序间接的访问物理地址，来解决以上几个问题。<br><br>- 分段：（segment）将程序需要的地址空间映射到一段虚拟空间上。以此将程序间隔离。此方法解决第一个和第三个问题。<br>- 分页：（paging）将地址空间人为分为固定大小的页（page）。一般为4KB大小。虚拟内存的实现需要依靠硬件支持。通常采用<code>MMU(Memory Management Unit)</code>来进行page mapping，将CPU使用的虚拟地址映射为实际的物理地址。<br><br><img src="/img/VPandPP.jpg" alt="进程虚拟空间、物理空间的映射"><br><br><h2 id="thread">线程</h2>

<p>线程结构：线程ID、指令指针PC、线程内栈和寄存器<br><img src="/img/thread2.jpeg" alt="线程结构"></p>
<p>现在基本都是多线程。</p>
<p>线程的访问权限。</p>
<table>
<thead>
<tr>
<th>线程私有</th>
<th style="text-align:center">线程间共享</th>
</tr>
</thead>
<tbody>
<tr>
<td>- 局部变量</td>
<td style="text-align:center">全局变量</td>
</tr>
<tr>
<td>- 函数的参数</td>
<td style="text-align:center">堆上的数据</td>
</tr>
<tr>
<td>- TLS数据</td>
<td style="text-align:center">函数中的静态变量</td>
</tr>
<tr>
<td></td>
<td style="text-align:center">程序代码</td>
</tr>
<tr>
<td></td>
<td style="text-align:center">打开的文件。线程A打开的文件可以由线程B读写</td>
</tr>
</tbody>
</table>
<p>线程安全</p>
<ul>
<li>单指令操作称为原子的Atomic。简单情况下可保证线程安全，但是在复杂的数据结构中，就有可能不能保证。此时需要更加通用的手段：锁</li>
<li>同步与锁。但是还是有可能出现问题，原因来自于CPU执行指令的换序（CPU有可能将后面的代码先执行）。</li>
<li>barrier阻塞机制。barrier指令会阻止CPU将barrier指令之前的指令交换到barrier之后，反之亦然。</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LearnSwift-小白学习map，reduce方法]]></title>
      <url>http://koalahl.github.io/2016/05/06/LearnSwift-%E5%B0%8F%E7%99%BD%E5%AD%A6%E4%B9%A0map%EF%BC%8Creduce%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>数组的map、reduce方法</p>
<a id="more"></a>
<p>map方法将遍历序列中每个元素<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>].<span class="built_in">map</span> &#123; (i) -&gt; <span class="type">Int</span> <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">return</span> i * <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>简化版<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>].<span class="built_in">map</span>(&#123;$<span class="number">0</span> * <span class="number">2</span>&#125;)</span><br></pre></td></tr></table></figure></p>
<p>reduce: i 这里是一个累加器（并不表示相加），保存了前一次运算的结果。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>].<span class="built_in">reduce</span>(<span class="number">1</span>) &#123; (i, element) -&gt; <span class="type">Int</span> <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(i,element)</span><br><span class="line">    <span class="keyword">return</span> i * element</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的reduce方法可以简化为<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>].<span class="built_in">reduce</span>(<span class="number">1</span>, combine: *)</span><br></pre></td></tr></table></figure></p>
<p>下面来看看flatMap,该函数会忽略为nil的集合元素。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> persons: [[<span class="type">String</span>: <span class="type">AnyObject</span>]] = [[<span class="string">"name"</span>: <span class="string">"Carl Saxon"</span>, <span class="string">"city"</span>: <span class="string">"New York, NY"</span>, <span class="string">"age"</span>: <span class="number">44</span>],</span><br><span class="line">                                      [<span class="string">"name"</span>: <span class="string">"Travis Downing"</span>, <span class="string">"city"</span>: <span class="string">"El Segundo, CA"</span>, <span class="string">"age"</span>: <span class="number">34</span>],</span><br><span class="line">                                      [<span class="string">"name"</span>: <span class="string">"Liz Parker"</span>, <span class="string">"city"</span>: <span class="string">"San Francisco, CA"</span>, <span class="string">"age"</span>: <span class="number">32</span>],</span><br><span class="line">                                      [<span class="string">"name"</span>: <span class="string">"John Newden"</span>, <span class="string">"city"</span>: <span class="string">"New Jersey, NY"</span>, <span class="string">"age"</span>: <span class="number">21</span>],</span><br><span class="line">                                      [<span class="string">"name"</span>: <span class="string">"Hector Simons"</span>, <span class="string">"city"</span>: <span class="string">"San Diego, CA"</span>, <span class="string">"age"</span>: <span class="number">37</span>],</span><br><span class="line">                                      [<span class="string">"name"</span>: <span class="string">"Brian Neo"</span>, <span class="string">"age"</span>: <span class="number">27</span>]] <span class="comment">//注意这家伙没有 city 键值</span></span><br><span class="line"><span class="comment">//找到住在CA的居民。</span></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">peopleFromState</span><span class="params">(state:String,persons:[[String:AnyObject]])</span></span> -&gt; <span class="type">Int</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> persons.flatMap &#123; $<span class="number">0</span>[<span class="string">"city"</span>]?.componentsSeparatedByString(<span class="string">", "</span>).last&#125;.<span class="built_in">filter</span> &#123; $<span class="number">0</span> == state&#125;.<span class="built_in">count</span></span><br><span class="line">&#125;</span><br><span class="line">peopleFromState(<span class="string">"CA"</span>, persons: persons)</span><br></pre></td></tr></table></figure></p>
<p>用reduce实现map、flatMap<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">rmap</span><span class="params">(element:[Int],transform:<span class="params">(Int)</span></span></span>-&gt;<span class="type">Int</span> ) -&gt;[<span class="type">Int</span>]&#123;</span><br><span class="line">    <span class="keyword">return</span> element.<span class="built_in">reduce</span>([<span class="type">Int</span>](), combine: &#123; (<span class="keyword">var</span> accemulator:[<span class="type">Int</span>], obj:<span class="type">Int</span>) -&gt; [<span class="type">Int</span>] <span class="keyword">in</span></span><br><span class="line">        <span class="built_in">print</span>(accemulator,obj)</span><br><span class="line">        accemulator.append(transform(obj))</span><br><span class="line">        <span class="keyword">return</span> accemulator</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rmap([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>], transform: &#123;$<span class="number">0</span> * <span class="number">2</span>&#125;)</span><br></pre></td></tr></table></figure></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">rmap2</span><span class="params">(element:[Int],transform:<span class="params">(Int)</span></span></span>-&gt;<span class="type">Int</span>) -&gt; [<span class="type">Int</span>] &#123;</span><br><span class="line">    <span class="keyword">return</span> element.<span class="built_in">reduce</span>([<span class="type">Int</span>](), combine: &#123;$<span class="number">0</span>  + [transform($<span class="number">1</span>)]&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> array = rmap2([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>], transform: &#123;$<span class="number">0</span> * <span class="number">2</span>&#125;)</span><br><span class="line"><span class="built_in">print</span>(array)</span><br><span class="line"></span><br><span class="line">结果都是[<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">12</span>]</span><br></pre></td></tr></table></figure>
<p>理解 <code>$0, $1</code><br>$0,$1是一个常量，类型根据所在函数的参数类型决定。<br><img src="/img/￥0类型.png" alt=""><br><img src="/img/$1类型.png" alt=""><br>为何它们是这个类型呢？<br>其所在函数是combine，那么$0和$1的类型都是由combine这个(函数/闭包/方法)的第二个参数类型决定的。所以我们来看看reduce函数的定义：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="func"><span class="keyword">func</span> <span class="title">reduce</span><span class="generics">&lt;T&gt;</span><span class="params">(initial: T, @noescape combine: <span class="params">(T, <span class="keyword">Self</span>.Generator.Element)</span></span></span> <span class="keyword">throws</span> -&gt; <span class="type">T</span>) <span class="keyword">rethrows</span></span><br></pre></td></tr></table></figure></p>
<p>$0代表第一个参数，其类型这里是[Int],$1代表的是combine内的第二个参数，所以其类型就是Int的。</p>
<p>用reduce实现filter<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">rfilter</span><span class="params">(element:[Int],<span class="built_in">filter</span>:<span class="params">(Int)</span></span></span>-&gt;<span class="type">Bool</span>)-&gt; [<span class="type">Int</span>]&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> element.<span class="built_in">reduce</span>([<span class="type">Int</span>](), combine: &#123; (<span class="keyword">var</span> acc:[<span class="type">Int</span>], value:<span class="type">Int</span>) -&gt; [<span class="type">Int</span>] <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">filter</span>(value)&#123;</span><br><span class="line">            acc.append(value)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> acc</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> xxc = rfilter([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>], <span class="built_in">filter</span>: &#123; $<span class="number">0</span> &gt; <span class="number">3</span>&#125;)</span><br><span class="line"><span class="built_in">print</span>(xxc)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">rfilter2</span><span class="params">(element:[Int],<span class="built_in">filter</span>:<span class="params">(Int)</span></span></span>-&gt;<span class="type">Bool</span>)-&gt; [<span class="type">Int</span>]&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> element.<span class="built_in">reduce</span>([<span class="type">Int</span>](), combine: &#123; <span class="keyword">guard</span> <span class="built_in">filter</span>($<span class="number">1</span>) <span class="keyword">else</span>&#123; <span class="keyword">return</span> $<span class="number">0</span>&#125;</span><br><span class="line">        <span class="keyword">return</span> $<span class="number">0</span> + [$<span class="number">1</span>]</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> oos = rfilter2([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>], <span class="built_in">filter</span>: &#123;$<span class="number">0</span> &gt; <span class="number">3</span> &#125;)</span><br><span class="line"><span class="built_in">print</span>(oos)</span><br></pre></td></tr></table></figure></p>
<p>再看前面提过的问题：找到住在CA的居民。并且计算他们的平均年龄<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">peopleFromState</span><span class="params">(state:String,persons:[[String:AnyObject]])</span></span> -&gt; (population:<span class="type">Int</span>,averageAge:<span class="type">CGFloat</span>)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//return persons.flatMap &#123; $0["city"]?.componentsSeparatedByString(", ").last&#125;.filter &#123; $0 == state&#125;.count</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">Result</span> = (population:<span class="type">Int</span>,averageAge:<span class="type">CGFloat</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> u = persons.<span class="built_in">reduce</span>((populatoin:<span class="number">0</span>,averageAge:<span class="number">0.0</span>)) &#123; (<span class="keyword">var</span> result:<span class="type">Result</span>, dic:[<span class="type">String</span>:<span class="type">AnyObject</span>]) -&gt; <span class="type">Result</span> <span class="keyword">in</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> locationStr = dic[<span class="string">"city"</span>]?.componentsSeparatedByString(<span class="string">", "</span>).last,<span class="keyword">let</span> personAge = dic[<span class="string">"age"</span>] <span class="keyword">where</span> locationStr == state <span class="keyword">else</span>&#123; <span class="keyword">return</span> result&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (result.population + <span class="number">1</span>,result.averageAge + <span class="type">CGFloat</span>(personAge <span class="keyword">as</span>! <span class="type">NSNumber</span>))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (u.populatoin,u.averageAge / <span class="type">CGFloat</span>(u.populatoin))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> result = peopleFromState(<span class="string">"CA"</span>, persons: persons)</span><br><span class="line">result.population <span class="comment">// 3</span></span><br><span class="line">result.averageAge <span class="comment">// 34.333333334</span></span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Learn Swift - Section 4th 扩展、协议、泛型]]></title>
      <url>http://koalahl.github.io/2016/04/28/Learn-Swift-Section-Four-%E6%89%A9%E5%B1%95%E3%80%81%E5%8D%8F%E8%AE%AE%E3%80%81%E6%B3%9B%E5%9E%8B/</url>
      <content type="html"><![CDATA[<h2 id="extension">扩展 Extension</h2><br>扩展<code>Extension</code>就是向一个已有的类、结构体、枚举类型或者协议类型添加新功能（functionality）。这包括在没有权限获取原始源代码的情况下扩展类型的能力（即逆向建模）。扩展和 Objective-C 中的分类（categories）类似。（不过与 Objective-C 不同的是，Swift 的扩展没有名字。）<br><br>Swift 中的扩展可以：<br>- 添加计算型属性和计算型静态属性<br>- 定义实例方法和类型方法<br>- 提供新的构造器<br>- 定义下标<br>- 定义和使用新的嵌套类型<br>- 使一个已有类型符合某个协议<br>- 也可以对一个协议进行扩展<br><br><a id="more"></a><br><br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Int</span></span>&#123;</span><br><span class="line">    <span class="comment">//转换成小时</span></span><br><span class="line">    <span class="keyword">var</span> hours : <span class="type">Int</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>/<span class="number">3600</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> ago : <span class="type">Int</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//x之前的时间</span></span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">ago</span><span class="params">(x:Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span> - x</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> currentTime = <span class="number">7200</span></span><br><span class="line"><span class="number">3</span>.hours</span><br><span class="line"><span class="number">3</span>.hours.ago</span><br><span class="line"><span class="number">3</span>.ago + currentTime</span><br><span class="line"><span class="comment">//5秒之前</span></span><br><span class="line">currentTime.ago(<span class="number">5</span>)</span><br><span class="line"><span class="comment">//1小时之前</span></span><br><span class="line">currentTime.hours.ago(<span class="number">1</span>)</span><br><span class="line">currentTime.hours.ago(<span class="number">3600</span>.hours)</span><br><span class="line"><span class="built_in">print</span>(<span class="number">3</span>.ago)</span><br></pre></td></tr></table></figure><br><br><h2 id="protocol">协议 Protocol</h2><br>协议定义了一个蓝图，规定了用来实现某一特定工作或者功能所必需的方法和属性。类，结构体或枚举类型都可以遵循协议，并提供具体实现来完成协议定义的方法和功能。任意能够满足协议要求的类型被称为遵循(conform)这个协议。<br><br>除了遵循协议的类型必须实现那些指定的规定以外，还可以对协议进行扩展，实现一些特殊的规定或者一些附加的功能，使得遵循的类型能够收益。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">SellProducts</span></span>&#123;</span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">sellProducts</span><span class="params">(product:String)</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name:<span class="type">String</span></span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> delegate:<span class="type">Seller</span>?</span><br><span class="line">    <span class="built_in">lazy</span> <span class="keyword">var</span> someClosure:(<span class="type">Int</span>,<span class="type">String</span>)-&gt;<span class="type">String</span> = &#123;</span><br><span class="line">        <span class="comment">//在闭包中将self修饰为无主引用。将delegate 修饰为 弱引用</span></span><br><span class="line">        [<span class="keyword">unowned</span> <span class="keyword">self</span>,<span class="keyword">weak</span> delegate = <span class="keyword">self</span>.delegate!]<span class="comment">//捕获列表</span></span><br><span class="line">        (index:<span class="type">Int</span>,strToProcess:<span class="type">String</span>)-&gt;<span class="type">String</span> <span class="keyword">in</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"<span class="subst">\(<span class="keyword">self</span>.name)</span>,<span class="subst">\(<span class="keyword">self</span>.delegate)</span>,<span class="subst">\(delegate)</span>"</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">init</span>(name:<span class="type">String</span>,delegate:<span class="type">Seller</span>?)&#123;</span><br><span class="line">        <span class="keyword">self</span>.name = name;</span><br><span class="line">        <span class="keyword">self</span>.delegate = delegate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">giveSellerProducts</span><span class="params">(product:String )</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.delegate?.sellProducts(product)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Seller</span> : <span class="title">SellProducts</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> product:<span class="type">String</span>?</span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">sellProducts</span><span class="params">( product: String)</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.product = product</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> seller = <span class="type">Seller</span>()</span><br><span class="line"><span class="keyword">var</span> person = <span class="type">Person</span> (name: <span class="string">"Hanliu"</span>, delegate: seller)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//刚开始seller是没有商品的，要等到Person给seller</span></span><br><span class="line"><span class="built_in">print</span>(seller.product)</span><br><span class="line"><span class="comment">//person告诉seller，帮我卖苹果</span></span><br><span class="line">person.giveSellerProducts(<span class="string">"apple"</span>)</span><br><span class="line"><span class="comment">//现在seller手中就有了商品了</span></span><br><span class="line"><span class="built_in">print</span>(seller.product!)</span><br><span class="line"></span><br><span class="line">person.someClosure(<span class="number">1</span>,<span class="string">"haha"</span>)</span><br></pre></td></tr></table></figure><br><br>协议中的属性一定要指明读写状态<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">SomeProtocol</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> mustBeSettable:<span class="type">Int</span>&#123;<span class="keyword">get</span> <span class="keyword">set</span>&#125;<span class="comment">//表示该属性是可读可写</span></span><br><span class="line">    <span class="keyword">var</span> notNeededForSetable:<span class="type">String</span>&#123;<span class="keyword">get</span>&#125;<span class="comment">//表示只读</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> someTypedProperty:<span class="type">String</span>&#123;<span class="keyword">get</span> <span class="keyword">set</span>&#125;<span class="comment">//类属性(当协议遵循者是class是，可以用class关键字)</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">FullyName</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> fullname:<span class="type">String</span>&#123;<span class="keyword">get</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PersonName</span>:<span class="title">FullyName</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> fullname: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> shortName :<span class="type">String</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = <span class="type">PersonName</span>(fullname: <span class="string">"Levi John"</span>,shortName: <span class="string">"LJ"</span>)</span><br><span class="line">person.fullname</span><br></pre></td></tr></table></figure><br><br>协议本身并不实现任何功能，但是协议可以被作为类型使用。就是与String、Int这些类型的作用相同。<br>- 作为函数、方法或构造器中的参数类型或返回值类型<br>- 作为常量、变量或属性的类型<br>- 作为数组、字典或其他容器中的元素的类型<br><br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">RandomGenerator</span> </span>&#123;</span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">random</span><span class="params">()</span></span>-&gt;<span class="type">Double</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinerGenerator</span>:<span class="title">RandomGenerator</span> </span>&#123;</span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">random</span><span class="params">()</span></span> -&gt; <span class="type">Double</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">11.0011</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dice</span></span>&#123;</span><br><span class="line">    <span class="keyword">let</span> slides:<span class="type">Int</span></span><br><span class="line">    <span class="keyword">var</span> generator:<span class="type">RandomGenerator</span><span class="comment">//作为属性类型</span></span><br><span class="line">    <span class="keyword">init</span>(slides:<span class="type">Int</span>,generator:<span class="type">RandomGenerator</span>)&#123;<span class="comment">//作为参数类型</span></span><br><span class="line">        <span class="keyword">self</span>.slides = slides</span><br><span class="line">        <span class="keyword">self</span>.generator = generator</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">roll</span><span class="params">()</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Int</span>(<span class="keyword">self</span>.generator.random() * <span class="type">Double</span>(slides))+<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>在扩展中遵循协议，增加协议成员（这种方法与直接在类后面遵循协议的效果相同）。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">TextRepresentable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> textDescription :<span class="type">String</span>&#123;<span class="keyword">get</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Dice</span>:<span class="title">TextRepresentable</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> textDescription:<span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"<span class="subst">\(slides)</span> - slides"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> dice = <span class="type">Dice</span>(slides: <span class="number">8</span>, generator: <span class="type">LinerGenerator</span>())</span><br><span class="line">dice.textDescription<span class="comment">//现在Dice的所有实例都可以使用textDescription属性了。</span></span><br></pre></td></tr></table></figure><br><br>协议类型的集合<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sir  = <span class="type">Dice</span>(slides: <span class="number">1</span>, generator: <span class="type">LinerGenerator</span>())</span><br><span class="line"><span class="keyword">let</span> sime = <span class="type">Dice</span>(slides: <span class="number">2</span>, generator: <span class="type">LinerGenerator</span>())</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arrayOfProtocolElements:[<span class="type">TextRepresentable</span>] = [dice,sir,sime]</span><br><span class="line"><span class="keyword">for</span> element <span class="keyword">in</span> arrayOfProtocolElements&#123;</span><br><span class="line">    <span class="built_in">print</span>(element.textDescription)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>协议能够继承.<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">TextGo</span>:<span class="title">TextRepresentable</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> prettyTextDescription:<span class="type">String</span>&#123;<span class="keyword">get</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Dice</span>:<span class="title">TextGo</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> prettyTextDescription:<span class="type">String</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> textDescription + <span class="string">"hello"</span><span class="comment">//可以使用上层协议的属性</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>类专属协议.在协议继承列表中的首位添加class关键字,然后这个协议就只能被类遵循，而不能被结构体或者枚举遵循。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">ClassOnlyProtocol</span>:<span class="title">class</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> mylove:<span class="type">String</span>&#123;<span class="keyword">get</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>检查协议一致性<br>使用<code>is</code>、<code>as?</code>、<code>as!</code><br><br>协议本身也可以被扩展<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">TextRepresentable</span></span>&#123;<span class="comment">//TextRepresentable是个协议</span></span><br><span class="line">    <span class="keyword">var</span> longTextDescription:<span class="type">String</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"<span class="subst">\(textDescription)</span> + long"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>为协议扩展添加限制条件 where<br>扩展<code>CollectionType</code>协议，让其遵循者的元素必须遵循<code>TextRepresentable</code>协议<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">CollectionType</span> <span class="title">where</span> <span class="title">Generator</span>.<span class="title">Element</span>:<span class="title">TextRepresentable</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> textDescription:<span class="type">String</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> items = <span class="keyword">self</span>.<span class="built_in">map</span>&#123;$<span class="number">0</span>.textDescription&#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"A hamster named <span class="subst">\(items)</span>"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Hamster</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> textDescription: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"a hamster named <span class="subst">\(name)</span>"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Hamster</span>: <span class="title">TextRepresentable</span> </span>&#123;&#125;<span class="comment">//让Hamster遵循TextRepresentable协议</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> murrayTheHamster = <span class="type">Hamster</span>(name: <span class="string">"Murray"</span>)</span><br><span class="line"><span class="keyword">let</span> morganTheHamster = <span class="type">Hamster</span>(name: <span class="string">"Morgan"</span>)</span><br><span class="line"><span class="keyword">let</span> mauriceTheHamster = <span class="type">Hamster</span>(name: <span class="string">"Maurice"</span>)</span><br><span class="line"><span class="keyword">let</span> hamsters = [murrayTheHamster, morganTheHamster, mauriceTheHamster]</span><br><span class="line"></span><br><span class="line">因为<span class="type">Array</span>遵循了`<span class="type">CollectionType</span>`协议，而hamster又遵循了`<span class="type">TextRepresentable</span>`协议，所以就满足了条件，此时 array可以使用`textDescription`属性</span><br><span class="line"><span class="built_in">print</span>(hamsters.textDescription)</span><br><span class="line"></span><br><span class="line">结果：<span class="type">A</span> hamster named [<span class="string">"a hamster named Murray"</span>, <span class="string">"a hamster named Morgan"</span>, <span class="string">"a hamster named Maurice"</span>]</span><br></pre></td></tr></table></figure><br><br><h2 id="Generics">泛型 Generics</h2>

<p>泛型代码可以让你写出根据自我需求定义、适用于任何类型的，灵活且可重用的函数和类型。它的可以让你避免重复的代码，用一种清晰和抽象的方式来表达代码的意图。</p>
<p>泛型是 Swift 强大特征中的其中一个，许多 Swift 标准库是通过泛型代码构建出来的。事实上，泛型的使用贯穿了整本语言手册，只是你没有发现而已。例如，Swift 的数组和字典类型都是泛型集。你可以创建一个Int数组，也可创建一个String数组，或者甚至于可以是任何其他 Swift 的类型数据数组。同样的，你也可以创建存储任何指定类型的字典（dictionary），而且这些类型可以是没有限制的</p>
<p></p><h3 id="func">泛型函数</h3><br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">swapTwoValues</span><span class="generics">&lt;T&gt;</span><span class="params">(<span class="keyword">inout</span> a:T,<span class="keyword">inout</span> b:T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">let</span> tempValue = a</span><br><span class="line">    a = b</span><br><span class="line">    b = tempValue</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p>
<ul>
<li>T 表示一个占位命名类型</li>
<li>尖括号<t>表示它里面的T是由函数<code>swapTwoValues</code>定义的一个类型，swift不会去查找命名为T的实际类型</t></li>
<li>参数列表中的T没有实际类型，仅表示两个参数的类型需要相同</li>
</ul>
<p></p><h3 id="generic stack">实现一个泛型版本的栈</h3><br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stack</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> items = [<span class="type">T</span>]()</span><br><span class="line">    <span class="keyword">mutating</span> <span class="func"><span class="keyword">func</span> <span class="title">push</span><span class="params">(item:T)</span></span>&#123;</span><br><span class="line">        items.append(item)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">mutating</span> <span class="func"><span class="keyword">func</span> <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        items.removeLast()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//泛型实例的创建,都必须指定T的类型</span></span><br><span class="line"><span class="keyword">var</span> stack = <span class="type">Stack</span>(items: [<span class="string">""</span>])</span><br><span class="line"><span class="keyword">var</span> stack2 = <span class="type">Stack</span>&lt;<span class="type">String</span>&gt;()</span><br></pre></td></tr></table></figure><p></p>
<p>//扩展一个泛型类型:添加一个属性<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Stack</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> topItem:<span class="type">T</span>?&#123;</span><br><span class="line">        <span class="keyword">return</span> items.isEmpty ? <span class="literal">nil</span> : items[items.<span class="built_in">count</span> - <span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">stack2.topItem</span><br></pre></td></tr></table></figure></p>
<p></p><h3 id="associated type">关联类型（Associated Type） </h3><br>swift2.2貌似修改了。声明的时候用associatedtype 实现的时候用typealias<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Container</span></span>&#123;</span><br><span class="line">    associatedtype <span class="type">ItemType</span></span><br><span class="line">    <span class="keyword">var</span> <span class="built_in">count</span>:<span class="type">Int</span>&#123;<span class="keyword">get</span>&#125;</span><br><span class="line">    <span class="keyword">mutating</span> <span class="func"><span class="keyword">func</span> <span class="title">append</span><span class="params">(item:ItemType)</span></span></span><br><span class="line">    <span class="keyword">subscript</span> (i:<span class="type">Int</span>)-&gt;<span class="type">ItemType</span>&#123;<span class="keyword">get</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//让泛型Stack遵循Container协议</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Stack</span>:<span class="title">Container</span></span>&#123;</span><br><span class="line">    <span class="comment">//typealias ItemType = T //这一行也是可以去掉，因为swift通过类型推断可以判断出T的类型</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="func"><span class="keyword">func</span> <span class="title">append</span><span class="params">(item: T)</span></span> &#123;</span><br><span class="line">        <span class="keyword">return</span>  <span class="keyword">self</span>.push(item)<span class="comment">//或者：items.append(item)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> <span class="built_in">count</span>:<span class="type">Int</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> items.<span class="built_in">count</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">subscript</span>(i:<span class="type">Int</span>)-&gt;<span class="type">T</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> items[i]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Learn Swift - Section 3rd 类与结构体]]></title>
      <url>http://koalahl.github.io/2016/04/26/Learn-Swift-Section-Three/</url>
      <content type="html"><![CDATA[<p>类与结构体的共同点：</p>
<ul>
<li>定义属性用于存储值</li>
<li>定义方法用于提供功能</li>
<li>定义附属脚本用于访问值</li>
<li>定义构造器用于生成初始化值</li>
<li>通过扩展以增加默认实现的功能</li>
<li>实现协议以提供某种标准功能</li>
</ul>
<p>与结构体相比，类还有如下的附加功能：</p>
<ul>
<li>继承允许一个类继承另一个类的特征</li>
<li>类型转换允许在运行时检查和解释一个类实例的类型</li>
<li>解构器允许一个类实例释放任何其所被分配的资源</li>
<li>引用计数允许对一个类的多次引用<a id="more"></a>
</li>
</ul>
<p>更多信息请参见继承，类型转换，析构过程，和自动引用计数。</p>
<p>注意</p>
<ul>
<li>结构体总是通过被复制的方式在代码中传递，不使用引用计数。</li>
</ul>
<p></p><h3 id="1">1.值类型与引用类型</h3><br>值类型被赋予给一个变量、常量或者被传递给一个函数的时候，其值会被拷贝。<p></p>
<p>在之前的章节中，我们已经大量使用了值类型。实际上，在 Swift 中，所有的基本类型：整数（Integer）、浮点数（floating-point）、布尔值（Boolean）、字符串（string)、数组（array）和字典（dictionary），都是值类型，并且在底层都是以结构体的形式所实现。</p>
<p>在 Swift 中，所有的结构体和枚举类型都是值类型。这意味着它们的实例，以及实例中所包含的任何值类型属性，在代码中传递的时候都会被复制。</p>
<p>“与值类型不同，引用类型在被赋予到一个变量、常量或者被传递到一个函数时，其值不会被拷贝。因此，引用的是已存在的实例本身而不是其拷贝。”</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> marray = [<span class="string">"lopl"</span>,<span class="string">"liu"</span>,<span class="string">"han"</span>]</span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">modifyArray</span><span class="params">()</span></span>  &#123;</span><br><span class="line">    <span class="keyword">var</span> saray = marray</span><br><span class="line">    saray.removeAtIndex(<span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line">modifyArray()</span><br><span class="line">marray<span class="comment">//并没有变，说明是值拷贝</span></span><br></pre></td></tr></table></figure>
<p></p><h3 id="2">2.将结构体实例赋值给一个常量，则无法修改结构体中的属性，即使属性是变量。</h3><br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Cars</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">""</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> car = <span class="type">Cars</span>()</span><br><span class="line">car.name = <span class="string">"Audi"</span></span><br><span class="line"><span class="comment">//而类则可以修改，因为类是引用类型。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CreateNewLife</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">""</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animals</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> kind = <span class="string">""</span></span><br><span class="line">    <span class="keyword">let</span> planet = <span class="string">"Earth"</span></span><br><span class="line">    <span class="built_in">lazy</span> <span class="keyword">var</span> createNewLife = <span class="type">CreateNewLife</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> life = <span class="type">CreateNewLife</span>()</span><br><span class="line"><span class="keyword">let</span> anAnimal = <span class="type">Animals</span>()</span><br><span class="line">anAnimal.kind = <span class="string">"Human"</span></span><br><span class="line"><span class="built_in">print</span>(anAnimal,life)</span><br><span class="line"><span class="keyword">if</span> life === anAnimal &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"same class"</span>)</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Different class"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(anAnimal.createNewLife.name)<span class="comment">//这时CreateNewLife实例才会被创建</span></span><br><span class="line">anAnimal.createNewLife.name = <span class="string">"liven"</span></span><br><span class="line"><span class="built_in">print</span>(anAnimal.kind,anAnimal.createNewLife.name)</span><br></pre></td></tr></table></figure><p></p>
<p></p><h3 id="3">3.结构体和类中的属性定义-getter和setter</h3><br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">0.0</span>,y = <span class="number">0.0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Size</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> width = <span class="number">0.0</span>,height = <span class="number">0.0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rect</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> origin = <span class="type">Point</span>()</span><br><span class="line">    <span class="keyword">var</span> size   = <span class="type">Size</span>()</span><br><span class="line">    <span class="keyword">var</span> center:<span class="type">Point</span>&#123;<span class="comment">//计算属性:即写了get或set的属性。如果只有get，就是只读属性</span></span><br><span class="line">        <span class="keyword">get</span>&#123;</span><br><span class="line">            <span class="keyword">let</span> centerX = origin.x + size.width/<span class="number">2</span></span><br><span class="line">            <span class="keyword">let</span> centerY = origin.y + size.height/<span class="number">2</span></span><br><span class="line">            <span class="keyword">return</span> <span class="type">Point</span>(x: centerX, y: centerY)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span>(newCenter)&#123;</span><br><span class="line">            origin.x = newCenter.x - size.width/<span class="number">2</span></span><br><span class="line">            origin.y = newCenter.y - size.height/<span class="number">2</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> arcPoint:<span class="type">Point</span>&#123;<span class="comment">//属性观察器didSet,willSet</span></span><br><span class="line">        <span class="keyword">willSet</span>(newValue)&#123;<span class="comment">//会将新的值传入</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"will set arcPoint <span class="subst">\(newValue)</span>"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">didSet</span>(oldValue)&#123;<span class="comment">//会将旧的值传入</span></span><br><span class="line">            <span class="comment">//arcPoint = Point(x: 8, y: 9)</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"did set arcPoint <span class="subst">\(arcPoint)</span> <span class="subst">\(oldValue)</span>"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> name = <span class="string">"my rect"</span><span class="comment">//Type property类型属性</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//值类型属性一般不能在它自己的实例方法中修改；如果非要修改，需要加关键字mutating</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="func"><span class="keyword">func</span> <span class="title">bigger</span><span class="params">(x:Double,y:Double)</span></span> &#123;</span><br><span class="line">        size.width  += x</span><br><span class="line">        size.height += y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Rect</span>.name</span><br><span class="line"><span class="type">Rect</span>.name = <span class="string">"xxxx"</span></span><br><span class="line"><span class="type">Rect</span>.name</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> rect = <span class="type">Rect</span>(origin: <span class="type">Point</span>(x: <span class="number">10</span>,y: <span class="number">10</span>), size: <span class="type">Size</span>(width: <span class="number">20</span>,height: <span class="number">30</span>), arcPoint: <span class="type">Point</span>(x: <span class="number">1</span>, y: <span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span>(rect.arcPoint)</span><br><span class="line">rect.arcPoint = <span class="type">Point</span>(x: <span class="number">3</span>, y: <span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(rect.arcPoint)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> rect2 = rect</span><br><span class="line">rect2.arcPoint = <span class="type">Point</span>(x: <span class="number">6</span>, y: <span class="number">6</span>)</span><br><span class="line"><span class="built_in">print</span>(rect.arcPoint,rect2.arcPoint)</span><br><span class="line"></span><br><span class="line">rect.bigger(<span class="number">20</span>, y: <span class="number">20</span>)</span><br><span class="line"><span class="built_in">print</span>(rect.size)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">var</span> <span class="title">overrideProperty</span>:<span class="title">Int</span></span>&#123;<span class="comment">//get省略了。class关键字表示重写父类的getter实现</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p>
<p></p><h3 id="4">4.方法</h3><br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LevelTraker</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> highestUnlockedLevel = <span class="number">1</span></span><br><span class="line">    <span class="keyword">static</span> <span class="func"><span class="keyword">func</span> <span class="title">unlockLevel</span><span class="params">(level:Int)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (level == highestUnlockedLevel + <span class="number">1</span>) &#123;highestUnlockedLevel = level&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="func"><span class="keyword">func</span> <span class="title">levelIsUnlocked</span><span class="params">(level:Int)</span></span>-&gt;<span class="type">Bool</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> level &lt;= highestUnlockedLevel</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> currentLevel = <span class="number">1</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="func"><span class="keyword">func</span> <span class="title">advanceLevel</span><span class="params">(level:Int)</span></span>-&gt;<span class="type">Bool</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="type">LevelTraker</span>.levelIsUnlocked(level) &#123;</span><br><span class="line">            currentLevel = level</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Player</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> traker = <span class="type">LevelTraker</span>()</span><br><span class="line">    <span class="keyword">var</span> playerName:<span class="type">String</span></span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">completeLevel</span><span class="params">(level:Int)</span></span> -&gt;<span class="type">Bool</span>&#123;</span><br><span class="line">        <span class="type">LevelTraker</span>.unlockLevel(level+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> traker.advanceLevel(level+<span class="number">1</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"Level <span class="subst">\(level)</span> hasn't been unlocked"</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">init</span>(name:<span class="type">String</span>)&#123;</span><br><span class="line">        playerName = name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> level111 = <span class="type">LevelTraker</span>()</span><br><span class="line"><span class="keyword">var</span> level121 = <span class="type">LevelTraker</span>()</span><br><span class="line">level121.currentLevel = <span class="number">2</span></span><br><span class="line"><span class="built_in">print</span>(level111.currentLevel, level121.currentLevel)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> player = <span class="type">Player</span>(name:<span class="string">"han"</span>)</span><br><span class="line">player.traker.currentLevel</span><br><span class="line">player.completeLevel(<span class="number">1</span>)</span><br><span class="line">player.traker.currentLevel</span><br><span class="line"><span class="type">LevelTraker</span>.highestUnlockedLevel</span><br><span class="line">player.completeLevel(<span class="number">5</span>)</span><br></pre></td></tr></table></figure><p></p>
<p></p><h3 id="5">5.构造过程</h3><br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cars</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> brand:<span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> usage:<span class="type">String</span></span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    <span class="keyword">init</span>()&#123;</span><br><span class="line">        brand = <span class="string">"BMW"</span></span><br><span class="line">        usage = <span class="string">"Family"</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">init</span>(_brand:<span class="type">String</span>,_usage:<span class="type">String</span>)&#123;</span><br><span class="line">        brand = _brand</span><br><span class="line">        usage = _usage</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> audi = <span class="type">Cars</span>(_brand: <span class="string">"Audi"</span>, _usage: <span class="string">"Sports"</span>)</span><br><span class="line"><span class="built_in">print</span>(audi.brand,audi.usage)</span><br><span class="line"><span class="keyword">let</span> car2 = <span class="type">Cars</span>()</span><br><span class="line"><span class="built_in">print</span>(car2.brand,car2.usage)</span><br></pre></td></tr></table></figure><p></p>
<p></p><h3 id="6">6.当属性有默认值，且没有构造方法时，结构体和类拥有默认构造方法。但是结构体可以有带属性参数的默认构造方法（逐一成员构造器），而类没有。</h3><br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name:<span class="type">String</span>?</span><br><span class="line">    <span class="keyword">var</span> sex:<span class="type">String</span>?</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Books</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> type:<span class="type">String</span>?</span><br><span class="line">    <span class="keyword">var</span> category:<span class="type">String</span>?</span><br><span class="line">    <span class="keyword">var</span> available = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p = <span class="type">People</span>()</span><br><span class="line"><span class="keyword">let</span> semdsd = <span class="type">People</span>(name: <span class="string">"han"</span>, sex: <span class="string">"famale"</span>)</span><br><span class="line"><span class="keyword">let</span> book   = <span class="type">Books</span>()</span><br><span class="line"><span class="comment">//var book2  = Books(type:"epub",category:"Computer",available:true)</span></span><br></pre></td></tr></table></figure><p></p>
<p></p><h3 id="7">7.析构过程</h3><br>/**<p></p>
<ul>
<li>析构器只适用于类类型，不能用于结构体。析构器用deinit关键字。<br>*/<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Telephones</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> type:<span class="type">String</span>?</span><br><span class="line">    <span class="keyword">var</span> category:<span class="type">String</span>?</span><br><span class="line">    <span class="keyword">var</span> available = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">deinit</span>&#123;</span><br><span class="line">        <span class="comment">//析构代码。。。</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"<span class="subst">\(type)</span>"</span>)</span><br><span class="line">        available = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>/<em><br> 析构过程会在ARC回收实例时被系统调用，不需要手动调用。
 </em>/</p>
<p></p><h3 id="8">8.类实例之间的循环强引用</h3><br>解决方式：<br>1.使用weak关键字，弱引用<br>2.使用unowned，无主引用<p></p>
<p></p><h3 id="9">9.解决闭包引起的循环引用–定义捕获列表</h3><br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">SellProducts</span></span>&#123;</span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">sellProducts</span><span class="params">(product:String)</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name:<span class="type">String</span></span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> delegate:<span class="type">Seller</span>?</span><br><span class="line">    <span class="built_in">lazy</span> <span class="keyword">var</span> someClosure:(<span class="type">Int</span>,<span class="type">String</span>)-&gt;<span class="type">String</span> = &#123;</span><br><span class="line">        <span class="comment">//在闭包中将self修饰为无主引用。将delegate 修饰为 弱引用</span></span><br><span class="line">        [<span class="keyword">unowned</span> <span class="keyword">self</span>,<span class="keyword">weak</span> delegate = <span class="keyword">self</span>.delegate!]<span class="comment">//捕获列表</span></span><br><span class="line">        (index:<span class="type">Int</span>,strToProcess:<span class="type">String</span>)-&gt;<span class="type">String</span> <span class="keyword">in</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"<span class="subst">\(<span class="keyword">self</span>.name)</span>,<span class="subst">\(<span class="keyword">self</span>.delegate)</span>,<span class="subst">\(delegate)</span>"</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">init</span>(name:<span class="type">String</span>,delegate:<span class="type">Seller</span>?)&#123;</span><br><span class="line">        <span class="keyword">self</span>.name = name;</span><br><span class="line">        <span class="keyword">self</span>.delegate = delegate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">giveSellerProducts</span><span class="params">(product:String )</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.delegate?.sellProducts(product)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Seller</span> : <span class="title">SellProducts</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> product:<span class="type">String</span>?</span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">sellProducts</span><span class="params">( product: String)</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.product = product</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> seller = <span class="type">Seller</span>()</span><br><span class="line"><span class="keyword">var</span> person = <span class="type">Person</span> (name: <span class="string">"Hanliu"</span>, delegate: seller)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//刚开始seller是没有商品的，要等到Person给seller</span></span><br><span class="line"><span class="built_in">print</span>(seller.product)</span><br><span class="line"><span class="comment">//person告诉seller，帮我卖苹果</span></span><br><span class="line">person.giveSellerProducts(<span class="string">"apple"</span>)</span><br><span class="line"><span class="comment">//现在seller手中就有了商品了</span></span><br><span class="line"><span class="built_in">print</span>(seller.product!)</span><br><span class="line"></span><br><span class="line">person.someClosure(<span class="number">1</span>,<span class="string">"haha"</span>)</span><br></pre></td></tr></table></figure><p></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Learn Swift - Section 2nd 集合类型和枚举]]></title>
      <url>http://koalahl.github.io/2016/04/26/Learn-Swift-Section-Two/</url>
      <content type="html"><![CDATA[<p>Arra、Dictionary、Set和枚举</p>
<a id="more"></a>
<p>//Array的map()方法<br>let digitNames = [<br>    0: “Zero”, 1: “One”, 2: “Two”,   3: “Three”, 4: “Four”,<br>    5: “Five”, 6: “Six”, 7: “Seven”, 8: “Eight”, 9: “Nine”<br>]<br>let numbers = [132,11,87,90,49,87,22,29,5,10,87]<br>//map方法会读取数组中的每一个元素，<br>let strings = numbers.map { (element) -&gt; String in<br>    var output = “”<br>    var number = element<br>    while number &gt; 0 {<br>        output = digitNames[number % 10]! + output<br>        number /= 10<br>    }<br>    return output<br>}<br>//把每个元素都+1<br>let so = numbers.map{(element)-&gt;Int in<br>    return element + 1<br>}<br>let lo = numbers.flatMap{(element)-&gt;Int in<br>    return element + 3</p>
<p>}<br>let split1 = numbers.split(70)<br>let split2 = numbers.split(87)<br>let split3 = numbers.split(87, maxSplit: 1, allowEmptySlices: true)<br>let split4 = numbers.split(87, maxSplit: 6, allowEmptySlices: true)<br>let split5 = numbers.split(87, maxSplit: 6, allowEmptySlices: false)</p>
<p>//过滤出满足条件的子序列。条件由闭包定义<br>numbers.filter { (element) -&gt; Bool in<br>    return element &gt; 50<br>}<br>numbers.filter{(element) in element &gt; 50}<br>numbers.filter{ $0 &gt; 50}</p>
<p>let scores = [“xiaoming”:66,”li”:89,”han”:78,”ming”:100,”xiag”:34]<br>scores.filter { (name,score) in score &gt; 60}</p>
<p>//“将闭包标注为@noescape使你能在闭包中隐式地引用self”<br>func functionWithNoescapeClosure(@noescape closure:()-&gt;Void){<br>    closure()<br>}<br>var completionHandlers:[() -&gt; Void] = []<br>func functionWithEscapeClosure(completionHandler:()-&gt;Void){<br>    completionHandler()<br>    completionHandlers.append(completionHandler)<br>}</p>
<p>class SomeClass {<br>    var x = 200<br>    func doSomething(){</p>
<pre><code>    functionWithEscapeClosure({self.x = <span class="number">100</span>})

    functionWithNoescapeClosure({x = <span class="number">300</span>})<span class="comment">//隐式引用self</span>

}
</code></pre><p>}<br>let some = SomeClass()<br>some.doSomething()<br>print(some.x)</p>
<p>completionHandlers.first?()<br>print(some.x)</p>
<p>//自动闭包 使用@autoclosure，就可以不用加闭包的{}<br>var names = [“charis”,”levis”,”luos”,”deric”,”htome”]<br>let customerProvider = {names.removeAtIndex(0)}//注意类型是()-&gt;String<br>func customName(@autoclosure customerProvider:()-&gt;String)  {<br>    print(“costomer’s name is (customerProvider())”)<br>}</p>
<p>customName(names.removeAtIndex(0))//闭包体不需要加{}，就好像是参数一样。</p>
<p>//枚举-一等公民 与类class一样<br>enum Compose{<br>    case North<br>    case South<br>    case West<br>    case East<br>}<br>//成员值的类型为枚举的名字Compose<br>let directionToHead = Compose.East</p>
<p>//带有关联值的枚举<br>enum Barcode {<br>    case UPCA(Int,Int,Int)//关联了Int类型的值<br>    case QRCode(String)//关联了String类型的值<br>}</p>
<p>var productorCode = Barcode.QRCode(“kasdjfiwoeklf”)</p>
<p>productorCode = .UPCA(2,5,1)</p>
<p>switch productorCode{<br>    case let .UPCA(first,second,third):<br>        print(“(first) (second) (third)”)<br>    case var .QRCode(code):<br>        print(“code is (code)”)<br>}</p>
<p>//原始值 Raw Values<br>enum ASCII:Character{//带有初始类型的枚举<br>    case Tab = “\t”<br>    case Return = “\r”<br>    case changeLine = “\n”<br>}</p>
<p>//关联值可以使枚举的嵌套成为可能.如果嵌套，则需要添加indirect关键字<br>enum Add{<br>    case Number(Int)<br>    indirect case Addition(Add,Add)<br>}<br>func evaluate(add:Add) -&gt; Int {<br>    switch add {<br>    case .Number(let i):<br>        return i<br>    case .Addition(let left, let right):<br>        return evaluate(left) + evaluate(right)<br>    }<br>}</p>
<p>let a = Add.Number(10)<br>let b = Add.Number(2)<br>let c = Add.Addition(a,b)</p>
<p>evaluate(a)<br>evaluate(c)</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Learn Swift - Section 1st 基础知识]]></title>
      <url>http://koalahl.github.io/2016/04/26/Learn-Swift-Section-One/</url>
      <content type="html"><![CDATA[<p>import UIKit</p>
<p>var str = “Hello, playground”</p>
<p>//常量和变量<br>let maxLoginCount = 10<br>var currentLoginCount = 5</p>
<p>//类型标注<br>var message = “welcome”//类型推断为String<br>var messageWithTypeAnnotation:String</p>
<a id="more"></a>
<p>message = “welcome here”<br>messageWithTypeAnnotation = “welcome go”</p>
<p>print(“Big world (message)”)//(message) 字符串转义<br>print(“Big world”, message)//</p>
<p>let newString = “Big world “  + “(message) “ + message<br>print(newString)<br>//多行语句用分号<br>let cat = “🐱”; print(cat)</p>
<p>let a:Int32 = 10<br>let uintb:UInt8 = 255</p>
<p>//类型别名<br>typealias SLInt = UInt64<br>let i:SLInt<br>var maxInt64 = SLInt.max</p>
<p>//元组<br>let HttpErrorCode  = (404,”NotFound”)<br>print(HttpErrorCode)</p>
<p>typealias HttpStateCode = (Int32,String)<br>var errorMsg = HttpErrorCode<br>var normal: HttpStateCode = (200,”OK”)<br>print(normal)</p>
<p>let (stateCode,stateMsg) = HttpErrorCode<br>print(“HTTP code is (stateCode)”)<br>//通过下标访问元组元素<br>print(HttpErrorCode.1)</p>
<p>//隐式解析可选类型</p>
<p>let possibleString:String? = “an optional string”<br>let forcedString:String = possibleString!</p>
<p>let possibleString2:String! = “an implicitly optional stirng”<br>let forcedString2:String = possibleString2</p>
<p>//可选绑定<br>if let bingStr = possibleString2{<br>    print(bingStr)<br>}</p>
<p>//错误处理</p>
<p>func canThrowAnError() throws{</p>
<p>}</p>
<p>func makeASanwich() -&gt; Bool {<br>    return false<br>}<br>func buyNewDishes() -&gt; Void {</p>
<p>}</p>
<p>do{<br>    try canThrowAnError()<br>    makeASanwich()<br>}catch Error.MissingNeededMetarail{<br>    buyNewDishes()<br>}</p>
<p>//断言<br>let num = 4<br>assert(num&gt;0, “a大于0”)</p>
<p>//空合运算符 ??<br>let defaultColor:String = “red”<br>var userDefinedColor:String?</p>
<p>//userDefinedColor = “orange”<br>var currentColorToUse = userDefinedColor ?? defaultColor<br>//等价于<br>var currentColorToUse2 = userDefinedColor != nil ? userDefinedColor! : defaultColor</p>
<p>//区间运算符<br>//1.闭区间 (a…b) 包含a和b<br>for index in (1…5){<br>    print(index)<br>    print(“(index) <em> 5 = (index </em> 5)”)<br>}<br>//2.半开区间 (a..&lt;b)<br>for index in (1..&lt;5){<br>    print(index)<br>    print(“(index) <em> 5 = (index </em> 5)”)<br>}</p>
<p>//字符串 String<br>//String是值类型<br>for charactor in “You R A🐶”.characters{<br>    print(charactor)<br>}<br>//独立的字符常量或变量<br>let singleCharactor:Character = “!”</p>
<p>//通过值类型为character的数组来创建字符串<br>let characters:[Character] = [“c”,”a”,”t”,”🐱”]<br>let catString = String(characters)<br>print(catString)</p>
<p>//插值运算  反斜杠\<br>let multiplier = 4<br>print(“(multiplier) times 5.12 =  (Double(multiplier) * 5.12)”)<br>print(“\r message”+” \u{E9}”)</p>
<p>//Unicode<br>let ccc1:Character = “\u{65}”<br>let ccc2:Character = “\u{65}\u{301}”</p>
<p>print(message)<br>message.startIndex<br>message.endIndex<br>//前一个index<br>message.endIndex.predecessor()<br>//后一个index<br>message.startIndex.successor()<br>//从starIndex开始 后面的第i个index<br>let xx = message.startIndex.advancedBy(4)<br>message.removeAtIndex(message.startIndex.advancedBy(4))<br>print(message)<br>//indices 获取字符串的全部索引 。空格不算。。。<br>for index in message.characters.indices{<br>    print(“(message[index])”)<br>}</p>
<p>message.insert(“u”, atIndex: xx)</p>
<p>message = “http:”+message<br>print(message)<br>//前后缀<br>var hasPrefix = message.hasPrefix(“http”)<br>var hasSuffix = message.hasSuffix(“png”)</p>
<p>//集合类型：数组Array 集合Set 字典Dictionary</p>
<p>//不可变和可变<br>/<em>“如果创建一个Arrays、Sets或Dictionaries并且把它分配成一个变量，这个集合将会是可变的。这意味着我们可以在创建之后添加更多或移除已存在的数据项来改变这个集合的大小。如果我们把Arrays、Sets或Dictionaries分配成常量，那么它就是不可变的，它的大小不能被改变。”
 </em>/<br>let immutableArray = <a href="count:1,repeatedValue:0" target="_blank" rel="external">Int</a><br>var mutableArray   = <a href="">Int</a></p>
<p>let strArray    = [“world”]</p>
<p>mutableArray.append(1)<br>var array1:[String] = Array()<br>array1.append(“hello”)<br>array1.appendContentsOf(strArray)<br>array1.insert(“gogogog”, atIndex: 1)<br>array1.count<br>array1.isEmpty</p>
<p>array1[0…1] = [“apple”,”pear”];<br>array1<br>//数组的遍历<br>for item in array1{<br>    print(item)<br>}</p>
<p>for (index,item) in array1.enumerate(){<br>    print(item,array1[index])<br>}</p>
<p>//集合<br>var asset = Set<string>()<br>asset.count<br>asset.insert(“hash string”)<br>asset.remove(“hash”)<br>//set类型必须显式声明,具体元素类型可以省略<br>let asset2:Set<character> = [“a”]<br>let asset3:Set = [“a”,”v”]<br>asset2.hashValue == asset3.hashValue<br>asset.hashValue == asset2.hashValue</character></string></p>
<p>let asset4 = Set.init(arrayLiteral: “a”,”b”,”c”)<br>let asset5 = Set.init(array1)<br>//集合操作：交集、外集、合集,减集</p>
<p>asset3.intersect(asset4)<br>asset3.exclusiveOr(asset4)<br>asset3.union(asset4)<br>asset3.subtract(asset4)</p>
<p>asset3 == asset4<br>asset3.isSubsetOf(asset4)<br>asset3.isSupersetOf(asset3)<br>asset3.isStrictSupersetOf(asset3)//是否是超集，并且不是同一集合<br>asset3.isStrictSubsetOf(asset3)//是否是子集，并且不是同一集合</p>
<p>asset3.isDisjointWith(asset4)//判断集合是否不含有相同的值。false说明包含相同的值</p>
<p>//字典 Dictionary<key,value><br>var dic1 = Dictionary<int,string>()<br>var dic2 = <a href="">Int:String</a><br>dic1.updateValue(“value”, forKey: 0)//updateValue方法返回值是该key的旧值<br>dic1.updateValue(“newValue”, forKey: 0)<br>print(dic1)<br>dic1[1] = “ahao”<br>dic1[2] = “dddd”<br>print(dic1)</int,string></key,value></p>
<p>for (key,value) in dic1{<br>    print(key ,value)<br>}</p>
<p>print(dic1.keys.sort())<br>print(dic1.values.sort())</p>
<p>//控制流程</p>
<p>//game<br>let finalSqura = 25<br>var board = <a href="count:finalSqura+1,repeatedValue:0" target="_blank" rel="external">Int</a><br>board[03] = +08; board[06] = +11; board[09] = +09; board[10] = +02<br>board[14] = -10; board[19] = -11; board[22] = -02; board[24] = -08<br>var square = 0<br>var diceRoll = 0</p>
<p>gameLoop:while square != finalSqura{<br>    //if ++diceRoll == 7 { diceRoll = 1 }<br>    switch square + diceRoll {<br>    case finalSqura:<br>        break gameLoop<br>    case let newSquare where newSquare &gt; finalSqura:<br>        coutinue gameLoop<br>    default:<br>        square += diceRoll<br>        square += board[square]<br>    }<br>}<br>print(“game over”)</p>
<p>//检查API可用性<br>if #available(iOS 9, *){</p>
<p>}else{</p>
<p>}<br>func checkOSVersion() -&gt; NSString {<br>    //必须在函数体内使用；必须跟着else；必须能跳出else<br>    guard #available(OSX 10.11, *) else {<br>        return “10.10”<br>    }<br>    return “10.11”<br>}</p>
<p>checkOSVersion()</p>
<p>//函数嵌套<br>func stepForword(input:Int)-&gt;Int{<br>    return input - 1<br>}<br>func stepBackword(input:Int)-&gt;Int{<br>    return input + 1<br>}<br>func chooseStep(value:Int) -&gt; (Int)-&gt;Int {<br>    return value &gt; 0 ? stepForword : stepBackword<br>}<br>func xxxx(tempFunction:(Int)-&gt;Int) -&gt;Int {<br>    return 1<br>}<br>//如果我再加一个函数嵌套<br>func nextStep(tempFunction:((Int)-&gt;Int)-&gt;Int) -&gt; Int{<br>    return 0<br>}<br>let number = 3<br>let myFunction = chooseStep(number)<br>myFunction(number)</p>
<p>let names = [“Chris”, “Alex”, “Ewa”, “Barry”, “Daniella”]<br>func absendOrdesend(s1:String,s2:String) -&gt; Bool {<br>    return s1&gt;s2<br>}<br>//使用函数的返回值作为参数<br>names.sort()<br>names.sort(absendOrdesend)<br>//闭包表达式</p>
<p>{(parameter:Type)-&gt;ReturnType in</p>
<p>}<br>Objective-C中的block<br>ReturnType ^(parameter){ return }</p>
<p>//使用闭包的返回值作为参数<br>names.sort({(s1:String,s2:String) -&gt; Bool in<br>        return s1 &gt; s2<br>})</p>
<p>//因为names数组参数类型确定，所以根据类型推断,省略参数类型和返回值类型<br>names.sort({s1,s2 in return s1&gt;s2})<br>names.sort({s1,s2 in s1&gt;s2})<br>names.sort({$0&gt;$1})<br>names.sort(&gt;)//根据String对&gt;这个符号的定义推断</p>
<p>//尾随闭包<br>//先定义一个closure<br>let bigger = {(a:Int,b:Int)-&gt;Bool in<br>    return a&gt;b<br>}<br>//声明一个函数，参数是一个闭包<br>func exchangeNumerWithClosure(bigger:(Int,Int)-&gt;Bool){<br>    if bigger(2,3) {<br>        print(“bigger”)<br>    }else{<br>        print(“lower”)<br>    }<br>}<br>//函数调用时<br>//没有使用尾随闭包<br>//exchangeNumerWithClosure({(a:Int,b:Int)-&gt;Bool in<br>//    return a&gt;b<br>//})</p>
<p>//使用尾随闭包<br>//exchangeNumerWithClosure(){(a:Int,b:Int)-&gt;Bool in return a&gt;b }<br>exchangeNumerWithClosure(){(a:Int,b:Int) -&gt;Bool in a&gt;b}<br>//同理，尾随闭包<br>names.sort(){$0&gt;$1}<br>names.sort{$0&gt;$1}//如果函数只需要闭包表达式一个参数，当您使用尾随闭包时,可以省略()</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[浅谈iOS中的userAgent]]></title>
      <url>http://koalahl.github.io/2016/04/10/%E6%B5%85%E8%B0%88iOS%E4%B8%AD%E7%9A%84userAgent/</url>
      <content type="html"><![CDATA[<p>User-Agent（用户代理）字符串是Web浏览器用于声明自身型号版本并随HTTP请求发送给Web服务器的字符串，在Web服务器上可以获取到该字符串。</p>
<p>在公司产品中，在userAgent中增加了NetType字段，用于标识客户端当前的网络环境。</p>
<ul>
<li>NetType/WIFI</li>
<li>NetType/3G<br>web服务器端根据NetType类型加载不同分辨率的商品图片。我们只有两种，WIFI下高清图，非WIFI低分辨率图。</li>
</ul>
<a id="more"></a>
<h3 id="1">获取WebView的userAgent</h3><br>iOS客户端中获取webView的userAgent的方法：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSMutableString</span> *userAgent = [<span class="built_in">NSMutableString</span> stringWithString:[[<span class="built_in">UIWebView</span> new] stringByEvaluatingJavaScriptFromString:<span class="string">@"navigator.userAgent"</span>]];</span><br></pre></td></tr></table></figure><br><br>根据需要添加不同的标识到新的userAgent中,这里添加一个WMall标识。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *newUagent = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@ WMall/%@"</span>, userAgent, [SystemInfo appShortVersion]];</span><br><span class="line"><span class="built_in">NSDictionary</span> *dictionnary = [[<span class="built_in">NSDictionary</span> alloc] initWithObjectsAndKeys:newUagent, <span class="string">@"UserAgent"</span>, <span class="literal">nil</span>];</span><br><span class="line">[[<span class="built_in">NSUserDefaults</span> standardUserDefaults] registerDefaults:dictionnary];</span><br></pre></td></tr></table></figure><br><br>newUagent 为<code>Mozilla/5.0 (iPhone; CPU iPhone OS 9_3 like Mac OS X) AppleWebKit/601.1.46 (KHTML, like Gecko) Mobile/13E230 WMall/3.0</code><br><br><h3 id="2">根据网络类型设置不同的NetType标识</h3>

<p>iOS中判断网络状态一般用AFNetWorking中的方法：<br>在appDelegate的<code>application didFinishLaunchingWithOptions</code>方法中启动网络状态监听：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[[AFNetworkReachabilityManager sharedManager] startMonitoring];</span><br><span class="line">[[AFNetworkActivityIndicatorManager sharedManager] setEnabled:<span class="literal">YES</span>];</span><br></pre></td></tr></table></figure></p>
<p>然后在基类BaseViewController中监听网络更新通知<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(networkReachabilityStatusDidChange:) name:AFNetworkingReachabilityDidChangeNotification object:<span class="literal">nil</span>];</span><br></pre></td></tr></table></figure></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)networkReachabilityStatusDidChange:(<span class="built_in">NSNotification</span> *)notify&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"网络变化通知：%@"</span>,notify<span class="variable">.userInfo</span>[AFNetworkingReachabilityNotificationStatusItem]);</span><br><span class="line">    AFNetworkReachabilityStatus status = [notify<span class="variable">.userInfo</span>[AFNetworkingReachabilityNotificationStatusItem] integerValue];</span><br><span class="line">    <span class="built_in">NSString</span> *net = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">switch</span> (status) &#123;</span><br><span class="line">        <span class="keyword">case</span> AFNetworkReachabilityStatusNotReachable:</span><br><span class="line">            net = <span class="string">@"无网络"</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> AFNetworkReachabilityStatusReachableViaWiFi:</span><br><span class="line">            net = <span class="string">@"WIFI"</span>;</span><br><span class="line">            [<span class="keyword">self</span> changeUserAgentWithType:<span class="string">@"WIFI"</span>];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> AFNetworkReachabilityStatusReachableViaWWAN:</span><br><span class="line">            net = <span class="string">@"2G/3G/4G"</span>;</span><br><span class="line">            [<span class="keyword">self</span> changeUserAgentWithType:<span class="string">@"3G"</span>];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            net = <span class="string">@"xxx"</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    [Error showError:[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"当前网络状态%@"</span>,net]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意先判断userAgent中是否存在NetType<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//更新NetType</span></span><br><span class="line">- (<span class="keyword">void</span>)changeUserAgentWithType:(<span class="built_in">NSString</span> *)type&#123;</span><br><span class="line">    <span class="built_in">NSMutableString</span> *userAgent = [<span class="built_in">NSMutableString</span> stringWithString:[[<span class="built_in">UIWebView</span> new] stringByEvaluatingJavaScriptFromString:<span class="string">@"navigator.userAgent"</span>]];</span><br><span class="line">    <span class="built_in">NSString</span> *newUagent = <span class="literal">nil</span>;</span><br><span class="line">    <span class="built_in">NSString</span> *temp = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">if</span> ([userAgent containsString:<span class="string">@"NetType"</span>]) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([userAgent containsString:<span class="string">@"WIFI"</span>]) &#123;</span><br><span class="line">            temp = <span class="string">@"WIFI"</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>([userAgent containsString:<span class="string">@"3G"</span>])&#123;</span><br><span class="line">            temp = <span class="string">@"3G"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        newUagent = [userAgent stringByReplacingOccurrencesOfString:temp withString:type];</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        newUagent = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@ NetType/%@"</span>, userAgent, type];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSDictionary</span> *dictionnary = [[<span class="built_in">NSDictionary</span> alloc] initWithObjectsAndKeys:newUagent, <span class="string">@"UserAgent"</span>, <span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"new useragent:%@"</span>,newUagent);</span><br><span class="line">    [[<span class="built_in">NSUserDefaults</span> standardUserDefaults] registerDefaults:dictionnary];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>newUagent 为<code>Mozilla/5.0 (iPhone; CPU iPhone OS 9_3 like Mac OS X) AppleWebKit/601.1.46 (KHTML, like Gecko) Mobile/13E230 WMall/3.0  NetType/WIFI</code></p>
<p>参考<br><a href="http://blog.csdn.net/lilin_emcc/article/details/40145113" target="_blank" rel="external">微信6.0内嵌浏览器User-Agent字符串增加了NetType字段</a><br><a href="http://blog.csdn.net/mangosnow/article/details/38798195" target="_blank" rel="external">获取 UIWebview 的 Useragent，以及附加自定义字段到 Useragent</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[UIButton设置文字图片居中、UIView相关方法以及UI切图的重要性]]></title>
      <url>http://koalahl.github.io/2016/03/31/UIButton%E8%AE%BE%E7%BD%AE%E6%96%87%E5%AD%97%E5%9B%BE%E7%89%87%E5%B1%85%E4%B8%AD-%E8%AE%BAUI%E5%88%87%E5%9B%BE%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7/</url>
      <content type="html"><![CDATA[<p>又是一个老生常谈的问题，o(╯□╰)o。UIButton作为最最常用的控件，想必都是很熟悉的。如下图所示的控件中</p>
<p><img src="/img/ordersButton.png" alt="Order Buttons"></p>
<p>如此设计在很多电商客户端中都有涉及，也没有什么难度。</p>
<p>但是我遇到的问题就是任凭如何设置边距，就是对不齐，其中还要考虑屏幕适配的问题。Orz…最后去工程里查看相应的图片大小，才发现每个图片的尺寸宽高都不同，很随意。</p>
<p>这搞半天，原来是图片尺寸的问题，想想这UI，唉！<br><a id="more"></a></p>
<h2 id="UIbutton">UIButton设置文字图片居中</h2>

<p>UIButton图片、文字居中的调整主要就是四个参数：（``）</p>
<ul>
<li><code>contentHorizontalAlignment</code>:设置真个Button内容（包括imageView和titleLabel）的水平位置。</li>
<li><code>contentVerticalAlignment</code>:设置整个Button内容（包括imageView和titleLabel）的垂直位置，这里用不到。</li>
<li><code>imageEdgeInsets</code>:设置imageView的边距。</li>
<li><p><code>titleEdgeInsets</code>:设置titleLabel的边距。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, <span class="built_in">UIControlContentVerticalAlignment</span>) &#123;</span><br><span class="line">    <span class="built_in">UIControlContentVerticalAlignmentCenter</span>  = <span class="number">0</span>,</span><br><span class="line">    <span class="built_in">UIControlContentVerticalAlignmentTop</span>     = <span class="number">1</span>,</span><br><span class="line">    <span class="built_in">UIControlContentVerticalAlignmentBottom</span>  = <span class="number">2</span>,</span><br><span class="line">    <span class="built_in">UIControlContentVerticalAlignmentFill</span>    = <span class="number">3</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, <span class="built_in">UIControlContentHorizontalAlignment</span>) &#123;</span><br><span class="line">    <span class="built_in">UIControlContentHorizontalAlignmentCenter</span> = <span class="number">0</span>,</span><br><span class="line">    <span class="built_in">UIControlContentHorizontalAlignmentLeft</span>   = <span class="number">1</span>,</span><br><span class="line">    <span class="built_in">UIControlContentHorizontalAlignmentRight</span>  = <span class="number">2</span>,</span><br><span class="line">    <span class="built_in">UIControlContentHorizontalAlignmentFill</span>   = <span class="number">3</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>在这里给出我用的通用方法，button高度为50为例：<br>1.设置button的<code>contentHorizontalAlignment</code>为<code>UIControlContentHorizontalAlignmentLeft</code>,这样便于根据button大小计算。当然非要用center计算也可！<br>2.设置imageView的Edge：<br>  <code>kButtonImageViewEdgeInsets(btn) UIEdgeInsetsMake(0,(kOptionBtnWidth - btn.imageView.frame.size.width)/2, 20, 0);</code><br>3.设置titleLabel的Edge：<br>  <code>#define kButtonTitleEdgeInsets(btn)     UIEdgeInsetsMake(30, (kOptionBtnWidth - btn.titleLabel.frame.size.width)/2-btn.titleLabel.frame.origin.x, 0, 20);</code>。</p>
<p>只要传入相应的button就可以了，其中button的宽度由此得来<code>#define kOptionBtnWidth  (CGRectGetWidth(frame)/kOptionBtnCount)</code>。</p>
<h2 id="UIView">UIView的相关方法</h2>

<p>直接采用上述设置button的方法是有条件的，即确定了当前Button的宽度。我们看到要计算button的宽度，得通过读取屏幕宽度得知。app中初始化UIView的方式通常有两种：<br>1.xib/Storyboard，然后关联<code>.h</code>,<code>.m</code>文件。<br>2.自定义UIView子类,通过<code>initWithFrame</code>方法设置。</p>
<p>当在UIView的子类中实现时，因为此时屏幕宽度已经通过初始化方法中得知，所以不需要再多设置。<br>而通过xib/sb关联的子类初始化方法中，若打印self.frame，就是当前xib的宽度，而不是实际屏幕宽度。所以不能再初始化方法中设置button的属性。</p>
<p>第一步重写父类方法，下面两个任选其一。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)updateConstraints;-需要重写父类的updateConstraints方法。</span><br><span class="line">- (<span class="keyword">void</span>)layoutSubviews;</span><br></pre></td></tr></table></figure></p>
<p>第二步对每个button调用<code>layoutIfNeeded</code>方法，让其立即刷新布局。</p>
<p>这个是没有调用layoutIfNeeded的情况：<br><img src="/img/Not call layoutIfNeeded.png" alt="Not call layoutIfNeeded"></p>
<p>以上。</p>
<p>参考文档<br><a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIView_Class/index.html#//apple_ref/swift/cl/c:objc(cs" target="_blank" rel="external">UIView Class Reference</a>UIView)</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Effective-Objective C 2.0 要点]]></title>
      <url>http://koalahl.github.io/2016/03/23/Effective-Objective-C-2-0-%E8%A6%81%E7%82%B9/</url>
      <content type="html"><![CDATA[<p>Effective-Ojective C 2.0 读书笔记</p>
<p>第一章的内容比较基础，就没有列在笔记当中了。另外该笔记只记录每一个要点之后的总结，重点地方会另外探讨。</p>
<a id="more"></a>
<h2 id="2">第二章 消息、对象、运行期</h2>

<p>7.在对象内部尽量直接访问实例变量</p>
<ul>
<li>在对象内部读取数据时，应该直接通过实例变量来读取；而写入数据时，应该通过属性的设置方法来写。</li>
<li>在初始化方法多及dealloc方法中，总是通过实例变量来读写数据。</li>
<li>有时会使用lazy initializition方式来初始化某数据，这种情况下，需要通过属性来读取数据。</li>
</ul>
<p>8.理解“对象同等性”这一概念</p>
<ul>
<li>若想检测对象的等同性，请提供<code>isEqual:</code>与<code>hash</code>方法。</li>
<li>相同的对象必须具有相同的哈希码，但是两个哈希码相同的对象却未必相同。</li>
<li>编写hash方法时，应该使用计算速度快而且哈希吗碰撞几率低的算法。</li>
</ul>
<p>9.以类簇模式隐藏实现细节</p>
<ul>
<li>类簇模式可以把实现细节隐藏在一套简单的公共接口后面。</li>
<li>系统框架中经常使用类簇。</li>
<li>从类簇的公共抽象基类中继承子类时要当心，若有开发文档，则应首先阅读。</li>
</ul>
<p>10.在既有类中使用关联对象存放自定义数据</p>
<p>1.关联对象的存储策略：枚举值</p>
<p>OBJC_ASSOCIATION_ASSIGN —&gt;assign<br>OBJC_ASSOCIATION_RETAIN_NONATOMIC —&gt;nonatomic,retain<br>OBJC_ASSOCIATION_COPY_NONATOMIC —&gt;nonatomic,copy<br>OBJC_ASSOCIATION_RETAIN —&gt;retain<br>OBJC_ASSOCIATION_COPY —&gt;copy</p>
<p>创建关联对象方法：<br>void objc_setAssociatedObject(id object,void *key,id value,objc_AssociationPolicy policy)</p>
<p>以给定的键获取某对象的关联对象的值<br>id objc_getAssociatedObject(id object,void *key)</p>
<p>移除该对象的所有关联对象<br>void objc_removeAssociatedObjects(id object)</p>
<p>Note:设置关联对象时的key是一个“不透明指针”（opaque pointer：其所指向的数据结构不局限与某种特定类型指针）；</p>
<p>在设置关联对象时，通常使用静态全局变量作为key。</p>
<ul>
<li>可以通过“associateObject”机制来吧两个对象连起来。</li>
<li>定义关联对象时可指定内存管理语义，用于模仿定义属性时所在用的拥有关系和非拥有关系。</li>
<li>只有在其他做法不可行时才选用关联对象，因为这种做法通常会引入难以查找的bug。</li>
</ul>
<p>11.理解objc_msgSend的作用。</p>
<ul>
<li>消息由接受者、选择器及参数构成。给某对象发送消息（invoke a message），也就相当于在该对象上调用方法（calla method）</li>
<li>发给某对象的全部消息都要有动态消息派发系统（dynamic message dispatch system）来处理，该系统会查出对应的方法，并执行其代码。</li>
</ul>
<p>12.理解消息转发机制。</p>
<ul>
<li>若对象无法响应某个选择器中的消息，则进入消息转发过程。</li>
<li>通过运行期的动态方法解析机制，我们可以在需要用到某个方法时再将其加入类中。</li>
<li>对象可以把其无法解读的消息转交给其他对象来处理。</li>
<li>若经过上述两步还是没办法处理消息，则启动完整的消息转发机制。</li>
</ul>
<p>13.使用方法调配技术Method Swizzling调试黑盒方法<br>void method_exchangeImplementations(Method m1,Method m2)</p>
<ul>
<li>在运行期，可以响雷中新增或替换选择器所对应的方法实现。</li>
<li>使用另一份实现来替换原有的方法实现，叫做方法调配，开发者可以用此技术向原有实现中添加新功能。</li>
<li>一般来说，只有调试程序的时候才需要在运行期修改方法实现，这种做法不宜滥用。</li>
</ul>
<p>14.理解“类对象”的用意</p>
<ul>
<li>每个实例都有一个指向Class对象的指针（isa），用意表明其类型，而这些Class对象则构成了类的继承体系（super_class指针）。</li>
<li>如果对象类型无法再编译期确定，那么久应该使用类型信息查询方法来探知。isMemberOfClass（特定类型的类），isKindOfClass（该类及其派生类）</li>
<li>尽量使用类型信息查询方法来确定对象类型，而不要直接比较类对象，因为某些对象可能实现了消息转发功能。</li>
</ul>
<h2 id="3">第三章 接口与API设计</h2>

<p>15.使用前缀避免命名空间冲突，解决duplicate symbol问题。<br>16.使用全能初始化方法，即带有特定参数的初始化方法。<br>17.实现description方法用来调试程序。并且最好用字典的方式输出类的属性，条理清晰。<br>18.尽量使用不可变对象。<br>19.使用清晰而协调的命名方式。参考Objective C编程规范。<br>20.为私有方法名添加前缀。<br>21.理解OC的错误模型。OC在遇到极其严重的错误后，会抛出异常，程序会退出（crash），所以不用太考虑异常安全。如果不太严重的错误，可以通过设置返回nil/0，或者NSError。<br>22.理解NSCopying协议。</p>
<ul>
<li>实现NSCopying协议。</li>
<li>重写<code>copyWithZone</code>方法。</li>
<li><p>如果类中有可变属性，则在copyWithZone方法中同时需要对可变属性进行<code>mutableCopy</code>。<br>举个例子：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">EOCPerson</span> : <span class="title">NSObject</span>&lt;<span class="title">NSCopying</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">copy</span>)<span class="built_in">NSString</span> * firstname;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">copy</span>)<span class="built_in">NSString</span> * lastname;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)initWithFirstName:(<span class="built_in">NSString</span> *)fisrtname lastName:(<span class="built_in">NSString</span> *)lastname;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#import <span class="title">"EOCPerson.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">EOCPerson</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSMutableSet</span> * _friends;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">id</span>)initWithFirstName:(<span class="built_in">NSString</span> *)fisrtname lastName:(<span class="built_in">NSString</span> *)lastname&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> == [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">        _firstname = firstname;</span><br><span class="line">        _lastname  = lastname;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)copyWithZone:(<span class="built_in">NSZone</span> *)zone&#123;</span><br><span class="line"></span><br><span class="line">    EOCPerson *<span class="keyword">copy</span> = [[[<span class="keyword">self</span> class] allocWithZone:zone] initWithFirstName:_firstname lastName:_lastname];</span><br><span class="line">    <span class="keyword">copy</span>-&gt;_friends = [_friends mutableCopy];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">copy</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>要点：</p>
<ul>
<li>自定义对象若想要进行copy操作，需实现NSCopying协议。</li>
<li>自定义对象若分为可变和不可变版本，则需实现NSCopying和NSMutableCopying协议。</li>
<li>复制对象时需要考虑使用浅拷贝还是深拷贝。一般应该尽量使用浅拷贝。</li>
<li>自定义对象若需要深拷贝，则可以新增一个专门执行深拷贝的方法。</li>
</ul>
</li>
</ul>
<h2 id="4">第四章 协议与分类</h2>

<p>23.通过委托与数据源协议进行对象间通信<br>24.将类的实现代码分散到数个分类（category）之中。<br>25.总是为第三方分类名称前加前缀。<br>26.尽量不要在分类中声明属性（当然非要做也可）<br>27.使用<code>class-continuation分类</code>（匿名分类）隐藏实现细节<br>28.通过协议提供匿名对象。例如 id<nscopying>,id<eocdelegate>。任意一个遵守了上述协议的对象都可以赋值给这个属性。</eocdelegate></nscopying></p>
<h2 id="5">第五章 内存管理</h2>

<p>29.理解引用计数。<br>30.以ARC简化引用计数。<br>31.在dealloc方法中只释放引用并解除监听。<br>32.编写“异常安全代码”时应留意内存管理问题。<br>33.以弱引用避免循环引用。<br>34.以“自动释放池”降低内存峰值。<br>35.使用<code>Zombie Object</code>调试内存问题。<br>36.不要使用retainCount。ARC下已废弃。</p>
<h2 id="6">第六章 GCD</h2>

<p>37.理解block。重点看一下block的内部结构那一节。</p>
<ul>
<li>block中的invoke变量，是一个函数指针，类型为<code>void(*)(void *,_)</code>指向了block的实现代码（需要执行的函数）。</li>
<li>block中的descriptor是一个结构体指针。该结构体中包含了这个block的一些信息，如block的size。</li>
<li>block还会把从外部捕获的变量拷贝一份，放在descriptor变量的后面。拷贝的并不是对象本身，而是这些对象的指针变量。invoke函数把block对象本身作为参数传递进来，就是为了能   拿到block捕获的这些变量。</li>
<li>block被定义时是分配在栈内存中。所以需要copy一份，复制到堆内存中，就可以在外部使用。<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//栈block：</span></span><br><span class="line"><span class="keyword">void</span>(^block)();</span><br><span class="line">  <span class="keyword">if</span> (<span class="comment">/* condition */</span>) &#123;</span><br><span class="line">    block = ^()&#123; <span class="built_in">NSLog</span>(<span class="string">@"Block in Stack"</span>); &#125;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    block = ^()&#123; <span class="built_in">NSLog</span>(<span class="string">@"Block in Stack still"</span>); &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  block();</span><br><span class="line"></span><br><span class="line"><span class="comment">//堆block：</span></span><br><span class="line"><span class="keyword">void</span>(^block)();</span><br><span class="line">  <span class="keyword">if</span> (<span class="comment">/* condition */</span>) &#123;</span><br><span class="line">    block = [^()&#123; <span class="built_in">NSLog</span>(<span class="string">@"Block in Heap"</span>); &#125; <span class="keyword">copy</span>];</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    block = [^()&#123; <span class="built_in">NSLog</span>(<span class="string">@"Block in Heap"</span>); &#125; <span class="keyword">copy</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  block();</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局block：</span></span><br><span class="line">  <span class="keyword">void</span> (^block)() = ^()&#123; <span class="built_in">NSLog</span>(<span class="string">@"I'm a global block"</span>);&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>38.为常用的block创建typedef。<br>39.用handler块来降低代码分散。常用于异步任务时。<br>40.使用block时注意不要出现循环引用。<br>41.多用dispatch queue，少用同步锁。例如涉及到数据的存取。<br>    GCD以前，有两种实现锁的方式：<br>    1.@synchronized(self){ … }.这种方式会降低代码执行效率，因为花括号内的代码都共用一个同步锁，且顺序执行。<br>    2.使用NSLock。<code>lock()</code>方法和<code>unlock()</code>方法。也可以使用递归锁<code>NSRecursiveLock</code>,线程能够多次持有该锁，而不会出现死锁现象。<br>    例子：属性的读取和设置中。</p>
<p>42.多用GCD，少用performeSelector.</p>
<ul>
<li><code>performSelector</code>系列方法在内存管理方面容易有陷阱。编译器无法确定其将要执行的SEL具体是什么，因此无法通过ARC在编译期插入内存管理方法。</li>
<li><code>performSelector</code>能够处理的<code>SEL</code>有点局限，选择器的返回类型和参数个数都有限制。</li>
</ul>
<p>43.掌握GCD和OperationQueue操作队列的使用时机。<br>  执行后台任务时，操作队列更有优势。<br>  使用<code>NSOperation和NSOperationQueue</code>的好处：</p>
<ul>
<li>取消某个操作。注意：可以取消的是队列中还没有执行的任务。</li>
<li>指定操作间的依赖关系。</li>
<li>通过KVO监测NSOperation对象的属性。</li>
<li>指定Operation的优先级。</li>
<li>重用operations。</li>
</ul>
<p>44.通过Dispatch_group机制，根据系统资源状况来执行任务</p>
<ul>
<li>dispatch_apply. 这个会阻塞当前线程。所以不能把主线程作为该方法执行的线程参数。</li>
</ul>
<p>45.使用<code>dispatch_once</code>来执行只需要运行一次的线程安全代码。常用于单例模式。<br>46.不要使用dispatch_get_current_queue</p>
<h2 id="7">第七章 系统框架</h2>

<p>47.熟悉系统框架。<br>  Fundation 和 CoreFoundation。</p>
<ul>
<li>无缝桥接，toll-free-bridging,可以将CoreFoundation中的C语言数据结构转换为Foundation中的对象，也可以反向转换。</li>
</ul>
<p>48.多用块枚举，少用for循环。</p>
<ol>
<li>for(int i=0;i&lt;max;i++){}</li>
<li>NSEnumerator. <code>allObjects()</code> 和<code>nextObject()</code>方法。</li>
<li>快速遍历 fast enumeration. for in<br>基于block的遍历方式<br><code>- enumerateObjectesUsingBlock:(void(^)(id object,NSUInteger index,BOOL *stop))block</code><br>…其他方法</li>
</ol>
<p>49.对自定义内存管理语义的collection集合类使用无缝桥接。</p>
<ul>
<li>__bridge</li>
<li>__bridge_retained</li>
<li><p>__bridge_transfer</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *nameArray = @[<span class="string">@"g"</span>,<span class="string">@"c"</span>,<span class="string">@"d"</span>];</span><br><span class="line"><span class="comment">//正向桥接：Foundation对象-&gt;CoreFoundation数据结构</span></span><br><span class="line"><span class="built_in">CFArrayRef</span> a<span class="built_in">CFArray</span> = (__bridge <span class="built_in">CFArrayRef</span>)nameArray  ;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"CFArray's count is %li"</span>,<span class="built_in">CFArrayGetCount</span>(a<span class="built_in">CFArray</span>));</span><br><span class="line"></span><br><span class="line"><span class="built_in">CFArrayRef</span> b<span class="built_in">CFArray</span> = (__bridge_retained <span class="built_in">CFArrayRef</span>)nameArray;</span><br><span class="line"><span class="comment">//或者用</span></span><br><span class="line">b<span class="built_in">CFArray</span> = <span class="built_in">CFBridgingRetain</span>(nameArray);</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"CFArray's count is %li"</span>,<span class="built_in">CFArrayGetCount</span>(b<span class="built_in">CFArray</span>));</span><br><span class="line"><span class="built_in">CFRelease</span>(b<span class="built_in">CFArray</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSArray</span> *names = (<span class="built_in">NSArray</span> *)(__bridge_transfer <span class="built_in">NSArray</span> *)a<span class="built_in">CFArray</span>;</span><br><span class="line"><span class="comment">//    //或者用</span></span><br><span class="line"><span class="comment">//    NSArray * names = CFBridgingRelease(aCFArray);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,names);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>50.构建缓存时使用NSCache而不是NSDictionary。</p>
<p>51.精简initialize和load的实现代码。<br>    两个都是类的初始化方法。<br>    1.<code>load()</code><br>    对于加入运行时的类class和分类category来说，当包含类和分类的程序库载入系统时，必定会调用<code>+ (void)load</code>方法，且只调用一次。<br>    对于iOS系统，是在应用程序启动的时候。对于Mac OS X来说更自由，因为可以使用动态加载<code>dynamic loading</code>这种特性,等应用程序启动完成之后再去加载程序库。若分类和类中都定义了load方法，则先调用类的，再调用分类的。<br>    load方法一般只用来调试程序，而不是在其中做什么操作。<br>    2.<code>initialize</code><br>    对于每个类来说，该方法会在首次使用该类之前调用，且只调用一次。它是由运行时系统来调用，而不是由代码调用。<br>  与load的区别：</p>
<ul>
<li>惰性调用。只有当用到这个类时，才会被调用。如果某个类没有被使用，则不会被调用。而程序必须阻塞把所有类的load方法执行完才能继续。</li>
<li>执行方法时运行时系统的状态。<code>initializer</code>被执行时，runtime system是正常状态的。而<code>load</code>被执行时，runtime system是脆弱状态的。(这个脆弱状态是指最好不要在load方法中使用别的类)</li>
<li><code>initialize</code>方法遵循继承调用。即子类即使没有实现initialize方法，也会调用父类的initialize方法。而load方法则不会，子类若没有实现load方法，也不会去调用父类的load。</li>
</ul>
<p>52.别忘了NSTimer会保留其目标对象。</p>
<ul>
<li>NSTimer对象会引用其目标对象，直到计时器本身失效为止，调用<code>invalidate</code>方法可令计时器失效，另外，一次性的计时器在触发完任务之后也会失效。</li>
<li>反复执行任务的计时器，很容易引起循环引用。</li>
<li>可以扩充NSTimer的功能，用block来打破这种循环引用。必须创建分类，将相关实现代码加入其中。</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//分类文件.h/.m</span></span><br><span class="line">  <span class="preprocessor">#import <span class="title">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">@interface</span> <span class="title">NSTimer</span> (<span class="title">BlockTimer</span>)</span></span><br><span class="line"></span><br><span class="line">  + (<span class="built_in">NSTimer</span> *)bt_scheduledTimerWithTimeInterval:(<span class="built_in">NSTimeInterval</span>)interval block:(<span class="keyword">void</span>(^)())block repeats:(<span class="built_in">BOOL</span>)repeats;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="preprocessor">#import <span class="title">"NSTimer+BlockTimer.h"</span></span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">@implementation</span> <span class="title">NSTimer</span> (<span class="title">BlockTimer</span>)</span></span><br><span class="line"></span><br><span class="line">  + (<span class="built_in">NSTimer</span> *)bt_scheduledTimerWithTimeInterval:(<span class="built_in">NSTimeInterval</span>)interval block:(<span class="keyword">void</span>(^)())block repeats:(<span class="built_in">BOOL</span>)repeats&#123;</span><br><span class="line">      <span class="keyword">return</span> [<span class="keyword">self</span> scheduledTimerWithTimeInterval:interval target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(bt_doSomething:) userInfo:[block <span class="keyword">copy</span>] repeats:repeats];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  + (<span class="keyword">void</span>)bt_doSomething:(<span class="built_in">NSTimer</span> *)timer&#123;</span><br><span class="line">      <span class="keyword">void</span>(^block)() = timer<span class="variable">.userInfo</span>;</span><br><span class="line">      <span class="keyword">if</span> (block) &#123;</span><br><span class="line">          block();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在调用时</span></span><br><span class="line">  __<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>)weakSelf = <span class="keyword">self</span>;</span><br><span class="line">  _timer = [<span class="built_in">NSTimer</span> bt_scheduledTimerWithTimeInterval:<span class="number">1</span> block:^&#123;</span><br><span class="line">      <span class="comment">//不需要再转成strong也可以啊！？</span></span><br><span class="line">      [weakSelf printName:<span class="string">@"hello"</span>];</span><br><span class="line"></span><br><span class="line">      ViewController * strongSelf = weakSelf;</span><br><span class="line">      [strongSelf printName:<span class="string">@"world"</span>];</span><br><span class="line"></span><br><span class="line">  &#125; repeats:<span class="literal">YES</span>];</span><br></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[iOS 蓝牙4.0开发]]></title>
      <url>http://koalahl.github.io/2016/03/08/iOS-%E8%93%9D%E7%89%994-0%E5%BC%80%E5%8F%91/</url>
      <content type="html"><![CDATA[<p>iOS 蓝牙4.0开发</p>
<h2>背景：</h2><br>1.iOS的蓝牙不能用来传输文件。<br>2.iOS与iOS设备之间进行数据通信，使用gameKit.framework<br>3.iOS与其他非iOS设备进行数据通信，使用coreBluetooth.framework<br><br><a id="more"></a><br><h2>iOS中蓝牙的实现方案</h2>


<p>iOS中提供了4个框架用于实现蓝牙连接<br>GameKit.framework（用法简单）<br>只能用于iOS设备之间的连接，多用于游戏（比如五子棋对战），从iOS7开始过期</p>
<p>MultipeerConnectivity.framework<br>只能用于iOS设备之间的连接，从iOS7开始引入，主要用于文件共享（仅限于沙盒的文件）</p>
<p>ExternalAccessory.framework<br>可用于第三方蓝牙设备交互，但是蓝牙设备必须经过苹果MFi认证（国内较少）</p>
<p>CoreBluetooth.framework（时下热门）<br>可用于第三方蓝牙设备交互，必须要支持蓝牙4.0<br>硬件至少是4s，系统至少是iOS6<br>蓝牙4.0以低功耗著称，一般也叫BLE（BluetoothLowEnergy）<br>目前应用比较多的案例：运动手坏、嵌入式设备、智能家居</p>
<p>下面具体介绍使用CoreBluetooth.framework的代码步骤：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//蓝牙系统库</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#import <span class="title">&lt;CoreBluetooth/CoreBluetooth.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//必须要由UUID来唯一标示对应的service和characteristic</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#define kServiceUUID @<span class="title">"5C476471-1109-4EBE-A826-45B4F9D74FB9"</span></span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#define kCharacteristicHeartRateUUID @<span class="title">"82C7AC0F-6113-4EC9-92D1-5EEF44571398"</span></span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#define kCharacteristicBodyLocationUUID @<span class="title">"537B5FD6-1889-4041-9C35-F6949D1CA034"</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()&lt;<span class="title">CBCentralManagerDelegate</span>,<span class="title">CBPeripheralDelegate</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">strong</span>)CBCentralManager * centralManager;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">strong</span>)CBPeripheral     * peripheral;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p></p><h3 id="create">创建中心角色</h3><br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">&lt;CoreBluetooth/CoreBluetooth.h&gt;</span> </span></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化蓝牙 central manager</span></span><br><span class="line"></span><br><span class="line">    _centralManager = [[CBCentralManager alloc]initWithDelegate:<span class="keyword">self</span> queue:dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>) options:<span class="literal">nil</span>];    </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p>
<p></p><h3 id="scan">扫描外设</h3><br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[manager scanForPeripheralsWithServices:<span class="literal">nil</span> options:@&#123;CBCentralManagerRestoredStateScanOptionsKey:@(<span class="literal">YES</span>)&#125;];</span><br></pre></td></tr></table></figure><p></p>
<p></p><h3 id="connect">连接外设</h3><br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)centralManager:(CBCentralManager *)central didDiscoverPeripheral:(CBPeripheral *)peripheral advertisementData:(<span class="built_in">NSDictionary</span> *)advertisementData RSSI:(<span class="built_in">NSNumber</span> *)RSSI </span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">if</span>([peripheral<span class="variable">.name</span>  isEqualToString:BLE_SERVICE_NAME])&#123;</span><br><span class="line">                [<span class="keyword">self</span> connect:peripheral];</span><br><span class="line">        &#125;</span><br><span class="line">s); </span><br><span class="line">&#125;       </span><br><span class="line"> </span><br><span class="line">-(<span class="built_in">BOOL</span>)connect:(CBPeripheral *)peripheral&#123;</span><br><span class="line">        <span class="keyword">self</span><span class="variable">.manager</span><span class="variable">.delegate</span> = <span class="keyword">self</span>;</span><br><span class="line">        [<span class="keyword">self</span><span class="variable">.manager</span> connectPeripheral:peripheral</span><br><span class="line">                                options:[<span class="built_in">NSDictionary</span> dictionaryWithObject:[<span class="built_in">NSNumber</span> numberWithBool:<span class="literal">YES</span>] forKey:CBConnectPeripheralOptionNotifyOnDisconnectionKey]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p>
<p></p><h3 id="service">扫描外设中的服务和特征</h3><br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)centralManager:(CBCentralManager *)central didConnectPeripheral:(CBPeripheral *)peripheral </span><br><span class="line">&#123; </span><br><span class="line">       </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Did connect to peripheral: %@"</span>, peripheral); </span><br><span class="line">    _testPeripheral = peripheral; </span><br><span class="line">       </span><br><span class="line">    [peripheral setDelegate:<span class="keyword">self</span>];  &lt;br&gt;<span class="comment">//查找服务</span></span><br><span class="line">    [peripheral discoverServices:<span class="literal">nil</span>]; </span><br><span class="line">       </span><br><span class="line">       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p>
<p></p><h3 id="find">发现服务：</h3><br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)peripheral:(CBPeripheral *)peripheral didDiscoverServices:(<span class="built_in">NSError</span> *)error </span><br><span class="line">&#123; </span><br><span class="line">   </span><br><span class="line">       </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"didDiscoverServices"</span>); </span><br><span class="line">       </span><br><span class="line">    <span class="keyword">if</span> (error) </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Discovered services for %@ with error: %@"</span>, peripheral<span class="variable">.name</span>, [error localizedDescription]); </span><br><span class="line">           </span><br><span class="line">        <span class="keyword">if</span> ([<span class="keyword">self</span><span class="variable">.delegate</span> respondsToSelector:<span class="keyword">@selector</span>(DidNotifyFailConnectService:withPeripheral:error:)]) </span><br><span class="line">            [<span class="keyword">self</span><span class="variable">.delegate</span> DidNotifyFailConnectService:<span class="literal">nil</span> withPeripheral:<span class="literal">nil</span> error:<span class="literal">nil</span>]; </span><br><span class="line">           </span><br><span class="line">        <span class="keyword">return</span>; </span><br><span class="line">    &#125; </span><br><span class="line">       </span><br><span class="line">   </span><br><span class="line">    <span class="keyword">for</span> (CBService *service <span class="keyword">in</span> peripheral<span class="variable">.services</span>) </span><br><span class="line">    &#123; </span><br><span class="line">         <span class="comment">//发现服务</span></span><br><span class="line">        <span class="keyword">if</span> ([service<span class="variable">.UUID</span> isEqual:[CBU<span class="built_in">UID</span> U<span class="built_in">UIDWithString</span>:U<span class="built_in">UIDSTR_ISSC_PROPRIETARY_SERVICE</span>]]) </span><br><span class="line">        &#123; </span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"Service found with UUID: %@"</span>, service<span class="variable">.UUID</span>);  &lt;br&gt;<span class="comment">//查找特征</span></span><br><span class="line">            [peripheral discoverCharacteristics:<span class="literal">nil</span> forService:service]; </span><br><span class="line">            <span class="keyword">break</span>; </span><br><span class="line">        &#125; </span><br><span class="line">           </span><br><span class="line">           </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p>
<p></p><h3 id="findChac">发现服务中的特征：</h3><br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)peripheral:(CBPeripheral *)peripheral didDiscoverCharacteristicsForService:(CBService *)service error:(<span class="built_in">NSError</span> *)error</span><br><span class="line">&#123;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">if</span> (error)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Discovered characteristics for %@ with error: %@"</span>, service<span class="variable">.UUID</span>, [error localizedDescription]);</span><br><span class="line">         </span><br><span class="line">        [<span class="keyword">self</span> error];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"服务：%@"</span>,service<span class="variable">.UUID</span>);</span><br><span class="line">    <span class="keyword">for</span> (CBCharacteristic *characteristic <span class="keyword">in</span> service<span class="variable">.characteristics</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="comment">//发现特征</span></span><br><span class="line">            <span class="keyword">if</span> ([characteristic<span class="variable">.UUID</span> isEqual:[CBU<span class="built_in">UID</span> U<span class="built_in">UIDWithString</span>:<span class="string">@"xxxxxxx"</span>]]) &#123;</span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@"监听：%@"</span>,characteristic);&lt;br&gt;<span class="comment">//监听特征</span></span><br><span class="line">                [<span class="keyword">self</span><span class="variable">.peripheral</span> setNotifyValue:<span class="literal">YES</span> forCharacteristic:characteristic];</span><br><span class="line">            &#125;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p>
<p></p><h3 id="interact">与外设进行数据交互</h3><br>读取数据：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)peripheral:(CBPeripheral *)peripheral didUpdateValueForCharacteristic:(CBCharacteristic *)characteristic error:(<span class="built_in">NSError</span> *)error</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (error)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Error updating value for characteristic %@ error: %@"</span>, characteristic<span class="variable">.UUID</span>, [error localizedDescription]);</span><br><span class="line">        <span class="keyword">self</span><span class="variable">.error_b</span> = BluetoothError_System;</span><br><span class="line">        [<span class="keyword">self</span> error];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line"><span class="comment">//    NSLog(@"收到的数据：%@",characteristic.value);</span></span><br><span class="line">    [<span class="keyword">self</span> decodeData:characteristic<span class="variable">.value</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>写数据：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSData</span> *d2 = [[PBABluetoothDecode sharedManager] HexStringTo<span class="built_in">NSData</span>:<span class="string">@"0x02"</span>];</span><br><span class="line">                [<span class="keyword">self</span><span class="variable">.peripheral</span> writeValue:d2 forCharacteristic:characteristic type:CBCharacteristicWriteWithoutResponse];</span><br></pre></td></tr></table></figure><p></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[SDWebImage内部实现过程]]></title>
      <url>http://koalahl.github.io/2016/03/08/SDWebImage%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E8%BF%87%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p>SDWebImage内部实现过程(新版本在各方法前加上了sd_前缀，以区分UIImageView+AFNetworking中的方法)</p>
<a id="more"></a>
<p>1.入口 <code>setImageWithURL:placeholderImage:options:</code>会先把 placeholderImage 显示，然后 SDWebImageManager 根据 URL 开始处理图片。</p>
<p>2.进入 SDWebImageManager-<code>downloadWithURL:delegate:options:userInfo:</code>，交给 SDImageCache 从缓存查找图片是否已经下载 <code>queryDiskCacheForKey:delegate:userInfo:</code>.</p>
<p>3.先从内存图片缓存查找是否有图片，如果内存中已经有图片缓存，SDImageCacheDelegate 回调 <code>imageCache:didFindImage:forKey:userInfo:</code> 到 SDWebImageManager。</p>
<p>4.SDWebImageManagerDelegate 回调 <code>webImageManager:didFinishWithImage:</code>到 UIImageView+WebCache 等前端展示图片。</p>
<p>5.如果内存缓存中没有，生成 NSInvocationOperation 添加到队列开始从硬盘查找图片是否已经缓存。</p>
<p>6.根据 URLKey 在硬盘缓存目录下尝试读取图片文件。这一步是在 NSOperation 进行的操作，所以回主线程进行结果回调 notifyDelegate:。</p>
<p>7.如果上一操作从硬盘读取到了图片，将图片添加到内存缓存中（如果空闲内存过小，会先清空内存缓存）。SDImageCacheDelegate 回调 <code>imageCache:didFindImage:forKey:userInfo:</code>。进而回调展示图片。</p>
<p>8.如果从硬盘缓存目录读取不到图片，说明所有缓存都不存在该图片，需要下载图片，回调 <code>imageCache:didNotFindImageForKey:userInfo:</code>。</p>
<p>9.共享或重新生成一个下载器 SDWebImageDownloader 开始下载图片。</p>
<p>10.图片下载由 NSURLConnection 来做，实现相关 delegate 来判断图片下载中、下载完成和下载失败。</p>
<p>11.<code>connection:didReceiveData:</code>中利用 ImageIO 做了按图片下载进度加载效果。</p>
<p>12.<code>connectionDidFinishLoading:</code>数据下载完成后交给 SDWebImageDecoder 做图片解码处理。</p>
<p>13.图片解码处理在一个 NSOperationQueue 完成，不会拖慢主线程 UI。如果有需要对下载的图片进行二次处理，最好也在这里完成，效率会好很多。</p>
<p>14.在主线程 <code>notifyDelegateOnMainThreadWithInfo:</code> 宣告解码完成，<code>imageDecoder:didFinishDecodingImage:userInfo:</code> 回调给 SDWebImageDownloader。</p>
<p>15.<code>imageDownloader:didFinishWithImage:</code> 回调给 SDWebImageManager 告知图片下载完成。</p>
<p>16.通知所有的 downloadDelegates 下载完成，回调给需要的地方展示图片。</p>
<p>17.将图片保存到 SDImageCache 中，内存缓存和硬盘缓存同时保存。写文件到硬盘也在以单独 NSInvocationOperation 完成，避免拖慢主线程。</p>
<p>18.SDImageCache 在初始化的时候会注册一些消息通知，在内存警告或退到后台的时候清理内存图片缓存，应用结束的时候清理过期图片。</p>
<p>19.SDWI 也提供了 UIButton+WebCache 和 MKAnnotationView+WebCache，方便使用。</p>
<p>20.SDWebImagePrefetcher 可以预先下载图片，方便后续使用。</p>
<p>从上面流程可以看出，当你调用setImageWithURL:方法的时候，他会自动去给你干这么多事，当你需要在某一具体时刻做事情的时候，你可以覆盖这些方法。比如在下载某个图片的过程中要响应一个事件，就覆盖这个方法：</p>
<p>覆盖方法，指哪打哪，这个方法是下载imagePath2的时候响应<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SDWebImageManager *manager = [SDWebImageManager sharedManager];</span><br><span class="line"> </span><br><span class="line">[manager downloadImageWithURL:imagePath2 options:SDWebImageRetryFailed progress:^(<span class="built_in">NSInteger</span> receivedSize, <span class="built_in">NSInteger</span> expectedSize) &#123;</span><br><span class="line">     </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"显示当前进度"</span>);</span><br><span class="line">     </span><br><span class="line">&#125; completed:^(<span class="built_in">UIImage</span> *image, <span class="built_in">NSError</span> *error, SDImageCacheType cacheType, <span class="built_in">BOOL</span> finished, <span class="built_in">NSURL</span> *imageURL) &#123;</span><br><span class="line">     </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"下载完成"</span>);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure></p>
<p>当服务器更新了某一张图片资源时，客户端需要重新加载，那么就可以设置SDWebImageOption为SDWebImageRefreshCached；附上全部的SDWebImageOptions：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">NS_OPTIONS</span><span class="params">(NSUInteger, SDWebImageOptions)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * By default, when a URL fail to be downloaded, the URL is blacklisted so the library won't keep trying.</span><br><span class="line">     * This flag disable this blacklisting.</span><br><span class="line">     */</span></span><br><span class="line">    SDWebImageRetryFailed = <span class="number">1</span> &lt;&lt; <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * By default, image downloads are started during UI interactions, this flags disable this feature,</span><br><span class="line">     * leading to delayed download on UIScrollView deceleration for instance.</span><br><span class="line">     */</span></span><br><span class="line">    SDWebImageLowPriority = <span class="number">1</span> &lt;&lt; <span class="number">1</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * This flag disables on-disk caching</span><br><span class="line">     */</span></span><br><span class="line">    SDWebImageCacheMemoryOnly = <span class="number">1</span> &lt;&lt; <span class="number">2</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * This flag enables progressive download, the image is displayed progressively during download as a browser would do.</span><br><span class="line">     * By default, the image is only displayed once completely downloaded.</span><br><span class="line">     */</span></span><br><span class="line">    SDWebImageProgressiveDownload = <span class="number">1</span> &lt;&lt; <span class="number">3</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Even if the image is cached, respect the HTTP response cache control, and refresh the image from remote location if needed.</span><br><span class="line">     * The disk caching will be handled by NSURLCache instead of SDWebImage leading to slight performance degradation.</span><br><span class="line">     * This option helps deal with images changing behind the same request URL, e.g. Facebook graph api profile pics.</span><br><span class="line">     * If a cached image is refreshed, the completion block is called once with the cached image and again with the final image.</span><br><span class="line">     *</span><br><span class="line">     * Use this flag only if you can't make your URLs static with embeded cache busting parameter.</span><br><span class="line">     */</span></span><br><span class="line">    SDWebImageRefreshCached = <span class="number">1</span> &lt;&lt; <span class="number">4</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * In iOS 4+, continue the download of the image if the app goes to background. This is achieved by asking the system for</span><br><span class="line">     * extra time in background to let the request finish. If the background task expires the operation will be cancelled.</span><br><span class="line">     */</span></span><br><span class="line">    SDWebImageContinueInBackground = <span class="number">1</span> &lt;&lt; <span class="number">5</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Handles cookies stored in NSHTTPCookieStore by setting</span><br><span class="line">     * NSMutableURLRequest.HTTPShouldHandleCookies = YES;</span><br><span class="line">     */</span></span><br><span class="line">    SDWebImageHandleCookies = <span class="number">1</span> &lt;&lt; <span class="number">6</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Enable to allow untrusted SSL ceriticates.</span><br><span class="line">     * Useful for testing purposes. Use with caution in production.</span><br><span class="line">     */</span></span><br><span class="line">    SDWebImageAllowInvalidSSLCertificates = <span class="number">1</span> &lt;&lt; <span class="number">7</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * By default, image are loaded in the order they were queued. This flag move them to</span><br><span class="line">     * the front of the queue and is loaded immediately instead of waiting for the current queue to be loaded (which </span><br><span class="line">     * could take a while).</span><br><span class="line">     */</span></span><br><span class="line">    SDWebImageHighPriority = <span class="number">1</span> &lt;&lt; <span class="number">8</span>,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * By default, placeholder images are loaded while the image is loading. This flag will delay the loading</span><br><span class="line">     * of the placeholder image until after the image has finished loading.</span><br><span class="line">     */</span></span><br><span class="line">    SDWebImageDelayPlaceholder = <span class="number">1</span> &lt;&lt; <span class="number">9</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * We usually don't call transformDownloadedImage delegate method on animated images,</span><br><span class="line">     * as most transformation code would mangle it.</span><br><span class="line">     * Use this flag to transform them anyway.</span><br><span class="line">     */</span></span><br><span class="line">    SDWebImageTransformAnimatedImage = <span class="number">1</span> &lt;&lt; <span class="number">10</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[QRCode与Core Image]]></title>
      <url>http://koalahl.github.io/2016/03/05/QRCode%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/</url>
      <content type="html"><![CDATA[<p>网上已经有很多关于二维码方面的文章了，写这篇文章的目的是因为要记录一个关于保存二维码图片到相册的问题，顺便回顾一下iOS开发中使用二维码的历史。好了，废话少说，让我们开始吧！</p>
<h2>要讨论的问题</h2><br>在参考<a href="http://www.appcoda.com/qr-code-generator-tutorial/" target="_blank" rel="external">Building a QR Code Generator with Core Image Filters</a>这篇文章，完成了二维码生成的栗子。<br>二维码的扫描则是用了AVFoundation框架来编写的<a href="https://github.com/koalahl/HLQRCode" target="_blank" rel="external">Github·HLQRCode</a>。最后想把生成的二维码图片保存到相册中却没有成功。<br>参考了网上的代码，使用了CIImag-&gt;CGImage-&gt;writeImageToAlbum的方式。<br><br><a id="more"></a><br>代码如下：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CIContext</span> * context = [<span class="built_in">CIContext</span> contextWithOptions:<span class="literal">nil</span>];</span><br><span class="line"><span class="built_in">CGImageRef</span> cgimg = [context create<span class="built_in">CGImage</span>:<span class="keyword">self</span><span class="variable">.qrcodeImg</span> fromRect:[<span class="keyword">self</span><span class="variable">.qrcodeImg</span> extent] ];</span><br><span class="line"></span><br><span class="line">ALAssetsLibrary *library = [[ALAssetsLibrary alloc] init];</span><br><span class="line">[library writeImageToSavedPhotosAlbum:cgimg metadata:[<span class="keyword">self</span><span class="variable">.qrcodeImg</span> properties] completionBlock:^(<span class="built_in">NSURL</span> *assetURL, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(error != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        msg = <span class="string">@"保存图片失败"</span> ;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,assetURL);</span><br><span class="line">        msg = <span class="string">@"保存图片成功"</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">UIAlertView</span> *alert = [[<span class="built_in">UIAlertView</span> alloc] initWithTitle:<span class="literal">nil</span></span><br><span class="line">                                                    message:msg</span><br><span class="line">                                                   delegate:<span class="keyword">self</span></span><br><span class="line">                                          cancelButtonTitle:<span class="string">@"确定"</span></span><br><span class="line">                                          otherButtonTitles:<span class="literal">nil</span>];</span><br><span class="line">    </span><br><span class="line">    [alert show];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><br><br>但是这样无论怎么样都无法在相册中看到保存的二维码图片。还报错<code>message &quot;BSXPCMessage received error for message: Connection interrupted&quot;</code>。对比参考的代码都是一样的，却找不出原因。我就在文章评论中留言问了这个问题，后来一个朋友提出了解决方案，仔细一看顿时恍然大悟。<br><br><h2>解决方式及要点</h2>

<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CIContext</span> * context = [<span class="built_in">CIContext</span> contextWithOptions:@&#123;k<span class="built_in">CIContextUseSoftwareRenderer</span>:@YES&#125;];</span><br></pre></td></tr></table></figure>
<p>看到区别了吗？是的，多了一个option参数<code>kCIContextUseSoftwareRenderer</code>.然后在development doc中查看了关于<code>contextWithOptions</code>方法的描述：<br>contextWithOptions:<br><blockquote><p>You can create a CPU-based context by providing the key kCIContextUseSoftwareRenderer. A CPU-based context supports larger input and output images than a GPU-based context. It also allows your app to perform processing in the background, such as when saving the rendered output to the Photo Library.</p>
<p>GPU rendering is faster than CPU rendering, but the resulting image is not displayed on the device until after is it copied to CPU memory and converted to another image type, such as a UIImage object.</p>
<footer><strong>@Apple Development Doc</strong><cite><a href="https://developer.apple.com/library/prerelease/ios/documentation/GraphicsImaging/Reference/QuartzCoreFramework/Classes/CIContext_Class/index.html#//apple_ref/occ/clm/CIContext/contextWithOptions:" target="_blank" rel="external">developer.apple.com/library/prerelease/ios/documentation/GraphicsImaging/Reference/QuartzCoreFramework/Classes/CIContext_Class/index.html#//apple_ref/occ/clm/CIContext/contextWithOptions:</a></cite></footer></blockquote></p>
<p>顿时觉得自己当时好笨，都没有想到去查一下开发文档。o(╯□╰)o</p>
<ul>
<li>NSString *kCIContextOutputColorSpace;       - A key for the color space to use for images before they are rendered to the context. 使用OpenGLES</li>
<li>NSString *kCIContextWorkingColorSpace;      - A key for the color space to use for image operations. 使用OpenGLES</li>
<li>NSString *kCIContextUseSoftwareRenderer;    - A key for enabling software renderer use. If the associated NSNumber object is YES, then the software renderer is required. 使用CPU</li>
<li>NSString *kCIContextPriorityRequestLow;     - A key for enabling low-priority GPU use.</li>
<li>NSString *kCIContextWorkingFormat;          - An option for the color format to use for intermediate results when rendering with the context.</li>
</ul>
<p><code>contextWithOptions</code>方法默认是在GPU上处理图像。根据不同的参数设置不同的处理方式。<br>以上这些其实不是很理解，囧。具体参考<a href="https://developer.apple.com/library/prerelease/ios/documentation/GraphicsImaging/Reference/QuartzCoreFramework/Classes/CIContext_Class/index.html#//apple_ref/doc/constant_group/Context_Options" target="_blank" rel="external">Context Options</a></p>
<p></p><h2>二维码的历史</h2><br>在iOS7以前，iOS开发使用二维码都是使用第三方库。比较流行的就是<code>ZXing</code>和<code>Zbar</code>了。<br>不说它们的实现原理了，遇到最多的问题就是与其他第三方库（比如支付宝SDK，百度地图SDK）继承在一起时出现duplicate symbol了。解决方法也很麻烦：修改源码，重新编译静态库.a文件。<p></p>
<p>不过现在很少用到二维码了，要用也要用系统自带的框架哟~！</p>
<p></p><h2>总结</h2><br>1.遇到问题先查看开发文档，再Google！<br>2.研究问题要深入！<br>后面学习一下Core Image的东西，还有与之的GPUImage库！<p></p>
<p></p><h2>参考文章</h2><br><a href="https://developer.apple.com/library/prerelease/ios/documentation/GraphicsImaging/Conceptual/CoreImaging/ci_intro/ci_intro.html#//apple_ref/doc/uid/TP30001185" target="_blank" rel="external">Core Image Programming Guide</a><br><a href="http://stackoverflow.com/questions/26065808/bsxpcmessage-received-error-for-message-connection-interrupted/29872829#29872829" target="_blank" rel="external">BSXPCMessage received error for message: Connection interrupted</a><p></p>
<div align="center"><br>    <img src="http://i3.sinaimg.cn/edu/2015/0724/U1151P42DT20150724094518.jpg" alt="girl"><br></div>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Xib与之关联的自定义Class]]></title>
      <url>http://koalahl.github.io/2016/03/04/Xib%E4%B8%8E%E4%B9%8B%E5%85%B3%E8%81%94%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89Class/</url>
      <content type="html"><![CDATA[<p>最近遇到了一个问题：点击【猜你喜欢】视图进入商品详情后，再返回到首页时，没有原先的数据了。<br> <img src="/img/被新生成的view覆盖.png" width="300" height="588" alt="被新生成的view覆盖" align="center"><br>打开Reveal看了下层级关系，原来是被二次生成的界面覆盖了。再细看一下，上面的视图都被二次生成了。真是哔了狗了！<br><img src="/img/reveal view UI hierarchy 2.png" alt="reveal view UI hierarchy"><br><img src="/img/reveal view UI hierarchy.png" alt="reveal view UI hierarchy"><br><a id="more"></a></p>
<p></p><h2><code>drawRect</code>方法</h2><br>好吧，修改代码吧。因为这些视图都是在xib上创建好了，另外新建了与之对应的自定义类，所以都直接用的<code>drawRect</code>方法去初始化UI元素。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)drawRect:(CGRect)rect &#123;&#10;&#10;    [self initSubViews];&#10;&#125;</span><br></pre></td></tr></table></figure><p></p>
<blockquote><p>The default implementation of this method does nothing. Subclasses that use technologies such as Core Graphics and UIKit to draw their view’s content should override this method and implement their drawing code there. You do not need to override this method if your view sets its content in other ways. For example, you do not need to override this method if your view just displays a background color or if your view sets its content directly using the underlying layer object.</p>
<p>If you subclass UIView directly, your implementation of this method does not need to call super. However, if you are subclassing a different view class, you should call super at some point in your implementation.<br>This method is called when a view is first displayed or when an event occurs that invalidates a visible part of the view. You should never call this method directly yourself. To invalidate part of your view, and thus cause that portion to be redrawn, call the setNeedsDisplay or setNeedsDisplayInRect: method instead.</p>
<footer><strong>@Apple Develop</strong><cite><a href="https://developer.apple.com/library/prerelease/ios/documentation/UIKit/Reference/UIView_Class/index.html#//apple_ref/swift/instm/UIView/c:objc(cs)UIView(im)drawRect:" target="_blank" rel="external">developer.apple.com/library/prerelease/ios/documentation/UIKit/Reference/UIView_Class/index.html#//apple_ref/swift/instm/UIView/c:objc(cs)UIView(im)drawRect:</a></cite></footer></blockquote>
<p>这里就出现了问题。在每次重新返回到首页后，<code>drawRect</code>方法又被重新调用了一次，所以生成了新的视图覆盖了原来的视图，但是又没有请求数据，所以就看不到了。<br><blockquote><p>drawRect方法只被重新调用了一次，在这之后就不会再被调用。</p>
</blockquote></p>
<p>因为为了解决这个问题，我就不用<code>drawRect</code>去初始化页面元素了，而是用了<code>initWithCorder</code>方法。<br>注意因为视图是被直接创建在xib上的，并没有执行<code>initWithFrame</code>方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)initWithCoder:(NSCoder *)aDecoder&#123;&#10;    self = [super initWithCoder:aDecoder];&#10;    if (self) &#123;&#10;        [self initSubViews];&#10;    &#125;&#10;&#10;    return self;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p></p><h2>总结</h2><br>1.尽量不要使用drawRect方法，性能下降厉害撒。<br>2.已经在xib上创建的视图，与其关联的子类中<code>initWithFrame</code>方法不会被调用。<p></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[移动IM开发要点]]></title>
      <url>http://koalahl.github.io/2016/02/28/%E7%A7%BB%E5%8A%A8IM%E5%BC%80%E5%8F%91%E8%A6%81%E7%82%B9/</url>
      <content type="html"><![CDATA[<p>个人对于IM开发中客户端与服务器之间的连接比较感兴趣，网搜一篇好文，记录下来。<br>转载于 <a href="http://xiangwangfeng.com/2015/05/20/%E7%A7%BB%E5%8A%A8IM%E5%BC%80%E5%8F%91%E9%82%A3%E4%BA%9B%E4%BA%8B/" target="_blank" rel="external">移动IM开发那些事</a></p>
<a id="more"></a>
<h2>通讯方式选择</h2><br>IM通讯方式无非两种选择:设备直连(P2P)和通过服务器中转。<br><h3>P2P</h3><br>P2P多见于局域网内聊天工具，典型的应用有:飞鸽传书，天网Maze(你懂的)等。这类软件在启动后一般做两件事情<br><br><em> 进行UDP广播:发送自己信息和接受同局域网内其他端信息
</em> 开启TCP监听:等待其他端进行连接<br><br>详细的流程可以参考<a href="http://ipmsg.org/" target="_blank" rel="external">飞鸽传书源码</a>。但是这种方式在有种种限制和不便:一方面它只适合在线的点对点消息传输，对离线，群组等业务支持不够。另一方面由于 <a href="http://zh.wikipedia.org/zh-cn/%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2" target="_blank" rel="external">NAT</a> 的存在，使得不同局域网内机器互联难度大大上升，在某些网络类型(对称NAT)下无法建立连接。<br><h3>服务器中转</h3><br>几乎所有互联网IM产品都采用服务器中转这种方式进行消息传输，相对于P2P的方式，它有如下的优点:<br><br><em> 能够支持更多P2P无法支持或支持不好的业务，如离线消息，群组，聊天室服务
</em> 方便业务逻辑的拓展和新旧版本的兼容<br><br>当然它也有自己的问题:服务器架构复杂，并发要求高。<br><br><br><h2>网络连接方式</h2><br>IM主流网络连接方式有两种:<br><br><em> 基于TCP的长连接
</em> 基于HTTP短连接PULL的方式<br><br>后者常见于WEB IM系统(当然现在很多WEB IM都是基于WebSocket实现)，它的优点是实现简单，方便开发上手，问题是流量大，服务器负载较大，消息及时性无法很好地保证，对大规模的用户量支持不够，比较适合小型的IM系统,如小网站的客户系统。<br><br>基于TCP长连接则能够更好地支持大批量用户，问题是客户端和服务器的实现比较复杂。当然也还有一些变种，如下行使用MQTT进行服务器通知/消息的下发，上行使用HTTP短连接进行指令和消息的上传。这种方式能够保证下行消息/指令的及时性，但是在弱网络下上行慢的问题还是比较严重。早期的来往就是基于这种方式。<br><br><h2>协议选择</h2>

<p>IM协议选择原则一般是:易于拓展，方便覆盖各种业务逻辑，同时又比较节约流量。后一点的需求在移动端IM上尤其重要。</p>
<p>常见的协议有:</p>
<ul>
<li><a href="http://zh.wikipedia.org/wiki/XMPP" target="_blank" rel="external">XMPP</a></li>
<li><a href="http://zh.wikipedia.org/wiki/%E4%BC%9A%E8%AF%9D%E5%8F%91%E8%B5%B7%E5%8D%8F%E8%AE%AE" target="_blank" rel="external">SIP</a></li>
<li><a href="http://mqtt.org/" target="_blank" rel="external">MQTT</a></li>
<li>私有协议</li>
</ul>
<p>XMPP协议的优点在于:协议开源，可拓展性强，在各个端(包括服务器)有各种语言的实现，开发者接入方便。但是缺点也是不少:XML表现力弱，有太多冗余信息，流量大，实际使用时有大量天坑。</p>
<p>SIP协议多用于VOIP相关的模块，是一种文本协议，由于我并没有实际用过，所以不做评论，但从它是文本协议这一点几乎可以断定它的流量不会小。</p>
<p>MQTT的优点是协议简单，流量少，但是它并不是一个专门为IM设计的协议，多使用于推送。</p>
<p>而市面上几乎所有主流IM APP都是是使用私有协议，一个被良好设计的私有协议一般有如下优点:高效，节约流量(一般使用二进制协议)，安全性高，难以破解。缺点则是在开发初期没有现有样列可以参考，对于设计者的要求比较高。</p>
<p>一个好的协议需要满足如下条件:高效，简洁，可读性好，节约流量，易于拓展，同时又能够匹配当前团队的技术堆栈。基于如上原则，我们可以推出:<br>如果团队小，团队技术在IM上积累不够可以考虑使用XMPP或者MQTT+HTTP短连接的实现。反之可以考虑自己设计和实现私有协议。</p>
<h2>私有协议的设计</h2> 

<h3>序列化选择</h3><br>移动互联网相对于有线网络最大特点是:带宽低，延迟高，丢包率高和稳定性差，流量费用高。所以在私有协议的序列化上一般使用二进制协议，而不是文本协议。常见的二进制序列化库有<a href="https://github.com/google/protobuf" target="_blank" rel="external">protobuf</a>和<a href="http://msgpack.org/" target="_blank" rel="external">MessagePack</a>，当然你也可以自己实现自己的二进制协议序列化和反序列的过程，比如蘑菇街的<a href="https://github.com/mogujie/TeamTalk" target="_blank" rel="external">TeamTalk</a>。但是前面二者无论是可拓展性还是可读性都完爆TeamTalk(TeamTalk连Variant都不支持，一个int传输时固定占用4个字节)，所以大部分情况下还是不推荐自己去实现二进制协议的序列化和反序列化过程。<br><br><h3>协议格式设计</h3>

<p>基于TCP的应用层协议一般都分为包头和包体(如HTTP)，IM协议也不例外。包头一般用于表示每个请求/反馈的公共部分，如包长，请求类型，返回码等。<br>而包头则填充不同请求/反馈对应的信息。</p>
<p>一个最简单的包头可以定义为</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> PackHeader</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int32_t</span>     length_;    <span class="comment">//包长度</span></span><br><span class="line">    <span class="keyword">int32_t</span>     serial_;    <span class="comment">//包序列号</span></span><br><span class="line">    <span class="keyword">int32_t</span>     command_;   <span class="comment">//包请求类型</span></span><br><span class="line">    <span class="keyword">int32_t</span>     code_;      <span class="comment">//返回码</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>以心跳包为例，假设当前的serial为1，心跳包的command为10，那么使用MessagePack做序列化时:length=4，serial=1，command=10，code=0，每个字段各占一个字节，包体为空，仅需要4个字节。</p>
<p>当然这是最简单的一个例子，面对真正的业务逻辑时，包体里面会需要塞入更多地信息，这个需要开发根据自己的业务逻辑总结公共部分,如为了兼容加入的协议版本号,为了负载均衡加入的模块id等。</p>
<p></p><h2>其他问题</h2><br>上面就是一个IM系统大致的选型过程:通讯方式，连接方式，协议选择，协议设计。但是实际开发过程中还有大量的问题需要处理。<p></p>
<p></p><h3>协议加密</h3><br>为了保证协议不容易被破解，市面上几乎所有主流IM都会对协议进行加密传输。常见的流程和HTTPS加密相似:建立连接后，客户端和服务器进行进行协商，最终客户端获得一个当前Sessino的秘钥，后续的数据传输都通过这个秘钥进行加解密。一般出于效率的考虑都会采用流式加密，如RC4。而前期协商过程则推荐使用RSA等非对称加密以增加破解难度。<p></p>
<p></p><h3>快速连接(登录)</h3><br>对iOS APP而言，因为没有真后台的存在，APP每次启动基本都需要一次重连登录(短时间内切换除外)，所以如何快速重连重登就非常重要。常见的优化思路如下:<p></p>
<ul>
<li>本地缓存服务器IP并定期刷新。移动网络调优可以参考<a href="http://xiangwangfeng.com/2013/10/16/iOS%E7%A7%BB%E5%8A%A8%E7%BD%91%E7%BB%9C%E8%B0%83%E4%BC%98%E9%82%A3%E4%BA%9B%E4%BA%8B/" target="_blank" rel="external">《iOS移动网络调优那些事》</a>。</li>
<li>合并部分请求。如加密和登录操作可以合并为同一个操作，这样就可以减少一次不必要的网络请求来回的时间。</li>
<li>简化登录后的同步请求，部分同步请求可以推迟到UI操作时进行，如群成员信息刷新。</li>
</ul>
<p></p><h3>连接保持</h3><br>一般APP实现连接保持的方式无非是采用应用层的心跳，通过心跳包的超时和其他条件(网络切换)来执行重连操作。那么问题来了:为什么要使用应用层心跳和如何设计应用层心跳。<p></p>
<p>众所周知TCP协议是有KEEPALIVE这个设置选项，设置为KEEPALIVE后，客户端每隔N秒(默认是7200s)会向服务器发送一个发送心跳包。但实际操作中我们更多的时是使用应用层心跳。原因如下:</p>
<ul>
<li>KEEPALIVE对服务器负载压力比较大(服务器大大是这么说的…)</li>
<li>socks代理对KEEPALIVE并不支持</li>
<li>部分复杂情况下KEEPALIVE会失效，如路由器挂掉，网线(移动端没有网线…)直接被拔除</li>
</ul>
<p>移动端在实际操作时为了节约流量和电量一般会在心跳包上做一些小优化</p>
<ul>
<li>精简心跳包，保证一个心跳包大小在10字节之内</li>
<li>心跳包只在空闲时发送 </li>
<li>根据APP前后台状态调整心跳包间隔 (主要是安卓)</li>
</ul>
<p></p><h3>消息可达</h3><br>在移动网络下，丢包，网络重连等情况非常之多，为了保证消息的可达，一般需要做消息回执和重发机制。参考易信，每条消息会最多会有3次重发，超时时间为15秒，同时在发送之前会检测当前连接状态，如果当前连接并没有正确建立，缓存消息且定时检查(每隔2秒检查一次，检查15次)。所以一条消息在最差的情况下会有2分钟左右的重试时间，以保证消息的可达。<p></p>
<p>因为重发的存在，接受端偶尔会收到重复消息，这种情况下就需要接收端进行去重。通用的做法是每条消息都带上自己唯一的message id(一般是uuid)。</p>
<p></p><h3>文件上传优化</h3><br>IM消息(包括SNS模块)内包含大量的文件上传的需求，如何优化文件的上传就成了一个比较大的主题。常见有下面这些优化思路:<p></p>
<ul>
<li>将上传流程提前:音频提供边录边传。朋友圈的图片进行预上传，选择图片后用户一般会进行文本输入，在这段时间内后台就可以默默将选好的图片进行上传。</li>
<li>提供闪电上传的方式:服务器根据MD5进行文件去重。</li>
<li>优化和上传服务器的连接(参考快速连接)，提供连接重用的功能。</li>
<li>文件分块上传:因为移动网络丢包严重，将文件分块上传可以使得一个分组包含合理数量的TCP包，使得重试概率下降，重试代价变小，更容易上传到服务器。</li>
<li>在分包的前提下支持上传的pipeline，避免不必要的网络等待时间。</li>
<li>支持断点续传</li>
</ul>
<p></p><h2>总结</h2><br>此处是软文，请全选阅读:<font color="white">一个大型IM系统涉及到东西实在太多，如果IM模块只是APP的附属功能，并不推荐自己去从头实现IM模块或者使用XMPP这种有天坑的开源实现，直接使用市面上的第三方SDK即可，比如我们的<a href="http://netease.im" target="_blank" rel="external">云信</a>。毕竟，我们，是，专业的！~~~~</font><p></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[如何做一个圆形的音量旋钮]]></title>
      <url>http://koalahl.github.io/2016/01/17/%E5%A6%82%E4%BD%95%E5%81%9A%E4%B8%80%E4%B8%AA%E5%9C%86%E5%BD%A2%E7%9A%84%E9%9F%B3%E9%87%8F%E6%97%8B%E9%92%AE/</url>
      <content type="html"><![CDATA[<p>最近在Medium上浏览一些国外的iOS开发相关的文章，看到感兴趣的便实践一番，记录下来。一来算是学习swift，另一方面则是为了拓宽技术面。</p>
<p>这篇文章来自<a href="https://medium.com/@karthikkeyan" target="_blank" rel="external">Karthik Keyan Balan</a>的<a href="https://medium.com/@karthikkeyan/how-to-create-a-circular-seek-bar-in-ios-edc6e2871cd0#.yqla9v503" target="_blank" rel="external">How to create a circular seek bar in iOS</a><br>主要展示了一个圆形的类似音量旋钮的UI控件，用swift实现。如下图，<br><img src="/img/circle seek bar.gif" alt="circle seek bar"></p>
<a id="more"></a>
<h2 id="strokeUI">如何画出圆形旋钮</h2>

<p>使用CAShapeLayer，并将其path设置为自定义的贝塞尔曲线的path。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">lazy</span> <span class="keyword">var</span> seekerBarLayer = <span class="type">CAShapeLayer</span>()</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="func"><span class="keyword">func</span> <span class="title">addSeekerBar</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> center = <span class="type">CGPointMake</span>(<span class="keyword">self</span>.bounds.size.width/<span class="number">2</span>, <span class="keyword">self</span>.bounds.size.height/<span class="number">2</span>)</span><br><span class="line">    <span class="comment">//弧度</span></span><br><span class="line">    <span class="keyword">let</span> sAngle = degreeToRadian(<span class="type">Double</span>(startAngle))</span><br><span class="line">    <span class="keyword">let</span> eAngle = degreeToRadian(<span class="type">Double</span>(endAngle))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> path = <span class="type">UIBezierPath</span>(arcCenter: center, radius: (<span class="keyword">self</span>.bounds.size.width - <span class="number">18</span>)/<span class="number">2</span>, startAngle:<span class="type">CGFloat</span>(sAngle) , endAngle:<span class="type">CGFloat</span>(eAngle) , clockwise: <span class="literal">true</span>)</span><br><span class="line">    </span><br><span class="line">    seekerBarLayer.path = path.<span class="type">CGPath</span>;</span><br><span class="line">    seekerBarLayer.lineWidth = <span class="number">4.0</span></span><br><span class="line">    seekerBarLayer.lineCap   = kCALineCapRound</span><br><span class="line">    seekerBarLayer.strokeColor = seekBarColor.<span class="type">CGColor</span></span><br><span class="line">    seekerBarLayer.fillColor = <span class="type">UIColor</span>.clearColor().<span class="type">CGColor</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> seekerBarLayer.superlayer == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.layer.addSublayer(seekerBarLayer)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="touch">根据touch位置移动旋钮位置</h2>

<p>重载touch相关的三个方法，重点是在<code>continueTrackingWithTouch</code>方法中，根据touch的坐标计算按钮需要移动的位置的<code>moveToPoint</code>方法。</p>
<ul>
<li><a href="#touchLocation">获取touch位置</a></li>
<li><a href="#buttonPoint">计算旋钮对应的坐标</a></li>
</ul>
<h3 id="touchLocation">获取touch位置</h3>

<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MARK: Touch Event</span></span><br><span class="line"><span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">beginTrackingWithTouch</span><span class="params">(touch: UITouch, withEvent event: UIEvent?)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> point = touch.locationInView(<span class="keyword">self</span>)</span><br><span class="line">    <span class="keyword">let</span> rect  = <span class="type">CGRectInset</span>(<span class="keyword">self</span>.thumbButton.frame, -<span class="number">20</span>, -<span class="number">20</span>)</span><br><span class="line">    <span class="keyword">let</span> canBegin = <span class="type">CGRectContainsPoint</span>(rect, point)</span><br><span class="line">    <span class="keyword">if</span> canBegin &#123;</span><br><span class="line">        <span class="type">UIView</span>.animateWithDuration(<span class="number">0.2</span>, delay: <span class="number">0.0</span>, options: .<span class="type">CurveEaseIn</span>, animations: &#123; () -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">                <span class="keyword">self</span>.thumbButton.transform = <span class="type">CGAffineTransformMakeScale</span>(<span class="number">1.2</span>, <span class="number">1.2</span>)</span><br><span class="line">            &#125;, completion: <span class="literal">nil</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> canBegin</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">continueTrackingWithTouch</span><span class="params">(touch: UITouch, withEvent event: UIEvent?)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> #available(iOS <span class="number">9</span>,*)&#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> coalescedTouches = event?.coalescedTouchesForTouch(touch) <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> moveToPoint(touch.locationInView(<span class="keyword">self</span>))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> result = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">for</span> cTouch <span class="keyword">in</span> coalescedTouches&#123;</span><br><span class="line">            <span class="keyword">let</span> result = moveToPoint(cTouch.locationInView(<span class="keyword">self</span>))</span><br><span class="line">            <span class="keyword">if</span> result == <span class="literal">false</span> &#123;<span class="keyword">break</span>&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="func"><span class="keyword">func</span> <span class="title">endTrackingWithTouch</span><span class="params">(touch: UITouch?, withEvent event: UIEvent?)</span></span> &#123;</span><br><span class="line">    thumbMoveDidComplete()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="buttonPoint">计算旋钮对应的坐标</h3>

<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">moveToPoint</span><span class="params">(point:CGPoint)</span></span> -&gt;<span class="type">Bool</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> degree = degreeForLocation(point)</span><br><span class="line">    </span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">moveToClosestEdge</span><span class="params">(degree:Double)</span></span>&#123;</span><br><span class="line">        <span class="keyword">let</span> startDistance = fabs(<span class="type">CGFloat</span>(degree) - startAngle)</span><br><span class="line">        <span class="keyword">let</span> endDistance   = fabs(<span class="type">CGFloat</span>(degree) - endAngle)</span><br><span class="line">        <span class="keyword">if</span> startDistance &lt; endDistance&#123;</span><br><span class="line">            currentAngle = startAngle</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            currentAngle = endAngle</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> startAngle &gt; endAngle &#123;</span><br><span class="line">        <span class="keyword">if</span> degree &lt; <span class="type">Double</span>(startAngle) &amp;&amp; degree &gt; <span class="type">Double</span>(endAngle)&#123;</span><br><span class="line">            moveToClosestEdge(degree)</span><br><span class="line">            thumbMoveDidComplete()</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> degree &gt; <span class="type">Double</span>(endAngle) || degree &lt; <span class="type">Double</span>(startAngle)&#123;</span><br><span class="line">            moveToClosestEdge(degree)</span><br><span class="line">            thumbMoveDidComplete()</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    currentAngle = <span class="type">CGFloat</span>(degree)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p></p><h3>手动发送action</h3><br>由于这个控件是继承自UIControl的，正如其他继承与UIControl的控件一样，我们可以自定义一个控件的状态事件。例如<code>valueChanged、TouchUpInside、TouchOutSide</code>。<br>这里我们需要的是控件的位置信息，所以当endTouch的时候发送一个<code>valueChanged</code>事件：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.sendActionsForControlEvents(.<span class="type">ValueChanged</span>)</span><br></pre></td></tr></table></figure><p></p>
<p>其中有一个小细节，当点击到按钮时，会有一个变大的动画效果，其实也是用到了一个基本的拉伸效果：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">UIView</span>.animateWithDuration(<span class="number">0.2</span>, delay: <span class="number">0.0</span>, options: .<span class="type">CurveEaseIn</span>, animations: &#123; () -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">                    <span class="keyword">self</span>.thumbButton.transform = <span class="type">CGAffineTransformMakeScale</span>(<span class="number">1.2</span>, <span class="number">1.2</span>)</span><br><span class="line">                &#125;, completion: <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure></p>
<h2 id="summary">总结</h2>

<ul>
<li>利用CAShapeLayer+贝塞尔曲线画出UI。</li>
<li>根据角度计算弧度，并导出按钮对应的坐标点。</li>
<li>touch事件的处理。- 手动发送action。</li>
</ul>
<p>参考代码：<a href="https://github.com/karthikkeyan/CircularSeek" target="_blank" rel="external">CircularSeek On GitHub</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[NSURLSession初探]]></title>
      <url>http://koalahl.github.io/2016/01/10/NSURLSession%E5%88%9D%E6%8E%A2/</url>
      <content type="html"><![CDATA[<p>NSURLSession是Apple自iOS7.0之后加入到Cocoa SDK中，用以替代NSURLConnection。它拥有更简洁易懂的API方法。<br>iOS中常用的网络库例如AFNetworking在3.0版本中就全部替换为了NSURLSession。<br><a id="more"></a><br>之前项目中一直使用的AFNetworking2.x版本，也没有花时间去仔细研究NSURLSession，特此周末粗略的看了看，一些方法也是试了试。</p>
<p>NSURLSession继承结构：</p>
<ul>
<li>NSURLSession - session对象。</li>
<li>NSURLSessionConfiguration - 当初始化session对象时设置session的配置信息。</li>
<li>NSURLSessoinTask - task基类<ul>
<li>NSURLSessionDataTask - 获取url内容，返回NSData对象。<ul>
<li>NSURLSessionUploadTask - 上传文件的task，并取回对应url内容，返回NSData对象。</li>
</ul>
</li>
<li>NSURLSessionDownloadTask - 获取url内容，并返回一个临时文件在沙盒中（tmp目录下）。</li>
</ul>
</li>
</ul>
<p>NSURLSession也提供了四组代理方法：</p>
<ul>
<li><p>NSURLSessionDelegate — Defines delegate methods to handle session-level events</p>
</li>
<li><p>NSURLSessionTaskDelegate — Defines delegate methods to handle task-level events common to all task types</p>
</li>
<li><p>NSURLSessionDataDelegate — Defines delegate methods to handle task-level events specific to data and upload tasks</p>
</li>
<li><p>NSURLSessionDownloadDelegate — Defines delegate methods to handle task-level events specific to download tasks</p>
</li>
</ul>
<p>首先来看看普通的sessoin请求方法。在completionHandler中返回的是NSData。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSURLSession</span> *session = [<span class="built_in">NSURLSession</span> sharedSession];</span><br><span class="line"><span class="built_in">NSURLSessionDataTask</span> * dataTask = [session dataTaskWithRequest:[<span class="built_in">NSURLRequest</span> requestWithURL:[<span class="built_in">NSURL</span> URLWithString:url]] completionHandler:^(<span class="built_in">NSData</span> * _Nullable data, <span class="built_in">NSURLResponse</span> * _Nullable response, <span class="built_in">NSError</span> * _Nullable error) &#123;</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.fileName</span> = response<span class="variable">.suggestedFilename</span>;</span><br><span class="line">    [<span class="keyword">self</span> saveToFile];</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.fileHandler</span> seekToEndOfFile];</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.fileHandler</span> writeData:data];</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.fileHandler</span> closeFile];</span><br><span class="line">&#125;];</span><br><span class="line">[dataTask resume];<span class="comment">//开始任务。resume有继续、恢复、重新开始的意思，当处理断点续传时就能体会到此含义了。</span></span><br></pre></td></tr></table></figure>
<p>再来看看download task的请求方式，上面提到过，download task最后返回的是一个临时文件，所以需要我们手动将其保存到其他沙盒目录中，就需要用到NSFileManager了。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSURLSessionDownloadTask</span> * downloadTask = [session downloadTaskWithRequest:[<span class="built_in">NSURLRequest</span> requestWithURL:[<span class="built_in">NSURL</span> URLWithString:url]] completionHandler:^(<span class="built_in">NSURL</span> * _Nullable location, <span class="built_in">NSURLResponse</span> * _Nullable response, <span class="built_in">NSError</span> * _Nullable error) &#123;</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.fileName</span> = response<span class="variable">.suggestedFilename</span>;</span><br><span class="line">    <span class="built_in">NSString</span> * directory = [<span class="built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="built_in">NSDocumentDirectory</span>, <span class="built_in">NSUserDomainMask</span>, <span class="literal">YES</span>) lastObject];</span><br><span class="line">    <span class="built_in">NSString</span> * filePath = [directory stringByAppendingPathComponent:<span class="keyword">self</span><span class="variable">.fileName</span>];</span><br><span class="line">    <span class="built_in">NSFileManager</span> * fileManager = [<span class="built_in">NSFileManager</span> defaultManager];</span><br><span class="line">    [fileManager moveItemAtPath:location<span class="variable">.path</span> toPath:filePath error:<span class="literal">nil</span>];</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"> [downloadTask resume];</span><br></pre></td></tr></table></figure></p>
<p>那有时候我们想取得下载进度信息，用block方式就不行了，所以就需要用到系统提供的代理方法了。这里我们用<code>NSURLSessionDownloadDelegate</code>.<br>此时session的创建方式就是另一种方式，设置delegate为self。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSURLSession</span> * session = [<span class="built_in">NSURLSession</span> sessionWithConfiguration:[<span class="built_in">NSURLSessionConfiguration</span> defaultSessionConfiguration]</span><br><span class="line">                                                           delegate:<span class="keyword">self</span> delegateQueue:[<span class="built_in">NSOperationQueue</span> mainQueue]];</span><br><span class="line"></span><br><span class="line"><span class="keyword">self</span><span class="variable">.downloadTask</span> = [session downloadTaskWithRequest:[<span class="built_in">NSURLRequest</span> requestWithURL:[<span class="built_in">NSURL</span> URLWithString:url]]];</span><br><span class="line">[<span class="keyword">self</span><span class="variable">.downloadTask</span> resume];</span><br></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#pragma mark - NSURLSessionDownloadDelegate</span></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> *  下载完毕</span><br><span class="line"> *</span><br><span class="line"> *  @param location     文件临时地址</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session downloadTask:(<span class="built_in">NSURLSessionDownloadTask</span> *)downloadTask</span><br><span class="line">didFinishDownloadingToURL:(<span class="built_in">NSURL</span> *)location</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"文件存放位置%@"</span>,location<span class="variable">.path</span>);</span><br><span class="line"><span class="comment">//    [self.startOrPauseOfSession setTitle:@"开始" forState:UIControlStateNormal];</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span><span class="variable">.fileName</span> = <span class="string">@"QQ4.1.0.dmg"</span>;</span><br><span class="line">    <span class="built_in">NSString</span> * directory = [<span class="built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="built_in">NSDocumentDirectory</span>, <span class="built_in">NSUserDomainMask</span>, <span class="literal">YES</span>) lastObject];</span><br><span class="line">    <span class="built_in">NSString</span> * filePath = [directory stringByAppendingPathComponent:<span class="keyword">self</span><span class="variable">.fileName</span>];</span><br><span class="line">    <span class="built_in">NSFileManager</span> * fileManager = [<span class="built_in">NSFileManager</span> defaultManager];</span><br><span class="line"></span><br><span class="line">    [fileManager moveItemAtPath:location<span class="variable">.path</span> toPath:filePath error:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span><br><span class="line"> *  每次写入沙盒完毕</span><br><span class="line"> *  在这里面监听下载进度，totalBytesWritten/totalBytesExpectedToWrite</span><br><span class="line"> *</span><br><span class="line"> *  @param bytesWritten              这次写入的大小</span><br><span class="line"> *  @param totalBytesWritten         已经写入沙盒的大小</span><br><span class="line"> *  @param totalBytesExpectedToWrite 文件总大小</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session downloadTask:(<span class="built_in">NSURLSessionDownloadTask</span> *)downloadTask</span><br><span class="line">      didWriteData:(int64_t)bytesWritten</span><br><span class="line"> totalBytesWritten:(int64_t)totalBytesWritten</span><br><span class="line">totalBytesExpectedToWrite:(int64_t)totalBytesExpectedToWrite</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.progressView</span><span class="variable">.progress</span> = (<span class="keyword">double</span>)totalBytesWritten/totalBytesExpectedToWrite;</span><br><span class="line">    <span class="keyword">self</span><span class="variable">.progressLabel</span><span class="variable">.text</span> = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%.1f%%"</span>,(<span class="keyword">double</span>)totalBytesWritten/totalBytesExpectedToWrite * <span class="number">100</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> *  恢复下载后调用，</span><br><span class="line"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session downloadTask:(<span class="built_in">NSURLSessionDownloadTask</span> *)downloadTask</span><br><span class="line"> didResumeAtOffset:(int64_t)fileOffset</span><br><span class="line">expectedTotalBytes:(int64_t)expectedTotalBytes</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#pragma mark - PrivateMethod</span></span><br><span class="line">- (<span class="keyword">void</span>)saveToFile&#123;</span><br><span class="line">    <span class="built_in">NSString</span> * cacheDirectory = [<span class="built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="built_in">NSCachesDirectory</span>, <span class="built_in">NSUserDomainMask</span>, <span class="literal">YES</span>) lastObject];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,cacheDirectory);</span><br><span class="line">    <span class="built_in">NSString</span> * filePath = [cacheDirectory stringByAppendingPathComponent:<span class="keyword">self</span><span class="variable">.fileName</span>];</span><br><span class="line">    <span class="built_in">NSFileManager</span> * fileManager = [<span class="built_in">NSFileManager</span> defaultManager];</span><br><span class="line">    [fileManager createFileAtPath:filePath contents:<span class="literal">nil</span> attributes:<span class="literal">nil</span>];</span><br><span class="line">    <span class="comment">//创建操作数据的文件handler</span></span><br><span class="line">    <span class="keyword">self</span><span class="variable">.fileHandler</span> = [<span class="built_in">NSFileHandle</span> fileHandleForWritingAtPath:filePath];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更多信息请查看<a href="http://developer.apple.com/library/ios/documentation/Foundation/Reference/NSURLSession_class/index.html" target="_blank" rel="external">NSURLSession官方文档</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[NS_ENUM与NSString]]></title>
      <url>http://koalahl.github.io/2016/01/07/NS-ENUM%E4%B8%8ENSString/</url>
      <content type="html"><![CDATA[<h3>NS_ENUM与NSString</h3>

<p>在项目中经常会使用到枚举类型：<code>NS_ENUM</code>,<code>enum</code>,但是系统提供的枚举类型只能设置为NSInteger类型，不能保存对象类型入<code>NSString</code>。<br>传统的用<code>#define</code> 方式，<code>Switch case</code> 转换方式，另外还发现了如下几种方式：</p>
<a id="more"></a>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;value1, value2, value3&#125; myValue;</span><br><span class="line"><span class="preprocessor">#define myValueString(enum) [@[@<span class="title">"value1"</span>,@<span class="title">"value2"</span>,@<span class="title">"value3"</span>] objectAtIndex:enum]</span></span><br></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123; a, b, c &#125; FirstThreeAlpha;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSString</span>*) convertToString:(FirstThreeAlpha) whichAlpha &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *result = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span>(whichAlpha) &#123;</span><br><span class="line">        <span class="keyword">case</span> a:</span><br><span class="line">            result = <span class="string">@"a"</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> b:</span><br><span class="line">            result = <span class="string">@"b"</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> c:</span><br><span class="line">            result = <span class="string">@"c"</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            result = <span class="string">@"unknown"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>,CabinetOperationType)&#123;</span><br><span class="line">    CabinetOperationTypeNothing = <span class="number">0</span>,</span><br><span class="line">    CabinetOperationTypeAdd     = <span class="number">1</span>,    <span class="comment">//加入酒柜</span></span><br><span class="line">    CabinetOperationTypeTake    = <span class="number">2</span>,       <span class="comment">//从酒柜提酒</span></span><br><span class="line">    CabinetOperationTypeAddAndSend = <span class="number">3</span> <span class="comment">//加入酒柜付款并直接赠予某人</span></span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">NSString</span> *<span class="keyword">const</span> CabinetOperationTypeString[] = &#123;</span><br><span class="line">    [CabinetOperationTypeNothing]    = <span class="string">@""</span>,</span><br><span class="line">    [CabinetOperationTypeAdd]        = <span class="string">@"1"</span>,</span><br><span class="line">    [CabinetOperationTypeTake]       = <span class="string">@"2"</span>,</span><br><span class="line">    [CabinetOperationTypeAddAndSend] = <span class="string">@"3"</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>此法和上面的定义NSString数组相似，但是是用了函数思想。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;</span><br><span class="line">    <span class="built_in">UIImageOrientationUp</span> = <span class="number">0</span>,            <span class="comment">// default orientation, set to 0 so that it always starts from 0</span></span><br><span class="line">    <span class="built_in">UIImageOrientationDown</span>,          <span class="comment">// 180 deg rotation</span></span><br><span class="line">    <span class="built_in">UIImageOrientationLeft</span>,          <span class="comment">// 90 deg CCW</span></span><br><span class="line">    <span class="built_in">UIImageOrientationRight</span>,         <span class="comment">// 90 deg CW</span></span><br><span class="line">    <span class="built_in">UIImageOrientationUpMirrored</span>,    <span class="comment">// as above but image mirrored along other axis. horizontal flip</span></span><br><span class="line">    <span class="built_in">UIImageOrientationDownMirrored</span>,  <span class="comment">// horizontal flip</span></span><br><span class="line">    <span class="built_in">UIImageOrientationLeftMirrored</span>,  <span class="comment">// vertical flip</span></span><br><span class="line">    <span class="built_in">UIImageOrientationRightMirrored</span>, <span class="comment">// vertical flip</span></span><br><span class="line">&#125; <span class="built_in">UIImageOrientation</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSString</span> *stringWith<span class="built_in">UIImageOrientation</span>(<span class="built_in">UIImageOrientation</span> input) &#123;</span><br><span class="line">    <span class="built_in">NSArray</span> *arr = @[</span><br><span class="line">    <span class="string">@"UIImageOrientationUp"</span>,            <span class="comment">// default orientation</span></span><br><span class="line">    <span class="string">@"UIImageOrientationDown"</span>,          <span class="comment">// 180 deg rotation</span></span><br><span class="line">    <span class="string">@"UIImageOrientationLeft"</span>,          <span class="comment">// 90 deg CCW</span></span><br><span class="line">    <span class="string">@"UIImageOrientationRight"</span>,         <span class="comment">// 90 deg CW</span></span><br><span class="line">    <span class="string">@"UIImageOrientationUpMirrored"</span>,    <span class="comment">// as above but image mirrored along other axis. horizontal flip</span></span><br><span class="line">    <span class="string">@"UIImageOrientationDownMirrored"</span>,  <span class="comment">// horizontal flip</span></span><br><span class="line">    <span class="string">@"UIImageOrientationLeftMirrored"</span>,  <span class="comment">// vertical flip</span></span><br><span class="line">    <span class="string">@"UIImageOrientationRightMirrored"</span>, <span class="comment">// vertical flip</span></span><br><span class="line">    ];</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">NSString</span> *)[arr objectAtIndex:input];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>综合众多方案得出，要熟练使用<code>typedef、#define</code> 就可以提高效率。<br>更多可以参考stackoverflow：<a href="http://stackoverflow.com/questions/6331762/enum-values-to-nsstring-ios" target="_blank" rel="external">enum Values to NSString (iOS)</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[如何在swift项目中创建Objective-C Bridging header]]></title>
      <url>http://koalahl.github.io/2015/12/30/%E5%A6%82%E4%BD%95%E5%9C%A8swift%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%88%9B%E5%BB%BAObjective-C-Bridging-header/</url>
      <content type="html"><![CDATA[<p>在swift工程中，有时候我们也需要使用OBJC代码写的第三方库或者工具类等，这时就需要创建objc文件到swift的桥接header。<br>现在有两种方法创建Objective-C Bridging Header:<br><a id="more"></a></p>
<p></p><h3 id="header">Create Objective-C File as Header</h3><br>Go to <code>File &gt; New &gt; File</code> and Select Objective-C:<p></p>
<p><img src="/img/Swift-Create-Objective-C-Bridging-Header.png" alt="Create Objective-C File as Header"><br>然后一直next，最后出现如下图时，点击yes：</p>
<p><img src="/img/create-objective-c-bridging-header-question.png" alt=""></p>
<p>这种方式会创建出.h和.m文件。</p>
<p></p><h3 id="headerDirectly"> Create Objective-C Header File Directly</h3><br>Go to <code>File &gt; New &gt; File</code> and Select Objective-C Header File:<p></p>
<p><img src="/img/Xcode-Choose-Header-File.png" alt="Create Objective-C Header File Directly"></p>
<p>最后，两种方法创建的.h文件中import你将使用的类。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">"xxxx"</span></span></span><br></pre></td></tr></table></figure></p>
<p>一般在项目中我们使用第二种方法。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[修改UIBarButtonItem标题文字大小、颜色、阴影等]]></title>
      <url>http://koalahl.github.io/2015/12/29/%E4%BF%AE%E6%94%B9UIBarButtonItem%E6%A0%87%E9%A2%98%E6%96%87%E5%AD%97%E5%A4%A7%E5%B0%8F%E3%80%81%E9%A2%9C%E8%89%B2%E3%80%81%E9%98%B4%E5%BD%B1%E7%AD%89/</url>
      <content type="html"><![CDATA[<p></p><h3>修改UIBarButtonItem的标题文字大小、颜色、阴影等</h3><br>有时候我们需要设置一下导航栏右侧按钮标题的大小、颜色等等，但是UIBarButtonItem没有直接提供相关方法。通过查看UIbarButtonItem官方文档，总结出有以下两种方法<br>第一种：使用<code>initWithCustomView</code>方法创建UIBarButtonItem。<br>第二种：通过KVC来修改相关属性。<p></p>
<a id="more"></a>
<p>那么先看看第一种方法：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIButton</span> * edit = [<span class="built_in">UIButton</span> buttonWithType:<span class="built_in">UIButtonTypeCustom</span>];</span><br><span class="line">edit<span class="variable">.frame</span> = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">80</span>, <span class="number">30</span>);</span><br><span class="line">[edit setTitle:<span class="string">@"批量管理"</span> forState:<span class="built_in">UIControlStateNormal</span>];</span><br><span class="line">[edit setTitleColor:[<span class="built_in">UIColor</span> blackColor] forState:<span class="built_in">UIControlStateNormal</span>];</span><br><span class="line">[edit addTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(edit) forControlEvents:<span class="built_in">UIControlEventTouchUpInside</span>];</span><br><span class="line">edit<span class="variable">.titleLabel</span><span class="variable">.font</span> = [<span class="built_in">UIFont</span> systemFontOfSize:<span class="number">13</span>];</span><br><span class="line">edit<span class="variable">.titleLabel</span><span class="variable">.textAlignment</span> = <span class="built_in">NSTextAlignmentRight</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">UIBarButtonItem</span> * rightBtn = [[<span class="built_in">UIBarButtonItem</span> alloc]initWithCustomView:edit];</span><br><span class="line">[rightBtn setTintColor:COLOR(black)];</span><br><span class="line"><span class="keyword">self</span><span class="variable">.navigationItem</span><span class="variable">.rightBarButtonItem</span> = rightBtn;</span><br></pre></td></tr></table></figure></p>
<p>这种方法比较简便，能够快速理解。</p>
<p>第二种方法：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIBarButtonItem</span> * submitComment = [[<span class="built_in">UIBarButtonItem</span> alloc] initWithTitle:<span class="string">@"提交评价"</span> </span><br><span class="line">                                    style:<span class="built_in">UIBarButtonItemStylePlain</span> </span><br><span class="line">                                    target:<span class="keyword">self</span> </span><br><span class="line">                                    action:<span class="keyword">@selector</span>(submitComment:)];</span><br><span class="line">submitComment<span class="variable">.tintColor</span> = [<span class="built_in">UIColor</span> darkGrayColor];</span><br><span class="line">[[<span class="built_in">UIBarButtonItem</span> appearance] setTitleTextAttributes:</span><br><span class="line">                                [<span class="built_in">NSDictionary</span> dictionaryWithObjectsAndKeys:[<span class="built_in">UIFont</span> boldSystemFontOfSize:<span class="number">15</span>], <span class="built_in">NSFontAttributeName</span>, <span class="literal">nil</span>] </span><br><span class="line">                                forState:<span class="built_in">UIControlStateNormal</span>];</span><br></pre></td></tr></table></figure></p>
<p>Also,可以使用如下方法：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="built_in">UIBarButtonItem</span> appearanceWhenContainedIn:[<span class="built_in">UINavigationController</span> class], <span class="literal">nil</span>] </span><br><span class="line">                                            setTitleTextAttributes:[<span class="built_in">NSDictionary</span> dictionaryWithObjectsAndKeys:</span><br><span class="line">                                            [<span class="built_in">UIFont</span> boldSystemFontOfSize:<span class="number">15</span>], <span class="built_in">NSFontAttributeName</span>, <span class="literal">nil</span>] </span><br><span class="line">                                            forState:<span class="built_in">UIControlStateNormal</span>];</span><br></pre></td></tr></table></figure></p>
<p>其中对于这些key需要看一下，常用的几个key已经被<code>NSFontAttributeName, NSForegroundColorAttributeName, NSShadowAttributeName</code>代替:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Keys for text attributes dictionaries.</span><br><span class="line"> These keys are superseded by the corresponding attribute name keys (NSFontAttributeName, NSForegroundColorAttributeName, NSShadowAttributeName)</span><br><span class="line"> in NSAttributedString.h.</span><br><span class="line"> */</span></span><br><span class="line"><span class="comment">// Key to the font in the text attributes dictionary. A UIFont instance is expected. Use a font with size 0.0 to get the default font size for the situation.</span></span><br><span class="line"><span class="built_in">UIKIT_EXTERN</span> <span class="built_in">NSString</span> *<span class="keyword">const</span> <span class="built_in">UITextAttributeFont</span> <span class="built_in">NS_DEPRECATED_IOS</span>(<span class="number">5</span>_0, <span class="number">7</span>_0, <span class="string">"Use NSFontAttributeName"</span>) __TVOS_PROHIBITED;</span><br><span class="line"><span class="comment">// Key to the text color in the text attributes dictionary. A UIColor instance is expected.</span></span><br><span class="line"><span class="built_in">UIKIT_EXTERN</span> <span class="built_in">NSString</span> *<span class="keyword">const</span> <span class="built_in">UITextAttributeTextColor</span> <span class="built_in">NS_DEPRECATED_IOS</span>(<span class="number">5</span>_0, <span class="number">7</span>_0, <span class="string">"Use NSForegroundColorAttributeName"</span>) __TVOS_PROHIBITED;</span><br><span class="line"><span class="comment">// Key to the text shadow color in the text attributes dictionary.  A UIColor instance is expected.</span></span><br><span class="line"><span class="built_in">UIKIT_EXTERN</span> <span class="built_in">NSString</span> *<span class="keyword">const</span> <span class="built_in">UITextAttributeTextShadowColor</span> <span class="built_in">NS_DEPRECATED_IOS</span>(<span class="number">5</span>_0, <span class="number">7</span>_0, <span class="string">"Use NSShadowAttributeName with an NSShadow instance as the value"</span>) __TVOS_PROHIBITED;</span><br><span class="line"><span class="comment">// Key to the offset used for the text shadow in the text attributes dictionary. An NSValue instance wrapping a UIOffset struct is expected.</span></span><br><span class="line"><span class="built_in">UIKIT_EXTERN</span> <span class="built_in">NSString</span> *<span class="keyword">const</span> <span class="built_in">UITextAttributeTextShadowOffset</span> <span class="built_in">NS_DEPRECATED_IOS</span>(<span class="number">5</span>_0, <span class="number">7</span>_0, <span class="string">"Use NSShadowAttributeName with an NSShadow instance as the value"</span>) __TVOS_PROHIBITED;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/************************ Attributes ************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Predefined character attributes for text. If the key is not in the dictionary, then use the default values as described below.</span></span><br><span class="line"><span class="built_in">UIKIT_EXTERN</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> <span class="built_in">NSFontAttributeName</span> <span class="built_in">NS_AVAILABLE</span>(<span class="number">10</span>_0, <span class="number">6</span>_0);                <span class="comment">// UIFont, default Helvetica(Neue) 12</span></span><br><span class="line"><span class="built_in">UIKIT_EXTERN</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> <span class="built_in">NSParagraphStyleAttributeName</span> <span class="built_in">NS_AVAILABLE</span>(<span class="number">10</span>_0, <span class="number">6</span>_0);      <span class="comment">// NSParagraphStyle, default defaultParagraphStyle</span></span><br><span class="line"><span class="built_in">UIKIT_EXTERN</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> <span class="built_in">NSForegroundColorAttributeName</span> <span class="built_in">NS_AVAILABLE</span>(<span class="number">10</span>_0, <span class="number">6</span>_0);     <span class="comment">// UIColor, default blackColor</span></span><br><span class="line"><span class="built_in">UIKIT_EXTERN</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> <span class="built_in">NSBackgroundColorAttributeName</span> <span class="built_in">NS_AVAILABLE</span>(<span class="number">10</span>_0, <span class="number">6</span>_0);     <span class="comment">// UIColor, default nil: no background</span></span><br><span class="line"><span class="built_in">UIKIT_EXTERN</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> <span class="built_in">NSLigatureAttributeName</span> <span class="built_in">NS_AVAILABLE</span>(<span class="number">10</span>_0, <span class="number">6</span>_0);            <span class="comment">// NSNumber containing integer, default 1: default ligatures, 0: no ligatures</span></span><br><span class="line"><span class="built_in">UIKIT_EXTERN</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> <span class="built_in">NSKernAttributeName</span> <span class="built_in">NS_AVAILABLE</span>(<span class="number">10</span>_0, <span class="number">6</span>_0);                <span class="comment">// NSNumber containing floating point value, in points; amount to modify default kerning. 0 means kerning is disabled.</span></span><br><span class="line"><span class="built_in">UIKIT_EXTERN</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> <span class="built_in">NSStrikethroughStyleAttributeName</span> <span class="built_in">NS_AVAILABLE</span>(<span class="number">10</span>_0, <span class="number">6</span>_0);  <span class="comment">// NSNumber containing integer, default 0: no strikethrough</span></span><br><span class="line"><span class="built_in">UIKIT_EXTERN</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> <span class="built_in">NSUnderlineStyleAttributeName</span> <span class="built_in">NS_AVAILABLE</span>(<span class="number">10</span>_0, <span class="number">6</span>_0);      <span class="comment">// NSNumber containing integer, default 0: no underline</span></span><br><span class="line"><span class="built_in">UIKIT_EXTERN</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> <span class="built_in">NSStrokeColorAttributeName</span> <span class="built_in">NS_AVAILABLE</span>(<span class="number">10</span>_0, <span class="number">6</span>_0);         <span class="comment">// UIColor, default nil: same as foreground color</span></span><br><span class="line"><span class="built_in">UIKIT_EXTERN</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> <span class="built_in">NSStrokeWidthAttributeName</span> <span class="built_in">NS_AVAILABLE</span>(<span class="number">10</span>_0, <span class="number">6</span>_0);         <span class="comment">// NSNumber containing floating point value, in percent of font point size, default 0: no stroke; positive for stroke alone, negative for stroke and fill (a typical value for outlined text would be 3.0)</span></span><br><span class="line"><span class="built_in">UIKIT_EXTERN</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> <span class="built_in">NSShadowAttributeName</span> <span class="built_in">NS_AVAILABLE</span>(<span class="number">10</span>_0, <span class="number">6</span>_0);              <span class="comment">// NSShadow, default nil: no shadow</span></span><br><span class="line"><span class="built_in">UIKIT_EXTERN</span> <span class="built_in">NSString</span> *<span class="keyword">const</span> <span class="built_in">NSTextEffectAttributeName</span> <span class="built_in">NS_AVAILABLE</span>(<span class="number">10</span>_10, <span class="number">7</span>_0);          <span class="comment">// NSString, default nil: no text effect</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">UIKIT_EXTERN</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> <span class="built_in">NSAttachmentAttributeName</span> <span class="built_in">NS_AVAILABLE</span>(<span class="number">10</span>_0, <span class="number">7</span>_0);          <span class="comment">// NSTextAttachment, default nil</span></span><br><span class="line"><span class="built_in">UIKIT_EXTERN</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> <span class="built_in">NSLinkAttributeName</span> <span class="built_in">NS_AVAILABLE</span>(<span class="number">10</span>_0, <span class="number">7</span>_0);                <span class="comment">// NSURL (preferred) or NSString</span></span><br><span class="line"><span class="built_in">UIKIT_EXTERN</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> <span class="built_in">NSBaselineOffsetAttributeName</span> <span class="built_in">NS_AVAILABLE</span>(<span class="number">10</span>_0, <span class="number">7</span>_0);      <span class="comment">// NSNumber containing floating point value, in points; offset from baseline, default 0</span></span><br><span class="line"><span class="built_in">UIKIT_EXTERN</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> <span class="built_in">NSUnderlineColorAttributeName</span> <span class="built_in">NS_AVAILABLE</span>(<span class="number">10</span>_0, <span class="number">7</span>_0);      <span class="comment">// UIColor, default nil: same as foreground color</span></span><br><span class="line"><span class="built_in">UIKIT_EXTERN</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> <span class="built_in">NSStrikethroughColorAttributeName</span> <span class="built_in">NS_AVAILABLE</span>(<span class="number">10</span>_0, <span class="number">7</span>_0);  <span class="comment">// UIColor, default nil: same as foreground color</span></span><br><span class="line"><span class="built_in">UIKIT_EXTERN</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> <span class="built_in">NSObliquenessAttributeName</span> <span class="built_in">NS_AVAILABLE</span>(<span class="number">10</span>_0, <span class="number">7</span>_0);         <span class="comment">// NSNumber containing floating point value; skew to be applied to glyphs, default 0: no skew</span></span><br><span class="line"><span class="built_in">UIKIT_EXTERN</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> <span class="built_in">NSExpansionAttributeName</span> <span class="built_in">NS_AVAILABLE</span>(<span class="number">10</span>_0, <span class="number">7</span>_0);           <span class="comment">// NSNumber containing floating point value; log of expansion factor to be applied to glyphs, default 0: no expansion</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">UIKIT_EXTERN</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> <span class="built_in">NSWritingDirectionAttributeName</span> <span class="built_in">NS_AVAILABLE</span>(<span class="number">10</span>_6, <span class="number">7</span>_0);    <span class="comment">// NSArray of NSNumbers representing the nested levels of writing direction overrides as defined by Unicode LRE, RLE, LRO, and RLO characters.  The control characters can be obtained by masking NSWritingDirection and NSTextWritingDirection values.  LRE: NSWritingDirectionLeftToRight|NSWritingDirectionEmbedding, RLE: NSWritingDirectionRightToLeft|NSWritingDirectionEmbedding, LRO: NSWritingDirectionLeftToRight|NSWritingDirectionOverride, RLO: NSWritingDirectionRightToLeft|NSWritingDirectionOverride,</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">UIKIT_EXTERN</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> <span class="built_in">NSVerticalGlyphFormAttributeName</span> <span class="built_in">NS_AVAILABLE</span>(<span class="number">10</span>_7, <span class="number">6</span>_0);   <span class="comment">// An NSNumber containing an integer value.  0 means horizontal text.  1 indicates vertical text.  If not specified, it could follow higher-level vertical orientation settings.  Currently on iOS, it's always horizontal.  The behavior for any other value is undefined.</span></span><br></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Block实现原理]]></title>
      <url>http://koalahl.github.io/2015/12/16/Block%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
      <content type="html"><![CDATA[<p>Block一直是iOS开发中常用的技巧，类似于C语言中的指针函数。多用于参数回调，异步加载等。下面就来探究以下block是如何实现的。<br>这篇是记录根据网上的文章进行的实际操作。C函数的生成中间编译代码的编译方法是clang -rewrite-objc xxxx.c。由于编译文件中内容较多，这里我们只截取有关block的部分。</p>
<p>首先，看看没有block的C函数以及编译后的结果：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#include <span class="title">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main()&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>编译代码中的block：这里我们可以看到一个block的C实现。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#ifndef BLOCK_IMPL</span></span><br><span class="line"><span class="preprocessor">#define BLOCK_IMPL</span></span><br><span class="line"><span class="keyword">struct</span> __block_impl &#123;</span><br><span class="line">  <span class="keyword">void</span> *isa;</span><br><span class="line">  <span class="keyword">int</span> Flags;</span><br><span class="line">  <span class="keyword">int</span> Reserved;</span><br><span class="line">  <span class="keyword">void</span> *FuncPtr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>*isa说明block也可以作为对象使用（例如我们定义一个myBlock类型的block1），指针变量FunPtr应该就是指向了block代码块的函数首地址<br><a id="more"></a><br>接着我们加一个block到.c文件中，并进行编译。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#include <span class="title">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main()&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span>(^myBlock)(<span class="keyword">void</span>) = ^(<span class="keyword">void</span>)&#123;</span><br><span class="line">	printf(<span class="string">"hello world! %d\n"</span>,i);</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">myBlock();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>编译后：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> __main_block_impl_0 &#123;</span><br><span class="line">  <span class="keyword">struct</span> __block_impl impl;</span><br><span class="line">  <span class="keyword">struct</span> __main_block_desc_0* Desc;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  __main_block_impl_0(<span class="keyword">void</span> *fp, <span class="keyword">struct</span> __main_block_desc_0 *desc, <span class="keyword">int</span> _i, <span class="keyword">int</span> flags=<span class="number">0</span>) : i(_i) &#123;</span><br><span class="line">    impl<span class="variable">.isa</span> = &amp;_<span class="built_in">NSConcreteStackBlock</span>;</span><br><span class="line">    impl<span class="variable">.Flags</span> = flags;</span><br><span class="line">    impl<span class="variable">.FuncPtr</span> = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(<span class="keyword">struct</span> __main_block_impl_0 *__cself) &#123;</span><br><span class="line">  <span class="keyword">int</span> i = __cself-&gt;i; <span class="comment">// bound by copy</span></span><br><span class="line"></span><br><span class="line">  printf(<span class="string">"hello world! %d\n"</span>,i);</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">struct</span> __main_block_desc_0 &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t Block_size;</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> __main_block_impl_0)&#125;;</span><br><span class="line"><span class="keyword">int</span> main()&#123;</span><br><span class="line"> <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">void</span>(*myBlock)(<span class="keyword">void</span>) = (<span class="keyword">void</span> (*)())&amp;__main_block_impl_0((<span class="keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA, i);</span><br><span class="line"></span><br><span class="line"> ((<span class="keyword">void</span> (*)(__block_impl *))((__block_impl *)myBlock)-&gt;FuncPtr)((__block_impl *)myBlock);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>3.假如我们要修改函数中局部变量的值，则需要加上__block修饰符，后面我们来看看为什么这样才可以修改。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#include <span class="title">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main()&#123;</span><br><span class="line">__block <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span>(^myBlock)(<span class="keyword">void</span>) = ^(<span class="keyword">void</span>)&#123;</span><br><span class="line">i = <span class="number">12</span>;</span><br><span class="line">	printf(<span class="string">"hello world! %d\n"</span>,i);</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">myBlock();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>编译后的cpp代码：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> __Block_byref_i_0 &#123;</span><br><span class="line">  <span class="keyword">void</span> *__isa;</span><br><span class="line">__Block_byref_i_0 *__forwarding;</span><br><span class="line"> <span class="keyword">int</span> __flags;</span><br><span class="line"> <span class="keyword">int</span> __size;</span><br><span class="line"> <span class="keyword">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> __main_block_impl_0 &#123;</span><br><span class="line">  <span class="keyword">struct</span> __block_impl impl;</span><br><span class="line">  <span class="keyword">struct</span> __main_block_desc_0* Desc;</span><br><span class="line">  __Block_byref_i_0 *i; <span class="comment">// by ref</span></span><br><span class="line">  __main_block_impl_0(<span class="keyword">void</span> *fp, <span class="keyword">struct</span> __main_block_desc_0 *desc, __Block_byref_i_0 *_i, <span class="keyword">int</span> flags=<span class="number">0</span>) : i(_i-&gt;__forwarding) &#123;</span><br><span class="line">    impl<span class="variable">.isa</span> = &amp;_<span class="built_in">NSConcreteStackBlock</span>;</span><br><span class="line">    impl<span class="variable">.Flags</span> = flags;</span><br><span class="line">    impl<span class="variable">.FuncPtr</span> = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(<span class="keyword">struct</span> __main_block_impl_0 *__cself) &#123;</span><br><span class="line">  __Block_byref_i_0 *i = __cself-&gt;i; <span class="comment">// bound by ref</span></span><br><span class="line"></span><br><span class="line">  (i-&gt;__forwarding-&gt;i) = <span class="number">12</span>;</span><br><span class="line">  printf(<span class="string">"hello world! %d\n"</span>,(i-&gt;__forwarding-&gt;i));</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_copy_0(<span class="keyword">struct</span> __main_block_impl_0*dst, <span class="keyword">struct</span> __main_block_impl_0*src) &#123;_Block_object_assign((<span class="keyword">void</span>*)&amp;dst-&gt;i, (<span class="keyword">void</span>*)src-&gt;i, <span class="number">8</span><span class="comment">/*BLOCK_FIELD_IS_BYREF*/</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_dispose_0(<span class="keyword">struct</span> __main_block_impl_0*src) &#123;_Block_object_dispose((<span class="keyword">void</span>*)src-&gt;i, <span class="number">8</span><span class="comment">/*BLOCK_FIELD_IS_BYREF*/</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">struct</span> __main_block_desc_0 &#123;</span><br><span class="line">  size_t reserved;</span><br><span class="line">  size_t Block_size;</span><br><span class="line">  <span class="keyword">void</span> (*<span class="keyword">copy</span>)(<span class="keyword">struct</span> __main_block_impl_0*, <span class="keyword">struct</span> __main_block_impl_0*);</span><br><span class="line">  <span class="keyword">void</span> (*dispose)(<span class="keyword">struct</span> __main_block_impl_0*);</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0&#125;;</span><br><span class="line"><span class="keyword">int</span> main()&#123;</span><br><span class="line"> __attribute__((__blocks__(<span class="keyword">byref</span>))) __Block_byref_i_0 i = &#123;(<span class="keyword">void</span>*)<span class="number">0</span>,(__Block_byref_i_0 *)&amp;i, <span class="number">0</span>, <span class="keyword">sizeof</span>(__Block_byref_i_0), <span class="number">10</span>&#125;;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">void</span>(*myBlock)(<span class="keyword">void</span>) = (<span class="keyword">void</span> (*)())&amp;__main_block_impl_0((<span class="keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA, (__Block_byref_i_0 *)&amp;i, <span class="number">570425344</span>);</span><br><span class="line"></span><br><span class="line"> ((<span class="keyword">void</span> (*)(__block_impl *))((__block_impl *)myBlock)-&gt;FuncPtr)((__block_impl *)myBlock);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[TableViewCell根据内容自适应高度的方法]]></title>
      <url>http://koalahl.github.io/2015/12/16/TableViewCell%E6%A0%B9%E6%8D%AE%E5%86%85%E5%AE%B9%E8%87%AA%E9%80%82%E5%BA%94%E9%AB%98%E5%BA%A6%E7%9A%84%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>本文同时参考 <a href="http://blog.sunnyxx.com/2015/05/17/cell-height-calculation/" target="_blank" rel="external">http://blog.sunnyxx.com/2015/05/17/cell-height-calculation/</a> </p>
<h2>一：根据cell内容手动计算cell高度</h2>

<p>无论使用xib还是代码写控件，核心思想都是根据cell中content内容的高度来计算cell的高度。<br>1.在获取到cell数据源的时候计算内容高度。可以设置一个size属性，用来记录。<br>2.如果是xib，去掉autolayout<br>3.在cellForRowAtIndexPath方法中填充cell数据的时候，根据内容高度，设置控件高度<br>4.在heightForRowAtIndexpath方法中，设置每一个cell 的高度</p>
<h2>二：Self sizing cell + autolayout</h2>

<p>Self sizing cell 是iOS8中添加一个新特性，用来自适应cell高度。<br><img src="/img/self sizing cell.jpg" alt="Self Sizing Cell"><br>同时打开以下参数：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span><span class="variable">.tableView</span><span class="variable">.estimatedRowHeight</span> = <span class="number">213</span>;<span class="comment">//添加估算高度，要不然自动算高失效？</span></span><br><span class="line"><span class="keyword">self</span><span class="variable">.tableView</span><span class="variable">.rowHeight</span> = <span class="built_in">UITableViewAutomaticDimension</span>;</span><br></pre></td></tr></table></figure></p>
<h2>三：UITableView+FDTemplateLayoutCell</h2>

<p>使用的API:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">&lt;UITableView+FDTemplateLayoutCell.h&gt;</span> </span></span><br><span class="line">- (<span class="built_in">CGFloat</span>)tableView:(<span class="built_in">UITableView</span> *)tableView heightForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath &#123; </span><br><span class="line">	<span class="keyword">return</span> [tableView fd_heightForCellWithIdentifier:<span class="string">@"identifer"</span> cacheByIndexPath:indexPath configuration:^(<span class="keyword">id</span> cell)</span><br><span class="line"> 			&#123;</span><br><span class="line">  			<span class="comment">// 配置 cell 的数据源，和 "cellForRow" 干的事一致，比如： </span></span><br><span class="line">			  cell<span class="variable">.entity</span> = <span class="keyword">self</span><span class="variable">.feedEntities</span>[indexPath<span class="variable">.row</span>]; </span><br><span class="line">  			&#125;]; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><a href="https://github.com/forkingdog/UITableView-FDTemplateLayoutCell" target="_blank" rel="external">https://github.com/forkingdog/UITableView-FDTemplateLayoutCell</a><br><a id="more"></a></p>
<p>下面给出第一种手动计算高度的代码思路：<br>详细步骤：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">HLComment *comment = [HLComment new];</span><br><span class="line"></span><br><span class="line"> comment<span class="variable">.floor</span> = obj[<span class="string">@"floor"</span>];</span><br><span class="line"></span><br><span class="line"> comment<span class="variable">.commentId</span> = obj[<span class="string">@"id"</span>];</span><br><span class="line"></span><br><span class="line"> comment<span class="variable">.content</span> = obj[<span class="string">@"content"</span>];</span><br></pre></td></tr></table></figure>
<p> //计算content内容高度<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="built_in">NSDictionary</span> *atrri = @&#123;<span class="built_in">NSFontAttributeName</span>: [<span class="built_in">UIFont</span> systemFontOfSize:<span class="number">15</span>]&#125;;</span><br><span class="line"></span><br><span class="line"> <span class="built_in">CGRect</span> rect = [comment<span class="variable">.content</span> boundingRectWithSize:<span class="built_in">CGSizeMake</span>(<span class="number">220</span>, <span class="number">1000</span>) options:<span class="built_in">NSStringDrawingUsesLineFragmentOrigin</span> attributes:atrri context:<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line">comment<span class="variable">.size</span> = rect<span class="variable">.size</span>;<span class="comment">//保存这个高度</span></span><br></pre></td></tr></table></figure></p>
<p>//填充cell内容时，根据content高度来设置label高度<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)fillCellWithModel:(HLItem *)item&#123;</span><br><span class="line"></span><br><span class="line">	….</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CGRect</span> frame = _content<span class="variable">.frame</span>;<span class="comment">//_content 是内容label</span></span><br><span class="line"></span><br><span class="line">    frame<span class="variable">.size</span> = item<span class="variable">.size</span>;</span><br><span class="line"></span><br><span class="line">    _content<span class="variable">.frame</span> = frame;</span><br><span class="line"></span><br><span class="line">	…..</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>另外在heightForRowAtIndexPath 中添加一定的余量。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自适应cell高度</span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">CGFloat</span>)tableView:(<span class="built_in">UITableView</span> *)tableView heightForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//NSLog(@"计算cell高度");;</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (indexPath<span class="variable">.row</span> == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">self</span><span class="variable">.item</span><span class="variable">.size</span><span class="variable">.height</span>+<span class="number">140</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    HLComment *item = _dataSource[indexPath<span class="variable">.row</span>-<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> item<span class="variable">.size</span><span class="variable">.height</span>+<span class="number">60</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[理解Objective-C中的消息发送]]></title>
      <url>http://koalahl.github.io/2015/12/16/%E7%90%86%E8%A7%A3Objective-C%E4%B8%AD%E7%9A%84%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81/</url>
      <content type="html"><![CDATA[<h2>消息发送</h2><br>首先来看看怎么理解发送消息的含义：<br><br>面对着 Cocoa 中大量 API，只知道简单的查文档和调用。还记得初学 Objective-C 时把<code>[receiver message]</code>当成简单的方法调用，而无视了“发送消息”这句话的深刻含义。于是<code>[receiver message]</code>会被编译器转化为：<br>    <code>objc_msgSend(receiver, selector)</code><br>如果消息含有参数，则为：<br>    <code>objc_msgSend(receiver, selector, arg1, arg2, ...)</code><br>如果消息的接收者能够找到对应的selector，那么就相当于直接执行了接收者这个对象的特定方法；否则，消息要么被转发，或是临时向接收者动态添加这个selector对应的实现内容，要么就干脆玩完崩溃掉。<br><br>现在可以看出[receiver message]真的不是一个简简单单的方法调用。因为这只是在编译阶段确定了要向接收者发送message这条消息，而receive将要如何响应这条消息，那就要看运行时发生的情况来决定了。<br><br>Objective-C 的 Runtime 铸就了它动态语言的特性，这些深层次的知识虽然平时写代码用的少一些，但是却是每个 Objc 程序员需要了解的。<br><br>Objc Runtime使得C具有了面向对象能力，在程序运行时创建，检查，修改类、对象和它们的方法。可以使用runtime的一系列方法实现。<br><br><h3>C语言中的动态方法</h3><br><br>由于Objective-C是C语言的超集，所以最好先理解C语言的函数调用方式。C语言使用“静态绑定（static binding）”，也就是说，在编译器就能决定运行时所应调用的函数。<br>示例代码：<br><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#import &lt;stdio.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello,world\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printGoodBye</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"GoodBye,world\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doThings</span><span class="params">(<span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(type == <span class="number">0</span>)&#123;</span><br><span class="line">        printHello();</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        printGoodBye();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>编译器在编译代码的时候就知道程序中有<code>printHello</code>,<code>printGoodBye</code>两个函数了，函数地址也硬编码在指令之中。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#import &lt;stdio.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello,world\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printGoodBye</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"GoodBye,world\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doThings</span><span class="params">(<span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> (*func)();</span><br><span class="line">    <span class="keyword">if</span>(type == <span class="number">0</span>)&#123;</span><br><span class="line">        func = printHello;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        func = printGoodBye;</span><br><span class="line">    &#125;</span><br><span class="line">    func();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>这样就是动态绑定（dynamic binding）了，因为索要调用的函数直到运行期才能确定。<br><br><h3>顺便附上OC中一个类的底层数据结构</h3><br>mac电脑上的路径/usr/include/objc/runtime.h<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">struct</span> objc_class &#123;</span><br><span class="line">	Class isa OBJC_ISA_<span class="built_in">AVAILABILITY</span>; <span class="comment">//isa指针指向Meta Class，因为Objc的类的本身也是一个Object，为了处理这个关系，r		untime就创造了Meta Class，当给类发送[NSObject alloc]这样消息时，实际上是把这个消息发给了Class Object</span></span><br><span class="line"></span><br><span class="line">	<span class="preprocessor">#if !__OBJC2__</span></span><br><span class="line">	Class super_class OBJC2_UN<span class="built_in">AVAILABLE</span>; <span class="comment">// 父类</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *name OBJC2_UN<span class="built_in">AVAILABLE</span>; <span class="comment">// 类名</span></span><br><span class="line">	<span class="keyword">long</span> version OBJC2_UN<span class="built_in">AVAILABLE</span>; <span class="comment">// 类的版本信息，默认为0</span></span><br><span class="line">	<span class="keyword">long</span> info OBJC2_UN<span class="built_in">AVAILABLE</span>; <span class="comment">// 类信息，供运行期使用的一些位标识</span></span><br><span class="line">	<span class="keyword">long</span> instance_size OBJC2_UN<span class="built_in">AVAILABLE</span>; <span class="comment">// 该类的实例变量大小</span></span><br><span class="line">	<span class="keyword">struct</span> objc_ivar_list *ivars OBJC2_UN<span class="built_in">AVAILABLE</span>; <span class="comment">// 该类的成员变量链表</span></span><br><span class="line">	<span class="keyword">struct</span> objc_method_list **methodLists OBJC2_UN<span class="built_in">AVAILABLE</span>; <span class="comment">// 方法定义的链表</span></span><br><span class="line">	<span class="keyword">struct</span> objc_cache *cache OBJC2_UN<span class="built_in">AVAILABLE</span>; <span class="comment">// 方法缓存，对象接到一个消息会根据isa指针查找消息对象，这时会在method		Lists中遍历，如果cache了，常用的方法调用时就能够提高调用的效率。</span></span><br><span class="line">	<span class="keyword">struct</span> objc_protocol_list *protocols OBJC2_UN<span class="built_in">AVAILABLE</span>; <span class="comment">// 协议链表</span></span><br><span class="line">	<span class="preprocessor">#endif</span></span><br><span class="line"></span><br><span class="line">&#125; OBJC2_UN<span class="built_in">AVAILABLE</span>;</span><br></pre></td></tr></table></figure><br><br><a id="more"></a><br>OC中一个类的对象实例的数据结构（/usr/include/objc/objc.h），就是定义了一个<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_class *Class;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Represents an instance of a class.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> objc_object &#123;</span><br><span class="line"></span><br><span class="line">    Class isa  OBJC_ISA_<span class="built_in">AVAILABILITY</span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// A pointer to an instance of a class.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_object *<span class="keyword">id</span>;</span><br></pre></td></tr></table></figure><br><br>向object发送消息时，Runtime库会根据object的isa指针找到这个实例object所属于的类，然后在类的方法列表以及父类方法列表寻找对应的方法运行。id是一个objc_object结构类型的指针，这个类型的对象能够转换成任何一种对象。<br><br><h3>然后再来看看消息发送的函数：<code>objc_msgSend</code>函数</h3><br><br>在引言中已经对objc_msgSend进行了一点介绍，看起来像是objc_msgSend返回了数据，其实objc_msgSend从不返回数据而是你的方法被调用后返回了数据。下面详细叙述下消息发送步骤：<br><br>1.检测这个 selector 是不是要忽略的。比如 Mac OS X 开发，有了垃圾回收就不理会 retain,release 这些函数了。<br>2.检测这个 target 是不是 nil 对象。ObjC 的特性是允许对一个 nil 对象执行任何一个方法不会 Crash，因为会被忽略掉。<br>3.如果上面两个都过了，那就开始查找这个类的 IMP，先从 cache 里面找，完了        找得到就跳到对应的函数去执行。<br>4.如果 cache 找不到就找一下方法分发表。<br>5.如果分发表找不到就到超类的分发表去找，一直找，直到找到NSObject类为止。<br>6.如果还找不到就要开始进入动态方法解析了，后面会提到。<br><br>这么一想，调用一个方法似乎需要很多步骤。不过objc_msgSend会将匹配结果缓存在<code>fast map</code>快速映射表里面，每个类都有这样一块缓存。当然这种fast path 还是不如静态绑定的函数调用那样迅速，不过只要把Selector<br>缓存起来，也就不会慢很多，实际上，这并不是瓶颈。<br><br><h2>消息转发机制</h2>

<p>当一个对象接收到无法解读的消息时，就会启动<code>消息转发（message forwording）</code>机制。coder可经由此过程告诉对象应该如何处理位置消息。<br>例如给某一个对象实例发送了一个该对象不存在的方法，最后就会crash掉。<br><code>-[NSCFDictionary indexOfObject:]: unrecognized selector sent to instance 0x10773929356</code><br>消息转发分为两大阶段。</p>
<ol>
<li>第一阶段先询问接受对象所属的类是否能够动态添加方法，以处理这个unknown selector，这叫做动态方法解析（dynamic method resolution）.</li>
<li>第二阶段设计完整的消息转发机制（full forwording mechanism）。<br>如果在运行期，系统已经把第一阶段执行完了，那么接受者自己就无法再以动态添加方法的方式来响应包含该unknown selector的消息了。此时，运行期系统会请求接受者以<br>其他手段来处理与消息相关的方法调用。这里又分为两小步：<br> 2.1 首先，接受者查看是否有其他对象能处理这条消息，若有，则运行时系统会将消息转给那个对象，一切如常。<br> 2.2 若没有可替代的接受者（replacement receiver），则启动完整的消息转发机制，运行时系统会把与消息有关的全部细节都封装到NSInvocation对象中，再给接受者最后一次机会，令其设法解决当前还未处理的消息。</li>
</ol>
<p>a.动态方法解析<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+ (Bool)resolveInstanceMethod:(SEL)Selector</span><br><span class="line">+ (Bool)resolveClassMethod:(SEL)Selector</span><br></pre></td></tr></table></figure></p>
<p>b.消息转发给可替代接受者（replacement receiver）<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (id)forwardingTargetForSelector:(SEL)Selector</span><br></pre></td></tr></table></figure></p>
<p>c.完整的消息转发机制，构造NSInvocation对象</p>
<ul>
<li>(id)forwardInvocation:(NSInvocation *)invocation</li>
</ul>
<p><img src="/img/message forwarding.png" alt="完整的消息转发流程图"></p>
<p></p><h2>总结</h2><p></p>
<ul>
<li>消息由接受者、选择器及参数构成。给某对象发送消息（invoke a message），也就相当于在该对象上调用方法（calla method）</li>
<li><p>发给某对象的全部消息都要有动态消息派发系统（dynamic message dispatch system）来处理，该系统会查出对应的方法，并执行其代码。</p>
</li>
<li><p>若对象无法响应某个选择器中的消息，则进入消息转发过程。</p>
</li>
<li>通过运行期的动态方法解析机制，我们可以在需要用到某个方法时再将其加入类中。</li>
<li>对象可以把其无法解读的消息转交给其他对象来处理。</li>
<li>若经过上述两步还是没办法处理消息，则启动完整的消息转发机制。</li>
</ul>
<p>详情可参考  <a href="http://blog.jobbole.com/79545/" title="Objective-C Runtime" target="_blank" rel="external">Objective-C Runtime</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[关于CoreData和SQLite多线程访问时的线程安全问题]]></title>
      <url>http://koalahl.github.io/2015/12/14/%E5%85%B3%E4%BA%8ECoreData%E5%92%8CSQLite%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AE%BF%E9%97%AE%E6%97%B6%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<p>数据库读取操作一般都是多线程访问的。在对数据进行读取时，我们要保证其当前状态不能被修改，即读取时加锁，否则就会出现数据错误混乱。<br>IOS中常用的两种数据持久化存储方式：CoreData和SQLite，两者都需要设置线程安全，在这里以FMDB来解释对SQLite的线程安全访问。</p>
<a id="more"></a>
<h3>一:FMDB的线程安全：（以读取图片为例）</h3>

<p>1.没有线程安全的执行方式：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//************** 数据库保存图片  ******************//</span></span><br><span class="line"></span><br><span class="line"> FMDatabase *database = [FMDatabase databaseWithPath:[<span class="keyword">self</span> getDatabasePath]];</span><br><span class="line"></span><br><span class="line"> <span class="comment">//打开数据库</span></span><br><span class="line"></span><br><span class="line"> [database open];</span><br><span class="line"></span><br><span class="line"> <span class="built_in">NSString</span> *sql = <span class="string">@"create table if not exists Test (id integer primary key autoincrement,name text,image blob);"</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//创建表</span></span><br><span class="line"></span><br><span class="line"> [database executeUpdate:sql];</span><br><span class="line"></span><br><span class="line"> <span class="comment">//把UIImage对象转化为NSData</span></span><br><span class="line"></span><br><span class="line"> <span class="built_in">NSData</span> *data = <span class="built_in">UIImagePNGRepresentation</span>([<span class="built_in">UIImage</span> imageNamed:<span class="string">@"user_browse"</span>]);    </span><br><span class="line"></span><br><span class="line"> <span class="comment">//写入数据</span></span><br><span class="line"></span><br><span class="line"> sql = <span class="string">@"insert into Test (name,image) values (?,?)"</span>;</span><br><span class="line"></span><br><span class="line"> [database executeUpdate:sql,<span class="string">@"张三"</span>,data];</span><br><span class="line"></span><br><span class="line"> <span class="comment">//读取显示</span></span><br><span class="line"></span><br><span class="line"> sql = <span class="string">@"select * from Test;"</span>;</span><br><span class="line"></span><br><span class="line"> FMResultSet *resultSet = [database executeQuery:sql];</span><br><span class="line"></span><br><span class="line"> <span class="keyword">while</span> (resultSet<span class="variable">.next</span>)</span><br><span class="line"></span><br><span class="line"> &#123;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//[resultSet dataForColumn:@"image"];</span></span><br><span class="line"></span><br><span class="line">     <span class="built_in">NSData</span> *imageData = [resultSet dataForColumnIndex:<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">     <span class="built_in">UIImageView</span> *imageView = [[<span class="built_in">UIImageView</span> alloc] initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">300</span>, <span class="number">300</span>)];</span><br><span class="line"></span><br><span class="line">     imageView<span class="variable">.image</span> = [<span class="built_in">UIImage</span> imageWithData:imageData];</span><br><span class="line"></span><br><span class="line">     [<span class="keyword">self</span><span class="variable">.view</span> addSubview:imageView];</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><br>2，使用线程队列<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//************** 数据库线程安全 ***********//</span></span><br><span class="line">    FMDatabaseQueue *queue = [[FMDatabaseQueue alloc] initWithPath:[<span class="keyword">self</span> getDatabasePath]];</span><br><span class="line"></span><br><span class="line">    [queue inDatabase:^(FMDatabase *db) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//线程安全的</span></span><br><span class="line"></span><br><span class="line">        __block <span class="built_in">NSString</span> *sql = <span class="string">@"create table if not exists Test (id integer primary key autoincrement,name text,image blob);"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建表</span></span><br><span class="line"></span><br><span class="line">        [database executeUpdate:sql];</span><br><span class="line"></span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//插入数据</span></span><br><span class="line"></span><br><span class="line">    [queue inDatabase:^(FMDatabase *db) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//写入数据</span></span><br><span class="line"></span><br><span class="line">        sql = <span class="string">@"insert into Test (name,image) values (?,?)"</span>;</span><br><span class="line"></span><br><span class="line">        [database executeUpdate:sql,<span class="string">@"张三"</span>,data];</span><br><span class="line"></span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取</span></span><br><span class="line">    [queue inDatabase:^(FMDatabase *db) &#123;</span><br><span class="line">        <span class="comment">//读取显示</span></span><br><span class="line">        sql = <span class="string">@"select * from Test;"</span>;</span><br><span class="line">        FMResultSet *resultSet = [database executeQuery:sql];</span><br><span class="line">        <span class="keyword">while</span> (resultSet<span class="variable">.next</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//[resultSet dataForColumn:@"image"];</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">NSData</span> *imageData = [resultSet dataForColumnIndex:<span class="number">2</span>];</span><br><span class="line">            <span class="built_in">UIImageView</span> *imageView = [[<span class="built_in">UIImageView</span> alloc] initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">300</span>, <span class="number">300</span>)];</span><br><span class="line"></span><br><span class="line">            imageView<span class="variable">.image</span> = [<span class="built_in">UIImage</span> imageWithData:imageData];</span><br><span class="line">            [<span class="keyword">self</span><span class="variable">.view</span> addSubview:imageView];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br></pre></td></tr></table></figure></p>
<p>分析一下线程安全下的FMDB的实现：<br>在当使用FMDBDatabaseQueue创建数据库时，会使用GCD创建一个线程队列：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">。。。</span><br><span class="line"> _queue = dispatch_queue_create([[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"fmdb.%@"</span>, <span class="keyword">self</span>] UTF8String], <span class="literal">NULL</span>);</span><br><span class="line">        dispatch_queue_set_specific(_queue, kDispatchQueueSpecificKey, (__bridge <span class="keyword">void</span> *)<span class="keyword">self</span>, <span class="literal">NULL</span>);</span><br><span class="line">        _openFlags = openFlags;</span><br><span class="line">。。。</span><br></pre></td></tr></table></figure></p>
<p>然后在读取时调用<code>[queue inDatabase:^(FMDatabase *db)</code>方法，在block中会锁定当前数据库<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_sync</span>(_queue, ^() &#123;</span><br><span class="line">        FMDatabase *db = [<span class="keyword">self</span> database];</span><br><span class="line">        block(db);</span><br><span class="line">	……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们可以看到实际上这里是对整个数据库进行加锁，以此来保证线程安全的。</p>
<h3>二、CoreData的线程安全</h3>

<p>1.没有线程安全的coredata数据读取：</p>
<p>NSManagedObjectContext对象的创建：<code>_managedObjectContext = [[NSManagedObjectContext alloc] init];</code></p>
<p>插入数据操作：（AppDetailModal为数据模型）</p>
<p>context 为返回的 _managedObjectContext<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AppDetailModal *newapp = [<span class="built_in">NSEntityDescription</span> insertNewObjectForEntityForName:TableName inManagedObjectContext:context];</span><br></pre></td></tr></table></figure></p>
<p>其他查询、更新、删除操作<br>//获取Entity<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSEntityDescription</span> *entity = [<span class="built_in">NSEntityDescription</span> entityForName:TableName inManagedObjectContext:context];</span><br></pre></td></tr></table></figure></p>
<p>2.线程安全的coreData操作：</p>
<p>首先创建并行的NSManagedObjectContext对象<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSManagedObjectContext</span>* context=[[<span class="built_in">NSManagedObjectContext</span> alloc] initWithConcurrencyType:<span class="built_in">NSPrivateQueueConcurrencyType</span>];</span><br></pre></td></tr></table></figure></p>
<p>然后在执行读取操作时使用一下两个方法：</p>
<ul>
<li><p>-(void)performBlock:(void (^)(void))block</p>
</li>
<li><p>-(void)performBlockAndWait:(void (^)(void))block   </p>
</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[context performBlock:^&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//要执行的读取操作</span></span><br><span class="line"></span><br><span class="line"> &#125;];</span><br></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[《iOS开发进阶》阅读笔记（二）——开发技巧]]></title>
      <url>http://koalahl.github.io/2015/12/13/%E3%80%8AiOS%E5%BC%80%E5%8F%91%E8%BF%9B%E9%98%B6%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/</url>
      <content type="html"><![CDATA[<h3 id="keyboard">收起键盘</h3>

<p>在UIViewController中收起键盘，处了调用相应控件的resignFirstResponder方法外，还有另外三种方法：</p>
<ul>
<li>重载UIViewController的touchBegin方法，然后在里面执行<code>[self.view endEditing:YES];</code>,这样单击UIViewController的任意地方，就可以收起键盘；</li>
<li>直接执行<code>[[UIApplicatoin sharedApplication] sendAction:@selector(resignFirstResponder) to:nil from:nil forEvent:nil];</code>,用于在获得当前UIViewController比较困难的时候使用。</li>
<li>直接执行<code>[[[UIApplicatoin sharedApplication] keyWindow] endEditing:YES];</code>。</li>
</ul>
<a id="more"></a>
<h3 id="json">NSJSONSerialization比NSKeyedArchiver更好</h3>

<p>在选择持久化方案时，系统提供的<code>NSJSONSerialization</code>比<code>NSKeyedArchiver</code>在效率和体积上都更优，更详细的测试参考：<a href="https://github.com/randomsequence/NSSerialisationTests" target="_blank" rel="external">https://github.com/randomsequence/NSSerialisationTests</a>;</p>
<h3 id="language">设置应用内的系统控件语言</h3>

<p>在工程的info.plist文件中增加如下内容：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">key</span>&gt;</span>CFBundleLocalizations<span class="tag">&lt;/<span class="title">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">array</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">string</span>&gt;</span>zh_CN<span class="tag">&lt;/<span class="title">string</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">string</span>&gt;</span>en<span class="tag">&lt;/<span class="title">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">array</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="snapshot">巧用系统的截屏功能</h3>

<p>iOS7以后，apple提供的系统的截屏API：<code>- (UIView *)snapshotViewAfterScreenUpdates:(BOOL)afterUpdates</code>来实现截屏功能。而对于iOS7以前的系统，可以用过代码来实现截屏功能：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">UIImage</span> *)captureImageFromView:(<span class="built_in">UIView</span> *)view&#123;</span><br><span class="line">	<span class="built_in">CGRect</span> screenRect = [view bounds];</span><br><span class="line">	<span class="built_in">UIGraphicsBeginImageContext</span>(screenRect<span class="variable">.size</span>);</span><br><span class="line">	<span class="built_in">CGContextRef</span> ctx = <span class="built_in">UIGraphicsGetCurrentContext</span>();</span><br><span class="line">	[view<span class="variable">.layer</span> renderInContext:ctx];</span><br><span class="line">	<span class="built_in">UIImage</span> *image = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();</span><br><span class="line">	<span class="built_in">UIGraphicsEndImageContext</span>();</span><br><span class="line">	<span class="keyword">return</span> image;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="js">Javascript文件设置调整</h3>

<p>Javascript的js后缀的文件默认被拖动到工程中后，是在编译列表中，而不是资源列表中。需要手动调整期位置，否则它就不能打包到ipa文件中。</p>
<p>注：xcode7已经修改此问题，如下图：<br><img src="/img/xcode7_js.png" alt="xcode7_js"></p>
<h3 id="warning">忽略编译警告</h3>

<p>在Build Phase中对应的文件中添加 <code>-w</code>参数。</p>
<p></p><h3 id="NSLog">定制NSLog</h3><br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#ifdef DEBUG</span></span><br><span class="line"><span class="preprocessor">#define NSLog(args,...) NSLog(@<span class="title">"-%d%s:%@"</span>,__LINE__,__FUNCTION__,[NSString stringWithFormat:(args), ##__VA_ARGS__])</span></span><br><span class="line"><span class="preprocessor">#else</span></span><br><span class="line"><span class="preprocessor">#define NSLog(...)</span></span><br><span class="line"><span class="preprocessor">#endif</span></span><br></pre></td></tr></table></figure><p></p>
<p></p><h3 id="hideNav">导航栏上的一些设置</h3><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#21435;&#25481;&#23548;&#33322;&#26639;&#38452;&#24433;&#40657;&#32447;&#12290;setBackGroundImage&#20013;&#20063;&#21487;&#20197;&#30452;&#25509;&#20351;&#29992;[UIImage new]&#10;UINavigationBar *navBar = self.navigationController.navigationBar;&#10;[navBar setBackgroundImage:[UIImage imageNamed:@&#34;white_backgroud&#34;] forBarPosition:UIBarPositionAny barMetrics:UIBarMetricsDefault];&#10;[navBar setShadowImage:[UIImage new]];&#10;&#10;&#21435;&#25481;searchBar&#30340;&#38452;&#24433;&#10;[self.searchBar setBackgroundImage:[UIImage new]];</span><br></pre></td></tr></table></figure><p></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[《iOS开发进阶》阅读笔记（一）内存管理释疑]]></title>
      <url>http://koalahl.github.io/2015/12/12/%E3%80%8AiOS%E5%BC%80%E5%8F%91%E8%BF%9B%E9%98%B6%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E9%87%8A%E7%96%91/</url>
      <content type="html"><![CDATA[<h3 id="arc">ARC</h3>

<p>ARC能够解决iOS开发中90%的内存管理问题，但是另外还有10%的内存管理是需要手动管理的，主要就是与底层Core Foundation对象交互的部分，因为底层Core Foundation对象由于不在ARC的管理下。</p>
<p>使用ARC需要额外注意的两个问题：<br>    1.过度使用block产生的循环引用问题。<br>    2.底层Core Foundation对象需要手动进行内存管理。<br><a id="more"></a></p>
<h3 id="corefoundation">Core Foundation对象的内存管理</h3>

<p>底层的Core Foundation对象的创建，大多数以XxxCreateWithXxx这样的方式创建，例如：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个CFStringRef对象</span></span><br><span class="line">	<span class="built_in">CFStringRef</span> str = <span class="built_in">CFStringCreateWithCString</span>(k<span class="built_in">CFAllocatorDefault</span>,<span class="string">"hello world"</span>,k<span class="built_in">CFStringEncodingUTF8</span>);</span><br></pre></td></tr></table></figure>
<p>或者<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置字间距</span></span><br><span class="line">+ (<span class="built_in">NSAttributedString</span> *)setLabelAttributeString:(<span class="built_in">NSString</span>*)labelText withCharactorSpace:(<span class="built_in">CGFloat</span>)charactorSpace&#123;</span><br><span class="line">    <span class="built_in">NSMutableAttributedString</span> * string =[[<span class="built_in">NSMutableAttributedString</span> alloc]initWithString:labelText];</span><br><span class="line">    <span class="keyword">long</span> number = charactorSpace;</span><br><span class="line">    <span class="built_in">CFNumberRef</span> num = <span class="built_in">CFNumberCreate</span>(k<span class="built_in">CFAllocatorDefault</span>,k<span class="built_in">CFNumberSInt8Type</span>,&amp;number);</span><br><span class="line">    [string addAttribute:(<span class="keyword">id</span>)kCTKernAttributeName value:(__bridge <span class="keyword">id</span>)num range:<span class="built_in">NSMakeRange</span>(<span class="number">0</span>,[string length])];</span><br><span class="line">    <span class="built_in">CFRelease</span>(num);</span><br><span class="line">    <span class="keyword">return</span> string;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对于这种对象的修改和释放，需要相应的使用CFRetain和CFRelease。<br>除此之外，还有另外一个问题需要解决。在ARC下，我们有时需要将一个Core Foundation对象转换成Objective-C对象，这个时候我们需要告诉编译器，转换过程中的引用计数如何调整。这就引入了与bridge相关的关键字：</p>
<ul>
<li><code>__bridge</code>:只做类型转换，不修改相关对象的引用计数，原来的Core Foundation对象在不用时，需要调用CFRelease方法。</li>
<li><code>__bridge_retained</code>:类型转换后，将相关对象的引用计数+1，原来的Core Foundation对象在不用时，需要调用CFRelease方法。</li>
<li><code>__bridge_transfer</code>:类型转换后，将该对象的引用计数交给ARC管理，Core Foundation对象在不用时，不再需要调用CFRelease方法。</li>
</ul>
<p>我们根据业务逻辑，合理使用上面三种转换关键字，就可以解决Core Foundation对象与Objc对象相互转换的问题了。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[iOS中处理四舍五入的问题]]></title>
      <url>http://koalahl.github.io/2015/12/05/iOS%E4%B8%AD%E5%A4%84%E7%90%86%E5%9B%9B%E8%88%8D%E4%BA%94%E5%85%A5%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<p>处理四舍五入主要使用下面这个方法：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="built_in">NSString</span> *)notRounding:(<span class="keyword">float</span>)price afterPoint:(<span class="keyword">int</span>)position&#123;</span><br><span class="line">    <span class="built_in">NSDecimalNumberHandler</span>* roundingBehavior = [<span class="built_in">NSDecimalNumberHandler</span> decimalNumberHandlerWithRoundingMode:<span class="built_in">NSRoundDown</span> scale:position raiseOnExactness:<span class="literal">NO</span> raiseOnOverflow:<span class="literal">NO</span> raiseOnUnderflow:<span class="literal">NO</span> raiseOnDivideByZero:<span class="literal">NO</span>];</span><br><span class="line">    <span class="built_in">NSDecimalNumber</span> *ouncesDecimal;</span><br><span class="line">    <span class="built_in">NSDecimalNumber</span> *roundedOunces;</span><br><span class="line">    </span><br><span class="line">    ouncesDecimal = [[<span class="built_in">NSDecimalNumber</span> alloc] initWithFloat:price];</span><br><span class="line">    roundedOunces = [ouncesDecimal decimalNumberByRoundingAccordingToBehavior:roundingBehavior];</span><br><span class="line">    [ouncesDecimal release];</span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@"</span>,roundedOunces];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>介绍一下参数：<br><code>price</code>:需要处理的数字，<br><code>position</code>：保留小数点第几位，<br>然后调用<br><blockquote><p>float s =0.126;<br>    NSString *sb = [self notRounding:s afterPoint:2];<br>    NSLog(@”sb = %@”,sb);<br>输出结果为：sb = 0.12</p>
</blockquote><br>接下来介绍NSDecimalNumberHandler初始化时的关键参数：decimalNumberHandlerWithRoundingMode：NSRoundDown，<br><code>NSRoundDown</code>代表的就是 只舍不入。<br>scale的参数<code>position</code>代表保留小数点后几位。</p>
<a id="more"></a>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Category添加属性所想到的]]></title>
      <url>http://koalahl.github.io/2015/12/03/Category%E6%B7%BB%E5%8A%A0%E5%B1%9E%E6%80%A7%E6%89%80%E6%83%B3%E5%88%B0%E7%9A%84/</url>
      <content type="html"><![CDATA[<p>iOS中category和extension相辅相成，长得也很相似。category与extension的主要区别：</p>
<p>Category：分类、类别</p>
<ul>
<li>category主要用来增加类的方法，并且适用于子类。</li>
<li>category不能添加实例变量（这个并不是属性），可以添加readonly的属性。</li>
<li>如果要添加readwrite的属性的话，需要用到runtime方法。</li>
</ul>
<p>Extension：扩展</p>
<ul>
<li>可以增加被扩展类的属性和方法。</li>
<li>Extension可以理解为匿名类别。</li>
<li>定义的方法必须在implementation中实现。</li>
</ul>
<a id="more"></a>
<p>下面主要看看category的使用：<br>1.添加readonly属性</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">UITableViewCell</span> (<span class="title">AccessoryView</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">///在Cell右侧添加的一个自定义label</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">strong</span>,<span class="keyword">readonly</span>)<span class="built_in">UILabel</span> *accessoryLabel;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">strong</span>,<span class="keyword">readonly</span>)<span class="built_in">UIImageView</span> *accessoryImageView;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>.m文件中重写getter方法</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UITableViewCell</span> (<span class="title">AccessoryView</span>)</span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">UILabel</span> *)accessoryLabel&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">id</span> obj <span class="keyword">in</span> <span class="keyword">self</span><span class="variable">.subviews</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([obj class] == [<span class="built_in">UILabel</span> class]) &#123;</span><br><span class="line">            [obj removeFromSuperview];<span class="comment">//因为accessoryLabel是添加在cell上的，而没有在cell.contentView上。</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">UILabel</span> * accessoryLabel = [[<span class="built_in">UILabel</span> alloc]initWithFrame:<span class="built_in">CGRectMake</span>(kWidth-<span class="number">200</span>, <span class="number">0</span>, <span class="number">160</span>, <span class="built_in">CGRectGetHeight</span>(<span class="keyword">self</span><span class="variable">.frame</span>))];</span><br><span class="line">    accessoryLabel<span class="variable">.textColor</span> = [<span class="built_in">UIColor</span> lightGrayColor];</span><br><span class="line">    accessoryLabel<span class="variable">.font</span>      = [<span class="built_in">UIFont</span> systemFontOfSize:<span class="number">12</span>];</span><br><span class="line">    accessoryLabel<span class="variable">.textAlignment</span> = <span class="built_in">NSTextAlignmentRight</span>;</span><br><span class="line">    [<span class="keyword">self</span> addSubview:accessoryLabel];</span><br><span class="line">    <span class="keyword">return</span>  accessoryLabel;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">UIImageView</span> *)accessoryImageView&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">id</span> obj <span class="keyword">in</span> <span class="keyword">self</span><span class="variable">.subviews</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([obj class] == [<span class="built_in">UIImageView</span> class]) &#123;</span><br><span class="line">            [obj removeFromSuperview];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">UIImageView</span> *accessoryImageView = [[<span class="built_in">UIImageView</span> alloc]initWithFrame:<span class="built_in">CGRectMake</span>(kWidth-<span class="number">100</span>, <span class="number">10</span>, <span class="number">60</span>, <span class="number">60</span>)];</span><br><span class="line">    accessoryImageView<span class="variable">.layer</span><span class="variable">.cornerRadius</span> = <span class="number">30</span>;</span><br><span class="line">    accessoryImageView<span class="variable">.layer</span><span class="variable">.masksToBounds</span> = <span class="literal">YES</span>;</span><br><span class="line">    [<span class="keyword">self</span> addSubview:accessoryImageView];</span><br><span class="line">    <span class="keyword">return</span> accessoryImageView;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>如果我们添加一个普通的属性<code>@property (nonatomic,strong)NSString * name;</code>,那么implementation中会报warning：</p>
<p><img src="/img/category_1.png" alt="category"></p>
<p>2.运行时添加属性：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSError</span> (<span class="title">Message</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">copy</span>)<span class="built_in">NSString</span> * errorMsg;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>.m</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> * strKey = &amp;strKey;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSError</span> (<span class="title">Message</span>)</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setErrorMsg:(<span class="built_in">NSString</span> *)errorMsg&#123;</span><br><span class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, &amp; strKey, errorMsg, OBJC_ASSO<span class="built_in">CIATION_COPY_NONATOMIC</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSString</span> *)errorMsg&#123;</span><br><span class="line">    <span class="keyword">return</span> objc_getAssociatedObject(<span class="keyword">self</span>, &amp;strKey);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>在实际使用中，大多数时候还是用的category较多。后面会给出一些常用的类的category。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>http://koalahl.github.io/2015/11/30/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="http://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="http://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="http://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<a id="more"></a>
<h2 id="Quick_Start">Quick Start</h2><h3 id="Create_a_new_post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run_server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate_static_files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy_to_remote_sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[常用排序算法]]></title>
      <url>http://koalahl.github.io/2015/11/30/%E5%B8%B8%E7%94%A8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>在此总结一下常用排序算法的代码实现</p>
<p><code>#include &lt;iostream&gt;</code><br><code>using namespace std;</code><br><code>typedef int ElemType;</code></p>
<p>/*<br>1、插入排序<br>（1）直接插入排序算法<br>算法思想：将等排序列划分为有序与无序两部分，然后再依次将无序部分插入到已经有序的部分，最后</p>
<p>就可以形成有序序列。<br>操作步骤如下：<br>1）查找出元素L（i）在表中的插入位置K；<br>2）将表中的第K个元素之前的元素依次后移一个位置；<br>3）将L（i）复制到L（K）。<br> */<br>时间复杂度为：O(n^2)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(ElemType arr[], <span class="keyword">int</span> length)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    ElemType guard; <span class="comment">// 哨兵</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; length; ++i)</span><br><span class="line"> &#123;</span><br><span class="line">   <span class="keyword">if</span> (arr[i]() &lt; arr[i-<span class="number">1</span>]()) <span class="comment">// 在无序部分寻找一个元素，使之插入到有序部分后仍然有序</span></span><br><span class="line"> 	&#123;</span><br><span class="line">	guard = arr[i]();<span class="comment">// 复制到“哨兵”</span></span><br><span class="line">	<span class="comment">// 将第i个元素之前的元素依次后移一个位置</span></span><br><span class="line">	<span class="keyword">for</span> (j = i - <span class="number">1</span>; arr[j]() &gt; guard; j--)</span><br><span class="line">	&#123;</span><br><span class="line">		arr[j + <span class="number">1</span>]() = arr[j]();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	arr[j + <span class="number">1</span>]() = guard; <span class="comment">// 复制到插入位置</span></span><br><span class="line">	&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>2、折半插入排序<br>  使用于排序表为顺序存储的线性表<br>  在查找插入位置时，采用折半查找<br>  算法思想是：<br>  1）设置折半查找范围；<br>  2）折半查找<br>  3）移动元素<br>  4）插入元素<br>  5）继续操作1）、2）、3）、4）步，直到表成有序。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BinaryInsertSort</span><span class="params">(ElemType arr[], <span class="keyword">int</span> length)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, low, high, mid;</span><br><span class="line">    ElemType tmp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">1</span>; i &lt; length; ++i )</span><br><span class="line">    &#123;</span><br><span class="line">      tmp = arr[i](); <span class="comment">// 复制到哨兵</span></span><br><span class="line">      <span class="comment">// 设置折半查找范围</span></span><br><span class="line">      low = <span class="number">0</span>;</span><br><span class="line">      high = i;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span> (low &lt;= high) <span class="comment">// 折半查找</span></span><br><span class="line">      &#123;</span><br><span class="line">        mid = (low + high) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (arr[mid]() &gt; tmp) <span class="comment">// 在左半部分查找</span></span><br><span class="line">        &#123;</span><br><span class="line">          high = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          low = mid + <span class="number">1</span>; <span class="comment">// 在右半部分查找</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 移动元素</span></span><br><span class="line">      <span class="keyword">for</span> ( j = i - <span class="number">1</span>; j &gt;= high + <span class="number">1</span>; --j )</span><br><span class="line">      &#123;</span><br><span class="line">        arr[j + <span class="number">1</span>]() = arr[j]();</span><br><span class="line">      &#125;</span><br><span class="line">      arr[j + <span class="number">1</span>]() = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>/*<br>3、希尔(Shell)排序<br>   基本思想：<br>   先将待排序的表分割成若干个形若L[i, i+d, i+2d, …, i+kd]的“特殊”子表，分别进行直接插入排序，<br>   当整个表已呈“基本有序”时，再对全体记录进行一次直接插入排序。<br>   算法过程：<br>   1）先取一个小于n的步长d1,把表中全部记录分成d1个组，所有距离为d1的倍数的记录放在同一组中，在各<br>  组中进行直接插入排序；<br>   2）然后取第二个步长d2 \&lt; d1, 重复步骤1<br>   3）直到dk = 1，再进行最后一次直接插入排序<br>*/</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShellSort</span><span class="params">(ElemType arr[], <span class="keyword">int</span> length)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, dk = length / <span class="number">2</span>;</span><br><span class="line">    ElemType tmp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (dk &gt;= <span class="number">1</span>)<span class="comment">// 控制步长</span></span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="keyword">for</span> (i = dk; i &lt; length; ++i)</span><br><span class="line">    	&#123;</span><br><span class="line">      	<span class="keyword">if</span> (arr[i]() &lt; arr[i - dk]())</span><br><span class="line">      	 &#123;</span><br><span class="line">      		tmp = arr[i](); <span class="comment">// 暂存</span></span><br><span class="line"></span><br><span class="line">      		<span class="comment">// 后移</span></span><br><span class="line">      		<span class="keyword">for</span> (j = i - dk; j &gt;= <span class="number">0</span> &amp;&amp; tmp &lt; arr[j](); j -= dk)</span><br><span class="line">      		&#123;</span><br><span class="line">      		  arr[j + dk]() = arr[j]();</span><br><span class="line">      		&#125;</span><br><span class="line">          arr[j + dk]() = tmp;</span><br><span class="line">      	&#125;</span><br><span class="line">    	&#125;</span><br><span class="line"></span><br><span class="line">    	dk /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>*<br>4、冒泡排序算法<br>   基本思想：<br>   假设待排序的表长为n， 从后向前或从前向后两两比较相邻元素的值，若为逆序，则交换之，直到序列比较完。<br>   这样一回就称为一趟冒泡。这样值较大的元素往下“沉”，而值较小的元素入上“浮”。<br>   时间复杂度为O(n^2)<br>*/</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(ElemType arr[], <span class="keyword">int</span> length)</span></span><br><span class="line"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i, j,k;</span><br><span class="line">  ElemType tmp;</span><br><span class="line">  <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; length; ++i)<span class="comment">// 趟次总共循环length次</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; length - <span class="number">1</span>; ++i)<span class="comment">//两两比较</span></span><br><span class="line">      &#123;</span><br><span class="line">        j = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (arr[j]() &gt; arr[i]())</span><br><span class="line">        &#123;</span><br><span class="line">          tmp = arr[i]();</span><br><span class="line">          arr[i]() = arr[j]();</span><br><span class="line">          arr[j]() = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>/*<br>5、快速排序算法<br>   基本思想：基于分治法，在待排序的n个元素中任取一个元素pivot作为基准，通过一趟排序将待排序表划分为独立的<br>   两部分L[1..k-1]和L[k+1 .. n],使得第一部分中的所有元素值都小于pivot，而第二部分中的所有元素值都大于pivot，<br>   则基准元素放在了其最终位置L（K）上，这个过程为一趟快速排序。而后分别递归地对两个子表重复上述过程，直到每<br>   部分内只有一个元素或为空为止，即所有元素都放在了其最终位置上。<br>*/</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(ElemType arr[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    ElemType pivot = arr[left]; <span class="comment">// 以当前表中第一个元素为枢轴值</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">while</span> (left \&lt; right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 从右向左找一个比枢轴值小的元素的位置</span></span><br><span class="line">        <span class="keyword">while</span> (left \&lt; right &amp;&amp; arr[right]() \&gt;= pivot)</span><br><span class="line">        &#123;</span><br><span class="line">          --right;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        arr[left]() = arr[right](); <span class="comment">// 将比枢轴值小的元素移动到左端</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从左向右查找比枢轴值大的元素的位置</span></span><br><span class="line">        <span class="keyword">while</span> (left \&lt; right &amp;&amp; arr[left]() \&lt;= pivot)</span><br><span class="line">        &#123;</span><br><span class="line">          ++left;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">       arr[right]() = arr[left]();<span class="comment">// 将比枢轴值大的元素移动到右端</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    arr[left]() = pivot; <span class="comment">// 将枢轴元素放在最终位置</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(ElemType arr[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left \&lt; right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> pivotPos = Partition(arr, left, right); <span class="comment">// 划分</span></span><br><span class="line">        QuickSort(arr, left, pivotPos - <span class="number">1</span>); <span class="comment">// 快速排序左半部分</span></span><br><span class="line">        QuickSort(arr, pivotPos + <span class="number">1</span>, right); <span class="comment">// 快速排序右半部分</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>/*<br>6、简单选择排序算法<br>   基本思想：<br>   假设排序表为L[1…n],第i趟排序从表中选择关键字最小的元素与Li交换，第一趟排序可以确定一个元素的<br>   最终位置，这样经过n-1趟排序就可以使得整个排序表有序。<br>*/</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SelectSort</span><span class="params">(ElemType arr[], <span class="keyword">int</span> length)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, min;</span><br><span class="line">    ElemType tmp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i \&lt; length - <span class="number">1</span>; ++i) <span class="comment">// 需要n-1趟</span></span><br><span class="line">    &#123;</span><br><span class="line">    min = i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = i + <span class="number">1</span>; j \&lt; length; ++j)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[j]() \&lt; arr[min]()) <span class="comment">// 每一趟选择元素值最小的下标</span></span><br><span class="line">      &#123;</span><br><span class="line">        min = j;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (min != i) <span class="comment">// 如果第i趟的Li元素值该趟找到的最小元素值，则交换，以使Li值最小</span></span><br><span class="line">    &#123;</span><br><span class="line">          tmp = arr[i]();</span><br><span class="line">          arr[i]() = arr[min]();</span><br><span class="line">          arr[min]() = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>/*<br>7、堆排序算法<br> 堆的定义如下：n个关键字序列号L<a href="">1..n</a>称为堆，仅当该序列满足：<br>1）L(i) \&lt;= L(2i)且L(i) \&lt;= L(2i+1) 或 2)L(i) >= L(2i)且L(i) >= L(2i+1)<br>满足第一种情况的堆，称为小根堆（小顶堆）；<br>满足第二种情况的堆，称为大根堆（大顶堆）。<br>*/</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapAdjust</span><span class="params">(ElemType \*a,<span class="keyword">int</span> i,<span class="keyword">int</span> size)</span>  <span class="comment">//调整堆</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lchild = <span class="number">2</span> \* i;       <span class="comment">//i的左孩子节点序号</span></span><br><span class="line">    <span class="keyword">int</span> rchild = <span class="number">2</span> \* i + <span class="number">1</span>;     <span class="comment">//i的右孩子节点序号</span></span><br><span class="line">    <span class="keyword">int</span> max = i;            <span class="comment">//临时变量</span></span><br><span class="line">   <span class="keyword">if</span>(i \&lt;= size / <span class="number">2</span>)          <span class="comment">//如果i是叶节点就不用进行调整</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (lchild \&lt;= size &amp;&amp; a[lchild]() \&gt; a[max]())</span><br><span class="line">&#123;</span><br><span class="line">max = lchild; <span class="comment">// 左孩子比双亲值还大，需要调整</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (rchild \&lt;= size &amp;&amp; a[rchild]() \&gt; a[max]())</span><br><span class="line">&#123;</span><br><span class="line">max = rchild;<span class="comment">// 右孩子比双亲值还大，需要调整</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (max != i) <span class="comment">// 需要调整</span></span><br><span class="line">&#123;</span><br><span class="line">ElemType tmp = a[max]();</span><br><span class="line">a[max]() = a[i]();</span><br><span class="line">a[i]() = tmp;</span><br><span class="line"></span><br><span class="line">HeapAdjust(a, max, size);    <span class="comment">//避免调整之后以max为父节点的子树不是堆</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BuildHeap</span><span class="params">(ElemType \*a,<span class="keyword">int</span> size)</span>    <span class="comment">//建立堆</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = size / <span class="number">2</span>; i \&gt;= <span class="number">0</span>; i--)    <span class="comment">//非叶节点最大序号值为size/2</span></span><br><span class="line">    &#123;</span><br><span class="line">        HeapAdjust(a, i, size);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapSort</span><span class="params">(ElemType \*a, <span class="keyword">int</span> size)</span>    <span class="comment">//堆排序</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    BuildHeap(a,size);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = size - <span class="number">1</span>; i \&gt;= <span class="number">0</span>; i--)</span><br><span class="line">&#123;</span><br><span class="line">swap(a[<span class="number">0</span>](), a[i]());           <span class="comment">//交换堆顶和最后一个元素，即每次将剩余元素中的最大者放到最后面</span></span><br><span class="line">BuildHeap(a, i-<span class="number">1</span>);        <span class="comment">//将余下元素重新建立为大顶堆</span></span><br><span class="line">HeapAdjust(a,<span class="number">1</span>,i-<span class="number">1</span>);      <span class="comment">//重新调整堆顶节点成为大顶堆</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Display</span><span class="params">(ElemType arr[], <span class="keyword">int</span> length)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i \&lt; length; ++i )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> \&lt;\&lt; arr[i] \&lt;\&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="built_in">cout</span> \&lt;\&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    ElemType arr[] = &#123;<span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">9</span>, -<span class="number">1</span>, <span class="number">4</span>, <span class="number">12</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//InsertSort(arr, sizeof(arr) / sizeof(ElemType));</span></span><br><span class="line"><span class="comment">//BinaryInsertSort(arr, sizeof(arr) / sizeof(ElemType));</span></span><br><span class="line"><span class="comment">//ShellSort(arr, sizeof(arr) / sizeof(ElemType));</span></span><br><span class="line"><span class="comment">//BubbleSort(arr, sizeof(arr) / sizeof(ElemType));</span></span><br><span class="line"><span class="comment">//QuickSort(arr, 0,  sizeof(arr) / sizeof(ElemType) - 1);</span></span><br><span class="line">HeapSort(arr, <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(ElemType));</span><br><span class="line">Display(arr, <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(ElemType));</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    </entry>
    
  
  
</search>
