<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[小时钟使用色采App进行自定义配色]]></title>
    <url>%2F2019%2F05%2F29%2F%E5%B0%8F%E6%97%B6%E9%92%9F%E4%BD%BF%E7%94%A8%E8%89%B2%E9%87%87App%E8%BF%9B%E8%A1%8C%E8%87%AA%E5%AE%9A%E4%B9%89%E9%85%8D%E8%89%B2%2F</url>
    <content type="text"><![CDATA[小时钟新版本核心功能强力上线啦！完全自由的主题配色，小时钟的颜值由你掌控！ 新版本的自定义配色功能可以和色采App配合使用。 1、 首先我们下载并打开色采App，从你身边的风景或者相册中制作一组配色 2、 点击某一组配色，进入编辑页面 3、 点击分享按钮 4、 系统分享组件中选择小时钟。如果没有，滑到最右侧，点击更多种选择。 5、 跳转到小时钟App的自定义配色页面，点击保存，完成啦~ 欢迎大家在即刻App分享自己创作的小时钟主题配色哟~❤️]]></content>
      <categories>
        <category>App</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[隐私政策]]></title>
    <url>%2F2018%2F11%2F11%2F%E9%9A%90%E7%A7%81%E6%94%BF%E7%AD%96%2F</url>
    <content type="text"><![CDATA[隐私政策: 本应用不会收集任何用户个人信息，请放心使用。 另外在未征得您事先许可的情况下，本应用不会将获取到的设备信息对外披露或向第三方提供。 本应用会不时更新本隐私权政策。 您在同意本应用服务使用协议之时，即视为您已经同意本隐私权政策全部内容。 本隐私权政策属于本应用服务使用协议不可分割的一部分。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Mapkit基本开发指南]]></title>
    <url>%2F2018%2F07%2F27%2FMapkit%E5%9F%BA%E6%9C%AC%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[MapKit是iOS自带的地图库。可以实现定位，地理编码，地图标注等功能。 一：查看是否导入MapKit.framework。 xcode5.1之后会自动导入二：创建地图 创建地图对象: _mapView = [[MKMapView alloc]initWithFrame:self.view.bounds]; 1.打开地图时的初始位置 1.1 设置地图中心点center 1CLLocationCoordinate2D center = CLLocationCoordinate2DMake(latitude, longitude); 1.2设置地图可视范围 数字越小，可现实范围越小 1MKCoordinateSpan span = MKCoordinateSpanMake(53-3, 135-73); 1.3设置region= cente+span 1234 CLLocationCoordinate2D center2 = CLLocationCoordinate2DMake(22.54387,113.950339); MKCoordinateSpan span2 = MKCoordinateSpanMake(0.1, 0.1);MKCoordinateRegion region2 = MKCoordinateRegionMake(center2, span2); [_mapView setRegion:region2 animated:YES]; 2.地图类型 12345MKMapTypeStandard = 0,MKMapTypeSatellite,MKMapTypeHybrid_mapView.mapType = MKMapTypeStandard; 3.设置地图上显示内容 123showsPointsOfInterestshowsBuildingsshowsTraffic 三： 获取当前点击位置的经纬度3.1给地图对象添加手势： 123//长按放置大头针，并获取当前点击位置的经纬度UILongPressGestureRecognizer *longPress = [[UILongPressGestureRecognizer alloc]initWithTarget:self action:@selector(whereAmI:)];[_mapView addGestureRecognizer:longPress]; 3.2创建地图编码器 CLGeocoder——地图编码器分为正向编码和反向编码。两种需要创建两个编码对象，不能公用。 _coder = [[CLGeocoder alloc]init]; 3.2.1正向地理编码：：将中文地址–&gt;经纬度 12345678910111213141516171819202122232425 [_coder geocodeAddressString:name completionHandler:^(NSArray *placemarks, NSError *error) &#123; NSLog(@"Error:%@",[error localizedDescription]); NSLog(@"------------正向地理编码------------"); for (CLPlacemark * mark in placemarks) &#123; CLLocation *location = mark.location;//是对CLLocationCoordinate2D的封装 NSLog(@"(纬度：%f,经度：%f)",location.coordinate.latitude,location.coordinate.longitude); NSLog(@"%@",mark.name);//位置的完整名称 NSLog(@"%@",mark.thoroughfare);//位置名称 NSLog(@"%@",mark.locality);//城市 NSLog(@"%@",mark.subLocality);//区 NSLog(@"%@",mark.administrativeArea);//省 //1.添加标注（大头针）// MKPointAnnotation *ann = [[MKPointAnnotation alloc]init];// //2.设置标注位置// ann.coordinate = CLLocationCoordinate2DMake(location.coordinate.latitude,location.coordinate.longitude);// ann.title = mark.thoroughfare;// ann.subtitle = mark.name; /*也可以使用自定义的Annotation*/ HLAnnotation *ann = [[HLAnnotation alloc]initWithTitle:mark.thoroughfare subtitle:mark.name coordinate:CLLocationCoordinate2DMake(location.coordinate.latitude, location.coordinate.longitude)]; //3.将标注添加到地图上 [_mapView addAnnotation:ann]; &#125; &#125;]; 3.2.2 反向地理编码：将经纬度—》中文地址信息 1234567891011121314151617181920212223[_coder reverseGeocodeLocation:location completionHandler:^(NSArray *placemarks, NSError *error) &#123; NSLog(@"Error:%@",[error localizedDescription]); NSLog(@"------------反向地理编码------------"); for (CLPlacemark * mark in placemarks) &#123; CLLocation *location = mark.location;//是对CLLocationCoordinate2D的封装 NSLog(@"(纬度：%f,经度：%f)",location.coordinate.latitude,location.coordinate.longitude); NSLog(@"%@",mark.name);//位置的完整名称 NSLog(@"%@",mark.thoroughfare);//位置名称 NSLog(@"%@",mark.locality);//城市 NSLog(@"%@",mark.subLocality);//区 NSLog(@"%@",mark.administrativeArea);//省 //1.添加标注（大头针） MKPointAnnotation *ann = [[MKPointAnnotation alloc]init]; //2.设置标注位置 ann.coordinate = CLLocationCoordinate2DMake(location.coordinate.latitude,location.coordinate.longitude); ann.title = mark.thoroughfare; ann.subtitle = mark.name; //3.将标注添加到地图上 [_mapView addAnnotation:ann]; &#125;&#125;]; 3.3 获取当前点击位置——-主要方法是 [tap locationInView：_mapView];获取当前点击的位置 1234567891011#pragma mark - 点击地图，添加标注大头针- (void)whereAmI:(UITapGestureRecognizer *)tap&#123; //1.获取点击点的位置 CGPoint point = [tap locationInView:_mapView]; //将点位置转换为当前经纬度 CLLocationCoordinate2D locationCor = [_mapView convertPoint:point toCoordinateFromView:_mapView]; //NSLog(@"(纬度：%f,经度：%f)",locationCor.latitude,locationCor.longitude); CLLocation *location = [[CLLocation alloc]initWithLatitude:locationCor.latitude longitude:locationCor.longitude]; [self reverseGeocodeLocation:location];&#125; 4.设置大头针的样式和状态——-需要遵守MKMapViewDelegate协议 12345#pragma mark - MKMapViewDelegate//也是有复用机制- (MKAnnotationView *)mapView:(MKMapView *)mapView viewForAnnotation:(id&lt;MKAnnotation&gt;)annotation;//设置大头针的状态——重点两个：1.设置大头针（pin）的拖拽状态为end。2.更新大头针的标注（annotation）内容- (void)mapView:(MKMapView *)mapView annotationView:(MKAnnotationView *)view didChangeDragState:(MKAnnotationViewDragState)newState fromOldState:(MKAnnotationViewDragState)oldState; //具体代码： 123456789101112131415161718192021222324252627282930313233343536- (MKAnnotationView *)mapView:(MKMapView *)mapView viewForAnnotation:(id&lt;MKAnnotation&gt;)annotation&#123; NSLog(@"annotation的类型：%@",[annotation class]); //1.先从复用队列中取出可用的大头针，如果没有，则创建 MKAnnotationView *annView = [mapView dequeueReusableAnnotationViewWithIdentifier:@"ann"]; //判断一下当前annotation的数据类型，如果是用户定位MKUserLocation类，则直接返回，这样当前位置的view就是一个蓝色小圆圈，而不是大头针。 if ([annotation isKindOfClass:[MKUserLocation class]]) &#123; return annView; &#125; if (annView == nil) &#123; annView = [[MKPinAnnotationView alloc]initWithAnnotation:annotation reuseIdentifier:@"ann"]; &#125; //MKPinAnnotationView是MKAnnotationView的子类 //如果使用 annView = [MKPinAnnotationView alloc] MKPinAnnotationView *pin = (MKPinAnnotationView *)annView; //pin.pinColor = MKPinAnnotationColorGreen; pin.animatesDrop = YES; //2.设置大头针 //2.1设置大头针图片 //annView.image = [UIImage imageNamed:@"map"]; //2.2设置拖拽 annView.draggable = YES; //2.3设置弹出泡泡 annView.canShowCallout = YES; //2.4设置左右视图 UIButton * right = [UIButton buttonWithType:UIButtonTypeDetailDisclosure]; right.frame = CGRectMake(0, 0, 30, 30); annView.rightCalloutAccessoryView = right;// annView.leftCalloutAccessoryView return annView;&#125; //设置大头针的状态 12345678910111213141516171819202122232425- (void)mapView:(MKMapView *)mapView annotationView:(MKAnnotationView *)view didChangeDragState:(MKAnnotationViewDragState)newState fromOldState:(MKAnnotationViewDragState)oldState&#123; if (newState == MKAnnotationViewDragStateEnding) &#123; //结束大头针View的拖拽状态 [view setDragState:MKAnnotationViewDragStateNone animated:YES]; //更新当前大头针的标注内容 HLAnnotation *ann = view.annotation; NSLog(@"(%f,%f)",ann.coordinate.latitude,ann.coordinate.longitude); CLLocation *location = [[CLLocation alloc]initWithLatitude:ann.coordinate.latitude longitude:ann.coordinate.longitude]; //反向获取位置信息 [_coder reverseGeocodeLocation:location completionHandler:^(NSArray *placemarks, NSError *error) &#123; NSLog(@"Error:%@",[error localizedDescription]); NSLog(@"------------反向地理编码------------"); for (CLPlacemark * mark in placemarks) &#123; CLLocation *location = mark.location;//是对CLLocationCoordinate2D的封装 //2.设置标注位置 ann.coordinate = CLLocationCoordinate2DMake(location.coordinate.latitude,location.coordinate.longitude); [ann setTitle:mark.thoroughfare]; [ann setSubtitle:mark.name]; //3.将标注添加到地图上 [_mapView addAnnotation:ann]; &#125; &#125;]; &#125;&#125; 四：定位用户定位与位置相关，所以使用的是CLLocationManager类。1.打开用户位置显示开关2.创建位置管理对象3.设置精度和更新频率4.启动位置更新 12345678910//创建位置管理对象_manager = [[CLLocationManager alloc]init];_mapView.showsUserLocation = YES;//显示用户当前位置//设置精度和更新频率_manager.desiredAccuracy = kCLLocationAccuracyNearestTenMeters;//精度_manager.distanceFilter = 100.0;//更新频率，每经过100m更新一次//启动定位，用完应该马上停止，定位结果在代理方法中获取_manager.delegate = self;[_manager startUpdatingLocation]; 那么如何让地图自动跳转到定位的位置呢？这里需要实现协议CLLocationManagerDelegate。定位结果就是从协议方法中取得 123456789101112#pragma mark - CLLocationManagerDelegate- (void)locationManager:(CLLocationManager *)manager didUpdateLocations:(NSArray *)locations&#123; CLLocation *currentLocation = [locations lastObject]; //将地图移动到当前定位的位置 CLLocationCoordinate2D currentCoordinate = currentLocation.coordinate; MKCoordinateSpan span = _mapView.region.span;//当前地图缩放比例 MKCoordinateRegion region = &#123;currentCoordinate,span&#125;; [_mapView setRegion:region]; NSLog(@"定位结束%@",currentLocation);&#125; 五：多个经纬度做反向地理编码。 有个需求要求我们先把策划给的一张包含2664个城市经纬度的表，通过反向地理编码得出对应的城市名，在做的过程中遇到并处理了以下问题：流程：1.读取CVS文件，并写入数组中。2.每次从数组中拿出50个数据，并判断是否finish。3.创建定时器timer，实现一直循环第2步。4.每次反向编码后的城市名写入文件中。 由于reverseGeocodeLocation处理经纬度的请求有限制：reverseGeocodeLocation方法有如下描述 Submits a reverse-geocoding request for the specified location. This method submits the specified location data to the geocoding server asynchronously and returns. When the request completes, the geocoder executes the provided completion handler on the main thread.After initiating a reverse-geocoding request, do not attempt to initiate another reverse- or forward-geocoding request. Geocoding requests are rate-limited for each app, so making too many requests in a short period of time may cause some of the requests to fail. When the maximum rate is exceeded, the geocoder passes an error object with the value kCLErrorNetwork to your completion handler. 划重点： 这个方法是异步的。 同一个app在一段时间间隔内会有一个调用频率（rate-limited）。经测试， geocoding server一次可以处理的请求数为50个，并且时间间隔大约在1分钟左右。 针对以上两点，我采用了dispatch_group，每一个请求结束后leave group，并且notify到主线程，将结果写入另外的文件。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960- (void)geocodingForLocations:(NSArray *)locations &#123; __weak typeof(self)wself = self; dispatch_group_t group = dispatch_group_create(); [locations enumerateObjectsUsingBlock:^(id _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) &#123; CLLocation *location = obj; dispatch_group_enter(group); CLGeocoder *geocoder = [[CLGeocoder alloc] init]; [geocoder reverseGeocodeLocation:location completionHandler:^(NSArray&lt;CLPlacemark *&gt; * _Nullable placemarks, NSError * _Nullable error) &#123; for (CLPlacemark * placemark in placemarks) &#123; NSLog(@"location：%@",location); NSLog(@"name：%@",placemark.name); NSDecimalNumberHandler *handle = [[NSDecimalNumberHandler alloc] initWithRoundingMode:NSRoundDown scale:6 raiseOnExactness:NO raiseOnOverflow:NO raiseOnUnderflow:NO raiseOnDivideByZero:NO] ; NSDecimalNumber *rLan = [[NSDecimalNumber alloc] initWithDouble:location.coordinate.latitude]; NSDecimalNumber *rLon = [[NSDecimalNumber alloc] initWithDouble:location.coordinate.longitude]; rLan = [rLan decimalNumberByRoundingAccordingToBehavior:handle]; rLon = [rLon decimalNumberByRoundingAccordingToBehavior:handle]; NSString *llllan = [NSString stringWithFormat:@"%0.6f",location.coordinate.latitude]; NSString *llllon = [NSString stringWithFormat:@"%0.6f",location.coordinate.longitude]; NSString *city = placemark.locality ?placemark.locality: placemark.administrativeArea; NSLog(@"city：%@",city); BOOL same = NO; NSString *tempNameFromGoogle = [NSString stringWithFormat:@"%@-%@",rLan,rLon]; //这里很耗时 for (NSDictionary *dic in self.locationsOfGoogle) &#123; NSString *latitude = dic[@"lan"]; NSString *longtitude = dic[@"lon"]; NSString *cityName = dic[@"name"]; NSComparisonResult latiresult = [rLan compare:latitude];// NSComparisonResult lonresult = [rLan compare:latitude]; if (([latitude isEqualToString:llllan] &amp;&amp; [longtitude isEqualToString:llllon]) || [cityName isEqualToString:city])&#123; //找到对应的坐标判断城市名 same = [cityName isEqualToString:city]; NSLog(@"城市名是否相同：%d--%f,%f",same,latitude.doubleValue,longtitude.doubleValue); tempNameFromGoogle = cityName; break; &#125; &#125; [wself.citys appendString:[NSString stringWithFormat:@"%f,%f,%@,%d,%@\r\n",location.coordinate.latitude,location.coordinate.longitude, city,same,tempNameFromGoogle]]; &#125; NSLog(@"第%lu次 leave ： %lu",wself.k/50,idx); dispatch_group_leave(group); &#125;]; &#125;]; dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123; NSLog(@"第%lu次 notify",wself.k/50); [self createFile]; &#125;);&#125; 六: MKMapView的zoomLevel系统类没有直接获取zoomLevel的属性，参考一下https://stackoverflow.com/questions/4189621/setting-the-zoom-level-for-a-mkmapview]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Mapkit</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[YYCache 源码解析]]></title>
    <url>%2F2018%2F07%2F19%2FYYCache-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[YYCache 源码解析 YYCache是国内开发者ibireme开源的一个线程安全的高性能缓存组件，代码风格简洁清晰，在GitHub上已经有了1600+颗星。 阅读它的源码有助于建立比较完整的缓存设计的思路，同时也能巩固一下双向链表，线程锁，数据库操作相关的知识。如果你还没有看过YYCache的源码，那么恭喜你，阅读此文会对理解YYCache的源码有比较大的帮助。 在正式开始讲解源码之前，先简单看一下该框架的使用方法。 基本使用方法举一个缓存用户姓名的例子来看一下YYCache的几个API： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647 //需要缓存的对象 NSString *userName = @&quot;Jack&quot;; //需要缓存的对象在缓存里对应的键 NSString *key = @&quot;user_name&quot;; //创建一个YYCache实例:userInfoCache YYCache *userInfoCache = [YYCache cacheWithName:@&quot;userInfo&quot;]; //存入键值对 [userInfoCache setObject:userName forKey:key withBlock:^&#123; NSLog(@&quot;caching object succeed&quot;); &#125;]; //判断缓存是否存在 [userInfoCache containsObjectForKey:key withBlock:^(NSString * _Nonnull key, BOOL contains) &#123; if (contains)&#123; NSLog(@&quot;object exists&quot;); &#125; &#125;]; //根据key读取数据 [userInfoCache objectForKey:key withBlock:^(NSString * _Nonnull key, id&lt;NSCoding&gt; _Nonnull object) &#123; NSLog(@&quot;user name : %@&quot;,object); &#125;]; //根据key移除缓存 [userInfoCache removeObjectForKey:key withBlock:^(NSString * _Nonnull key) &#123; NSLog(@&quot;remove user name %@&quot;,key); &#125;]; //移除所有缓存 [userInfoCache removeAllObjectsWithBlock:^&#123; NSLog(@&quot;removing all cache succeed&quot;); &#125;]; //移除所有缓存带进度 [userInfoCache removeAllObjectsWithProgressBlock:^(int removedCount, int totalCount) &#123; NSLog(@&quot;remove all cache objects: removedCount :%d totalCount : %d&quot;,removedCount,totalCount); &#125; endBlock:^(BOOL error) &#123; if(!error)&#123; NSLog(@&quot;remove all cache objects: succeed&quot;); &#125;else&#123; NSLog(@&quot;remove all cache objects: failed&quot;); &#125; &#125;];复制代码 总体来看这些API与NSCache是差不多的。 再来看一下框架的架构图与成员职责划分。 架构图与成员职责划分架构图 成员职责划分从架构图上来看，该组件里面的成员并不多： YYCache：提供了最外层的接口，调用了YYMemoryCache与YYDiskCache的相关方法。 YYMemoryCache：负责处理容量小，相对高速的内存缓存。线程安全，支持自动和手动清理缓存等功能。 _YYLinkedMap：YYMemoryCache使用的双向链表类。 _YYLinkedMapNode：是_YYLinkedMap使用的节点类。 YYDiskCache：负责处理容量大，相对低速的磁盘缓存。线程安全，支持异步操作，自动和手动清理缓存等功能。 YYKVStorage：YYDiskCache的底层实现类，用于管理磁盘缓存。 YYKVStorageItem：内置在YYKVStorage中，是YYKVStorage内部用于封装某个缓存的类。 代码讲解知道了YYCache的架构图与成员职责划分以后，现在结合代码开始正式讲解。 讲解分为下面6个部分： YYCache YYMemoryCache YYDiskCache 保证线程安全的不同方案 提高缓存性能的几个尝试 其他知识点 YYCacheYYCache给用户提供所有最外层的缓存操作接口，而这些接口的内部内部实际上是调用了YYMemoryCache和YYDiskCache对象的相关方法。 我们来看一下YYCache的属性和接口： YYCache的属性和接口1234567891011121314151617181920212223242526272829303132333435363738@interface YYCache : NSObject@property (copy, readonly) NSString *name;//缓存名称@property (strong, readonly) YYMemoryCache *memoryCache;//内存缓存@property (strong, readonly) YYDiskCache *diskCache;//磁盘缓存//是否包含某缓存，无回调- (BOOL)containsObjectForKey:(NSString *)key;//是否包含某缓存，有回调- (void)containsObjectForKey:(NSString *)key withBlock:(nullable void(^)(NSString *key, BOOL contains))block;//获取缓存对象，无回调- (nullable id&lt;NSCoding&gt;)objectForKey:(NSString *)key;//获取缓存对象，有回调- (void)objectForKey:(NSString *)key withBlock:(nullable void(^)(NSString *key, id&lt;NSCoding&gt; object))block;//写入缓存对象，无回调- (void)setObject:(nullable id&lt;NSCoding&gt;)object forKey:(NSString *)key;//写入缓存对象，有回调- (void)setObject:(nullable id&lt;NSCoding&gt;)object forKey:(NSString *)key withBlock:(nullable void(^)(void))block;//移除某缓存，无回调- (void)removeObjectForKey:(NSString *)key;//移除某缓存，有回调- (void)removeObjectForKey:(NSString *)key withBlock:(nullable void(^)(NSString *key))block;//移除所有缓存，无回调- (void)removeAllObjects;//移除所有缓存，有回调- (void)removeAllObjectsWithBlock:(void(^)(void))block;//移除所有缓存，有进度和完成的回调- (void)removeAllObjectsWithProgressBlock:(nullable void(^)(int removedCount, int totalCount))progress endBlock:(nullable void(^)(BOOL error))end;@end复制代码 从上面的接口可以看出YYCache的接口和NSCache很相近，而且在接口上都区分了有无回调的功能。 下面结合代码看一下这些接口是如何实现的： YYCache的接口实现下面省略了带有回调的接口，因为与无回调的接口非常接近。 123456789101112131415161718192021222324252627282930313233343536373839404142- (BOOL)containsObjectForKey:(NSString *)key &#123; //先检查内存缓存是否存在，再检查磁盘缓存是否存在 return [_memoryCache containsObjectForKey:key] || [_diskCache containsObjectForKey:key];&#125;- (id&lt;NSCoding&gt;)objectForKey:(NSString *)key &#123; //首先尝试获取内存缓存，然后获取磁盘缓存 id&lt;NSCoding&gt; object = [_memoryCache objectForKey:key]; //如果内存缓存不存在，就会去磁盘缓存里面找：如果找到了，则再次写入内存缓存中；如果没找到，就返回nil if (!object) &#123; object = [_diskCache objectForKey:key]; if (object) &#123; [_memoryCache setObject:object forKey:key]; &#125; &#125; return object;&#125;- (void)setObject:(id&lt;NSCoding&gt;)object forKey:(NSString *)key &#123; //先写入内存缓存，后写入磁盘缓存 [_memoryCache setObject:object forKey:key]; [_diskCache setObject:object forKey:key];&#125;- (void)removeObjectForKey:(NSString *)key &#123; //先移除内存缓存，后移除磁盘缓存 [_memoryCache removeObjectForKey:key]; [_diskCache removeObjectForKey:key];&#125;- (void)removeAllObjects &#123; //先全部移除内存缓存，后全部移除磁盘缓存 [_memoryCache removeAllObjects]; [_diskCache removeAllObjects];&#125;复制代码 从上面的接口实现可以看出：在YYCache中，永远都是先访问内存缓存，然后再访问磁盘缓存（包括了写入，读取，查询，删除缓存的操作）。而且关于内存缓存（_memoryCache）的操作，是不存在block回调的。 值得一提的是：在读取缓存的操作中，如果在内存缓存中无法获取对应的缓存，则会去磁盘缓存中寻找。如果在磁盘缓存中找到了对应的缓存，则会将该对象再次写入内存缓存中，保证在下一次尝试获取同一缓存时能够在内存中就能返回，提高速度。 OK，现在了解了YYCache的接口以及实现，下面我分别讲解一下YYMemoryCache（内存缓存）和YYDiskCache（磁盘缓存）这两个类。 YYMemoryCacheYYMemoryCache负责处理容量小，相对高速的内存缓存：它将需要缓存的对象与传入的key关联起来，操作类似于NSCache。 但是与NSCache不同的是，YYMemoryCache的内部有： 缓存淘汰算法：使用LRU(least-recently-used) 算法来淘汰（清理）使用频率较低的缓存。 缓存清理策略：使用三个维度来标记，分别是count（缓存数量），cost（开销），age（距上一次的访问时间）。YYMemoryCache提供了分别针对这三个维度的清理缓存的接口。用户可以根据不同的需求（策略）来清理在某一维度超标的缓存。 一个是淘汰算法，另一个是清理维度，乍一看可能没什么太大区别。我在这里先简单区分一下： 缓存淘汰算法的目的在于区分出使用频率高和使用频率低的缓存，当缓存数量达到一定限制的时候会优先清理那些使用频率低的缓存。因为使用频率已经比较低的缓存在将来的使用频率也很有可能会低。 缓存清理维度是给每个缓存添加的标记： 如果用户需要删除age（距上一次的访问时间）超过1天的缓存，在YYMemoryCache内部，就会从使用频率最低的那个缓存开始查找，直到所有距上一次的访问时间超过1天的缓存都清理掉为止。 如果用户需要将缓存总开销清理到总开销小于或等于某个值，在YYMemoryCache内部，就会从使用频率最低的那个缓存开始清理，直到总开销小于或等于这个值。 如果用户需要将缓存总数清理到总开销小于或等于某个值，在YYMemoryCache内部，就会从使用频率最低的那个缓存开始清理，直到总开销小于或等于这个值。 可以看出，无论是以哪个维度来清理缓存，都是从缓存使用频率最低的那个缓存开始清理。而YYMemoryCache保留的所有缓存的使用频率的高低，是由LRU这个算法决定的。 现在知道了这二者的区别，下面来具体讲解一下缓存淘汰算法和缓存清理策略： YYMemoryCache的缓存淘汰算法在详细讲解这个算法之前我觉得有必要先说一下该算法的核心： 我个人认为LRU缓存替换策略的核心在于如果某个缓存访问的频率越高，就认定用户在将来越有可能访问这个缓存。 所以在这个算法中，将那些最新访问（写入），最多次被访问的缓存移到最前面，然后那些很早之前写入，不经常访问的缓存就被自动放在了后面。这样一来，在保留的缓存个数一定的情况下，留下的缓存都是访问频率比较高的，这样一来也就提升了缓存的命中率。谁都不想留着一些很难被用户再次访问的缓存，毕竟缓存本身也占有一定的资源不是么？ 其实这个道理和一些商城类app的商品推荐逻辑是一样的： 如果首页只能展示10个商品，对于一个程序员用户来说，可能推荐的是于那些他最近购买商品类似的机械键盘鼠标，技术书籍或者显示屏之类的商品，而不是一些洋娃娃或是钢笔之类的商品。 那么LRU算法具体是怎么做的呢？ 在YYMemoryCache中，使用了双向链表这个数据结构来保存这些缓存： 当写入一个新的缓存时，要把这个缓存节点放在链表头部，并且并且原链表头部的缓存节点要变成现在链表的第二个缓存节点。 当访问一个已有的缓存时，要把这个缓存节点移动到链表头部，原位置两侧的缓存要接上，并且原链表头部的缓存节点要变成现在链表的第二个缓存节点。 （根据清理维度）自动清理缓存时，要从链表的最后端逐个清理。 这样一来，就可以保证链表前端的缓存是最近写入过和经常访问过的。而且该算法总是从链表的最后端删除缓存，这也就保证了留下的都是一些“比较新鲜的”缓存。 下面结合代码来讲解一下这个算法的实现： YYMemoryCache用一个链表节点类来保存某个单独的内存缓存的信息（键，值，缓存时间等），然后用一个双向链表类来保存和管理这些节点。这两个类的名称分别是： _YYLinkedMapNode：链表内的节点类，可以看做是对某个单独内存缓存的封装。 _YYLinkedMap：双向链表类，用于保存和管理所有内存缓存(节点) _YYLinkedMapNode_YYLinkedMapNode可以被看做是对某个缓存的封装：它包含了该节点上一个和下一个节点的指针，以及缓存的key和对应的值（对象），还有该缓存的开销和访问时间。 12345678910111213141516@interface _YYLinkedMapNode : NSObject &#123; @package __unsafe_unretained _YYLinkedMapNode *_prev; // retained by dic __unsafe_unretained _YYLinkedMapNode *_next; // retained by dic id _key; //缓存key id _value; //key对应值 NSUInteger _cost; //缓存开销 NSTimeInterval _time; //访问时间&#125;@end@implementation _YYLinkedMapNode@end复制代码 下面看一下双向链表类： _YYLinkedMap12345678910111213141516171819202122232425262728@interface _YYLinkedMap : NSObject &#123; @package CFMutableDictionaryRef _dic; // 用于存放节点 NSUInteger _totalCost; //总开销 NSUInteger _totalCount; //节点总数 _YYLinkedMapNode *_head; // 链表的头部结点 _YYLinkedMapNode *_tail; // 链表的尾部节点 BOOL _releaseOnMainThread; //是否在主线程释放，默认为NO BOOL _releaseAsynchronously; //是否在子线程释放，默认为YES&#125;//在链表头部插入某节点- (void)insertNodeAtHead:(_YYLinkedMapNode *)node;//将链表内部的某个节点移到链表头部- (void)bringNodeToHead:(_YYLinkedMapNode *)node;//移除某个节点- (void)removeNode:(_YYLinkedMapNode *)node;//移除链表的尾部节点并返回它- (_YYLinkedMapNode *)removeTailNode;//移除所有节点（默认在子线程操作）- (void)removeAll;@end复制代码 从链表类的属性上看：链表类内置了CFMutableDictionaryRef，用于保存节点的键值对，它还持有了链表内节点的总开销，总数量，头尾节点等数据。 可以参考下面这张图来看一下二者的关系： 看一下_YYLinkedMap的接口的实现： 将节点插入到链表头部： 123456789101112131415161718192021222324252627- (void)insertNodeAtHead:(_YYLinkedMapNode *)node &#123; //设置该node的值 CFDictionarySetValue(_dic, (__bridge const void *)(node-&gt;_key), (__bridge const void *)(node)); //增加开销和总缓存数量 _totalCost += node-&gt;_cost; _totalCount++; if (_head) &#123; //如果链表内已经存在头节点，则将这个头节点赋给当前节点的尾指针（原第一个节点变成了现第二个节点） node-&gt;_next = _head; //将该节点赋给现第二个节点的头指针（此时_head指向的节点是先第二个节点） _head-&gt;_prev = node; //将该节点赋给链表的头结点指针（该节点变成了现第一个节点） _head = node; &#125; else &#123; //如果链表内没有头结点，说明是空链表。说明是第一次插入，则将链表的头尾节点都设置为当前节点 _head = _tail = node; &#125;&#125;复制代码 要看懂节点操作的代码只要了解双向链表的特性即可。在双向链表中： 每个节点都有两个分别指向前后节点的指针。所以说每个节点都知道它前一个节点和后一个节点是谁。 链表的头部节点指向它前面节点的指针为空；链表尾部节点指向它后侧节点的指针也为空。 为了便于理解，我们可以把这个抽象概念类比于幼儿园手拉手的小朋友们： 每个小朋友的左手都拉着前面小朋友的右手；每个小朋友的右手都拉着后面小朋友的左手； 而且最前面的小朋友的左手和最后面的小朋友的右手都没有拉任何一个小朋友。 将某个节点移动到链表头部： 123456789101112131415161718192021222324252627282930313233343536373839- (void)bringNodeToHead:(_YYLinkedMapNode *)node &#123; //如果该节点已经是链表头部节点，则立即返回，不做任何操作 if (_head == node) return; if (_tail == node) &#123; //如果该节点是链表的尾部节点 //1. 将该节点的头指针指向的节点变成链表的尾节点（将倒数第二个节点变成倒数第一个节点，即尾部节点） _tail = node-&gt;_prev; //2. 将新的尾部节点的尾部指针置空 _tail-&gt;_next = nil; &#125; else &#123; //如果该节点是链表头部和尾部以外的节点（中间节点） //1. 将该node的头指针指向的节点赋给其尾指针指向的节点的头指针 node-&gt;_next-&gt;_prev = node-&gt;_prev; //2. 将该node的尾指针指向的节点赋给其头指针指向的节点的尾指针 node-&gt;_prev-&gt;_next = node-&gt;_next; &#125; //将原头节点赋给该节点的尾指针（原第一个节点变成了现第二个节点） node-&gt;_next = _head; //将当前节点的头节点置空 node-&gt;_prev = nil; //将现第二个节点的头结点指向当前节点（此时_head指向的节点是现第二个节点） _head-&gt;_prev = node; //将该节点设置为链表的头节点 _head = node;&#125;复制代码 第一次看上面的代码我自己是懵逼的，不过如果结合上面小朋友拉手的例子就可以快一点理解。 如果要其中一个小朋友放在队伍的最前面，需要 将原来这个小朋友前后的小朋友的手拉上。 然后将这个小朋友的右手和原来排在第一位的小朋友的左手拉上。 上面说的比较简略，但是相信对大家理解整个过程会有帮助。 也可以再结合链表的图解来看一下： 读者同样可以利用这种思考方式理解下面这段代码： 移除链表中的某个节点： 1234567891011121314151617181920212223- (void)removeNode:(_YYLinkedMapNode *)node &#123; //除去该node的键对应的值 CFDictionaryRemoveValue(_dic, (__bridge const void *)(node-&gt;_key)); //减去开销和总缓存数量 _totalCost -= node-&gt;_cost; _totalCount--; //节点操作 //1. 将该node的头指针指向的节点赋给其尾指针指向的节点的头指针 if (node-&gt;_next) node-&gt;_next-&gt;_prev = node-&gt;_prev; //2. 将该node的尾指针指向的节点赋给其头指针指向的节点的尾指针 if (node-&gt;_prev) node-&gt;_prev-&gt;_next = node-&gt;_next; //3. 如果该node就是链表的头结点，则将该node的尾部指针指向的节点赋给链表的头节点（第二变成了第一） if (_head == node) _head = node-&gt;_next; //4. 如果该node就是链表的尾节点，则将该node的头部指针指向的节点赋给链表的尾节点（倒数第二变成了倒数第一） if (_tail == node) _tail = node-&gt;_prev;&#125;复制代码 移除并返回尾部的node: 12345678910111213141516171819202122232425262728- (_YYLinkedMapNode *)removeTailNode &#123; //如果不存在尾节点，则返回nil if (!_tail) return nil; _YYLinkedMapNode *tail = _tail; //移除尾部节点对应的值 CFDictionaryRemoveValue(_dic, (__bridge const void *)(_tail-&gt;_key)); //减少开销和总缓存数量 _totalCost -= _tail-&gt;_cost; _totalCount--; if (_head == _tail) &#123; //如果链表的头尾节点相同，说明链表只有一个节点。将其置空 _head = _tail = nil; &#125; else &#123; //将链表的尾节指针指向的指针赋给链表的尾指针（倒数第二变成了倒数第一） _tail = _tail-&gt;_prev; //将新的尾节点的尾指针置空 _tail-&gt;_next = nil; &#125; return tail;&#125;复制代码 OK，现在了解了YYMemoryCache底层的节点操作的代码。现在来看一下YYMemoryCache是如何使用它们的。 YYMemoryCache的属性和接口1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980//YYMemoryCache.h@interface YYMemoryCache : NSObject#pragma mark - Attribute//缓存名称，默认为nil@property (nullable, copy) NSString *name;//缓存总数量@property (readonly) NSUInteger totalCount;//缓存总开销@property (readonly) NSUInteger totalCost;#pragma mark - Limit//数量上限，默认为NSUIntegerMax，也就是无上限@property NSUInteger countLimit;//开销上限，默认为NSUIntegerMax，也就是无上限@property NSUInteger costLimit;//缓存时间上限，默认为DBL_MAX，也就是无上限@property NSTimeInterval ageLimit;//清理超出上限之外的缓存的操作间隔时间，默认为5s@property NSTimeInterval autoTrimInterval;//收到内存警告时是否清理所有缓存，默认为YES@property BOOL shouldRemoveAllObjectsOnMemoryWarning;//app进入后台是是否清理所有缓存，默认为YES@property BOOL shouldRemoveAllObjectsWhenEnteringBackground;//收到内存警告的回调block@property (nullable, copy) void(^didReceiveMemoryWarningBlock)(YYMemoryCache *cache);//进入后台的回调block@property (nullable, copy) void(^didEnterBackgroundBlock)(YYMemoryCache *cache);//缓存清理是否在后台进行，默认为NO@property BOOL releaseOnMainThread;//缓存清理是否异步执行，默认为YES@property BOOL releaseAsynchronously;#pragma mark - Access Methods//是否包含某个缓存- (BOOL)containsObjectForKey:(id)key;//获取缓存对象- (nullable id)objectForKey:(id)key;//写入缓存对象- (void)setObject:(nullable id)object forKey:(id)key;//写入缓存对象，并添加对应的开销- (void)setObject:(nullable id)object forKey:(id)key withCost:(NSUInteger)cost;//移除某缓存- (void)removeObjectForKey:(id)key;//移除所有缓存- (void)removeAllObjects;#pragma mark - Trim// =========== 缓存清理接口 =========== //清理缓存到指定个数- (void)trimToCount:(NSUInteger)count;//清理缓存到指定开销- (void)trimToCost:(NSUInteger)cost;//清理缓存时间小于指定时间的缓存- (void)trimToAge:(NSTimeInterval)age;复制代码 YYMemoryCache的接口实现在YYMemoryCache的初始化方法里，会实例化一个_YYLinkedMap的实例来赋给_lru这个成员变量。 123456789- (instancetype)init&#123; .... _lru = [_YYLinkedMap new]; ... &#125;复制代码 然后所有的关于缓存的操作，都要用到_lru这个成员变量，因为它才是在底层持有这些缓存（节点）的双向链表类。下面我们来看一下这些缓存操作接口的实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136//是否包含某个缓存对象- (BOOL)containsObjectForKey:(id)key &#123; //尝试从内置的字典中获得缓存对象 if (!key) return NO; pthread_mutex_lock(&amp;_lock); BOOL contains = CFDictionaryContainsKey(_lru-&gt;_dic, (__bridge const void *)(key)); pthread_mutex_unlock(&amp;_lock); return contains;&#125;//获取某个缓存对象- (id)objectForKey:(id)key &#123; if (!key) return nil; pthread_mutex_lock(&amp;_lock); _YYLinkedMapNode *node = CFDictionaryGetValue(_lru-&gt;_dic, (__bridge const void *)(key)); if (node) &#123; //如果节点存在，则更新它的时间信息（最后一次访问的时间） node-&gt;_time = CACurrentMediaTime(); [_lru bringNodeToHead:node]; &#125; pthread_mutex_unlock(&amp;_lock); return node ? node-&gt;_value : nil;&#125;//写入某个缓存对象，开销默认为0- (void)setObject:(id)object forKey:(id)key &#123; [self setObject:object forKey:key withCost:0];&#125;//写入某个缓存对象，并存入缓存开销- (void)setObject:(id)object forKey:(id)key withCost:(NSUInteger)cost &#123; if (!key) return; if (!object) &#123; [self removeObjectForKey:key]; return; &#125; pthread_mutex_lock(&amp;_lock); _YYLinkedMapNode *node = CFDictionaryGetValue(_lru-&gt;_dic, (__bridge const void *)(key)); NSTimeInterval now = CACurrentMediaTime(); if (node) &#123; //如果存在与传入的key值匹配的node，则更新该node的value,cost,time，并将这个node移到链表头部 //更新总cost _lru-&gt;_totalCost -= node-&gt;_cost; _lru-&gt;_totalCost += cost; //更新node node-&gt;_cost = cost; node-&gt;_time = now; node-&gt;_value = object; //将node移动至链表头部 [_lru bringNodeToHead:node]; &#125; else &#123; //如果不存在与传入的key值匹配的node，则新建一个node，将key,value,cost,time赋给它，并将这个node插入到链表头部 //新建node,并赋值 node = [_YYLinkedMapNode new]; node-&gt;_cost = cost; node-&gt;_time = now; node-&gt;_key = key; node-&gt;_value = object; //将node插入至链表头部 [_lru insertNodeAtHead:node]; &#125; //如果cost超过了限制，则进行删除缓存操作（从链表尾部开始删除，直到符合限制要求） if (_lru-&gt;_totalCost &gt; _costLimit) &#123; dispatch_async(_queue, ^&#123; [self trimToCost:_costLimit]; &#125;); &#125; //如果total count超过了限制，则进行删除缓存操作（从链表尾部开始删除，删除一次即可） if (_lru-&gt;_totalCount &gt; _countLimit) &#123; _YYLinkedMapNode *node = [_lru removeTailNode]; if (_lru-&gt;_releaseAsynchronously) &#123; dispatch_queue_t queue = _lru-&gt;_releaseOnMainThread ? dispatch_get_main_queue() : YYMemoryCacheGetReleaseQueue(); dispatch_async(queue, ^&#123; [node class]; //hold and release in queue &#125;); &#125; else if (_lru-&gt;_releaseOnMainThread &amp;&amp; !pthread_main_np()) &#123; dispatch_async(dispatch_get_main_queue(), ^&#123; [node class]; //hold and release in queue &#125;); &#125; &#125; pthread_mutex_unlock(&amp;_lock);&#125;//移除某个缓存对象- (void)removeObjectForKey:(id)key &#123; if (!key) return; pthread_mutex_lock(&amp;_lock); _YYLinkedMapNode *node = CFDictionaryGetValue(_lru-&gt;_dic, (__bridge const void *)(key)); if (node) &#123; //内部调用了链表的removeNode：方法 [_lru removeNode:node]; if (_lru-&gt;_releaseAsynchronously) &#123; dispatch_queue_t queue = _lru-&gt;_releaseOnMainThread ? dispatch_get_main_queue() : YYMemoryCacheGetReleaseQueue(); dispatch_async(queue, ^&#123; [node class]; //hold and release in queue &#125;); &#125; else if (_lru-&gt;_releaseOnMainThread &amp;&amp; !pthread_main_np()) &#123; dispatch_async(dispatch_get_main_queue(), ^&#123; [node class]; //hold and release in queue &#125;); &#125; &#125; pthread_mutex_unlock(&amp;_lock);&#125;//内部调用了链表的removeAll方法- (void)removeAllObjects &#123; pthread_mutex_lock(&amp;_lock); [_lru removeAll]; pthread_mutex_unlock(&amp;_lock);&#125;复制代码 上面的实现是针对缓存的查询，写入，获取操作的，接下来看一下缓存的清理策略。 YYMemoryCache的缓存清理策略如上文所说，在YYCache中，缓存的清理可以从缓存总数量，缓存总开销，缓存距上一次的访问时间来清理缓存。而且每种维度的清理操作都可以分为自动和手动的方式来进行。 缓存自动清理缓存的自动清理功能在YYMemoryCache初始化之后就开始了，是一个递归调用的实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344//YYMemoryCache.m- (instancetype)init&#123; ... //开始定期清理 [self _trimRecursively]; ...&#125;//递归清理，相隔时间为_autoTrimInterval，在初始化之后立即执行- (void)_trimRecursively &#123; __weak typeof(self) _self = self; dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(_autoTrimInterval * NSEC_PER_SEC)), dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, 0), ^&#123; __strong typeof(_self) self = _self; if (!self) return; //在后台进行清理操作 [self _trimInBackground]; //调用自己，递归操作 [self _trimRecursively]; &#125;);&#125;//清理所有不符合限制的缓存，顺序为：cost，count，age- (void)_trimInBackground &#123; dispatch_async(_queue, ^&#123; [self _trimToCost:self-&gt;_costLimit]; [self _trimToCount:self-&gt;_countLimit]; [self _trimToAge:self-&gt;_ageLimit]; &#125;);&#125;复制代码 1234567891011121314151617//YYMemoryCache.m- (void)trimToCount:(NSUInteger)count &#123; if (count == 0) &#123; [self removeAllObjects]; return; &#125; [self _trimToCount:count];&#125;- (void)trimToCost:(NSUInteger)cost &#123; [self _trimToCost:cost];&#125;- (void)trimToAge:(NSTimeInterval)age &#123; [self _trimToAge:age];&#125;复制代码 可以看到，YYMemoryCache是按照缓存数量，缓存开销，缓存时间的顺序来自动清空缓存的。我们结合代码看一下它是如何按照缓存数量来清理缓存的（其他两种清理方式类似，暂不给出）： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//YYMemoryCache.m//将内存缓存数量降至等于或小于传入的数量；如果传入的值为0，则删除全部内存缓存- (void)_trimToCount:(NSUInteger)countLimit &#123; BOOL finish = NO; pthread_mutex_lock(&amp;_lock); //如果传入的参数=0，则删除所有内存缓存 if (countLimit == 0) &#123; [_lru removeAll]; finish = YES; &#125; else if (_lru-&gt;_totalCount &lt;= countLimit) &#123; //如果当前缓存的总数量已经小于或等于传入的数量，则直接返回YES，不进行清理 finish = YES; &#125; pthread_mutex_unlock(&amp;_lock); if (finish) return; NSMutableArray *holder = [NSMutableArray new]; while (!finish) &#123; //==0的时候说明在尝试加锁的时候，获取锁成功，从而可以进行操作；否则等待10秒（但是不知道为什么是10s而不是2s，5s，等等） if (pthread_mutex_trylock(&amp;_lock) == 0) &#123; if (_lru-&gt;_totalCount &gt; countLimit) &#123; _YYLinkedMapNode *node = [_lru removeTailNode]; if (node) [holder addObject:node]; &#125; else &#123; finish = YES; &#125; pthread_mutex_unlock(&amp;_lock); &#125; else &#123; usleep(10 * 1000); //10 ms &#125; &#125; if (holder.count) &#123; dispatch_queue_t queue = _lru-&gt;_releaseOnMainThread ? dispatch_get_main_queue() : YYMemoryCacheGetReleaseQueue(); dispatch_async(queue, ^&#123; [holder count]; // release in queue &#125;); &#125;&#125;复制代码 缓存手动清理其实上面这三种清理的方法在YYMemoryCache封装成了接口，所以用户也可以通过YYCache的memoryCache这个属性来手动清理相应维度上不符合传入标准的缓存： 123456789101112//YYMemoryCache.h// =========== 缓存清理接口 =========== //清理缓存到指定个数- (void)trimToCount:(NSUInteger)count;//清理缓存到指定开销- (void)trimToCost:(NSUInteger)cost;//清理缓存时间小于指定时间的缓存- (void)trimToAge:(NSTimeInterval)age;复制代码 看一下它们的实现： 12345678910111213141516171819//清理缓存到指定个数- (void)trimToCount:(NSUInteger)count &#123; if (count == 0) &#123; [self removeAllObjects]; return; &#125; [self _trimToCount:count];&#125;//清理缓存到指定开销- (void)trimToCost:(NSUInteger)cost &#123; [self _trimToCost:cost];&#125;//清理缓存时间小于指定时间的缓存- (void)trimToAge:(NSTimeInterval)age &#123; [self _trimToAge:age];&#125;复制代码 YYDiskCacheYYDiskCache负责处理容量大，相对低速的磁盘缓存。线程安全，支持异步操作。作为YYCache的第二级缓存，它与第一级缓存YYMemoryCache的相同点是： 都具有查询，写入，读取，删除缓存的接口。 不直接操作缓存，也是间接地通过另一个类（YYKVStorage）来操作缓存。 它使用LRU算法来清理缓存。 支持按 cost，count 和 age 这三个维度来清理不符合标准的缓存。 它与YYMemoryCache不同点是： 根据缓存数据的大小来采取不同的形式的缓存： 数据库sqlite: 针对小容量缓存，缓存的data和元数据都保存在数据库里。 文件+数据库的形式: 针对大容量缓存，缓存的data写在文件系统里，其元数据保存在数据库里。 除了 cost，count 和 age 三个维度之外，还添加了一个磁盘容量的维度。 这里需要说明的是： 对于上面的第一条：我看源码的时候只看出来有这两种缓存形式，但是从内部的缓存type枚举来看，其实是分为三种的： 1234567typedef NS_ENUM(NSUInteger, YYKVStorageType) &#123; YYKVStorageTypeFile = 0, YYKVStorageTypeSQLite = 1, YYKVStorageTypeMixed = 2,&#125;;复制代码 也就是说我只找到了第二，第三种缓存形式，而第一种纯粹的文件存储（YYKVStorageTypeFile）形式的实现我没有找到：当type为 YYKVStorageTypeFile和YYKVStorageTypeMixed的时候的缓存实现都是一致的：都是讲data存在文件里，将元数据放在数据库里面。 在YYDiskCache的初始化方法里，没有发现正确的将缓存类型设置为YYKVStorageTypeFile的方法： 12345678910111213141516171819202122232425262728//YYDiskCache.m- (instancetype)init &#123; @throw [NSException exceptionWithName:@&quot;YYDiskCache init error&quot; reason:@&quot;YYDiskCache must be initialized with a path. Use &apos;initWithPath:&apos; or &apos;initWithPath:inlineThreshold:&apos; instead.&quot; userInfo:nil]; return [self initWithPath:@&quot;&quot; inlineThreshold:0];&#125;- (instancetype)initWithPath:(NSString *)path &#123; return [self initWithPath:path inlineThreshold:1024 * 20]; // 20KB&#125;- (instancetype)initWithPath:(NSString *)path inlineThreshold:(NSUInteger)threshold &#123; ... YYKVStorageType type; if (threshold == 0) &#123; type = YYKVStorageTypeFile; &#125; else if (threshold == NSUIntegerMax) &#123; type = YYKVStorageTypeSQLite; &#125; else &#123; type = YYKVStorageTypeMixed; &#125; ...&#125;复制代码 从上面的代码可以看出来，当给指定初始化方法initWithPath:inlineThreshold:的第二个参数传入0的时候，缓存类型才是YYKVStorageTypeFile。而且比较常用的初始化方法initWithPath:的实现里，是将20kb传入了指定初始化方法里，结果就是将type设置成了YYKVStorageTypeMixed。 而且我也想不出如果只有文件形式的缓存的话，其元数据如何保存。如果有读者知道的话，麻烦告知一下，非常感谢了~~ 在本文暂时对于上面提到的”文件+数据库的形式”在下文统一说成文件缓存了。 在接口的设计上，YYDiskCache与YYMemoryCache是高度一致的，只不过因为有些时候大文件的访问可能会比较耗时，所以框架作者在保留了与YYMemoryCache一样的接口的基础上，还在原来的基础上添加了block回调，避免阻塞线程。来看一下YYDiskCache的接口(省略了注释)： 12345678910111213141516171819202122232425262728293031323334353637383940414243//YYDiskCache.h- (BOOL)containsObjectForKey:(NSString *)key;- (void)containsObjectForKey:(NSString *)key withBlock:(void(^)(NSString *key, BOOL contains))block;- (nullable id&lt;NSCoding&gt;)objectForKey:(NSString *)key;- (void)objectForKey:(NSString *)key withBlock:(void(^)(NSString *key, id&lt;NSCoding&gt; _Nullable object))block;- (void)setObject:(nullable id&lt;NSCoding&gt;)object forKey:(NSString *)key;- (void)setObject:(nullable id&lt;NSCoding&gt;)object forKey:(NSString *)key withBlock:(void(^)(void))block;- (void)removeObjectForKey:(NSString *)key;- (void)removeObjectForKey:(NSString *)key withBlock:(void(^)(NSString *key))block;- (void)removeAllObjects;- (void)removeAllObjectsWithBlock:(void(^)(void))block;- (void)removeAllObjectsWithProgressBlock:(nullable void(^)(int removedCount, int totalCount))progress endBlock:(nullable void(^)(BOOL error))end;- (NSInteger)totalCount;- (void)totalCountWithBlock:(void(^)(NSInteger totalCount))block;- (NSInteger)totalCost;- (void)totalCostWithBlock:(void(^)(NSInteger totalCost))block;#pragma mark - Trim- (void)trimToCount:(NSUInteger)count;- (void)trimToCount:(NSUInteger)count withBlock:(void(^)(void))block;- (void)trimToCost:(NSUInteger)cost;- (void)trimToCost:(NSUInteger)cost withBlock:(void(^)(void))block;- (void)trimToAge:(NSTimeInterval)age;- (void)trimToAge:(NSTimeInterval)age withBlock:(void(^)(void))block;复制代码 从上面的接口代码可以看出，YYDiskCache与YYMemoryCache在接口设计上是非常相似的。但是，YYDiskCache有一个非常重要的属性，它作为用sqlite做缓存还是用文件做缓存的分水岭： 123//YYDiskCache.h@property (readonly) NSUInteger inlineThreshold;复制代码 这个属性的默认值是20480byte，也就是20kb。即是说，如果缓存数据的长度大于这个值，就使用文件存储；如果小于这个值，就是用sqlite存储。来看一下这个属性是如何使用的： 首先我们会在YYDiskCache的指定初始化方法里看到这个属性： 12345678//YYDiskCache.m- (instancetype)initWithPath:(NSString *)path inlineThreshold:(NSUInteger)threshold &#123; ... _inlineThreshold = threshold; ...&#125;复制代码 在这里将_inlineThreshold赋值，也是唯一一次的赋值。然后在写入缓存的操作里判断写入缓存的大小是否大于这个临界值，如果是，则使用文件缓存： 123456789101112131415161718//YYDiskCache.m- (void)setObject:(id&lt;NSCoding&gt;)object forKey:(NSString *)key &#123; ... NSString *filename = nil; if (_kv.type != YYKVStorageTypeSQLite) &#123; //如果长度大临界值，则生成文件名称，使得filename不为nil if (value.length &gt; _inlineThreshold) &#123; filename = [self _filenameForKey:key]; &#125; &#125; Lock(); //在该方法内部判断filename是否为nil，如果是，则使用sqlite进行缓存；如果不是，则使用文件缓存 [_kv saveItemWithKey:key value:value filename:filename extendedData:extendedData]; Unlock();&#125;复制代码 现在我们知道了YYDiskCache相对于YYMemoryCache最大的不同之处是缓存类型的不同。 细心的朋友会发现上面这个写入缓存的方法（saveItemWithKey:value:filename:extendedData:）实际上是属于_kv的。这个_kv就是上面提到的YYKVStorage的实例，它在YYDiskCache的初始化方法里被赋值： 1234567891011//YYDiskCache.m- (instancetype)initWithPath:(NSString *)path inlineThreshold:(NSUInteger)threshold &#123; ... YYKVStorage *kv = [[YYKVStorage alloc] initWithPath:path type:type]; if (!kv) return nil; _kv = kv; ...&#125;复制代码 同样地，再举其他两个接口为例，内部也是调用了_kv的方法： 123456789101112131415- (BOOL)containsObjectForKey:(NSString *)key &#123; if (!key) return NO; Lock(); BOOL contains = [_kv itemExistsForKey:key]; Unlock(); return contains;&#125;- (void)removeObjectForKey:(NSString *)key &#123; if (!key) return; Lock(); [_kv removeItemForKey:key]; Unlock();&#125; 复制代码 所以是时候来看一下YYKVStorage的接口和实现了： YYKVStorageYYKVStorage实例负责保存和管理所有磁盘缓存。和YYMemoryCache里面的_YYLinkedMap将缓存封装成节点类_YYLinkedMapNode类似，YYKVStorage也将某个单独的磁盘缓存封装成了一个类，这个类就是YYKVStorageItem，它保存了某个缓存所对应的一些信息(key, value, 文件名，大小等等)： 1234567891011121314//YYKVStorageItem.h@interface YYKVStorageItem : NSObject@property (nonatomic, strong) NSString *key; //键@property (nonatomic, strong) NSData *value; //值@property (nullable, nonatomic, strong) NSString *filename; //文件名@property (nonatomic) int size; //值的大小，单位是byte@property (nonatomic) int modTime; //修改时间戳@property (nonatomic) int accessTime; //最后访问的时间戳@property (nullable, nonatomic, strong) NSData *extendedData; //extended data@end复制代码 既然在这里将缓存封装成了YYKVStorageItem实例，那么作为缓存的管理者，YYKVStorage就必然有操作YYKVStorageItem的接口了： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//YYKVStorage.h//写入某个item- (BOOL)saveItem:(YYKVStorageItem *)item;//写入某个键值对，值为NSData对象- (BOOL)saveItemWithKey:(NSString *)key value:(NSData *)value;//写入某个键值对，包括文件名以及data信息- (BOOL)saveItemWithKey:(NSString *)key value:(NSData *)value filename:(nullable NSString *)filename extendedData:(nullable NSData *)extendedData;#pragma mark - Remove Items//移除某个键的item- (BOOL)removeItemForKey:(NSString *)key;//移除多个键的item- (BOOL)removeItemForKeys:(NSArray&lt;NSString *&gt; *)keys;//移除大于参数size的item- (BOOL)removeItemsLargerThanSize:(int)size;//移除时间早于参数时间的item- (BOOL)removeItemsEarlierThanTime:(int)time;//移除item，使得缓存总容量小于参数size- (BOOL)removeItemsToFitSize:(int)maxSize;//移除item，使得缓存数量小于参数size- (BOOL)removeItemsToFitCount:(int)maxCount;//移除所有的item- (BOOL)removeAllItems;//移除所有的item，附带进度与结束block- (void)removeAllItemsWithProgressBlock:(nullable void(^)(int removedCount, int totalCount))progress endBlock:(nullable void(^)(BOOL error))end;#pragma mark - Get Items//读取参数key对应的item- (nullable YYKVStorageItem *)getItemForKey:(NSString *)key;//读取参数key对应的data- (nullable NSData *)getItemValueForKey:(NSString *)key;//读取参数数组对应的item数组- (nullable NSArray&lt;YYKVStorageItem *&gt; *)getItemForKeys:(NSArray&lt;NSString *&gt; *)keys;//读取参数数组对应的item字典- (nullable NSDictionary&lt;NSString *, NSData *&gt; *)getItemValueForKeys:(NSArray&lt;NSString *&gt; *)keys;复制代码 大家最关心的应该是写入缓存的接口是如何实现的，下面重点讲一下写入缓存的接口： 123456789101112//写入某个item- (BOOL)saveItem:(YYKVStorageItem *)item;//写入某个键值对，值为NSData对象- (BOOL)saveItemWithKey:(NSString *)key value:(NSData *)value;//写入某个键值对，包括文件名以及data信息- (BOOL)saveItemWithKey:(NSString *)key value:(NSData *)value filename:(nullable NSString *)filename extendedData:(nullable NSData *)extendedData;复制代码 这三个接口都比较类似，上面的两个方法都会调用最下面参数最多的方法。在详细讲解写入缓存的代码之前，我先讲一下写入缓存的大致逻辑，有助于让大家理解整个YYDiskCache写入缓存的流程： 首先判断传入的key和value是否符合要求，如果不符合要求，则立即返回NO，缓存失败。 再判断是否type==YYKVStorageTypeFile并且文件名为空字符串（或nil）：如果是，则立即返回NO，缓存失败。 判断filename是否为空字符串： 如果不为空：写入文件，并将缓存的key，等信息写入数据库，但是不将key对应的data写入数据库。 如果为空： 如果缓存类型为YYKVStorageTypeSQLite：将缓存文件删除 如果缓存类型不为YYKVStorageTypeSQLite：则将缓存的key和对应的data等其他信息存入数据库。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849- (BOOL)saveItem:(YYKVStorageItem *)item &#123; return [self saveItemWithKey:item.key value:item.value filename:item.filename extendedData:item.extendedData];&#125;- (BOOL)saveItemWithKey:(NSString *)key value:(NSData *)value &#123; return [self saveItemWithKey:key value:value filename:nil extendedData:nil];&#125;- (BOOL)saveItemWithKey:(NSString *)key value:(NSData *)value filename:(NSString *)filename extendedData:(NSData *)extendedData &#123; if (key.length == 0 || value.length == 0) return NO; if (_type == YYKVStorageTypeFile &amp;&amp; filename.length == 0) &#123; return NO; &#125; if (filename.length) &#123; //如果文件名不为空字符串，说明要进行文件缓存 if (![self _fileWriteWithName:filename data:value]) &#123; return NO; &#125; //写入元数据 if (![self _dbSaveWithKey:key value:value fileName:filename extendedData:extendedData]) &#123; //如果缓存信息保存失败，则删除对应的文件 [self _fileDeleteWithName:filename]; return NO; &#125; return YES; &#125; else &#123; //如果文件名为空字符串，说明不要进行文件缓存 if (_type != YYKVStorageTypeSQLite) &#123; //如果缓存类型不是数据库缓存，则查找出相应的文件名并删除 NSString *filename = [self _dbGetFilenameWithKey:key]; if (filename) &#123; [self _fileDeleteWithName:filename]; &#125; &#125; // 缓存类型是数据库缓存，把元数据和value写入数据库 return [self _dbSaveWithKey:key value:value fileName:nil extendedData:extendedData]; &#125;&#125;复制代码 从上面的代码可以看出，在底层写入缓存的方法是_dbSaveWithKey:value:fileName:extendedData:，这个方法使用了两次: 在以文件（和数据库）存储缓存时 在以数据库存储缓存时 不过虽然调用了两次，我们可以从传入的参数是有差别的：第二次filename传了nil。那么我们来看一下_dbSaveWithKey:value:fileName:extendedData:内部是如何区分有无filename的情况的： 当filename为空时，说明在外部没有写入该缓存的文件：则把data写入数据库里 当filename不为空时，说明在外部有写入该缓存的文件：则不把data也写入了数据库里 下面结合代码看一下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//数据库存储- (BOOL)_dbSaveWithKey:(NSString *)key value:(NSData *)value fileName:(NSString *)fileName extendedData:(NSData *)extendedData &#123; //sql语句 NSString *sql = @&quot;insert or replace into manifest (key, filename, size, inline_data, modification_time, last_access_time, extended_data) values (?1, ?2, ?3, ?4, ?5, ?6, ?7);&quot;; sqlite3_stmt *stmt = [self _dbPrepareStmt:sql]; if (!stmt) return NO; int timestamp = (int)time(NULL); //key sqlite3_bind_text(stmt, 1, key.UTF8String, -1, NULL); //filename sqlite3_bind_text(stmt, 2, fileName.UTF8String, -1, NULL); //size sqlite3_bind_int(stmt, 3, (int)value.length); //inline_data if (fileName.length == 0) &#123; //如果文件名长度==0，则将value存入数据库 sqlite3_bind_blob(stmt, 4, value.bytes, (int)value.length, 0); &#125; else &#123; //如果文件名长度不为0，则不将value存入数据库 sqlite3_bind_blob(stmt, 4, NULL, 0, 0); &#125; //modification_time sqlite3_bind_int(stmt, 5, timestamp); //last_access_time sqlite3_bind_int(stmt, 6, timestamp); //extended_data sqlite3_bind_blob(stmt, 7, extendedData.bytes, (int)extendedData.length, 0); int result = sqlite3_step(stmt); if (result != SQLITE_DONE) &#123; if (_errorLogsEnabled) NSLog(@&quot;%s line:%d sqlite insert error (%d): %s&quot;, __FUNCTION__, __LINE__, result, sqlite3_errmsg(_db)); return NO; &#125; return YES;&#125;复制代码 框架作者用数据库的一条记录来保存关于某个缓存的所有信息。 而且数据库的第四个字段是保存缓存对应的data的，从上面的代码可以看出当filename为空和不为空的时候的处理的差别。 上面的sqlite3_stmt可以看作是一个已经把sql语句解析了的、用sqlite自己标记记录的内部数据结构。 而sqlite3_bind_text和sqlite3_bind_int是绑定函数，可以看作是将变量插入到字段的操作。 OK，现在看完了写入缓存，我们再来看一下获取缓存的操作： 123456789101112131415161718192021222324//YYKVSorage.m- (YYKVStorageItem *)getItemForKey:(NSString *)key &#123; if (key.length == 0) return nil; YYKVStorageItem *item = [self _dbGetItemWithKey:key excludeInlineData:NO]; if (item) &#123; //更新内存访问的时间 [self _dbUpdateAccessTimeWithKey:key]; if (item.filename) &#123; //如果有文件名，则尝试获取文件数据 item.value = [self _fileReadWithName:item.filename]; //如果此时获取文件数据失败，则删除对应的item if (!item.value) &#123; [self _dbDeleteItemWithKey:key]; item = nil; &#125; &#125; &#125; return item;&#125;复制代码 从上面这段代码我们可以看到获取YYKVStorageItem的实例的方法是_dbGetItemWithKey:excludeInlineData:我们来看一下它的实现： 首先根据查找key的sql语句生成stmt 然后将传入的key与该stmt进行绑定 最后通过这个stmt来查找出与该key对应的有关该缓存的其他数据并生成item。 来看一下代码： 12345678910111213141516171819- (YYKVStorageItem *)_dbGetItemWithKey:(NSString *)key excludeInlineData:(BOOL)excludeInlineData &#123; NSString *sql = excludeInlineData ? @&quot;select key, filename, size, modification_time, last_access_time, extended_data from manifest where key = ?1;&quot; : @&quot;select key, filename, size, inline_data, modification_time, last_access_time, extended_data from manifest where key = ?1;&quot;; sqlite3_stmt *stmt = [self _dbPrepareStmt:sql]; if (!stmt) return nil; sqlite3_bind_text(stmt, 1, key.UTF8String, -1, NULL); YYKVStorageItem *item = nil; int result = sqlite3_step(stmt); if (result == SQLITE_ROW) &#123; //传入stmt来生成YYKVStorageItem实例 item = [self _dbGetItemFromStmt:stmt excludeInlineData:excludeInlineData]; &#125; else &#123; if (result != SQLITE_DONE) &#123; if (_errorLogsEnabled) NSLog(@&quot;%s line:%d sqlite query error (%d): %s&quot;, __FUNCTION__, __LINE__, result, sqlite3_errmsg(_db)); &#125; &#125; return item;&#125;复制代码 我们可以看到最终生成YYKVStorageItem实例的是通过_dbGetItemFromStmt:excludeInlineData:来实现的： 123456789101112131415161718192021222324252627282930- (YYKVStorageItem *)_dbGetItemFromStmt:(sqlite3_stmt *)stmt excludeInlineData:(BOOL)excludeInlineData &#123; //提取数据 int i = 0; char *key = (char *)sqlite3_column_text(stmt, i++); char *filename = (char *)sqlite3_column_text(stmt, i++); int size = sqlite3_column_int(stmt, i++); //判断excludeInlineData const void *inline_data = excludeInlineData ? NULL : sqlite3_column_blob(stmt, i); int inline_data_bytes = excludeInlineData ? 0 : sqlite3_column_bytes(stmt, i++); int modification_time = sqlite3_column_int(stmt, i++); int last_access_time = sqlite3_column_int(stmt, i++); const void *extended_data = sqlite3_column_blob(stmt, i); int extended_data_bytes = sqlite3_column_bytes(stmt, i++); //将数据赋给item的属性 YYKVStorageItem *item = [YYKVStorageItem new]; if (key) item.key = [NSString stringWithUTF8String:key]; if (filename &amp;&amp; *filename != 0) item.filename = [NSString stringWithUTF8String:filename]; item.size = size; if (inline_data_bytes &gt; 0 &amp;&amp; inline_data) item.value = [NSData dataWithBytes:inline_data length:inline_data_bytes]; item.modTime = modification_time; item.accessTime = last_access_time; if (extended_data_bytes &gt; 0 &amp;&amp; extended_data) item.extendedData = [NSData dataWithBytes:extended_data length:extended_data_bytes]; return item;&#125;复制代码 上面这段代码分为两个部分： 获取数据库里每一个字段对应的数据 将数据赋给YYKVStorageItem的实例 需要注意的是： 字符串类型需要使用stringWithUTF8String:来转成NSString类型。 这里面会判断excludeInlineData： 如果为TRUE，就提取存入的data数据 如果为FALSE，就不提取 保证线程安全的方案我相信对于某个设计来说，它的产生一定是基于某种个特定问题下的某个场景的 由上文可以看出： YYMemoryCache 使用了 pthread_mutex 线程锁（互斥锁）来确保线程安全 YYDiskCache 则选择了更适合它的 dispatch_semaphore。 内存缓存操作的互斥锁在YYMemoryCache中，是使用互斥锁来保证线程安全的。 首先在YYMemoryCache的初始化方法中得到了互斥锁，并在它的所有接口里都加入了互斥锁来保证线程安全，包括setter，getter方法和缓存操作的实现。举几个例子： 123456789101112131415161718192021222324252627282930313233343536373839- (NSUInteger)totalCost &#123; pthread_mutex_lock(&amp;_lock); NSUInteger totalCost = _lru-&gt;_totalCost; pthread_mutex_unlock(&amp;_lock); return totalCost;&#125;- (void)setReleaseOnMainThread:(BOOL)releaseOnMainThread &#123; pthread_mutex_lock(&amp;_lock); _lru-&gt;_releaseOnMainThread = releaseOnMainThread; pthread_mutex_unlock(&amp;_lock);&#125;- (BOOL)containsObjectForKey:(id)key &#123; if (!key) return NO; pthread_mutex_lock(&amp;_lock); BOOL contains = CFDictionaryContainsKey(_lru-&gt;_dic, (__bridge const void *)(key)); pthread_mutex_unlock(&amp;_lock); return contains;&#125;- (id)objectForKey:(id)key &#123; if (!key) return nil; pthread_mutex_lock(&amp;_lock); _YYLinkedMapNode *node = CFDictionaryGetValue(_lru-&gt;_dic, (__bridge const void *)(key)); if (node) &#123; //如果节点存在，则更新它的时间信息（最后一次访问的时间） node-&gt;_time = CACurrentMediaTime(); [_lru bringNodeToHead:node]; &#125; pthread_mutex_unlock(&amp;_lock); return node ? node-&gt;_value : nil;&#125;复制代码 而且需要在dealloc方法中销毁这个锁头： 12345678- (void)dealloc &#123; ... //销毁互斥锁 pthread_mutex_destroy(&amp;_lock);&#125;复制代码 磁盘缓存使用信号量来代替锁框架作者采用了信号量的方式来给 首先在初始化的时候实例化了一个信号量： 1234567- (instancetype)initWithPath:(NSString *)path inlineThreshold:(NSUInteger)threshold &#123; ... _lock = dispatch_semaphore_create(1); _queue = dispatch_queue_create(&quot;com.ibireme.cache.disk&quot;, DISPATCH_QUEUE_CONCURRENT); ...复制代码 然后使用了宏来代替加锁解锁的代码： 123#define Lock() dispatch_semaphore_wait(self-&gt;_lock, DISPATCH_TIME_FOREVER)#define Unlock() dispatch_semaphore_signal(self-&gt;_lock)复制代码 简单说一下信号量： dispatch_semaphore是GCD用来同步的一种方式，与他相关的共有三个函数，分别是 dispatch_semaphore_create：定义信号量 dispatch_semaphore_signal：使信号量+1 dispatch_semaphore_wait：使信号量-1 当信号量为0时，就会做等待处理，这是其他线程如果访问的话就会让其等待。所以如果信号量在最开始的的时候被设置为1，那么就可以实现“锁”的功能： 执行某段代码之前，执行dispatch_semaphore_wait函数，让信号量-1变为0，执行这段代码。 此时如果其他线程过来访问这段代码，就要让其等待。 当这段代码在当前线程结束以后，执行dispatch_semaphore_signal函数，令信号量再次+1，那么如果有正在等待的线程就可以访问了。 需要注意的是：如果有多个线程等待，那么后来信号量恢复以后访问的顺序就是线程遇到dispatch_semaphore_wait的顺序。 这也就是信号量和互斥锁的一个区别：互斥量用于线程的互斥，信号线用于线程的同步。 互斥：是指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但互斥无法限制访问者对资源的访问顺序，即访问是无序的。 同步：是指在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的有序访问。在大多数情况下，同步已经实现了互斥，特别是所有写入资源的情况必定是互斥的。也就是说使用信号量可以使多个线程有序访问某个资源。 那么问题来了：为什么内存缓存使用的是互斥锁（pthread_mutex），而磁盘缓存使用的就是信号量（dispatch_semaphore）呢？ 答案在框架作者的文章YYCache 设计思路里可以找到: 为什么内存缓存使用互斥锁（pthread_mutex）？ 框架作者在最初使用的是自旋锁(OSSpinLock)作为内存缓存的线程锁，但是后来得知其不够安全，所以退而求其次，使用了pthread_mutex。 为什么磁盘缓存使用的是信号量（dispatch_semaphore）？ dispatch_semaphore 是信号量，但当信号总量设为 1 时也可以当作锁来。在没有等待情况出现时，它的性能比 pthread_mutex 还要高，但一旦有等待情况出现时，性能就会下降许多。相对于 OSSpinLock 来说，它的优势在于等待时不会消耗 CPU 资源。对磁盘缓存来说，它比较合适。 因为YYDiskCache在写入比较大的缓存时，可能会有比较长的等待时间，而dispatch_semaphore在这个时候是不消耗CPU资源的，所以比较适合。 提高缓存性能的几个尝试选择合适的线程锁可以参考上一部分YYMemoryCache 和YYDiskCache使用的不同的锁以及原因。 选择合适的数据结构在YYMemoryCache中，作者选择了双向链表来保存这些缓存节点。那么可以思考一下，为什么要用双向链表而不是单向链表或是数组呢？ 为什么不选择单向链表：单链表的节点只知道它后面的节点（只有指向后一节点的指针），而不知道前面的。所以如果想移动其中一个节点的话，其前后的节点不好做衔接。 为什么不选择数组：数组中元素在内存的排列是连续的，对于寻址操作非常便利；但是对于插入，删除操作很不方便，需要整体移动，移动的元素个数越多，代价越大。而链表恰恰相反，因为其节点的关联仅仅是靠指针，所以对于插入和删除操作会很便利，而寻址操作缺比较费时。由于在LRU策略中会有非常多的移动，插入和删除节点的操作，所以使用双向链表是比较有优势的。 选择合适的线程来操作不同的任务无论缓存的自动清理和释放，作者默认把这些任务放到子线程去做： 看一下释放所有内存缓存的操作： 12345678910111213141516171819202122232425262728293031- (void)removeAll &#123; //将开销，缓存数量置为0 _totalCost = 0; _totalCount = 0; //将链表的头尾节点置空 _head = nil; _tail = nil; if (CFDictionaryGetCount(_dic) &gt; 0) &#123; CFMutableDictionaryRef holder = _dic; _dic = CFDictionaryCreateMutable(CFAllocatorGetDefault(), 0, &amp;kCFTypeDictionaryKeyCallBacks, &amp;kCFTypeDictionaryValueCallBacks); //是否在子线程操作 if (_releaseAsynchronously) &#123; dispatch_queue_t queue = _releaseOnMainThread ? dispatch_get_main_queue() : YYMemoryCacheGetReleaseQueue(); dispatch_async(queue, ^&#123; CFRelease(holder); // hold and release in specified queue &#125;); &#125; else if (_releaseOnMainThread &amp;&amp; !pthread_main_np()) &#123; dispatch_async(dispatch_get_main_queue(), ^&#123; CFRelease(holder); // hold and release in specified queue &#125;); &#125; else &#123; CFRelease(holder); &#125; &#125;&#125;复制代码 这里的YYMemoryCacheGetReleaseQueue()使用了内联函数，返回了低优先级的并发队列。 12345//内联函数，返回优先级最低的全局并发队列static inline dispatch_queue_t YYMemoryCacheGetReleaseQueue() &#123; return dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, 0);&#125;复制代码 选择底层的类同样是字典实现，但是作者使用了更底层且快速的CFDictionary而没有用NSDictionary来实现。 其他知识点禁用原生初始化方法并标明新定义的指定初始化方法YYCache有4个供外部调用的初始化接口，无论是对象方法还是类方法都需要传入一个字符串（名称或路径）。 而两个原生的初始化方法被框架作者禁掉了： 123- (instancetype)init UNAVAILABLE_ATTRIBUTE;+ (instancetype)new UNAVAILABLE_ATTRIBUTE;复制代码 如果用户使用了上面两个初始化方法就会在编译期报错。 而剩下的四个可以使用的初始化方法中，有一个是指定初始化方法，被作者用NS_DESIGNATED_INITIALIZER标记了。 123456- (nullable instancetype)initWithName:(NSString *)name;- (nullable instancetype)initWithPath:(NSString *)path NS_DESIGNATED_INITIALIZER;+ (nullable instancetype)cacheWithName:(NSString *)name;+ (nullable instancetype)cacheWithPath:(NSString *)path;复制代码 指定初始化方法就是所有可使用的初始化方法都必须调用的方法。更详细的介绍可以参考我的下面两篇文章： iOS 代码规范中讲解“类”的这一部分。 《Effective objc》干货三部曲（三）：技巧篇中的第16条。 异步释放对象的技巧为了异步将某个对象释放掉，可以通过在GCD的block里面给它发个消息来实现。这个技巧在该框架中很常见，举一个删除一个内存缓存的例子： 首先将这个缓存的node类取出，然后异步将其释放掉。 12345678910111213141516171819202122- (void)removeObjectForKey:(id)key &#123; if (!key) return; pthread_mutex_lock(&amp;_lock); _YYLinkedMapNode *node = CFDictionaryGetValue(_lru-&gt;_dic, (__bridge const void *)(key)); if (node) &#123; [_lru removeNode:node]; if (_lru-&gt;_releaseAsynchronously) &#123; dispatch_queue_t queue = _lru-&gt;_releaseOnMainThread ? dispatch_get_main_queue() : YYMemoryCacheGetReleaseQueue(); dispatch_async(queue, ^&#123; [node class]; //hold and release in queue &#125;); &#125; else if (_lru-&gt;_releaseOnMainThread &amp;&amp; !pthread_main_np()) &#123; dispatch_async(dispatch_get_main_queue(), ^&#123; [node class]; //hold and release in queue &#125;); &#125; &#125; pthread_mutex_unlock(&amp;_lock);&#125;复制代码 为了释放掉这个node对象，在一个异步执行的（主队列或自定义队列里）block里给其发送了class这个消息。不需要纠结这个消息具体是什么，他的目的是为了避免编译错误，因为我们无法在block里面硬生生地将某个对象写进去。 其实关于上面这一点我自己也有点拿不准，希望理解得比较透彻的同学能在下面留个言~ ^^ 内存警告和进入后台的监听YYCache默认在收到内存警告和进入后台时，自动清除所有内存缓存。所以在YYMemoryCache的初始化方法里，我们可以看到这两个监听的动作： 12345678910111213//YYMemoryCache.m- (instancetype)init&#123; ... //监听app生命周期 [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(_appDidReceiveMemoryWarningNotification) name:UIApplicationDidReceiveMemoryWarningNotification object:nil]; [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(_appDidEnterBackgroundNotification) name:UIApplicationDidEnterBackgroundNotification object:nil]; ...&#125;复制代码 然后实现监听到消息后的处理方法： 12345678910111213141516171819202122//内存警告时，删除所有内存缓存- (void)_appDidReceiveMemoryWarningNotification &#123; if (self.didReceiveMemoryWarningBlock) &#123; self.didReceiveMemoryWarningBlock(self); &#125; if (self.shouldRemoveAllObjectsOnMemoryWarning) &#123; [self removeAllObjects]; &#125;&#125;//进入后台时，删除所有内存缓存- (void)_appDidEnterBackgroundNotification &#123; if (self.didEnterBackgroundBlock) &#123; self.didEnterBackgroundBlock(self); &#125; if (self.shouldRemoveAllObjectsWhenEnteringBackground) &#123; [self removeAllObjects]; &#125;&#125;复制代码 判断头文件的导入1234567891011121314#if __has_include(&lt;YYCache/YYCache.h&gt;)#import &lt;YYCache/YYMemoryCache.h&gt;#import &lt;YYCache/YYDiskCache.h&gt;#import &lt;YYCache/YYKVStorage.h&gt;#elif __has_include(&lt;YYWebImage/YYCache.h&gt;)#import &lt;YYWebImage/YYMemoryCache.h&gt;#import &lt;YYWebImage/YYDiskCache.h&gt;#import &lt;YYWebImage/YYKVStorage.h&gt;#else#import &quot;YYMemoryCache.h&quot;#import &quot;YYDiskCache.h&quot;#import &quot;YYKVStorage.h&quot;#endif复制代码 在这里作者使用__has_include来检查Frameworks是否引入某个类。 因为YYWebImage已经集成YYCache,所以如果导入过YYWebImage的话就无需重再导入YYCache了。 最后的话通过看该组件的源码，我收获的不仅有缓存设计的思路，还有： 双向链表的概念以及相关操作 数据库的使用 互斥锁，信号量的使用 实现线程安全的方案 变量，方法的命名以及接口的设计 相信读过这篇文章的你也会有一些收获~ 如果能趁热打铁，下载一个YYCache源码看就更好啦~ 本篇已同步到个人博客：传送门]]></content>
      <categories>
        <category>sourcecode</category>
      </categories>
      <tags>
        <tag>YYCache</tag>
        <tag>hashmap</tag>
        <tag>双向链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS底层原理总结 - 关联对象实现原理]]></title>
    <url>%2F2018%2F07%2F05%2FiOS%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93-%E5%85%B3%E8%81%94%E5%AF%B9%E8%B1%A1%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[iOS底层原理总结 - 关联对象实现原理面试题问： Category能否添加成员变量？如果可以，如何给Category添加成员变量？ 答：不能直接添加成员变量，但是可以通过runtime的方式间接实现添加成员变量的效果。 Runtime为Category动态关联对象使用RunTime给系统的类添加属性，首先需要了解对象与属性的关系。我们通过之前的学习知道，对象一开始初始化的时候其属性为nil，给属性赋值其实就是让属性指向一块存储内容的内存，使这个对象的属性跟这块内存产生一种关联。 那么如果想动态的添加属性，其实就是动态的产生某种关联就好了。而想要给系统的类添加属性，只能通过分类。 这里给NSObject添加name属性，创建NSObject的分类 我们可以使用@property给分类添加属性 1@property(nonatomic,strong)NSString *name; 通过探寻Category的本质我们知道，虽然在分类中可以写@property 添加属性，但是不会自动生成私有属性，也不会生成set,get方法的实现，只会生成set,get的声明，需要我们自己去实现。 方法一：我们可以通过使用静态全局变量给分类添加属性123456789static NSString *_name;-(void)setName:(NSString *)name&#123; _name = name;&#125;-(NSString *)name&#123; return _name;&#125; 但是这样_name静态全局变量与类并没有关联，无论对象创建与销毁，只要程序在运行_name变量就存在，并不是真正意义上的属性。 方法二：使用RunTime动态添加属性RunTime提供了动态添加属性和获得属性的方法。 12345678-(void)setName:(NSString *)name&#123; objc_setAssociatedObject(self, @&quot;name&quot;,name, OBJC_ASSOCIATION_RETAIN_NONATOMIC);&#125;-(NSString *)name&#123; return objc_getAssociatedObject(self, @&quot;name&quot;); &#125; 动态添加属性 1objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy); 参数一：id object: 给哪个对象添加属性，这里要给自己添加属性，用self。 参数二：void * == id key: 属性名，根据key获取关联对象的属性的值，在objc_getAssociatedObject中通过次key获得属性的值并返回。 参数三：id value** : 关联的值，也就是set方法传入的值给属性去保存。 参数四：objc_AssociationPolicy policy**: 策略，属性以什么形式保存。 有以下几种 1234567typedef OBJC_ENUM(uintptr_t, objc_AssociationPolicy) &#123; OBJC_ASSOCIATION_ASSIGN = 0, // 指定一个弱引用相关联的对象 OBJC_ASSOCIATION_RETAIN_NONATOMIC = 1, // 指定相关对象的强引用，非原子性 OBJC_ASSOCIATION_COPY_NONATOMIC = 3, // 指定相关的对象被复制，非原子性 OBJC_ASSOCIATION_RETAIN = 01401, // 指定相关对象的强引用，原子性 OBJC_ASSOCIATION_COPY = 01403 // 指定相关的对象被复制，原子性 &#125;; key值只要是一个指针即可，我们可以传入@selector(name) 获得属性 1objc_getAssociatedObject(id object, const void *key); 参数一：id object: 获取哪个对象里面的关联的属性。 参数二：void * == id key: 什么属性，与objc_setAssociatedObject中的key相对应，即通过key值取出value。 移除所有关联对象 12345- (void)removeAssociatedObjects&#123; // 移除所有关联对象 objc_removeAssociatedObjects(self);&#125; 此时已经成功给NSObject添加name属性，并且NSObject对象可以通过点语法为属性赋值。 123NSObject *objc = [[NSObject alloc]init];objc.name = @&quot;xx_cc&quot;;NSLog(@&quot;%@&quot;,objc.name); 可以看出关联对象的使用非常简单，接下来我们来探寻关联对象的底层原理 关联对象实现原理实现关联对象技术的核心对象有 AssociationsManager AssociationsHashMap ObjectAssociationMap ObjcAssociation其中Map同我们平时使用的字典类似。通过key-value一一对应存值。 对关联对象技术的核心对象有了一个大概的意识，我们通过源码来探寻这些对象的存在形式以及其作用 objc_setAssociatedObject函数来到runtime源码，首先找到objc_setAssociatedObject函数，看一下其实现 我们看到其实内部调用的是_object_set_associative_reference函数，我们来到_object_set_associative_reference函数中 _object_set_associative_reference函数 _object_set_associative_reference函数内部我们可以全部找到我们上面说过的实现关联对象技术的核心对象。接下来我们来一个一个看其内部实现原理探寻他们之间的关系。 AssociationsManager通过AssociationsManager内部源码发现，AssociationsManager内部有一个AssociationsHashMap对象。 AssociationsHashMap我们来看一下AssociationsHashMap内部的源码。 通过AssociationsHashMap内部源码我们发现AssociationsHashMap继承自unordered_map首先来看一下unordered_map内的源码 从unordered_map源码中我们可以看出_Key和_Tp也就是前两个参数对应着map中的Key和Value，那么对照上面AssociationsHashMap内源码发现_Key中传入的是disguised_ptr_t，_Tp中传入的值则为ObjectAssociationMap*。 紧接着我们来到ObjectAssociationMap中，上图中ObjectAssociationMap已经标记出，我们发现ObjectAssociationMap中同样以key、Value的方式存储着ObjcAssociation。 接着我们来到ObjcAssociation中 我们发现ObjcAssociation存储着_policy、_value，而这两个值我们可以发现正是我们调用objc_setAssociatedObject函数传入的值，也就是说我们在调用objc_setAssociatedObject函数中传入的value和policy这两个值最终是存储在ObjcAssociation中的。 现在我们已经对AssociationsManager、 AssociationsHashMap、 ObjectAssociationMap、ObjcAssociation四个对象之间的关系有了简单的认识，那么接下来我们来细读源码，看一下objc_setAssociatedObject函数中传入的四个参数分别放在哪个对象中充当什么作用。 重新回到_object_set_associative_reference函数实现中 细读上述源码我们可以发现，首先根据我们传入的value经过acquireValue函数处理获取new_value。acquireValue函数内部其实是通过对策略的判断返回不同的值 之后创建AssociationsManager manager;以及拿到manager内部的AssociationsHashMap即associations。 之后我们看到了我们传入的第一个参数object object经过DISGUISE函数被转化为了disguised_ptr_t类型的disguised_object。 DISGUISE函数其实仅仅对object做了位运算 之后我们看到被处理成new_value的value，同policy被存入了ObjcAssociation中。 而ObjcAssociation对应我们传入的key被存入了ObjectAssociationMap中。 disguised_object和ObjectAssociationMap则以key-value的形式对应存储在associations中也就是AssociationsHashMap中。 如果我们value设置为nil的话那么会执行下面的代码 从上述代码中可以看出，如果我们设置value为nil时，就会将关联对象从ObjectAssociationMap中移除。 最后我们通过一张图可以很清晰的理清楚其中的关系 通过上图我们可以总结为：一个实例对象就对应一个ObjectAssociationMap，而ObjectAssociationMap中存储着多个此实例对象的关联对象的key以及ObjcAssociation，为ObjcAssociation中存储着关联对象的value和policy策略。 由此我们可以知道关联对象并不是放在了原来的对象里面，而是自己维护了一个全局的map用来存放每一个对象及其对应关联属性表格。 objc_getAssociatedObject函数objc_getAssociatedObject内部调用的是_object_get_associative_reference _object_get_associative_reference函数 从_object_get_associative_reference函数内部可以看出，向set方法中那样，反向将value一层一层取出最后return出去。 objc_removeAssociatedObjects函数objc_removeAssociatedObjects用来删除所有的关联对象，objc_removeAssociatedObjects函数内部调用的是_object_remove_assocations函数 _object_remove_assocations函数 上述源码可以看出_object_remove_assocations函数将object对象向对应的所有关联对象全部删除。 总结：关联对象并不是存储在被关联对象本身内存中，而是存储在全局的统一的一个AssociationsManager中，如果设置关联对象为nil，就相当于是移除关联对象。 此时我们我们在回过头来看objc_AssociationPolicy policy 参数: 属性以什么形式保存的策略。 1234567typedef OBJC_ENUM(uintptr_t, objc_AssociationPolicy) &#123; OBJC_ASSOCIATION_ASSIGN = 0, // 指定一个弱引用相关联的对象 OBJC_ASSOCIATION_RETAIN_NONATOMIC = 1, // 指定相关对象的强引用，非原子性 OBJC_ASSOCIATION_COPY_NONATOMIC = 3, // 指定相关的对象被复制，非原子性 OBJC_ASSOCIATION_RETAIN = 01401, // 指定相关对象的强引用，原子性 OBJC_ASSOCIATION_COPY = 01403 // 指定相关的对象被复制，原子性 &#125;; 我们会发现其中只有RETAIN和COPY而为什么没有weak呢？ 总过上面对源码的分析我们知道，object经过DISGUISE函数被转化为了disguised_ptr_t类型的disguised_object。 1disguised_ptr_t disguised_object = DISGUISE(object); 而同时我们知道，weak修饰的属性，当没有拥有对象之后就会被销毁，并且指针置位nil，那么在对象销毁之后，虽然在map中既然存在值object对应的AssociationsHashMap，但是因为object地址已经被置位nil，会造成坏地址访问而无法根据object对象的地址转化为disguised_object了。]]></content>
      <categories>
        <category>principle</category>
      </categories>
      <tags>
        <tag>associate object</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS底层原理总结 - Category的本质]]></title>
    <url>%2F2018%2F07%2F05%2FiOS%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93-Category%E7%9A%84%E6%9C%AC%E8%B4%A8%2F</url>
    <content type="text"><![CDATA[iOS底层原理总结 - Category的本质面试题 Category的实现原理，以及Category为什么只能加方法不能加属性。 Category中有load方法吗？load方法是什么时候调用的？load 方法能继承吗？ load、initialize的区别，以及它们在category重写的时候的调用的次序。 Category的本质 首先我们写一段简单的代码，之后的分析都基于这段代码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263Presen类 // Presen.h#import &lt;Foundation/Foundation.h&gt;@interface Preson : NSObject&#123; int _age;&#125;- (void)run;@end// Presen.m#import &quot;Preson.h&quot;@implementation Preson- (void)run&#123; NSLog(@&quot;Person - run&quot;);&#125;@endPresen扩展1// Presen+Test.h#import &quot;Preson.h&quot;@interface Preson (Test) &lt;NSCopying&gt;- (void)test;+ (void)abc;@property (assign, nonatomic) int age;- (void)setAge:(int)age;- (int)age;@end// Presen+Test.m#import &quot;Preson+Test.h&quot;@implementation Preson (Test)- (void)test&#123;&#125;+ (void)abc&#123;&#125;- (void)setAge:(int)age&#123;&#125;- (int)age&#123; return 10;&#125;@endPresen分类2// Preson+Test2.h#import &quot;Preson.h&quot;@interface Preson (Test2)@end// Preson+Test2.m#import &quot;Preson+Test2.h&quot;@implementation Preson (Test2)- (void)run&#123; NSLog(@&quot;Person (Test2) - run&quot;);&#125;@end 我们之前讲到过实例对象的isa指针指向类对象，类对象的isa指针指向元类对象，当p调用run方法时，类对象的isa指针找到类对象的isa指针，然后在类对象中查找对象方法，如果没有找到，就通过类对象的superclass指针找到父类对象，接着去寻找run方法。 那么当调用分类的方法时，步骤是否和调用对象方法一样呢？ 分类中的对象方法依然是存储在类对象中的，同对象方法在同一个地方，那么调用步骤也同调用对象方法一样。如果是类方法的话，也同样是存储在元类对象中。 那么分类方法是如何存储在类对象中的，我们来通过源码看一下分类的底层结构。 分类的底层结构如何验证上述问题？通过查看分类的源码我们可以找到category_t 结构体。 1234567891011121314151617struct category_t &#123; const char *name; classref_t cls; struct method_list_t *instanceMethods; // 对象方法 struct method_list_t *classMethods; // 类方法 struct protocol_list_t *protocols; // 协议 struct property_list_t *instanceProperties; // 属性 // Fields below this point are not always present on disk. struct property_list_t *_classProperties; method_list_t *methodsForMeta(bool isMeta) &#123; if (isMeta) return classMethods; else return instanceMethods; &#125; property_list_t *propertiesForMeta(bool isMeta, struct header_info *hi);&#125;; 从源码基本可以看出我们平时使用categroy的方式，对象方法，类方法，协议，和属性都可以找到对应的存储方式。并且我们发现分类结构体中是不存在成员变量的，因此分类中是不允许添加成员变量的。分类中添加的属性并不会帮助我们自动生成成员变量，只会生成get set方法的声明，需要我们自己去实现。 通过源码我们发现，分类的方法，协议，属性等好像确实是存放在categroy结构体里面的，那么他又是如何存储在类对象中的呢？ 我们来看一下底层的内部方法探寻其中的原理。 首先我们通过命令行将Preson+Test.m文件转化为c++文件，查看其中的编译过程。 1xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc Preson+Test.m 在分类转化为c++文件中可以看出_category_t结构体中，存放着类名，对象方法列表，类方法列表，协议列表，以及属性列表。 紧接着，我们可以看到_method_list_t类型的结构体，如下图所示 上图中我们发现这个结构体_OBJC_$_CATEGORY_INSTANCE_METHODS_Preson_$_Test从名称可以看出是INSTANCE_METHODS对象方法，并且一一对应为上面结构体内赋值。我们可以看到结构体中存储了方法占用的内存，方法数量，以及方法列表。并且从上图中找到分类中我们实现对应的对象方法，test , setAge, age三个方法 接下来我们发现同样的_method_list_t类型的类方法结构体，如下图所示 同上面对象方法列表一样，这个我们可以看出是类方法列表结构体 _OBJC_$_CATEGORY_CLASS_METHODS_Preson_$_Test，同对象方法结构体相同，同样可以看到我们实现的类方法，abc。 接下来是协议方法列表 通过上述源码可以看到先将协议方法通过_method_list_t结构体存储，之后通过_protocol_t结构体存储在_OBJC_CATEGORY_PROTOCOLS_$_Preson_$_Test中同_protocol_list_t结构体一一对应，分别为protocol_count 协议数量以及存储了协议方法的_protocol_t结构体。 最后我们可以看到属性列表 属性列表结构体_OBJC_$_PROP_LIST_Preson_$_Test同_prop_list_t结构体对应，存储属性的占用空间，属性属性数量，以及属性列表，从上图中可以看到我们自己写的age属性。 最后我们可以看到定义了_OBJC_$_CATEGORY_Preson_$_Test结构体，并且将我们上面着重分析的结构体一一赋值，我们通过两张图片对照一下。 上下两张图一一对应，并且我们看到定义_class_t类型的OBJC_CLASS_$_Preson结构体，最后将_OBJC_$_CATEGORY_Preson_$_Test的cls指针指向OBJC_CLASS_$_Preson结构体地址。我们这里可以看出，cls指针指向的应该是分类的主类类对象的地址。 通过以上分析我们发现。分类源码中确实是将我们定义的对象方法，类方法，属性等都存放在catagory_t结构体中。接下来我们在回到runtime源码查看catagory_t存储的方法，属性，协议等是如何存储在类对象中的。 首先来到runtime初始化函数 接着我们来到 &amp;map_images读取模块（images这里代表模块），来到map_images_nolock函数中找到_read_images函数，在_read_images函数中我们找到分类相关代码 从上述代码中我们可以知道这段代码是用来查找有没有分类的。通过_getObjc2CategoryList函数获取到分类列表之后，进行遍历，获取其中的方法，协议，属性等。可以看到最终都调用了remethodizeClass(cls);函数。我们来到remethodizeClass(cls);函数内部查看。 通过上述代码我们发现attachCategories函数接收了类对象cls和分类数组cats，如我们一开始写的代码所示，一个类可以有多个分类。之前我们说到分类信息存储在category_t结构体中，那么多个分类则保存在category_list中。 我们来到attachCategories函数内部。 上述源码中可以看出，首先根据方法列表，属性列表，协议列表，malloc分配内存，根据多少个分类以及每一块方法需要多少内存来分配相应的内存地址。之后从分类数组里面往三个数组里面存放分类数组里面存放的分类方法，属性以及协议放入对应mlist、proplists、protolosts数组中，这三个数组放着所有分类的方法，属性和协议。 之后通过类对象的data()方法，拿到类对象的class_rw_t结构体rw，在class结构中我们介绍过，class_rw_t中存放着类对象的方法，属性和协议等数据，rw结构体通过类对象的data方法获取，所以rw里面存放这类对象里面的数据。 之后分别通过rw调用方法列表、属性列表、协议列表的attachList函数，将所有的分类的方法、属性、协议列表数组传进去，我们大致可以猜想到在attachList方法内部将分类和本类相应的对象方法，属性，和协议进行了合并。 我们来看一下attachLists函数内部。 上述源代码中有两个重要的数组 array()-&gt;lists： 类对象原来的方法列表，属性列表，协议列表。 addedLists：传入所有分类的方法列表，属性列表，协议列表。 attachLists函数中最重要的两个方法为memmove内存移动和memcpy内存拷贝。我们先来分别看一下这两个函数 123456789101112131415// memmove ：内存移动。/* __dst : 移动内存的目的地* __src : 被移动的内存首地址* __len : 被移动的内存长度* 将__src的内存移动__len块内存到__dst中*/void *memmove(void *__dst, const void *__src, size_t __len);// memcpy ：内存拷贝。/* __dst : 拷贝内存的拷贝目的地* __src : 被拷贝的内存首地址* __n : 被移动的内存长度* 将__src的内存拷贝__n块内存到__dst中*/void *memcpy(void *__dst, const void *__src, size_t __n); 下面我们图示经过memmove和memcpy方法过后的内存变化。 经过memmove方法之后，内存变化为 12345// array()-&gt;lists 原来方法、属性、协议列表数组// addedCount 分类数组长度// oldCount * sizeof(array()-&gt;lists[0]) 原来数组占据的空间memmove(array()-&gt;lists + addedCount, array()-&gt;lists, oldCount * sizeof(array()-&gt;lists[0])); 经过memmove方法之后，我们发现，虽然本类的方法，属性，协议列表会分别后移，但是本类的对应数组的指针依然指向原始位置。 memcpy方法之后，内存变化 12345// array()-&gt;lists 原来方法、属性、协议列表数组// addedLists 分类方法、属性、协议列表数组// addedCount * sizeof(array()-&gt;lists[0]) 原来数组占据的空间memcpy(array()-&gt;lists, addedLists, addedCount * sizeof(array()-&gt;lists[0])); 我们发现原来指针并没有改变，至始至终指向开头的位置。并且经过memmove和memcpy方法之后，分类的方法，属性，协议列表被放在了类对象中原本存储的方法，属性，协议列表前面。 那么为什么要将分类方法的列表追加到本来的对象方法前面呢，这样做的目的是为了保证分类方法优先调用，我们知道当分类重写本类的方法时，会覆盖本类的方法。 其实经过上面的分析我们知道本质上并不是覆盖，而是优先调用。本类的方法依然在内存中的。我们可以通过打印所有类的所有方法名来查看 12345678910111213141516171819202122232425262728- (void)printMethodNamesOfClass:(Class)cls&#123; unsigned int count; // 获得方法数组 Method *methodList = class_copyMethodList(cls, &amp;count); // 存储方法名 NSMutableString *methodNames = [NSMutableString string]; // 遍历所有的方法 for (int i = 0; i &lt; count; i++) &#123; // 获得方法 Method method = methodList[i]; // 获得方法名 NSString *methodName = NSStringFromSelector(method_getName(method)); // 拼接方法名 [methodNames appendString:methodName]; [methodNames appendString:@&quot;, &quot;]; &#125; // 释放 free(methodList); // 打印方法名 NSLog(@&quot;%@ - %@&quot;, cls, methodNames);&#125;- (void)viewDidLoad &#123; [super viewDidLoad]; Preson *p = [[Preson alloc] init]; [p run]; [self printMethodNamesOfClass:[Preson class]];&#125; 通过下图中打印内容可以发现，调用的是Test2中的run方法，并且Person类中存储着两个run方法。 总结：问： Category的实现原理，以及Category为什么只能加方法不能加属性? 答：分类的实现原理是将category中的方法，属性，协议数据放在category_t结构体中，然后将结构体内的方法列表拷贝到类对象的方法列表中。 Category可以添加属性，但是并不会自动生成成员变量及set/get方法。因为category_t结构体中并不存在成员变量。通过之前对对象的分析我们知道成员变量是存放在实例对象中的，并且编译的那一刻就已经决定好了。而分类是在运行时才去加载的。那么我们就无法再程序运行时将分类的成员变量中添加到实例对象的结构体中。因此分类中不可以添加成员变量。 load 和 initializeload方法会在程序启动就会调用，当装载类信息的时候就会调用。 调用顺序看一下源代码。 通过源码我们发现是优先调用类的load方法，之后调用分类的load方法。 我们通过代码验证一下： 我们添加Student继承Presen类，并添加Student+Test分类，分别重写只+load方法，其他什么都不做通过打印发现 确实是优先调用类的load方法之后调用分类的load方法，不过调用类的load方法之前会保证其父类已经调用过load方法。 之后我们为Preson、Student 、Student+Test 添加initialize方法。 我们知道当类第一次接收到消息时，就会调用initialize，相当于第一次使用类的时候就会调用initialize方法。调用子类的initialize之前，会先保证调用父类的initialize方法。如果之前已经调用过initialize，就不会再调用initialize方法了。当分类重写initialize方法时会先调用分类的方法。但是load方法并不会被覆盖，首先我们来看一下initialize的源码。 上图中我们发现，initialize是通过消息发送机制调用的，消息发送机制通过isa指针找到对应的方法与实现，因此先找到分类方法中的实现，会优先调用分类方法中的实现。 我们再来看一下load方法的调用源码 我们看到load方法中直接拿到load方法的内存地址直接调用方法，不在是通过消息发送机制调用。 我们可以看到分类中也是通过直接拿到load方法的地址进行调用。因此正如我们之前试验的一样，分类中重写load方法，并不会优先调用分类的load方法，而不调用本类中的load方法了。 总结问：Category中有load方法吗？load方法是什么时候调用的？load 方法能继承吗？ 答：Category中有load方法，load方法在程序启动装载类信息的时候就会调用。load方法可以继承。调用子类的load方法之前，会先调用父类的load方法 问：load、initialize的区别，以及它们在category重写的时候的调用的次序。 答：区别在于调用方式和调用时刻 调用方式：load是根据函数地址直接调用，initialize是通过objc_msgSend调用 调用时刻：load是runtime加载类、分类的时候调用（只会调用1次），initialize是类第一次接收到消息的时候调用，每一个类只会initialize一次（父类的initialize方法可能会被调用多次） 调用顺序：先调用类的load方法，先编译那个类，就先调用load。在调用load之前会先调用父类的load方法。分类中load方法不会覆盖本类的load方法，先编译的分类优先调用load方法。initialize先初始化父类，之后再初始化子类。如果子类没有实现+initialize，会调用父类的+initialize（所以父类的+initialize可能会被调用多次），如果分类实现了+initialize，就覆盖类本身的+initialize调用。 作者：xx_cc链接：https://juejin.im/post/5aef0a3b518825670f7bc0f3来源：掘金著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。]]></content>
      <categories>
        <category>principle</category>
      </categories>
      <tags>
        <tag>Category</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS底层原理总结 - RunLoop]]></title>
    <url>%2F2018%2F07%2F05%2FiOS%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93-RunLoop%2F</url>
    <content type="text"><![CDATA[iOS底层原理总结 - RunLoop面试题 讲讲 RunLoop，项目中有用到吗？ RunLoop内部实现逻辑？ Runloop和线程的关系？ timer 与 Runloop 的关系？ 程序中添加每3秒响应一次的NSTimer，当拖动tableview时timer可能无法响应要怎么解决？ Runloop 是怎么响应用户操作的， 具体流程是什么样的？ 说说RunLoop的几种状态？ Runloop的mode作用是什么？ 一. RunLoop简介运行循环，在程序运行过程中循环做一些事情，如果没有Runloop程序执行完毕就会立即退出，如果有Runloop程序会一直运行，并且时时刻刻在等待用户的输入操作。RunLoop可以在需要的时候自己跑起来运行，在没有操作的时候就停下来休息。充分节省CPU资源，提高程序性能。 二. RunLoop基本作用： 保持程序持续运行，程序一启动就会开一个主线程，主线程一开起来就会跑一个主线程对应的RunLoop,RunLoop保证主线程不会被销毁，也就保证了程序的持续运行 处理App中的各种事件（比如：触摸事件，定时器事件，Selector事件等） 节省CPU资源，提高程序性能，程序运行起来时，当什么操作都没有做的时候，RunLoop就告诉CPU，现在没有事情做，我要去休息，这时CPU就会将其资源释放出来去做其他的事情，当有事情做的时候RunLoop就会立马起来去做事情我们先通过API内一张图片来简单看一下RunLoop内部运行原理 通过图片可以看出，RunLoop在跑圈过程中，当接收到Input sources 或者 Timer sources时就会交给对应的处理方去处理。当没有事件消息传入的时候，RunLoop就休息了。这里只是简单的理解一下这张图，接下来我们来了解RunLoop对象和其一些相关类，来更深入的理解RunLoop运行流程。 三. RunLoop在哪里开启UIApplicationMain函数内启动了Runloop，程序不会马上退出，而是保持运行状态。因此每一个应用必须要有一个runloop， 我们知道主线程一开起来，就会跑一个和主线程对应的RunLoop，那么RunLoop一定是在程序的入口main函数中开启。 12345int main(int argc, char * argv[]) &#123; @autoreleasepool &#123; return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class])); &#125;&#125; 进入UIApplicationMain 1UIKIT_EXTERN int UIApplicationMain(int argc, char *argv[], NSString * __nullable principalClassName, NSString * __nullable delegateClassName); 我们发现它返回的是一个int数，那么我们对main函数做一些修改 12345678int main(int argc, char * argv[]) &#123; @autoreleasepool &#123; NSLog(@&quot;开始&quot;); int re = UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class])); NSLog(@&quot;结束&quot;); return re; &#125;&#125; 运行程序，我们发现只会打印开始，并不会打印结束，这说明在UIApplicationMain函数中，开启了一个和主线程相关的RunLoop，导致UIApplicationMain不会返回，一直在运行中，也就保证了程序的持续运行。 我们来看到RunLoop的源码 12345678// 用DefaultMode启动void CFRunLoopRun(void) &#123; /* DOES CALLOUT */ int32_t result; do &#123; result = CFRunLoopRunSpecific(CFRunLoopGetCurrent(), kCFRunLoopDefaultMode, 1.0e10, false); CHECK_FOR_FORK(); &#125; while (kCFRunLoopRunStopped != result &amp;&amp; kCFRunLoopRunFinished != result);&#125; 我们发现RunLoop确实是do while通过判断result的值实现的。因此，我们可以把RunLoop看成一个死循环。如果没有RunLoop，UIApplicationMain函数执行完毕之后将直接返回，也就没有程序持续运行一说了。 四. RunLoop对象 Fundation框架 （基于CFRunLoopRef的封装） NSRunLoop对象 CoreFoundation CFRunLoopRef对象 因为Fundation框架是基于CFRunLoopRef的一层OC封装，这里我们主要研究CFRunLoopRef源码 如何获得RunLoop对象1234567Foundation[NSRunLoop currentRunLoop]; // 获得当前线程的RunLoop对象[NSRunLoop mainRunLoop]; // 获得主线程的RunLoop对象Core FoundationCFRunLoopGetCurrent(); // 获得当前线程的RunLoop对象CFRunLoopGetMain(); // 获得主线程的RunLoop对象 五. RunLoop和线程间的关系 每条线程都有唯一的一个与之对应的RunLoop对象 RunLoop保存在一个全局的Dictionary里，线程作为key,RunLoop作为value 主线程的RunLoop已经自动创建好了，子线程的RunLoop需要主动创建 RunLoop在第一次获取时创建，在线程结束时销毁 通过源码查看上述对应12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// 拿到当前Runloop 调用_CFRunLoopGet0CFRunLoopRef CFRunLoopGetCurrent(void) &#123; CHECK_FOR_FORK(); CFRunLoopRef rl = (CFRunLoopRef)_CFGetTSD(__CFTSDKeyRunLoop); if (rl) return rl; return _CFRunLoopGet0(pthread_self());&#125;// 查看_CFRunLoopGet0方法内部CF_EXPORT CFRunLoopRef _CFRunLoopGet0(pthread_t t) &#123; if (pthread_equal(t, kNilPthreadT)) &#123; t = pthread_main_thread_np(); &#125; __CFLock(&amp;loopsLock); if (!__CFRunLoops) &#123; __CFUnlock(&amp;loopsLock); CFMutableDictionaryRef dict = CFDictionaryCreateMutable(kCFAllocatorSystemDefault, 0, NULL, &amp;kCFTypeDictionaryValueCallBacks); // 根据传入的主线程获取主线程对应的RunLoop CFRunLoopRef mainLoop = __CFRunLoopCreate(pthread_main_thread_np()); // 保存主线程 将主线程-key和RunLoop-Value保存到字典中 CFDictionarySetValue(dict, pthreadPointer(pthread_main_thread_np()), mainLoop); if (!OSAtomicCompareAndSwapPtrBarrier(NULL, dict, (void * volatile *)&amp;__CFRunLoops)) &#123; CFRelease(dict); &#125; CFRelease(mainLoop); __CFLock(&amp;loopsLock); &#125; // 从字典里面拿，将线程作为key从字典里获取一个loop CFRunLoopRef loop = (CFRunLoopRef)CFDictionaryGetValue(__CFRunLoops, pthreadPointer(t)); __CFUnlock(&amp;loopsLock); // 如果loop为空，则创建一个新的loop，所以runloop会在第一次获取的时候创建 if (!loop) &#123; CFRunLoopRef newLoop = __CFRunLoopCreate(t); __CFLock(&amp;loopsLock); loop = (CFRunLoopRef)CFDictionaryGetValue(__CFRunLoops, pthreadPointer(t)); // 创建好之后，以线程为key runloop为value，一对一存储在字典中，下次获取的时候，则直接返回字典内的runloop if (!loop) &#123; CFDictionarySetValue(__CFRunLoops, pthreadPointer(t), newLoop); loop = newLoop; &#125; // don&apos;t release run loops inside the loopsLock, because CFRunLoopDeallocate may end up taking it __CFUnlock(&amp;loopsLock); CFRelease(newLoop); &#125; if (pthread_equal(t, pthread_self())) &#123; _CFSetTSD(__CFTSDKeyRunLoop, (void *)loop, NULL); if (0 == _CFGetTSD(__CFTSDKeyRunLoopCntr)) &#123; _CFSetTSD(__CFTSDKeyRunLoopCntr, (void *)(PTHREAD_DESTRUCTOR_ITERATIONS-1), (void (*)(void *))__CFFinalizeRunLoop); &#125; &#125; return loop;&#125; 从上面的代码可以看出，线程和 RunLoop 之间是一一对应的，其关系是保存在一个 Dictionary 里。所以我们创建子线程RunLoop时，只需在子线程中获取当前线程的RunLoop对象即可[NSRunLoop currentRunLoop];如果不获取，那子线程就不会创建与之相关联的RunLoop，并且只能在一个线程的内部获取其 RunLoop[NSRunLoop currentRunLoop];方法调用时，会先看一下字典里有没有存子线程相对用的RunLoop，如果有则直接返回RunLoop，如果没有则会创建一个，并将与之对应的子线程存入字典中。当线程结束时，RunLoop会被销毁。 六. RunLoop结构体通过源码我们找到__CFRunLoop结构体 123456789101112131415161718struct __CFRunLoop &#123; CFRuntimeBase _base; pthread_mutex_t _lock; /* locked for accessing mode list */ __CFPort _wakeUpPort; // used for CFRunLoopWakeUp Boolean _unused; volatile _per_run_data *_perRunData; // reset for runs of the run loop pthread_t _pthread; uint32_t _winthread; CFMutableSetRef _commonModes; CFMutableSetRef _commonModeItems; CFRunLoopModeRef _currentMode; CFMutableSetRef _modes; struct _block_item *_blocks_head; struct _block_item *_blocks_tail; CFAbsoluteTime _runTime; CFAbsoluteTime _sleepTime; CFTypeRef _counterpart;&#125;; 除一些记录性属性外，主要来看一下以下两个成员变量 12CFRunLoopModeRef _currentMode;CFMutableSetRef _modes; CFRunLoopModeRef 其实是指向__CFRunLoopMode结构体的指针，__CFRunLoopMode结构体源码如下 12345678910111213141516171819202122232425262728293031typedef struct __CFRunLoopMode *CFRunLoopModeRef;struct __CFRunLoopMode &#123; CFRuntimeBase _base; pthread_mutex_t _lock; /* must have the run loop locked before locking this */ CFStringRef _name; Boolean _stopped; char _padding[3]; CFMutableSetRef _sources0; CFMutableSetRef _sources1; CFMutableArrayRef _observers; CFMutableArrayRef _timers; CFMutableDictionaryRef _portToV1SourceMap; __CFPortSet _portSet; CFIndex _observerMask;#if USE_DISPATCH_SOURCE_FOR_TIMERS dispatch_source_t _timerSource; dispatch_queue_t _queue; Boolean _timerFired; // set to true by the source when a timer has fired Boolean _dispatchTimerArmed;#endif#if USE_MK_TIMER_TOO mach_port_t _timerPort; Boolean _mkTimerArmed;#endif#if DEPLOYMENT_TARGET_WINDOWS DWORD _msgQMask; void (*_msgPump)(void);#endif uint64_t _timerSoftDeadline; /* TSR */ uint64_t _timerHardDeadline; /* TSR */&#125;; 主要查看以下成员变量 1234CFMutableSetRef _sources0;CFMutableSetRef _sources1;CFMutableArrayRef _observers;CFMutableArrayRef _timers; 通过上面分析我们知道，CFRunLoopModeRef代表RunLoop的运行模式，一个RunLoop包含若干个Mode，每个Mode又包含若干个Source0/Source1/Timer/Observer，而RunLoop启动时只能选择其中一个Mode作为currentMode。 Source1/Source0/Timers/Observer分别代表什么1. Source1 : 基于Port的线程间通信 2. Source0 : 触摸事件，PerformSelectors 我们通过代码验证一下 1234- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123; NSLog(@&quot;点击了屏幕&quot;);&#125; 打断点之后打印堆栈信息，当xcode工具区打印的堆栈信息不全时，可以在控制台通过“bt”指令打印完整的堆栈信息，由堆栈信息中可以发现，触摸事件确实是会触发Source0事件。 同样的方式验证performSelector堆栈信息 123dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; [self performSelectorOnMainThread:@selector(test) withObject:nil waitUntilDone:YES];&#125;); 可以发现PerformSelectors同样是触发Source0事件 其实，当我们触发了事件（触摸/锁屏/摇晃等）后，由IOKit.framework生成一个 IOHIDEvent事件，而IOKit是苹果的硬件驱动框架，由它进行底层接口的抽象封装与系统进行交互传递硬件感应的事件，并专门处理用户交互设备，由IOHIDServices和IOHIDDisplays两部分组成，其中IOHIDServices是专门处理用户交互的，它会将事件封装成IOHIDEvents对象，接着用mach port转发给需要的App进程，随后 Source1就会接收IOHIDEvent，之后再回调__IOHIDEventSystemClientQueueCallback()，__IOHIDEventSystemClientQueueCallback()内触发Source0，Source0 再触发 _UIApplicationHandleEventQueue()。所以触摸事件看到是在 Source0 内的。 3. Timers : 定时器，NSTimer 通过代码验证 123[NSTimer scheduledTimerWithTimeInterval:3.0 repeats:NO block:^(NSTimer * _Nonnull timer) &#123; NSLog(@&quot;NSTimer ---- timer调用了&quot;);&#125;]; 打印完整堆栈信息 4. Observer : 监听器，用于监听RunLoop的状态 七. 详解RunLoop相关类及作用通过上面的分析，我们对RunLoop内部结构有了大致的了解，接下来来详细分析RunLoop的相关类。以下为Core Foundation中关于RunLoop的5个类 CFRunLoopRef - 获得当前RunLoop和主RunLoop CFRunLoopModeRef - RunLoop 运行模式，只能选择一种，在不同模式中做不同的操作 CFRunLoopSourceRef - 事件源，输入源 CFRunLoopTimerRef - 定时器时间 CFRunLoopObserverRef - 观察者 1. CFRunLoopModeRefCFRunLoopModeRef代表RunLoop的运行模式 一个 RunLoop 包含若干个 Mode，每个Mode又包含若干个Source、Timer、Observer 每次RunLoop启动时，只能指定其中一个 Mode，这个Mode被称作 CurrentMode 如果需要切换Mode，只能退出RunLoop，再重新指定一个Mode进入，这样做主要是为了分隔开不同组的Source、Timer、Observer，让其互不影响。如果Mode里没有任何Source0/Source1/Timer/Observer，RunLoop会立马退出如图所示： 注意：一种Mode中可以有多个Source(事件源，输入源，基于端口事件源例键盘触摸等) Observer(观察者，观察当前RunLoop运行状态) 和Timer(定时器事件源)。但是必须至少有一个Source或者Timer，因为如果Mode为空，RunLoop运行到空模式不会进行空转，就会立刻退出。 系统默认注册的5个Mode:RunLoop 有五种运行模式，其中常见的有1.2两种 123451. kCFRunLoopDefaultMode：App的默认Mode，通常主线程是在这个Mode下运行2. UITrackingRunLoopMode：界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响3. UIInitializationRunLoopMode: 在刚启动 App 时第进入的第一个 Mode，启动完成后就不再使用，会切换到kCFRunLoopDefaultMode4. GSEventReceiveRunLoopMode: 接受系统事件的内部 Mode，通常用不到5. kCFRunLoopCommonModes: 这是一个占位用的Mode，作为标记kCFRunLoopDefaultMode和UITrackingRunLoopMode用，并不是一种真正的Mode Mode间的切换我们平时在开发中一定遇到过，当我们使用NSTimer每一段时间执行一些事情时滑动UIScrollView，NSTimer就会暂停，当我们停止滑动以后，NSTimer又会重新恢复的情况，我们通过一段代码来看一下 代码中的注释也很重要，展示了我们探索的过程 1234567891011121314151617181920212223242526-(void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123; // [NSTimer scheduledTimerWithTimeInterval:2.0 target:self selector:@selector(show) userInfo:nil repeats:YES]; NSTimer *timer = [NSTimer timerWithTimeInterval:2.0 target:self selector:@selector(show) userInfo:nil repeats:YES]; // 加入到RunLoop中才可以运行 // 1. 把定时器添加到RunLoop中，并且选择默认运行模式NSDefaultRunLoopMode = kCFRunLoopDefaultMode // [[NSRunLoop mainRunLoop] addTimer:timer forMode:NSDefaultRunLoopMode]; // 当textFiled滑动的时候，timer失效，停止滑动时，timer恢复 // 原因：当textFiled滑动的时候，RunLoop的Mode会自动切换成UITrackingRunLoopMode模式，因此timer失效，当停止滑动，RunLoop又会切换回NSDefaultRunLoopMode模式，因此timer又会重新启动了 // 2. 当我们将timer添加到UITrackingRunLoopMode模式中，此时只有我们在滑动textField时timer才会运行 // [[NSRunLoop mainRunLoop] addTimer:timer forMode:UITrackingRunLoopMode]; // 3. 那个如何让timer在两个模式下都可以运行呢？ // 3.1 在两个模式下都添加timer 是可以的，但是timer添加了两次，并不是同一个timer // 3.2 使用站位的运行模式 NSRunLoopCommonModes标记，凡是被打上NSRunLoopCommonModes标记的都可以运行，下面两种模式被打上标签 //0 : &lt;CFString 0x10b7fe210 [0x10a8c7a40]&gt;&#123;contents = &quot;UITrackingRunLoopMode&quot;&#125; //2 : &lt;CFString 0x10a8e85e0 [0x10a8c7a40]&gt;&#123;contents = &quot;kCFRunLoopDefaultMode&quot;&#125; // 因此也就是说如果我们使用NSRunLoopCommonModes，timer可以在UITrackingRunLoopMode，kCFRunLoopDefaultMode两种模式下运行 [[NSRunLoop mainRunLoop] addTimer:timer forMode:NSRunLoopCommonModes]; NSLog(@&quot;%@&quot;,[NSRunLoop mainRunLoop]);&#125;-(void)show&#123; NSLog(@&quot;-------&quot;);&#125; 由上述代码可以看出，NSTimer不管用是因为Mode的切换，因为如果我们在主线程使用定时器，此时RunLoop的Mode为kCFRunLoopDefaultMode，即定时器属于kCFRunLoopDefaultMode，那么此时我们滑动ScrollView时，RunLoop的Mode会切换到UITrackingRunLoopMode，因此在主线程的定时器就不在管用了，调用的方法也就不再执行了，当我们停止滑动时，RunLoop的Mode切换回kCFRunLoopDefaultMode，所以NSTimer就又管用了。 同样道理的还有ImageView的显示，我们直接来看代码，不再赘述了 1234567-(void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123; NSLog(@&quot;%s&quot;,__func__); // performSelector默认是在default模式下运行，因此在滑动ScrollView时，图片不会加载 // [self.imageView performSelector:@selector(setImage:) withObject:[UIImage imageNamed:@&quot;abc&quot;] afterDelay:2.0 ]; // inModes: 传入Mode数组 [self.imageView performSelector:@selector(setImage:) withObject:[UIImage imageNamed:@&quot;abc&quot;] afterDelay:2.0 inModes:@[NSDefaultRunLoopMode,UITrackingRunLoopMode]]; 使用GCD也可是创建计时器，而且更为精确我们来看一下代码 123456789101112131415161718192021222324252627282930-(void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123; //创建队列 dispatch_queue_t queue = dispatch_get_global_queue(0, 0); //1.创建一个GCD定时器 /* 第一个参数:表明创建的是一个定时器 第四个参数:队列 */ dispatch_source_t timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue); // 需要对timer进行强引用，保证其不会被释放掉，才会按时调用block块 // 局部变量，让指针强引用 self.timer = timer; //2.设置定时器的开始时间,间隔时间,精准度 /* 第1个参数:要给哪个定时器设置 第2个参数:开始时间 第3个参数:间隔时间 第4个参数:精准度 一般为0 在允许范围内增加误差可提高程序的性能 GCD的单位是纳秒 所以要*NSEC_PER_SEC */ dispatch_source_set_timer(timer, DISPATCH_TIME_NOW, 2.0 * NSEC_PER_SEC, 0 * NSEC_PER_SEC); //3.设置定时器要执行的事情 dispatch_source_set_event_handler(timer, ^&#123; NSLog(@&quot;---%@--&quot;,[NSThread currentThread]); &#125;); // 启动 dispatch_resume(timer);&#125; 2. CFRunLoopSourceRef事件源（输入源）Source分为两种 Source0：非基于Port的 用于用户主动触发的事件（点击button 或点击屏幕） Source1：基于Port的 通过内核和其他线程相互发送消息（与内核相关） 触摸事件及PerformSelectors会触发Source0事件源在前文已经验证过，这里不在赘述 3. CFRunLoopObserverRefCFRunLoopObserverRef是观察者，能够监听RunLoop的状态改变 我们直接来看代码，给RunLoop添加监听者，监听其运行状态 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162-(void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123; //创建监听者 /* 第一个参数 CFAllocatorRef allocator：分配存储空间 CFAllocatorGetDefault()默认分配 第二个参数 CFOptionFlags activities：要监听的状态 kCFRunLoopAllActivities 监听所有状态 第三个参数 Boolean repeats：YES:持续监听 NO:不持续 第四个参数 CFIndex order：优先级，一般填0即可 第五个参数 ：回调 两个参数observer:监听者 activity:监听的事件 */ /* 所有事件 typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123; kCFRunLoopEntry = (1UL &lt;&lt; 0), // 即将进入RunLoop kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1), // 即将处理Timer kCFRunLoopBeforeSources = (1UL &lt;&lt; 2), // 即将处理Source kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5), //即将进入休眠 kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6),// 刚从休眠中唤醒 kCFRunLoopExit = (1UL &lt;&lt; 7),// 即将退出RunLoop kCFRunLoopAllActivities = 0x0FFFFFFFU &#125;; */ CFRunLoopObserverRef observer = CFRunLoopObserverCreateWithHandler(CFAllocatorGetDefault(), kCFRunLoopAllActivities, YES, 0, ^(CFRunLoopObserverRef observer, CFRunLoopActivity activity) &#123; switch (activity) &#123; case kCFRunLoopEntry: NSLog(@&quot;RunLoop进入&quot;); break; case kCFRunLoopBeforeTimers: NSLog(@&quot;RunLoop要处理Timers了&quot;); break; case kCFRunLoopBeforeSources: NSLog(@&quot;RunLoop要处理Sources了&quot;); break; case kCFRunLoopBeforeWaiting: NSLog(@&quot;RunLoop要休息了&quot;); break; case kCFRunLoopAfterWaiting: NSLog(@&quot;RunLoop醒来了&quot;); break; case kCFRunLoopExit: NSLog(@&quot;RunLoop退出了&quot;); break; default: break; &#125; &#125;); // 给RunLoop添加监听者 /* 第一个参数 CFRunLoopRef rl：要监听哪个RunLoop,这里监听的是主线程的RunLoop 第二个参数 CFRunLoopObserverRef observer 监听者 第三个参数 CFStringRef mode 要监听RunLoop在哪种运行模式下的状态 */ CFRunLoopAddObserver(CFRunLoopGetCurrent(), observer, kCFRunLoopDefaultMode); /* CF的内存管理（Core Foundation） 凡是带有Create、Copy、Retain等字眼的函数，创建出来的对象，都需要在最后做一次release GCD本来在iOS6.0之前也是需要我们释放的，6.0之后GCD已经纳入到了ARC中，所以我们不需要管了 */ CFRelease(observer);&#125; 我们来看一下输出 以上可以看出，Observer确实用来监听RunLoop的状态，包括唤醒，休息，以及处理各种事件。 八. RunLoop处理逻辑这时我们再来分析RunLoop的处理逻辑，就会简单明了很多，现在回头看官方文档RunLoop的处理逻辑，对RunLoop的处理逻辑有新的认识。 源码解析下面源码仅保留了主流程代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100// 共外部调用的公开的CFRunLoopRun方法，其内部会调用CFRunLoopRunSpecificvoid CFRunLoopRun(void) &#123; /* DOES CALLOUT */ int32_t result; do &#123; result = CFRunLoopRunSpecific(CFRunLoopGetCurrent(), kCFRunLoopDefaultMode, 1.0e10, false); CHECK_FOR_FORK(); &#125; while (kCFRunLoopRunStopped != result &amp;&amp; kCFRunLoopRunFinished != result);&#125;// 经过精简的 CFRunLoopRunSpecific 函数代码，其内部会调用__CFRunLoopRun函数SInt32 CFRunLoopRunSpecific(CFRunLoopRef rl, CFStringRef modeName, CFTimeInterval seconds, Boolean returnAfterSourceHandled) &#123; /* DOES CALLOUT */ // 通知Observers : 进入Loop // __CFRunLoopDoObservers内部会调用 __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__函数 if (currentMode-&gt;_observerMask &amp; kCFRunLoopEntry ) __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopEntry); // 核心的Loop逻辑 result = __CFRunLoopRun(rl, currentMode, seconds, returnAfterSourceHandled, previousMode); // 通知Observers : 退出Loop if (currentMode-&gt;_observerMask &amp; kCFRunLoopExit ) __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit); return result;&#125;// 精简后的 __CFRunLoopRun函数，保留了主要代码static int32_t __CFRunLoopRun(CFRunLoopRef rl, CFRunLoopModeRef rlm, CFTimeInterval seconds, Boolean stopAfterHandle, CFRunLoopModeRef previousMode) &#123; int32_t retVal = 0; do &#123; // 通知Observers：即将处理Timers __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeTimers); // 通知Observers：即将处理Sources __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeSources); // 处理Blocks __CFRunLoopDoBlocks(rl, rlm); // 处理Sources0 if (__CFRunLoopDoSources0(rl, rlm, stopAfterHandle)) &#123; // 处理Blocks __CFRunLoopDoBlocks(rl, rlm); &#125; // 如果有Sources1，就跳转到handle_msg标记处 if (__CFRunLoopServiceMachPort(dispatchPort, &amp;msg, sizeof(msg_buffer), &amp;livePort, 0, &amp;voucherState, NULL)) &#123; goto handle_msg; &#125; // 通知Observers：即将休眠 __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeWaiting); // 进入休眠，等待其他消息唤醒 __CFRunLoopSetSleeping(rl); __CFPortSetInsert(dispatchPort, waitSet); do &#123; __CFRunLoopServiceMachPort(waitSet, &amp;msg, sizeof(msg_buffer), &amp;livePort, poll ? 0 : TIMEOUT_INFINITY, &amp;voucherState, &amp;voucherCopy); &#125; while (1); // 醒来 __CFPortSetRemove(dispatchPort, waitSet); __CFRunLoopUnsetSleeping(rl); // 通知Observers：已经唤醒 __CFRunLoopDoObservers(rl, rlm, kCFRunLoopAfterWaiting); handle_msg: // 看看是谁唤醒了RunLoop，进行相应的处理 if (被Timer唤醒的) &#123; // 处理Timer __CFRunLoopDoTimers(rl, rlm, mach_absolute_time()); &#125; else if (被GCD唤醒的) &#123; __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg); &#125; else &#123; // 被Sources1唤醒的 __CFRunLoopDoSource1(rl, rlm, rls, msg, msg-&gt;msgh_size, &amp;reply); &#125; // 执行Blocks __CFRunLoopDoBlocks(rl, rlm); // 根据之前的执行结果，来决定怎么做，为retVal赋相应的值 if (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123; retVal = kCFRunLoopRunHandledSource; &#125; else if (timeout_context-&gt;termTSR &lt; mach_absolute_time()) &#123; retVal = kCFRunLoopRunTimedOut; &#125; else if (__CFRunLoopIsStopped(rl)) &#123; __CFRunLoopUnsetStopped(rl); retVal = kCFRunLoopRunStopped; &#125; else if (rlm-&gt;_stopped) &#123; rlm-&gt;_stopped = false; retVal = kCFRunLoopRunStopped; &#125; else if (__CFRunLoopModeIsEmpty(rl, rlm, previousMode)) &#123; retVal = kCFRunLoopRunFinished; &#125; &#125; while (0 == retVal); return retVal;&#125; 上述源代码中，相应处理事件函数内部还会调用更底层的函数，内部调用才是真正处理事件的函数，通过上面bt打印全部堆栈信息也可以得到验证。 __CFRunLoopDoObservers 内部调用 __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__ __CFRunLoopDoBlocks 内部调用 __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__ __CFRunLoopDoSources0 内部调用 __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__ __CFRunLoopDoTimers 内部调用 __CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__ GCD 调用 __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__ __CFRunLoopDoSource1 内部调用 __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__ RunLoop处理逻辑流程图此时我们按照源码重新整理一下RunLoop处理逻辑就会很清晰 九. RunLoop退出 主线程销毁RunLoop退出 Mode中有一些Timer 、Source、 Observer，这些保证Mode不为空时保证RunLoop没有空转并且是在运行的，当Mode中为空的时候，RunLoop会立刻退出 我们在启动RunLoop的时候可以设置什么时候停止 12[NSRunLoop currentRunLoop]runUntilDate:&lt;#(nonnull NSDate *)#&gt;[NSRunLoop currentRunLoop]runMode:&lt;#(nonnull NSString *)#&gt; beforeDate:&lt;#(nonnull NSDate *)#&gt; 十. RunLoop应用1. 常驻线程常驻线程的作用：我们知道，当子线程中的任务执行完毕之后就被销毁了，那么如果我们需要开启一个子线程，在程序运行过程中永远都存在，那么我们就会面临一个问题，如何让子线程永远活着，这时就要用到常驻线程：给子线程开启一个RunLoop注意：子线程执行完操作之后就会立即释放，即使我们使用强引用引用子线程使子线程不被释放，也不能给子线程再次添加操作，或者再次开启。子线程开启RunLoop的代码，先点击屏幕开启子线程并开启子线程RunLoop，然后点击button。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#import &quot;ViewController.h&quot;@interface ViewController ()@property(nonatomic,strong)NSThread *thread;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad];&#125;-(void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123; // 创建子线程并开启 NSThread *thread = [[NSThread alloc]initWithTarget:self selector:@selector(show) object:nil]; self.thread = thread; [thread start];&#125;-(void)show&#123; // 注意：打印方法一定要在RunLoop创建开始运行之前，如果在RunLoop跑起来之后打印，RunLoop先运行起来，已经在跑圈了就出不来了，进入死循环也就无法执行后面的操作了。 // 但是此时点击Button还是有操作的，因为Button是在RunLoop跑起来之后加入到子线程的，当Button加入到子线程RunLoop就会跑起来 NSLog(@&quot;%s&quot;,__func__); // 1.创建子线程相关的RunLoop，在子线程中创建即可，并且RunLoop中要至少有一个Timer 或 一个Source 保证RunLoop不会因为空转而退出，因此在创建的时候直接加入 // 添加Source [NSMachPort port] 添加一个端口 [[NSRunLoop currentRunLoop] addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode]; // 添加一个Timer NSTimer *timer = [NSTimer scheduledTimerWithTimeInterval:2.0 target:self selector:@selector(test) userInfo:nil repeats:YES]; [[NSRunLoop currentRunLoop] addTimer:timer forMode:NSDefaultRunLoopMode]; //创建监听者 CFRunLoopObserverRef observer = CFRunLoopObserverCreateWithHandler(CFAllocatorGetDefault(), kCFRunLoopAllActivities, YES, 0, ^(CFRunLoopObserverRef observer, CFRunLoopActivity activity) &#123; switch (activity) &#123; case kCFRunLoopEntry: NSLog(@&quot;RunLoop进入&quot;); break; case kCFRunLoopBeforeTimers: NSLog(@&quot;RunLoop要处理Timers了&quot;); break; case kCFRunLoopBeforeSources: NSLog(@&quot;RunLoop要处理Sources了&quot;); break; case kCFRunLoopBeforeWaiting: NSLog(@&quot;RunLoop要休息了&quot;); break; case kCFRunLoopAfterWaiting: NSLog(@&quot;RunLoop醒来了&quot;); break; case kCFRunLoopExit: NSLog(@&quot;RunLoop退出了&quot;); break; default: break; &#125; &#125;); // 给RunLoop添加监听者 CFRunLoopAddObserver(CFRunLoopGetCurrent(), observer, kCFRunLoopDefaultMode); // 2.子线程需要开启RunLoop [[NSRunLoop currentRunLoop]run]; CFRelease(observer);&#125;- (IBAction)btnClick:(id)sender &#123; [self performSelector:@selector(test) onThread:self.thread withObject:nil waitUntilDone:NO];&#125;-(void)test&#123; NSLog(@&quot;%@&quot;,[NSThread currentThread]);&#125;@end 注意：创建子线程相关的RunLoop，在子线程中创建即可，并且RunLoop中要至少有一个Timer 或 一个Source 保证RunLoop不会因为空转而退出，因此在创建的时候直接加入，如果没有加入Timer或者Source，或者只加入一个监听者，运行程序会崩溃 2. 自动释放池Timer和Source也是一些变量，需要占用一部分存储空间，所以要释放掉，如果不释放掉，就会一直积累，占用的内存也就越来越大，这显然不是我们想要的。 那么什么时候释放，怎么释放呢？ RunLoop内部有一个自动释放池，当RunLoop开启时，就会自动创建一个自动释放池，当RunLoop在休息之前会释放掉自动释放池的东西，然后重新创建一个新的空的自动释放池，当RunLoop被唤醒重新开始跑圈时，Timer,Source等新的事件就会放到新的自动释放池中，当RunLoop退出的时候也会被释放。 注意：只有主线程的RunLoop会默认启动。也就意味着会自动创建自动释放池，子线程需要在线程调度方法中手动添加自动释放池。 123@autorelease&#123; // 执行代码 &#125; NSTimer、ImageView显示、PerformSelector等在上面已经有过例子，这里不再赘述。 最后检验一下自己文章开头的面试题，在文中都可以找到答案，这里不在赘述了。 文献资料苹果官方文档 CFRunLoopRef源码]]></content>
      <categories>
        <category>principle</category>
      </categories>
      <tags>
        <tag>runloop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS底层原理总结 - 探寻Class的本质]]></title>
    <url>%2F2018%2F07%2F05%2FiOS%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93-%E6%8E%A2%E5%AF%BBClass%E7%9A%84%E6%9C%AC%E8%B4%A8%2F</url>
    <content type="text"><![CDATA[iOS底层原理总结 - 探寻Class的本质对小码哥底层班视频学习的总结与记录。面试题部分，通过对面试题的分析探索问题的本质内容。 上接 iOS底层原理总结 - 探寻OC对象的本质 Class的本质我们知道不管是类对象还是元类对象，类型都是Class，class和mete-class的底层都是objc_class结构体的指针，内存中就是结构体，本章来探寻Class的本质。 12Class objectClass = [NSObject class]; Class objectMetaClass = object_getClass([NSObject class]); 点击Class来到内部，我们可以发现 1typedef struct objc_class *Class; Class对象其实是一个指向objc_class结构体的指针。因此我们可以说类对象或元类对象在内存中其实就是objc_class结构体。 我们来到objc_class内部，可以看到这段在底层原理中经常出现的代码。 1234567891011121314151617struct objc_class &#123; Class _Nonnull isa OBJC_ISA_AVAILABILITY;#if !__OBJC2__ Class _Nullable super_class OBJC2_UNAVAILABLE; const char * _Nonnull name OBJC2_UNAVAILABLE; long version OBJC2_UNAVAILABLE; long info OBJC2_UNAVAILABLE; long instance_size OBJC2_UNAVAILABLE; struct objc_ivar_list * _Nullable ivars OBJC2_UNAVAILABLE; struct objc_method_list * _Nullable * _Nullable methodLists OBJC2_UNAVAILABLE; struct objc_cache * _Nonnull cache OBJC2_UNAVAILABLE; struct objc_protocol_list * _Nullable protocols OBJC2_UNAVAILABLE;#endif&#125; OBJC2_UNAVAILABLE;/* Use `Class` instead of `struct objc_class *` */ 这部分代码相信在文章中很常见，但是OBJC2_UNAVAILABLE;说明这些代码已经不在使用了。那么目前objc_class的结构是什么样的呢？我们通过objc源码中去查找objc_class结构体的内容。 我们发现这个结构体继承 objc_object 并且结构体内有一些函数，因为这是c++结构体，在c上做了扩展，因此结构体中可以包含函数。我们来到objc_object内，截取部分代码 我们发现objc_object中有一个isa指针，那么objc_class继承objc_object，也就同样拥有一个isa指针 那么我们之前了解到的，类中存储的类的成员变量信息，实例方法，属性名等这些信息在哪里呢。我们来到class_rw_t中，截取部分代码，我们发现class_rw_t中存储着方法列表，属性列表，协议列表等内容。 而class_rw_t是通过bits调用data方法得来的，我们来到data方法内部实现。我们可以看到，data函数内部仅仅对bits进行&amp;FAST_DATA_MASK操作 而成员变量信息则是存储在class_ro_t内部中的，我们来到class_ro_t内查看。 最后总结通过一张图进行总结 如何证明上述内容是正确的。我们可以自定义一个结构体，如果我们自己写的结构和objc_class真实结构是一样的，那么当我们强制转化的时候，就会一一对应的赋值。此时我们就可以拿到结构体内部的信息。 下列代码是我们仿照objc_class结构体，提取其中需要使用到的信息，自定义的一个结构体。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136#import &lt;Foundation/Foundation.h&gt;#ifndef XXClassInfo_h#define XXClassInfo_h# if __arm64__# define ISA_MASK 0x0000000ffffffff8ULL# elif __x86_64__# define ISA_MASK 0x00007ffffffffff8ULL# endif#if __LP64__typedef uint32_t mask_t;#elsetypedef uint16_t mask_t;#endiftypedef uintptr_t cache_key_t;struct bucket_t &#123; cache_key_t _key; IMP _imp;&#125;;struct cache_t &#123; bucket_t *_buckets; mask_t _mask; mask_t _occupied;&#125;;struct entsize_list_tt &#123; uint32_t entsizeAndFlags; uint32_t count;&#125;;struct method_t &#123; SEL name; const char *types; IMP imp;&#125;;struct method_list_t : entsize_list_tt &#123; method_t first;&#125;;struct ivar_t &#123; int32_t *offset; const char *name; const char *type; uint32_t alignment_raw; uint32_t size;&#125;;struct ivar_list_t : entsize_list_tt &#123; ivar_t first;&#125;;struct property_t &#123; const char *name; const char *attributes;&#125;;struct property_list_t : entsize_list_tt &#123; property_t first;&#125;;struct chained_property_list &#123; chained_property_list *next; uint32_t count; property_t list[0];&#125;;typedef uintptr_t protocol_ref_t;struct protocol_list_t &#123; uintptr_t count; protocol_ref_t list[0];&#125;;struct class_ro_t &#123; uint32_t flags; uint32_t instanceStart; uint32_t instanceSize; // instance对象占用的内存空间#ifdef __LP64__ uint32_t reserved;#endif const uint8_t * ivarLayout; const char * name; // 类名 method_list_t * baseMethodList; protocol_list_t * baseProtocols; const ivar_list_t * ivars; // 成员变量列表 const uint8_t * weakIvarLayout; property_list_t *baseProperties;&#125;;struct class_rw_t &#123; uint32_t flags; uint32_t version; const class_ro_t *ro; method_list_t * methods; // 方法列表 property_list_t *properties; // 属性列表 const protocol_list_t * protocols; // 协议列表 Class firstSubclass; Class nextSiblingClass; char *demangledName;&#125;;#define FAST_DATA_MASK 0x00007ffffffffff8ULstruct class_data_bits_t &#123; uintptr_t bits;public: class_rw_t* data() &#123; // 提供data()方法进行 &amp; FAST_DATA_MASK 操作 return (class_rw_t *)(bits &amp; FAST_DATA_MASK); &#125;&#125;;/* OC对象 */struct xx_objc_object &#123; void *isa;&#125;;/* 类对象 */struct xx_objc_class : xx_objc_object &#123; Class superclass; cache_t cache; class_data_bits_t bits;public: class_rw_t* data() &#123; return bits.data(); &#125; xx_objc_class* metaClass() &#123; // 提供metaClass函数，获取元类对象// 上一篇我们讲解过，isa指针需要经过一次 &amp; ISA_MASK操作之后才得到真正的地址 return (xx_objc_class *)((long long)isa &amp; ISA_MASK); &#125;&#125;;#endif /* XXClassInfo_h */ 接下来我们将自己定义的类强制转化为我们自定义的精简的class结构体类型。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#import &lt;Foundation/Foundation.h&gt;#import &lt;objc/runtime.h&gt;#import &quot;XXClassInfo.h&quot;/* Person */@interface Person : NSObject &lt;NSCopying&gt;&#123; @public int _age;&#125;@property (nonatomic, assign) int height;- (void)personMethod;+ (void)personClassMethod;@end@implementation Person- (void)personMethod &#123;&#125;+ (void)personClassMethod &#123;&#125;@end/* Student */@interface Student : Person &lt;NSCoding&gt;&#123; @public int _no;&#125;@property (nonatomic, assign) int score;- (void)studentMethod;+ (void)studentClassMethod;@end@implementation Student- (void)studentMethod &#123;&#125;+ (void)studentClassMethod &#123;&#125;@endint main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; NSObject *object = [[NSObject alloc] init]; Person *person = [[Person alloc] init]; Student *student = [[Student alloc] init]; xx_objc_class *objectClass = (__bridge xx_objc_class *)[object class]; xx_objc_class *personClass = (__bridge xx_objc_class *)[person class]; xx_objc_class *studentClass = (__bridge xx_objc_class *)[student class]; xx_objc_class *objectMetaClass = objectClass-&gt;metaClass(); xx_objc_class *personMetaClass = personClass-&gt;metaClass(); xx_objc_class *studentMetaClass = studentClass-&gt;metaClass(); class_rw_t *objectClassData = objectClass-&gt;data(); class_rw_t *personClassData = personClass-&gt;data(); class_rw_t *studentClassData = studentClass-&gt;data(); class_rw_t *objectMetaClassData = objectMetaClass-&gt;data(); class_rw_t *personMetaClassData = personMetaClass-&gt;data(); class_rw_t *studentMetaClassData = studentMetaClass-&gt;data(); // 0x00007ffffffffff8 NSLog(@&quot;%p %p %p %p %p %p&quot;, objectClassData, personClassData, studentClassData, objectMetaClassData, personMetaClassData, studentMetaClassData); return 0;&#125; 通过打断点，我们可以看到class内部信息。 至此，我们再次拿出那张经典的图，挨个分析图中isa指针和superclass指针的指向 instance对象首先我们来看instance对象，我们通过上一篇文章知道，instance对象中存储着isa指针和其他成员变量，并且instance对象的isa指针是指向其类对象地址的。我们首先分析上述代码中我们创建的object，person，student三个instance对象与其相对应的类对象objectClass，personClass，studentClass。 从上图中我们可以发现instance对象中确实存储了isa指针和其成员变量，同时将instance对象的isa指针经过&amp;运算之后计算出的地址确实是其相应类对象的内存地址。由此我们证明isa，superclass指向图中的1，2，3号线。 class对象接着我们来看class对象，同样通过上一篇文章，我们明确class对象中存储着isa指针，superclass指针，以及类的属性信息，类的成员变量信息，类的对象方法，和类的协议信息，而通过上面对object源码的分析，我们知道这些信息存储在class对象的class_rw_t中，我们通过强制转化来窥探其中的内容。如下图 上图中我们通过模拟对person类对象调用.data函数，即对bits进行&amp;FAST_DATA_MASK(0x00007ffffffffff8UL)运算，并转化为class_rw_t。即上图中的personClassData。其中我们发现成员变量信息，对象方法，属性等信息只显示first第一个，如果想要拿到更多的需要通过代码将指针后移获取。而上图中的instaceSize = 16也同person对象中isa指针8个字节+_age4个字节+_height4个字节相对应起来。这里不在展开对objectClassData及studentClassData进行分析，基本内容同personClassData相同。 那么类对象中的isa指针和superclass指针的指向是否如那张经典的图示呢？我们来验证一下。 通过上图中的内存地址的分析，由此我们证明isa，superclass指向图中，isa指针的4，5，6号线，以及superclass指针的10，11，12号线。 meta-class对象最后我们来看meta-class元类对象，上文提到meta-class中存储着isa指针，superclass指针，以及类的类方法信息。同时我们知道meta-class元类对象与class类对象，具有相同的结构，只不过存储的信息不同，并且元类对象的isa指针指向基类的元类对象，基类的元类对象的isa指针指向自己。元类对象的superclass指针指向其父类的元类对象，基类的元类对象的superclass指针指向其类对象。 与class对象相同，我们同样通过模拟对person元类对象调用.data函数，即对bits进行&amp;FAST_DATA_MASK(0x00007ffffffffff8UL)运算，并转化为class_rw_t。 首先我们可以看到结构同personClassData相同，并且成员变量及属性列表等信息为空，而methods中存储着类方法personClassMethod。 接着来验证isa及superclass指针的指向是否同上图序号标注一样。 上图中通过地址证明meta-class的isa指向基类的meta-class，基类的isa指针也指向自己。 上图中通过地址证明meta-class的superclass指向父类的meta-class，基类的meta-class的superclass指向基类的class类。 最近看到一句话，在这里与大家共勉。当承认自己与别人的差距的时候，会变得很轻松。因为我们终于不用计较为什么他行我不行，终于不用默默努力较劲心里告诉自己一定要超过别人。而同时也失去了斗志，失去了战胜别人得唯一筹码。最怕一生碌碌无为，还安慰自己平凡可贵。 作者：xx_cc链接：https://juejin.im/post/5ad210636fb9a028da7cf90c来源：掘金著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。]]></content>
      <categories>
        <category>principle</category>
      </categories>
      <tags>
        <tag>Class本质</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS底层原理总结 - 探寻OC对象的本质]]></title>
    <url>%2F2018%2F07%2F05%2FiOS%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93-%E6%8E%A2%E5%AF%BBOC%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%9C%AC%E8%B4%A8%2F</url>
    <content type="text"><![CDATA[iOS底层原理总结 - 探寻OC对象的本质对小码哥底层班视频学习的总结与记录。面试题部分，通过对面试题的分析探索问题的本质内容。 面试题：一个NSObject对象占用多少内存？ 探寻OC对象的本质，我们平时编写的Objective-C代码，底层实现其实都是C\C++代码。 OC的对象结构都是通过基础C\C++的结构体实现的。 我们通过创建OC文件及对象，并将OC文件转化为C++文件来探寻OC对象的本质 OC如下代码 12345678910#import &lt;Foundation/Foundation.h&gt;int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; NSObject *objc = [[NSObject alloc] init]; NSLog(@&quot;Hello, World!&quot;); &#125; return 0;&#125; 我们通过命令行将OC的mian.m文件转化为c++文件。 12clang -rewrite-objc main.m -o main.cpp // 这种方式没有指定架构例如arm64架构 其中cpp代表（c plus plus）生成 main.cpp 我们可以指定架构模式的命令行，使用xcode工具 xcrun 12xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m -o main-arm64.cpp 生成 main-arm64.cpp main-arm64.cpp 文件中搜索NSObjcet，可以找到NSObjcet_IMPL（IMPL代表 implementation 实现） 我们看一下NSObject_IMPL内部 123456struct NSObject_IMPL &#123; Class isa;&#125;;// 查看Class本质typedef struct objc_class *Class;我们发现Class其实就是一个指针，对象底层实现其实就是这个样子。 思考： 一个OC对象在内存中是如何布局的。 NSObjcet的底层实现，点击NSObjcet进入发现NSObject的内部实现 1234567@interface NSObject &lt;NSObject&gt; &#123;#pragma clang diagnostic push#pragma clang diagnostic ignored &quot;-Wobjc-interface-ivars&quot; Class isa OBJC_ISA_AVAILABILITY;#pragma clang diagnostic pop&#125;@end 转化为c语言其实就是一个结构体 123struct NSObject_IMPL &#123; Class isa;&#125;; 那么这个结构体占多大的内存空间呢，我们发现这个结构体只有一个成员，isa指针，而指针在64位架构中占8个字节。也就是说一个NSObjec对象所占用的内存是8个字节。到这里我们已经可以基本解答第一个问题。但是我们发现NSObject对象中还有很多方法，那这些方法不占用内存空间吗？其实类的方法等也占用内存空间，但是这些方法所占用的存储空间并不在NSObject对象中。 为了探寻OC对象在内存中如何体现，我们来看下面一段代码 1NSObject *objc = [[NSObject alloc] init]; 上面一段代码在内存中如何体现的呢？上述一段代码中系统为NSObject对象分配8个字节的内存空间，用来存放一个成员isa指针。那么isa指针这个变量的地址就是结构体的地址，也就是NSObjcet对象的地址。 假设isa的地址为0x100400110，那么上述代码分配存储空间给NSObject对象，然后将存储空间的地址赋值给objc指针。objc存储的就是isa的地址。objc指向内存中NSObject对象地址，即指向内存中的结构体，也就是isa的位置。 自定义类的内部实现123456789101112131415161718192021@interface Student : NSObject&#123; @public int _no; int _age;&#125;@end@implementation Studentint main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; Student *stu = [[Student alloc] init]; stu -&gt; _no = 4; stu -&gt; _age = 5; NSLog(@&quot;%@&quot;,stu); &#125; return 0;&#125;@end 按照上述步骤同样生成c++文件。并查找Student，我们发现Student_IMPL 12345struct Student_IMPL &#123; struct NSObject_IMPL NSObject_IVARS; int _no; int _age;&#125;; 发现第一个是 NSObject_IMPL的实现。而通过上面的实验我们知道NSObject_IMPL内部其实就是Class isa 那么我们假设 struct NSObject_IMPL NSObject_IVARS; 等价于 Class isa; 可以将上述代码转化为 12345struct Student_IMPL &#123; Class *isa; int _no; int _age;&#125;; 因此此结构体占用多少存储空间，对象就占用多少存储空间。因此结构体占用的存储空间为，isa指针8个字节空间+int类型_no4个字节空间+int类型_age4个字节空间共16个字节空间 123Student *stu = [[Student alloc] init];stu -&gt; _no = 4;stu -&gt; _age = 5; 那么上述代码实际上在内存中的体现为，创建Student对象首先会分配16个字节，存储3个东西，isa指针8个字节，4个字节的_no ,4个字节的_age sutdent对象的3个变量分别有自己的地址。而stu指向isa指针的地址。因此stu的地址为0x100400110，stu对象在内存中占用16个字节的空间。并且经过赋值，_no里面存储4 ，_age里面存储5 验证Student在内存中模样 123456789101112131415161718192021222324struct Student_IMPL &#123; Class isa; int _no; int _age;&#125;;@interface Student : NSObject&#123; @public int _no; int _age;&#125;@end@implementation Studentint main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; // 强制转化 struct Student_IMPL *stuImpl = (__bridge struct Student_IMPL *)stu; NSLog(@&quot;_no = %d, _age = %d&quot;, stuImpl-&gt;_no, stuImpl-&gt;_age); // 打印出 _no = 4, _age = 5 &#125; return 0;&#125; 上述代码将oc对象强转成Student_IMPL的结构体。也就是说把一个指向oc对象的指针，指向这种结构体。由于我们之前猜想，对象在内存中的布局与结构体在内存中的布局相同，那么如果可以转化成功，说明我们的猜想正确。由此说明stu这个对象指向的内存确实是一个结构体。 实际上想要获取对象占用内存的大小，可以通过更便捷的运行时方法来获取。 123class_getInstanceSize([Student class])NSLog(@&quot;%zd,%zd&quot;, class_getInstanceSize([NSObject class]) ,class_getInstanceSize([Student class]));// 打印信息 8和16 窥探内存结构实时查看内存数据 方式一：通过打断点。 Debug Workflow -&gt; viewMemory address中输入stu的地址 从上图中，我们可以发现读取数据从高位数据开始读，查看前16位字节，每四个字节读出的数据为 16进制 0x0000004(4字节) 0x0000005(4字节) isa的地址为 00D1081000001119(8字节) 方式二：通过lldb指令xcode自带的调试器 12345678910memory read 0x10074c450// 简写 x 0x10074c450// 增加读取条件// memory read/数量格式字节数 内存地址// 简写 x/数量格式字节数 内存地址// 格式 x是16进制，f是浮点，d是10进制// 字节大小 b：byte 1字节，h：half word 2字节，w：word 4字节，g：giant word 8字节示例：x/4xw // /后面表示如何读取数据 w表示4个字节4个字节读取，x表示以16进制的方式读取数据，4则表示读取4次 同时也可以通过lldb修改内存中的值 12memory write 0x100400c68 6将_no的值改为了6 那么一个NSObject对象占用多少内存？ NSObjcet实际上是只有一个名为isa的指针的结构体，因此占用一个指针变量所占用的内存空间大小，如果64bit占用8个字节，如果32bit占用4个字节。 更复杂的继承关系 面试题：在64bit环境下， 下面代码的输出内容？ 123456789101112131415161718192021222324252627282930/* Person */@interface Person : NSObject&#123; int _age;&#125;@end@implementation Person@end/* Student */@interface Student : Person&#123; int _no;&#125;@end@implementation Student@endint main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; NSLog(@&quot;%zd %zd&quot;, class_getInstanceSize([Person class]), class_getInstanceSize([Student class]) ); &#125; return 0;&#125; 这道面试题的实质是想问一个Person对象，一个Student对象分别占用多少内存空间？ 我们依据上面的分析与发现，类对象实质上是以结构体的形式存储在内存中，画出真正的内存图例 我们发现只要是继承自NSObject的对象，那么底层结构体内一定有一个isa指针。 那么他们所占的内存空间是多少呢？单纯的将指针和成员变量所占的内存相加即可吗？上述代码实际打印的内容是16 16，也就是说，person对象和student对象所占用的内存空间都为16个字节。 其实实际上person对象确实只使用了12个字节。但是因为内存对齐的原因。使person对象也占用16个字节。 编译器在给结构体开辟空间时，首先找到结构体中最宽的基本数据类型，然后寻找内存地址能是该基本数据类型的整倍的位置，作为结构体的首地址。将这个最宽的基本数据类型的大小作为对齐模数。 为结构体的一个成员开辟空间之前，编译器首先检查预开辟空间的首地址相对于结构体首地址的偏移是否是本成员的整数倍，若是，则存放本成员，反之，则在本成员和上一个成员之间填充一定的字节，以达到整数倍的要求，也就是将预开辟空间的首地址后移几个字节。 我们可以总结内存对齐为两个原则： 原则 1. 前面的地址必须是后面的地址正数倍,不是就补齐。 原则 2. 整个Struct的地址必须是最大字节的整数倍。 通过上述内存对齐的原则我们来看，person对象的第一个地址要存放isa指针需要8个字节，第二个地址要存放_age成员变量需要4个字节，根据原则一，8是4的整数倍，符合原则一，不需要补齐。然后检查原则2，目前person对象共占据12个字节的内存，不是最大字节数8个字节的整数倍，所以需要补齐4个字节，因此person对象就占用16个字节空间。 而对于student对象，我们知道sutdent对象中，包含person对象的结构体实现，和一个int类型的_no成员变量，同样isa指针8个字节，_age成员变量4个字节，_no成员变量4个字节，刚好满足原则1和原则2，所以student对象占据的内存空间也是16个字节。 OC对象的分类 面试题：OC的类信息存放在哪里。 面试题：对象的isa指针指向哪里。 示例代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#import &lt;Foundation/Foundation.h&gt;#import &lt;objc/runtime.h&gt;/* Person */ @interface Person : NSObject &lt;NSCopying&gt;&#123; @public int _age;&#125;@property (nonatomic, assign) int height;- (void)personMethod;+ (void)personClassMethod;@end@implementation Person- (void)personMethod &#123;&#125;+ (void)personClassMethod &#123;&#125;@end/* Student */@interface Student : Person &lt;NSCoding&gt;&#123; @public int _no;&#125;@property (nonatomic, assign) int score;- (void)studentMethod;+ (void)studentClassMethod;@end@implementation Student- (void)studentMethod &#123;&#125;+ (void)studentClassMethod &#123;&#125;@endint main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; NSObject *object1 = [[NSObject alloc] init]; NSObject *object2 = [[NSObject alloc] init]; Student *stu = [[Student alloc] init]; [Student load]; Person *p1 = [[Person alloc] init]; p1-&gt;_age = 10; [p1 personMethod]; [Person personClassMethod]; Person *p2 = [[Person alloc] init]; p2-&gt;_age = 20; &#125; return 0;&#125; OC的类信息存放在哪里 OC对象主要可以分为三种 instance对象（实例对象） class对象（类对象） meta-class对象（元类对象） instance对象就是通过类alloc出来的对象，每次调用alloc都会产生新的instance对象 12NSObjcet *object1 = [[NSObjcet alloc] init];NSObjcet *object2 = [[NSObjcet alloc] init]; object1和object2都是NSObject的instace对象（实例对象），但他们是不同的两个对象，并且分别占据着两块不同的内存。 instance对象在内存中存储的信息包括 isa指针 其他成员变量 衍生问题：在上图实例对象中根本没有看到方法，那么实例对象的方法的代码放在什么地方呢？那么类的方法的信息，协议的信息，属性的信息都存放在什么地方呢？ class对象 我们通过class方法或runtime方法得到一个class对象。class对象也就是类对象 12345678Class objectClass1 = [object1 class];Class objectClass2 = [object2 class];Class objectClass3 = [NSObject class];// runtimeClass objectClass4 = object_getClass(object1);Class objectClass5 = object_getClass(object2);NSLog(@&quot;%p %p %p %p %p&quot;, objectClass1, objectClass2, objectClass3, objectClass4, objectClass5); 每一个类在内存中有且只有一个class对象。可以通过打印内存地址证明 class对象在内存中存储的信息主要包括 isa指针 superclass指针 类的属性信息（@property），类的成员变量信息（ivar） 类的对象方法信息（instance method），类的协议信息（protocol） 成员变量的值时存储在实例对象中的，因为只有当我们创建实例对象的时候才为成员变赋值。但是成员变量叫什么名字，是什么类型，只需要有一份就可以了。所以存储在class对象中。 类方法放在那里？ 元类对象 meta-class 1234567//runtime中传入类对象此时得到的就是元类对象Class objectMetaClass = object_getClass([NSObject class]);// 而调用类对象的class方法时得到还是类对象，无论调用多少次都是类对象Class cls = [[NSObject class] class];Class objectClass3 = [NSObject class];class_isMetaClass(objectMetaClass) // 判断该对象是否为元类对象NSLog(@&quot;%p %p %p&quot;, objectMetaClass, objectClass3, cls); // 后面两个地址相同，说明多次调用class得到的还是类对象 每个类在内存中有且只有一个meta-class对象。 meta-class对象和class对象的内存结构是一样的，但是用途不一样，在内存中存储的信息主要包括 isa指针 superclass指针 类的类方法的信息（class method） meta-class对象和class对象的内存结构是一样的，所以meta-class中也有类的属性信息，类的对象方法信息等成员变量，但是其中的值可能是空的。 对象的isa指针指向哪里 当对象调用实例方法的时候，我们上面讲到，实例方法信息是存储在class类对象中的，那么要想找到实例方法，就必须找到class类对象，那么此时isa的作用就来了。 1[stu studentMethod]; instance的isa指向class，当调用对象方法时，通过instance的isa找到class，最后找到对象方法的实现进行调用。 当类对象调用类方法的时候，同上，类方法是存储在meta-class元类对象中的。那么要找到类方法，就需要找到meta-class元类对象，而class类对象的isa指针就指向元类对象 1[Student studentClassMethod]; class的isa指向meta-class 当调用类方法时，通过class的isa找到meta-class，最后找到类方法的实现进行调用 当对象调用其父类对象方法的时候，又是怎么找到父类对象方法的呢？，此时就需要使用到class类对象superclass指针。 12[stu personMethod];[stu init]; 当Student的instance对象要调用Person的对象方法时，会先通过isa找到Student的class，然后通过superclass找到Person的class，最后找到对象方法的实现进行调用，同样如果Person发现自己没有响应的对象方法，又会通过Person的superclass指针找到NSObject的class对象，去寻找响应的方法 当类对象调用父类的类方法时，就需要先通过isa指针找到meta-class，然后通过superclass去寻找响应的方法 12[Student personClassMethod];[Student load]; 当Student的class要调用Person的类方法时，会先通过isa找到Student的meta-class，然后通过superclass找到Person的meta-class，最后找到类方法的实现进行调用 最后又是这张静定的isa指向图，经过上面的分析我们在来看这张图，就显得清晰明了很多。 对isa、superclass总结 instance的isa指向class class的isa指向meta-class meta-class的isa指向基类的meta-class，基类的isa指向自己 class的superclass指向父类的class，如果没有父类，superclass指针为nil meta-class的superclass指向父类的meta-class，基类的meta-class的superclass指向基类的class instance调用对象方法的轨迹，isa找到class，方法不存在，就通过superclass找父类 class调用类方法的轨迹，isa找meta-class，方法不存在，就通过superclass找父类 如何证明isa指针的指向真的如上面所说？我们通过如下代码证明： 12345NSObject *object = [[NSObject alloc] init];Class objectClass = [NSObject class];Class objectMetaClass = object_getClass([NSObject class]);NSLog(@&quot;%p %p %p&quot;, object, objectClass, objectMetaClass); 打断点并通过控制台打印相应对象的isa指针 我们发现object-&gt;isa与objectClass的地址不同，这是因为从64bit开始，isa需要进行一次位运算，才能计算出真实地址。而位运算的值我们可以通过下载objc源代码找到。 我们通过位运算进行验证。 我们发现，object-isa指针地址0x001dffff96537141经过同0x00007ffffffffff8位运算，得出objectClass的地址0x00007fff96537140 接着我们来验证class对象的isa指针是否同样需要位运算计算出meta-class对象的地址。 当我们以同样的方式打印objectClass-&gt;isa指针时，发现无法打印 同时也发现左边objectClass对象中并没有isa指针。我们来到Class内部看一下 12345678910111213141516171819typedef struct objc_class *Class;struct objc_class &#123; Class _Nonnull isa OBJC_ISA_AVAILABILITY;#if !__OBJC2__ Class _Nullable super_class OBJC2_UNAVAILABLE; const char * _Nonnull name OBJC2_UNAVAILABLE; long version OBJC2_UNAVAILABLE; long info OBJC2_UNAVAILABLE; long instance_size OBJC2_UNAVAILABLE; struct objc_ivar_list * _Nullable ivars OBJC2_UNAVAILABLE; struct objc_method_list * _Nullable * _Nullable methodLists OBJC2_UNAVAILABLE; struct objc_cache * _Nonnull cache OBJC2_UNAVAILABLE; struct objc_protocol_list * _Nullable protocols OBJC2_UNAVAILABLE;#endif&#125; OBJC2_UNAVAILABLE;/* Use `Class` instead of `struct objc_class *` */ 相信了解过isa指针的同学对objc_class结构体内的内容很熟悉了，今天这里不深入研究，我们只看第一个对象是一个isa指针，为了拿到isa指针的地址，我们自己创建一个同样的结构体并通过强制转化拿到isa指针。 1234567struct xx_cc_objc_class&#123; Class isa;&#125;;Class objectClass = [NSObject class];struct xx_cc_objc_class *objectClass2 = (__bridge struct xx_cc_objc_class *)(objectClass); 此时我们重新验证一下 确实，objectClass2的isa指针经过位运算之后的地址是meta-class的地址。 本文面试题总结： 一个NSObject对象占用多少内存？ 答：一个指针变量所占用的大小（64bit占8个字节，32bit占4个字节） 对象的isa指针指向哪里？ 答：instance对象的isa指针指向class对象，class对象的isa指针指向meta-class对象，meta-class对象的isa指针指向基类的meta-class对象，基类自己的isa指针也指向自己。 OC的类信息存放在哪里？ 答：成员变量的具体值存放在instance对象。对象方法，协议，属性，成员变量信息存放在class对象。类方法信息存放在meta-class对象。 作者：xx_cc链接：https://juejin.im/post/5ac81c75518825556534c0af来源：掘金著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。]]></content>
      <categories>
        <category>principle</category>
      </categories>
      <tags>
        <tag>Object本质</tag>
        <tag>isa</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[WWDC2018] - 图像最佳实践 Image and Graphics Best Practices]]></title>
    <url>%2F2018%2F06%2F21%2FWWDC2018-%E5%9B%BE%E5%83%8F%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-Image-and-Graphics-Best-Practices%2F</url>
    <content type="text"><![CDATA[Image and Graphics Best Practices目录1.UIImage and UIImageView2.Custom drawing with UIKit3.Advanced CPU and GPU4.总结 1. UIImage and UIImageView1.1 渲染的过程 在经典的MVC框架中，UIImage扮演Model的角色，UIImageView则充当View，UIImage用于加载图片内容，UIImageView负责将图片内容渲染和显示，看似单向逻辑关系，但实际上为了衡量应用程序的性能，我们必须关注隐藏的Decode环节，如下图所示。但在讨论Decode环节前，我们得先明确buffers的概念。 1.2 Buffersimagebuffer中的每一个元素描述的是一个像素的颜色信息，buffer的size与图片的size为正相关关系。imagebuffer的一个典型例子便是framebuffer，framebuffer真正管理着屏幕的输出。 在应用程序更新图层时，UIKit将window及其subviews渲染至framebuffer，这个framebuffer提供每个像素的信息以供显示硬件定时读取，读取的频率一般为60Hz，但在ipad上可提升至120Hz。 与imagebuffer不同，Data Buffer存储着一个图片文件的内容，通常为JPG,PNG等压缩格式，因此其内容不是直接与像素的信息一一对应。metadata存储着图片的尺寸。 1.3 Decode过程 明确了buffers的概念后，我们便理解了Decode环节存在的必要性。如上图所示，在实际的渲染过程中，UIImage负责解压Data Buffer内容并申请buffer（Image Buffer）存储解压后的图片信息，然后UIImageView负责将Image Buffer 拷贝至 framebuffer，用于给显示硬件提供颜色信息。 解压过程是一个大量占用CPU资源的工作，因此UIImage 会retain存储解压后信息的Image Buffer以便给重复的渲染工作提供信息，Image Buffer与图片的实际尺寸有关（理论值为height width 4 bytes），与图片文件大小无关。若是在TableView等列表中连续加载多张图片，便会引发连续的大块内存分配，这将对Memory和CPU带来沉重的负担。 1.4 DownSampling DownSampling即在Decode前插入创建缩略图的过程。如下图所示，即对image进行预处理，采用缩小解码后Image Buffer的size的方式，减少内存的占用。此处需注意两个选项的设置。1.kCGImageSourceShouldCache此处设为false，目的在于告知系统此imageSource仅为建立与imageURL的链接，不需要解码。2.kCGImageSourceShouldCacheImmediately设为true，以此控制系统以计算出的size创建Image Buffer并解压。 经过此预处理过程后，内存占用的前后对比如下： 但正如Decode部分的介绍，解压是一个CPU密集型工作，如果在主线程中做同步解压，会导致主线程卡顿，影响用户的使用体验。因此使用Downsampling的正确姿势如下： 此处通过两种手段解决主线程卡顿的问题：1. 预取.2. 异步解码.异步解码需注意，不用通过dispatch至global queue中，可能会导致 thread explosion的问题。 1.5 Image Source推荐使用Image Assets，主要有如下几点原因:1.对基于名字和特性的查找做了优化.2.更加智能的缓存策略.3.针对设备选择相应的图片.4.支持矢量图.从iOS11之后，Image Assets支持 Preserve Vector Data 选项，系统会在compile过程保留矢量图信息，以防止图片渲染至超出或小于自身尺寸的view中引发的模糊问题。 2. Custom drawing with UIKit2.1 Custom drawing以如下live按钮的实现为例： 一解决方案如下： 在说明这种解决方案的优劣前，我们先来说明重写draw：函数后，系统渲染的过程： 众所周知，UIView背后的CALayer负责将contents传递给framebuffer，当重写draw：函数后，CALayer会负责创建一个Backing Store（尺寸与view显示的size成正相关），然后在此Backing store上执行draw：函数，最后将其中的内容传递给framebuffer。 我们可以通过设置CALayer的contentsFormat（指明是否需要支持wide range color）来控制Backing Store中每个元素的大小，但在iOS12中，系统对wide range color做了优化，如需要，可自动增加buffer的size以支持。 因此为了减少Backing Store的使用，针对live按钮的实现，我们应该将大的view化为多个subview的组合，减少draw：函数的使用减少imageData的多重拷贝（在给出的解决方案中，会将image ‘draw at’ Backing store，多了一次imageData的拷贝动作），使用优化的选项和属性（UIView的backgroundColor属性可以不通过Backing store直接渲染至framebuffer。但pattern color例外，可用添加imageview为subview代替）。 2.2 背景的实现UIView的maskView 及CALayer.maskLayer都会将图层渲染到临时的image buffer中，而CALayer.cornerRadius不需要。对于live按钮的背景实现，不要用maskView，以UIImageView+Resizable的方式解决。 2.3 图片的实现UIImageView在渲染时可直接对单色图片着色，设置tint color来改变单色图片的颜色从而达到复用图片的目的。 2.4 文字的实现UILabel对单色的string做了优化处理，可节省75%的Backing Store，并能自动更新Backing Store的size以适配富文本或emoji。至此，live按钮的实现方案应如下。 3. Advanced CPU and GPU此sessions对这一部分仅做了简单的描述。 3.1 Advanced Image Effects 对图片进行实时处理时考虑使用Core Image 使用GPU处理，解放CPU UIImageView 可有效地处理CIImage 3.2 Advanced Image Processing 使用CVPixelBuffer在Metal，Vision，Accelerate框架之间传递数据 不要重复已经做过的工作 不要将工作在CPU和GPU间来回传递 确保给Accelerate传递正确的buffer格式 4. 总结 采用预取和异步decode的方式 使用UIImageView 和 UILabel来减少Backing Store 不要无意中关闭了custom draw中系统尝试做的优化 推荐使用 Image Assets 不要过度依赖Preserve Vector DataP 本文转载自今日头条技术博客作者：今日头条技术博客链接：https://techblog.toutiao.com/2018/06/19/untitled-42/著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。]]></content>
      <categories>
        <category>graphic</category>
      </categories>
      <tags>
        <tag>WWDC2018</tag>
        <tag>Rendering</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Runtime的运用和减少应用崩溃]]></title>
    <url>%2F2018%2F06%2F08%2FRuntime%E7%9A%84%E8%BF%90%E7%94%A8%E5%92%8C%E5%87%8F%E5%B0%91%E5%BA%94%E7%94%A8%E5%B4%A9%E6%BA%83%2F</url>
    <content type="text"><![CDATA[Objective-C 是一个动态语言，它需要一个运行时系统来动态的创建类和对象、进行消息传递和转发。关于Runtime的知识大家可以参看Apple开源的Runtime代码 和Rumtime编程指南 。 本文总结一些其常用的方法。 一、新建测试Demo我们先创建一个测试Demo如下图，其中TestClass是一个测试类，TestClass+Category是它的一个分类，NSObject+Runtime封装了一些Runtime的方法。大家可以在这里下载Demo。 Demo 下面是几个类的主要部分： TestClass.h TestClass.m TestClass+Category.h TestClass+Category.m 二、Runtime的封装接下来我们就来看看NSObject+Runtime中的内容，其对Runtime常用的方法进行了简单的封装： Paste_Image.png 别着急，我们一个一个看。 1、获取成员变量下面这个方法就是获取类的成员变量列表，其中包括属性生成的成员变量。我们可以用ivar_getTypeEncoding()来获取成员变量的类型，用ivar_getName()来获取成员变量的名称： 12345678910111213141516171819+ (NSArray *)fetchIvarList&#123; unsigned int count = 0; Ivar *ivarList = class_copyIvarList(self, &amp;count); NSMutableArray *mutableList = [NSMutableArray arrayWithCapacity:count]; for (unsigned int i = 0; i &lt; count; i++ ) &#123; NSMutableDictionary *dic = [NSMutableDictionary dictionaryWithCapacity:2]; const char *ivarName = ivar_getName(ivarList[i]); const char *ivarType = ivar_getTypeEncoding(ivarList[i]); dic[@"type"] = [NSString stringWithUTF8String: ivarType]; dic[@"ivarName"] = [NSString stringWithUTF8String: ivarName]; [mutableList addObject:dic]; &#125; free(ivarList); return [NSArray arrayWithArray:mutableList];&#125; 使用[TestClass fetchIvarList]方法获取TestClass类的成员变量结果： TestClass的成员变量列表 2、获取属性列表下面这个方法获取的是属性列表，包括私有和公有属性，也包括分类中的属性： 1234567891011121314+ (NSArray *)fetchPropertyList&#123; unsigned int count = 0; objc_property_t *propertyList = class_copyPropertyList(self, &amp;count); NSMutableArray *mutableList = [NSMutableArray arrayWithCapacity:count]; for (unsigned int i = 0; i &lt; count; i++) &#123; const char *propertyName = property_getName(propertyList[i]); [mutableList addObject:[NSString stringWithUTF8String:propertyName]]; &#125; free(propertyList); return [NSArray arrayWithArray:mutableList];&#125; 使用[TestClass fetchPropertyList]获取TestClass的属性列表结果: TestClass的属性列表 3、获取实例方法下面这个方法就是获取类的实例方法列表，包括getter, setter, 分类中的方法等： 123456789101112131415+ (NSArray *)fetchInstanceMethodList&#123; unsigned int count = 0; Method *methodList = class_copyMethodList(self, &amp;count); NSMutableArray *mutableList = [NSMutableArray arrayWithCapacity:count]; for (unsigned int i = 0; i &lt; count; i++) &#123; Method method = methodList[i]; SEL methodName = method_getName(method); [mutableList addObject:NSStringFromSelector(methodName)]; &#125; free(methodList); return [NSArray arrayWithArray:mutableList];&#125; 使用[TestClass fetchInstanceMethodList]获取TestClass的实例方法列表的结果： TestClass实例方法列表 4、获取类方法列表下方这个方法就是获取类的类方法列表： 123456789101112131415+ (NSArray *)fetchClassMethodList&#123; unsigned int count = 0; Method *methodList = class_copyMethodList(object_getClass(self), &amp;count); NSMutableArray *mutableList = [NSMutableArray arrayWithCapacity:count]; for (unsigned int i = 0; i &lt; count; i++) &#123; Method method = methodList[i]; SEL methodName = method_getName(method); [mutableList addObject:NSStringFromSelector(methodName)]; &#125; free(methodList); return [NSArray arrayWithArray:mutableList];&#125; 使用[TestClass fetchClassMethodList]获取TestClass的类方法列表的结果： TestClass类方法列表 5、获取协议列表下面是获取类所遵循协议列表的方法： 123456789101112131415+ (NSArray *)fetchProtocolList&#123; unsigned int count = 0; __unsafe_unretained Protocol **protocolList = class_copyProtocolList(self, &amp;count); NSMutableArray *mutableList = [NSMutableArray arrayWithCapacity:count]; for (unsigned int i = 0; i &lt; count; i++ ) &#123; Protocol *protocol = protocolList[i]; const char *protocolName = protocol_getName(protocol); [mutableList addObject:[NSString stringWithUTF8String:protocolName]]; &#125; return [NSArray arrayWithArray:mutableList];&#125; 使用[TestClass fetchProtocolList]获取TestClass类所遵循的协议列表的结果： TestClass的协议列表 6、给类添加一个方法下面的方法就是给类添加方法。第一个参数是方法的SEL，第二个参数则是提供方法实现的SEL。这个可以用在找不到某个方法时就添加一个，不然有可能会崩溃。详见Demo。 1234567+ (void)addMethod:(SEL)methodSel methodImp:(SEL)methodImp;&#123; Method method = class_getInstanceMethod(self, methodImp); IMP methodIMP = method_getImplementation(method); const char *types = method_getTypeEncoding(method); class_addMethod(self, methodSel, methodIMP, types);&#125; 7、交换实例方法下面的方法就是将类的两个实例方法进行交换。如果将originMethod与currentMethod的方法实现进行交换的话，调用originMethod时就会执行currentMethod的内容。详见Demo。 123456+ (void)swapMethod:(SEL)originMethod currentMethod:(SEL)currentMethod;&#123; Method firstMethod = class_getInstanceMethod(self, originMethod); Method secondMethod = class_getInstanceMethod(self, currentMethod); method_exchangeImplementations(firstMethod, secondMethod);&#125; 8、交换类方法下面的方法就是将类的两个类方法进行交换，与交换实例方法类似，详见Demo。 123456+ (void)swapClassMethod:(SEL)originMethod currentMethod:(SEL)currentMethod;&#123; Method firstMethod = class_getClassMethod(self, originMethod); Method secondMethod = class_getClassMethod(self, currentMethod); method_exchangeImplementations(firstMethod, secondMethod);&#125; 三、利用Runtime减少应用崩溃利用交换方法可以减少程序中的崩溃，例如数组越界等等。demo里面的Safe文件夹就是一些防止崩溃的分类，直接放进工程就可以了。 Safe 补充：如果有键盘推到后台崩溃的话，需要到build phase里给NSArray+Safe.m文件加上-fno-objc-arc标识。 我们看一个例子，其他的大家可以去demo里面看。 我们首先把__NSArrayI的objectAtIndex方法换成我们的ls_objectAtIndex，然后方法里面判断但是否越界，是的话直接返回nil： 12345678910[NSClassFromString(@"__NSArrayI") swapMethod:@selector(objectAtIndex:) currentMethod:@selector(ls_objectAtIndex:)];- (id)ls_objectAtIndex:(NSUInteger)index&#123; if (index &gt;= [self count]) &#123; return nil; &#125; return [self ls_objectAtIndex:index];&#125; 然后当我们想下面这样写的时候就不会崩溃了： 12NSArray *array = @[@"aa",@"ddd"];array[5]; 好了，先说到这里吧。大家可以下载我的demo详细看一下。 作者：iOS_小松哥链接：https://www.jianshu.com/p/35971a7e8bf6來源：简书著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>runtime</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[老司机 iOS 周报 #20 | 2018-05-21]]></title>
    <url>%2F2018%2F05%2F25%2F%E8%80%81%E5%8F%B8%E6%9C%BA-iOS-%E5%91%A8%E6%8A%A5-20-2018-05-21%2F</url>
    <content type="text"><![CDATA[老司机 iOS 周报，只为你呈现有价值的信息。 你也可以为这个项目出一份力，如果发现有价值的信息、文章、工具等可以到 Issues 里提给我们，我们会尽快处理。记得写上推荐的理由哦。有建议和意见也欢迎到 Issues 提出。 ##专栏 ###再谈 iOS App Crash 防护我们老司机 iOS 专栏内最新出炉的一篇文章。作者分析了几种可能的 Crash 防护方案，并结合自己实践网易 Baymax 防护方案中遇到的各种问题，给出了解决方法，也提出了自己对这套方案的一些思考。 ##新闻 ###MongoDB 官方提供对 Swift 原生支持MongoDB是一个基于分布式文件存储的开源数据库系统。现在官方在 C 驱动(libmongoc)的基础上，用 Swift 进行封装，提供 Pure Swift 驱动。这或许表明 Server-side Swift 越来越成熟，期待不久的将来能看到大规模应用。 ##文章 ###关于 MVC 的一个常见的误用如何避免把 Model View Controller 写成 Massive View Controller 已经是老生常谈的问题了。我们可以通过 MVVM , Reactive 模式或 Reducer 模式等进行优化改造。但比起模式和框架，更重要的是认识到解决的问题本质在于：我们要如何才能更清晰地管理“用户操作，模型变更，UI 反馈”这一数据流动的方式。本文则是通过一个简单的 To Do 列表来阐述如何清晰地管理数据流动。 ###Flutter 原理简解Flutter 可以说是近期最热门的一个开发框架了，上周已经推过一篇 Flutter UI 绘制流程的文章，本篇文章也 cover 了一部分绘制的流程，不过与之前 focus 在 layout 环节不同, 本篇文章的渲染部分主要讲解了 Flutter 是如何通过 Skia 框架将 layout 之后的元素提交给 GPU 进行绘制。 除此之外，文章还分析了 Flutter 引擎的组件架构以及一些安装配置教学。简单来说有用的内容不少，不过结构有点乱，看起来略费劲。（逃。。 ###『如何使用现代的 App 工程与架构的技术来构建我们的 App』系列文章How to refactor your app to add unit testsHow to add CocoaPods to your projectHow to clean up your code formatting with SwiftLintHow to streamline your development with Fastlane上述四篇是一个系列文章， 围绕一个核心问题来讲述：如何使用现代的 App 工程与架构的技术来构建我们的 App。不得不说作者写的是很良心的，整体文风对新手都很友好而且做到了循序渐进、抽丝剥茧的叙事逻辑，是不可多得的项目教程。系列文章从一个普通的、设计缺乏考量的 demo 工程开始，首先为其添加了单元测试框架的支持，然后整合了 CocoaPods 来管理第三方的依赖，引入了 SwiftLint 来对代码进行静态检查，最终介绍了如何配置 Fastlane 来把传统打包提审流程中最繁琐的截屏步骤给自动化。基本涵盖了现在的 iOS App 项目的核心工程要素，尤其适合小公司的“多面手”型工程师阅读。 ###Tips for using Xcode Playground虽然 Xcode Playground 老爱崩溃，但 Playground 的确很适合测试一小段代码。文章介绍如何设置手动运行，来降低 Playground 的 CPU 使用率及崩溃率，以及如何为手动运行添加⌘R快捷键。另外 Playground 在最后一行代码执行完毕之后就会立即停止，并不会等待还没有执行的异步回调，可以设置停止方式为手动停止，或者代码来控制停止。 ###Running Xcode Playgrounds on Travis CIPlaygrounds 是一个很好的展示代码的方式。Mattt 新写的 Guide to Codable 就是基于 Playgrounds 去传递他的想法。而他为了解决及时发现自己的代码还是否适配最新的 Swift 版本和 SDK 版本，借助了 Travis CI 自动的去检查版本的适配。 ###TouchID 和 FaceID 实战使用的一些经验LocalAuthentication虽然只有LAContext一个 class，但并不代表清晰好用，其文档不够清晰甚至有错误。作者在实际 App 中使用过LocalAuthentication之后列出了文档的一些错误并给出了许多最佳实践。 ###手机京东技术团队对iOS自动化埋点探索客户端埋点是产品分析用户数据的重要途径，常见的埋点方式有以下三种：代码埋点，最直接的手动埋点方式，由开发人员完成；可视化埋点，本文将会介绍的方式，可由埋点维护人员自行完成；无埋点，相当于全埋点，网易 HubbleData 中有使用到。本文整体介绍可视化埋点的使用方式和技术细节，另外针对可视化埋点中遇到的问题，尝试给出解决方案和并提出了一些思考。 ###如何在实现类似于 rx 的命名空间大家应该在 Kingfisher 和 RxSwift 这些库里见过kf和rx的命名空间，刚开始用的时候会觉得有点陌生，但习惯之后就会理解这是一种多么优雅的代码组织方式，这篇文章会一步一步教大家如何实现这样的命名空间。如果觉得英文阅读比较困难的同学，也可以考虑一下看 Enjoy 的 iOS 工程师写的这篇博文 Swift 命名空间形式扩展的实现。 ###监控启动崩溃一套监控启动闪退的方案，与以前通过检测 App 在某段时间后是否仍然存活的方式相比，这套方案的检测时机更加提前，通过 hookmsg_send函数实现，并且自己处理了 crash 后的日志上报功能。 ##代码 ###ParadeParade 是一个简单易用的视差效果引擎，适用于基于 UIScrollView 任何视图。除了简单易用以外，Parade 的源码和示例代码质量都很高，是一个不错的 Swift 开源库。 ###ClassicKit一套 Windows 95 风格的 UI 样式库。比较有意思的是它支持@IBDesignable，这样就可以在 Xib 或者 Storyboard 中直接查看效果。 ##工具 ###Scheduling Services一个微型 Swift 计划服务框架，基于 NSNotification 实现，用于计划未来（重复的）事件。使用 Codable 持久化任务内容，支持存储和恢复事件状态，API 简单、清晰。 ###Catching smiles with Google’s ML Kit on iOSGoogle I/O 大会推出了谷歌的全新移动端机器学习框架 MLKit，可以实现在本地跑机器学习模型的能力，各方面都很像苹果已经推出的 CoreML 框架。这篇文章教大家如何使用 MLKit，包括设置 Firebase 服务，然后在 iOS 上进行代码开发，实现了一个对照片进行微笑检测的功能。 ##关注我们我们开通了公众号，每期发布时公众号会推送消息，欢迎关注。同时也支持了 RSS 订阅：https://github.com/SwiftOldDriver/iOS-Weekly/wiki.atom 。 ##本期编辑@没故事的卓同学，@四娘，@mmoaay，@享耳先森，@Damonwong，@折腾范儿_味精，@张嘉夫，@AidenRao，@Parsifal，@aaaron7，@方秋枋 作者：老司机iOS周报链接：https://juejin.im/post/5b0248b5518825429c598309来源：掘金著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。]]></content>
      <categories>
        <category>swiftOldDriver</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP和HTTPS详解]]></title>
    <url>%2F2018%2F05%2F17%2FHTTP%E5%92%8CHTTPS%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[计算机通信原理互联网的关键技术就是TCP/IP协议。两台计算机之间的通信是通过TCP/IP协议在因特网上进行的。实际上这个是两个协议： TCP: Transmission Control Protocol 传输控制协议 IP: Internet Protocol 网际协议。 引自维基百科TCP/IP协议族是一个网络通信模型，以及一整个网络传输协议家族，为互联网的基础通信架构。该协议家族的两个核心协议：TCP（传输控制协议）和IP（网际协议），为该家族中最早通过的标准。这个协议族由互联网工程任务组负责维护。 TCP: 应用程序之间的通信TCP确保数据包以正确的次序到达，并且尝试确认数据包的内容没有改变。TCP在IP地址之上引端口（port），它允许计算机通过网络提供各种服务。一些端口号为不同的服务保留，而且这些端口号是众所周知。 服务或者守护进程：在提供服务的机器上，有程序监听特定端口上的通信流。例如大多数电子邮件通信流出现在端口25上，用于wwww的HTTP通信流出现在80端口上。 当应用程序希望通过 TCP 与另一个应用程序通信时，它会发送一个通信请求。这个请求必须被送到一个确切的地址。在双方“握手”之后，TCP 将在两个应用程序之间建立一个全双工 (full-duplex) 的通信，占用两个计算机之间整个的通信线路。TCP 用于从应用程序到网络的数据传输控制。TCP 负责在数据传送之前将它们分割为 IP 包，然后在它们到达的时候将它们重组。 TCP/IP 就是TCP 和 IP 两个协议在一起协同工作，有上下层次的关系。 TCP 负责应用软件（比如你的浏览器）和网络软件之间的通信。IP 负责计算机之间的通信。TCP 负责将数据分割并装入 IP 包，IP 负责将包发送至接受者，传输过程要经IP路由器负责根据通信量、网络中的错误或者其他参数来进行正确地寻址，然后在它们到达的时候重新组合它们。 IP: 计算机之间的通信IP协议是计算机用来相互识别的通信的一种机制，每台计算机都有一个IP.用来在internet上标识这台计算机。 IP 负责在因特网上发送和接收数据包。通过 IP，消息（或者其他数据）被分割为小的独立的包，并通过因特网在计算机之间传送。IP 负责将每个包路由至它的目的地。 IP协议仅仅是允许计算机相互发消息，但它并不检查消息是否以发送的次序到达而且没有损坏（只检查关键的头数据）。为了提供消息检验功能，直接在IP协议上设计了传输控制协议TCP。 HTTPHTTP概念 引自维基百科HTTP:超文本传输协议（英文：HyperText Transfer Protocol，缩写：HTTP）是一种用于分布式、协作式和超媒体信息系统的应用层协议。HTTP是万维网的数据通信的基础。 设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。通过HTTP或者HTTPS协议请求的资源由统一资源标识符（Uniform Resource Identifiers，URI）来标识。 HTTP协议层HTTP（HyperText Transfer Protocol），超文本传输协议，是一个基于TCP实现的应用层协议。 HTTP请求响应模型HTTP由请求和响应构成，是一个标准的客户端服务器模型（B/S）。HTTP协议永远都是客户端发起请求，服务器回送响应。见下图: HTTP是一个无状态的协议。无状态是指客户机（Web浏览器）和服务器之间不需要建立持久的连接，这意味着当一个客户端向服务器端发出请求，然后服务器返回响应(response)，连接就被关闭了，在服务器端不保留连接的有关信息.HTTP遵循请求(Request)/应答(Response)模型。客户机（浏览器）向服务器发送请求，服务器处理请求并返回适当的应答。所有HTTP连接都被构造成一套请求和应答。 HTTP工作过程一次HTTP操作称为一个事务，其工作整个过程如下： 地址解析如用客户端浏览器请求这个页面：http://localhost.com:8080/index.htm 从中分解出协议名、主机名、端口、对象路径等部分，对于我们的这个地址，解析得到的结果如下： 1234协议名：http主机名：localhost.com端口：8080对象路径：/index.htm 在这一步，需要域名系统DNS解析域名localhost.com,得主机的IP地址。 封装HTTP请求数据包把以上部分结合本机自己的信息，封装成一个HTTP请求数据包 封装成TCP包，建立TCP连接（TCP的三次握手）在HTTP工作开始之前，客户机（Web浏览器）首先要通过网络与服务器建立连接，该连接是通过TCP来完成的，该协议与IP协议共同构建Internet，即著名的TCP/IP协议族，因此Internet又被称作是TCP/IP网络。HTTP是比TCP更高层次的应用层协议，根据规则，只有低层协议建立之后才能，才能进行更层协议的连接，因此，首先要建立TCP连接，一般TCP连接的端口号是80。这里是8080端口。 客户机发送请求命令建立连接后，客户机发送一个请求给服务器，请求方式的格式为：统一资源标识符（URL）、协议版本号，后边是MIME信息包括请求修饰符、客户机信息和可内容。 服务器响应服务器接到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是MIME信息包括服务器信息、实体信息和可能的内容。 实体消息是服务器向浏览器发送头信息后，它会发送一个空白行来表示头信息的发送到此为结束，接着，它就以Content-Type应答头信息所描述的格式发送用户所请求的实际数据 服务器关闭TCP连接一般情况下，一旦Web服务器向浏览器发送了请求数据，它就要关闭TCP连接，然后如果浏览器或者服务器在其头信息加入了这行代码 1Connection:keep-alive TCP连接在发送后将仍然保持打开状态，于是，浏览器可以继续通过相同的连接发送请求。保持连接节省了为每个请求建立新连接所需的时间，还节约了网络带宽。 HTTP工作过程用到的概念报文格式HTTP1.0的报文有两种类型：请求和响应。其报文格式分别为： 请求报文格式1234请求方法 URL HTTP/版本号请求首部字段(可选)空行body(只对Post请求有效) 例如： 123456GET http://m.baidu.com/ HTTP/1.1Host m.baidu.comConnection Keep-Alive...// 其他headerkey=iOS 响应报文格式1234HTTP/版本号 返回码 返回码描述应答首部字段(可选)空行body 例如： 12345HTTP/1.1 200 OKContent-Type text/html;charset=UTF-8...// 其他header&lt;html&gt;... URL的结构使用HTTP协议访问资源是通过URL（Uniform Resource Locator）统一资源定位符来实现的。URL的格式如下： 123456789scheme://host:port/path?queryscheme: 表示协议，如Http, Https, Ftp等；host: 表示所访问资源所在的主机名：如：www.baidu.com;port: 表示端口号，默认为80；path: 表示所访问的资源在目标主机上的储存路径；query: 表示查询条件；例如： http://www.baidu.com/search?words=Baidu HTTP的请求方法12345678GET: 获取URL指定的资源；POST：传输实体信息PUT：上传文件DELETE：删除文件HEAD：获取报文首部，与GET相比，不返回报文主体部分OPTIONS：询问支持的方法TRACE：追踪请求的路径；CONNECT：要求在与代理服务器通信时建立隧道，使用隧道进行TCP通信。主要使用SSL和TLS将数据加密后通过网络隧道进行传输。 报文字段HTTP首部字段由字段名和字段值组成，中间以”:”分隔，如Content-Type: text/html.其中，同一个字段名可对应多个字段值。 HTTP的报文字段分为5种： 请求报文字段 应答报文字段 实体首部字段 通用报文字段 其他报文字段 请求报文字段HTTP请求中支持的报文字段。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667Accept：客户端能够处理的媒体类型。如text/html, 表示客户端让服务器返回html类型的数据，如果没有，返回text类型的也可以。媒体类型的格式一般为：type/subType, 表示优先请求subType类型的数据，如果没有，返回type类型数据也可以。常见的媒体类型：文本文件：text/html, text/plain, text/css, application/xml图片文件：iamge/jpeg, image/gif, image/png;视频文件：video/mpeg应用程序使用的二进制文件：application/octet-stream, application/zipAccept字段可设置多个字段值，这样服务器依次进行匹配，并返回最先匹配到的媒体类型，当然，也可通过q参数来设置媒体类型的权重，权重越高，优先级越高。q的取值为[0, 1], 可取小数点后3位，默认为1.0。例如：Accept: text/html, application/xml; q=0.9, */*Accept-Charset: 表示客户端支持的字符集。例如：Accept-Charset: GB2312, ISO-8859-1Accept-Encoding： 表示客户端支持的内容编码格式。如：Accept-Encoding：gzip常用的内容编码：gzip: 由文件压缩程序gzip生成的编码格式；compress: 由Unix文件压缩程序compress生成的编码格式；deflate: 组合使用zlib和deflate压缩算法生成的编码格式；identity：默认的编码格式，不执行压缩。Accept-Language：表示客户端支持的语言。如：Accept-Language: zh-cn, enAuthorization：表示客户端的认证信息。客户端在访问需要认证的也是时，服务器会返回401，随后客户端将认证信息加在Authorization字段中发送到服务器后，如果认证成功，则返回200. 如Linux公社下的Ftp服务器就是这种流程：ftp://ftp1.linuxidc.com。Host: 表示访问资源所在的主机名，即URL中的域名部分。如：m.baidu.comIf-Match: If-Match的值与所请求资源的ETag值（实体标记，与资源相关联。资源变化，实体标记跟着变化）一致时，服务器才处理此请求。If-Modified-Since: 用于确认客户端拥有的本地资源的时效性。 如果客户端请求的资源在If-Modified-Since指定的时间后发生了改变，则服务器处理该请求。如：If-Modified-Since:Thu 09 Jul 2018 00:00:00, 表示如果客户端请求的资源在2018年1月9号0点之后发生了变化，则服务器处理改请求。通过该字段我们可解决以下问题：有一个包含大量数据的接口，且实时性较高，我们在刷新时就可使用改字段，从而避免多余的流量消耗。If-None-Match: If-Match的值与所请求资源的ETag值不一致时服务器才处理此请求。If-Range： If-Range的值（ETag值或时间）与所访问资源的ETag值或时间相一致时，服务器处理此请求，并返回Range字段中设置的指定范围的数据。如果不一致，则返回所有内容。If-Range其实算是If-Match的升级版，因为它的值不匹配时，依然能够返回数据，而If-Match不匹配时，请求不会被处理，需要数据时需再次进行请求。If-Unmodified-Since：与If-Modified-Since相反，表示请求的资源在指定的时间之后未发生变化时，才处理请求，否则返回412。Max-Forwards：表示请求可经过的服务器的最大数目，请求每被转发一次，Max-Forwards减1，当Max-Forwards为0时，所在的服务器将不再转发，而是直接做出应答。通过此字段可定位通信问题，比如之前支付宝光纤被挖断，就可通过设置Max-Forwards来定位大概的位置。Proxy-Authorization：当客户端接收到来自代理服务器的认证质询时，客户端会将认证信息添加到Proxy-Authorization来完成认证。与Authorization类似，只不过Authorization是发生在客户端与服务端之间。Range：获取部分资源，例如：Range: bytes=500-1000表示获取指定资源的第500到1000字节之间的内容，如果服务器能够正确处理，则返回206作为应答，表示返回了部分数据，如果不能处理这种范围请求，则以200作为应答，返回完整的数据，Referer：告知服务器请求是从哪个页面发起的。例如在百度首页中搜索某个关键字，结果页面的请求头部就会有这个字段，其值为https://www.baidu.com/。通过这个字段可统计广告的点击情况。User-Agent：将发起请求的浏览器和代理名称等信息发送给服务端，例如：User-Agent: Mozilla/5.0 (Linux; Android 5.0; SM-G900P Build/LRX21T) AppleWebKit/537.36(KHTML, like Gecko) Chrome/63.0.3239.84 Mobile Safari/537.36 应答报文字段HTTP应答中支持的报文字段。 1234567891011121314151617表示不能处理。Age：服务端告知客户端，源服务器（而不是缓存服务器）在多久之前创建了响应。单位为秒。ETag： 实体资源的标识，可用来请求指定的资源。Location：请求的资源所在的新位置。Proxy-Authenticate：将代理服务器需要的认证信息发送给客户端。Retry-After：服务端告知客户端多久之后再重试，一般与503和3xx重定向类型的应答一起使用。Server：告知服务端当前使用的HTTP服务器应用程序的相关信息。WWW-Authenticate：告知客户端适用于所访问资源的认证方案，如Basic或Digest。401的响应中肯定带有WWW-Authenticate字段。 实体首部字段12345678910111213141516Allow：通知客户端，服务器所支持的请求方法。但服务器收到不支持的请求方法时，会以405（Method Not Allowed）作为响应。Content-Encoding：告知客户端，服务器对资源的内容编码。Content-Language：告知客户端，资源所使用的自然语言。Content-Length：告知客户端资源的长度Content-Location：告知客户端资源所在的位置。Content-Type：告知客户端资源的媒体类型，取值同请求首部字段中的Accept。Expires：告知客户端资源的失效日期。可用于对缓存的处理。Last-Modified：告知客户端资源最后一次修改的时间。 通用报文字段即可在HTTP请求中使用，也可在HTTP应答中使用的报文字段。 12345678910111213141516Cache-Control：控制缓存行为；Connection：管理持久连接，设置其值为Keep-Alive可实现长连接。Date：创建HTTP报文的日期和时间。Pragma：Http/1.1之前的历史遗留字段，仅作为HTTP/1.0向后兼容而定义，虽然是通用字段，当通常被使用在客户单的请求中，如Pragma: no-cache, 表示客户端在请求过程中不循序服务端返回缓存的数据；Transfer-Encoding：规定了传输报文主题时使用的传输编码，如Transfer-Encoding: chunkedUpgrade: 用于检查HTTP协议或其他协议是否有可使用的更高版本。Via：追踪客户端和服务端之间的报文的传输路径，还可避免会环的发生，所以在经过代理时必须添加此字段。Warning：Http/1.1的报文字段，从Http/1.0的AfterRetry演变而来，用来告知用户一些与缓存相关的警告信息。 其他报文字段这些字段不是HTTP协议中定义的，但被广泛应用于HTTP请求中。 Cookie：属于请求型报文字段，在请求时添加Cookie, 以实现HTTP的状态记录。 Set-Cookie：属于应答型报文字段。服务器给客户端传递Cookie信息时，就是通过此字段实现的。 Set-Cookie的字段属性： 12345678NAME=VALUE：赋予Cookie的名称和值；expires=DATE: Cookie的有效期；path=PATH: 将服务器上的目录作为Cookie的适用对象，若不指定，则默认为文档所在的文件目录；domin=域名：作为Cookies适用对象的域名，若不指定，则默认为创建Cookie的服务器域名；Secure: 仅在HTTPS安全通信是才会发送Cookie；HttpOnly: 使Cookie不能被JS脚本访问；如：Set-Cookie:BDSVRBFE=Go; max-age=10; domain=m.baidu.com; path=/ HTTP应答状态码 状态码 类别 描述 1xx Informational(信息性状态码) 请求正在被处理 2xx Success(成功状态码) 请求处理成功 3xx Redirection(重定向状态码) 需要进行重定向 4xx Client Error(客户端状态码) 服务器无法处理请求 5xx Server Error(服务端状态码) 服务器处理请求时出错 常见应答状态码： 了解应答状态码的含义，有助于我们在开发过程中定位问题，比如出现4xx, 我们首先需要检查的是请求是否有问题，而出现5xx时，则应让服务端做相应的检查工作。 HTTP缺点 通信使用明文，可能被窃听 不验证通信方的身份，可能遭遇伪装 无法证明报文的完整性，有可能遭遇篡改 以上是HTTP的缺点，这在网络通信中对企业安全是很致命的问题。那HTTPS能解决这些问题吗？下面讲讲HTTPS。 HTTPSHTTP+加密+认证+完整性保护 = HTTPS HTTPS概念 引自维基百科HTTPS：超文本传输安全协议（英语：Hypertext Transfer Protocol Secure，缩写：HTTPS，常称为HTTP over TLS，HTTP over SSL或HTTP Secure）是一种通过计算机网络进行安全通信的传输协议。HTTPS经由HTTP进行通信，但利用SSL/TLS来加密数据包。HTTPS开发的主要目的，是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。这个协议由网景公司（Netscape）在1994年首次提出，随后扩展到互联网上。历史上，HTTPS连接经常用于万维网上的交易支付和企业信息系统中敏感信息的传输。在2000年代晚期和2010年代早期，HTTPS开始广泛使用于保护所有类型网站上的网页真实性，保护账户和保持用户通信，身份和网络浏览的私密性。 HTTP协议采用明文传输信息，存在信息窃听、信息篡改和信息劫持的风险，而协议TLS/SSL具有身份验证、信息加密和完整性校验的功能，可以避免此类问题发生。 TLS/SSL全称安全传输层协议Transport Layer Security, 是介于TCP和HTTP之间的一层安全协议，不影响原有的TCP协议和HTTP协议，所以使用HTTPS基本上不需要对HTTP页面进行太多的改造。 HTTPS是在HTTP上建立SSL加密层，并对传输数据进行加密，是HTTP协议的安全版。HTTPS主要作用是： 对数据进行加密，并建立一个信息安全通道，来保证传输过程中的数据安全 对网站服务器进行真实身份认证 HTTPS和HTTP的区别 可以看到HTTPS比HTTP多了一层TLS/SSL协议，这个协议是干嘛的，有什么作用呢？ 下面讲解TLS/SSL工作原理。 TLS/SSL工作原理HTTPS协议的主要功能基本都依赖于TLS/SSL协议，TLS/SSL的功能实现主要依赖于三类基本算法：散列函数 Hash、对称加密和非对称加密，其利用非对称加密实现身份认证和密钥协商，对称加密算法采用协商的密钥对数据加密，基于散列函数验证信息的完整性。 散列函数Hash常见的有 MD5、SHA1、SHA256，该类函数特点是函数单向不可逆、对输入非常敏感、输出长度固定，针对数据的任何修改都会改变散列函数的结果，用于防止信息篡改并验证数据的完整性; 在信息传输过程中，散列函数不能单独实现信息防篡改，因为明文传输，中间人可以修改信息之后重新计算信息摘要，因此需要对传输的信息以及信息摘要进行加密; 对称加密常见的有AES-CBC、DES、3DES、AES-GCM等，相同的密钥可以用于信息的加密和解密，掌握密钥才能获取信息，能够防止信息窃听，通信方式是1对1; 对称加密的优势是信息传输1对1，需要共享相同的密码，密码的安全是保证信息安全的基础，服务器和 N 个客户端通信，需要维持 N 个密码记录，且缺少修改密码的机制; 非对称加密即常见的 RSA 算法，还包括 ECC、DH 等算法，算法特点是，密钥成对出现，一般称为公钥(公开)和私钥(保密)，公钥加密的信息只能私钥解开，私钥加密的信息只能公钥解开。因此掌握公钥的不同客户端之间不能互相解密信息，只能和掌握私钥的服务器进行加密通信，服务器可以实现1对多的通信，客户端也可以用来验证掌握私钥的服务器身份。 非对称加密的特点是信息传输1对多，服务器只需要维持一个私钥就能够和多个客户端进行加密通信，但服务器发出的信息能够被所有的客户端解密，且该算法的计算复杂，加密速度慢。 结合三类算法的特点，TLS的基本工作方式是，客户端使用非对称加密与服务器进行通信，实现身份验证并协商对称加密使用的密钥， 然后对称加密算法采用协商密钥对信息以及信息摘要进行加密通信，不同的节点之间采用的对称密钥不同，从而可以保证信息只能通信双方获取。 PKI体系RSA身份验证的隐患身份验证和密钥协商是TLS的基础功能，要求的前提是合法的服务器掌握着对应的私钥。但RSA算法无法确保服务器身份的合法性，因为公钥并不包含服务器的信息，存在安全隐患: 客户端C和服务器S进行通信，中间节点M截获了二者的通信; 节点M自己计算产生一对公钥pub_M和私钥pri_M; C向S请求公钥时，M把自己的公钥pub_M发给了C; C使用公钥 pub_M加密的数据能够被M解密，因为M掌握对应的私钥pri_M，而 C无法根据公钥信息判断服务器的身份，从而 C和 * M之间建立了”可信”加密连接; 中间节点 M和服务器S之间再建立合法的连接，因此 C和 S之间通信被M完全掌握，M可以进行信息的窃听、篡改等操作。 另外，服务器也可以对自己的发出的信息进行否认，不承认相关信息是自己发出。 因此该方案下至少存在两类问题：中间人攻击和信息抵赖。 身份验证CA和证书解决上述身份验证问题的关键是确保获取的公钥途径是合法的，能够验证服务器的身份信息，为此需要引入权威的第三方机构CA(如沃通CA)。CA 负责核实公钥的拥有者的信息，并颁发认证”证书”，同时能够为使用者提供证书验证服务，即PKI体系(PKI基础知识)。 基本的原理为，CA负责审核信息，然后对关键信息利用私钥进行”签名”，公开对应的公钥，客户端可以利用公钥验证签名。CA也可以吊销已经签发的证书，基本的方式包括两类 CRL 文件和 OCSP。CA使用具体的流程如下： a.服务方S向第三方机构CA提交公钥、组织信息、个人信息(域名)等信息并申请认证; b.CA通过线上、线下等多种手段验证申请者提供信息的真实性，如组织是否存在、企业是否合法，是否拥有域名的所有权等; c.如信息审核通过，CA会向申请者签发认证文件-证书。 证书包含以下信息：申请者公钥、申请者的组织信息和个人信息、签发机构 CA的信息、有效时间、证书序列号等信息的明文，同时包含一个签名; 签名的产生算法：首先，使用散列函数计算公开的明文信息的信息摘要，然后，采用 CA的私钥对信息摘要进行加密，密文即签名; d.客户端 C 向服务器 S 发出请求时，S 返回证书文件; e.客户端 C读取证书中的相关的明文信息，采用相同的散列函数计算得到信息摘要，然后，利用对应 CA的公钥解密签名数据，对比证书的信息摘要，如果一致，则可以确认证书的合法性，即公钥合法; f.客户端然后验证证书相关的域名信息、有效时间等信息; g.客户端会内置信任CA的证书信息(包含公钥)，如果CA不被信任，则找不到对应 CA的证书，证书也会被判定非法。 在这个过程注意几点： a.申请证书不需要提供私钥，确保私钥永远只能服务器掌握; b.证书的合法性仍然依赖于非对称加密算法，证书主要是增加了服务器信息以及签名; c.内置 CA 对应的证书称为根证书，颁发者和使用者相同，自己为自己签名，即自签名证书（为什么说”部署自签SSL证书非常不安全”） d.证书=公钥+申请者与颁发者信息+签名; 证书链如 CA根证书和服务器证书中间增加一级证书机构，即中间证书，证书的产生和验证原理不变，只是增加一层验证，只要最后能够被任何信任的CA根证书验证合法即可。 a.服务器证书 server.pem 的签发者为中间证书机构 inter，inter 根据证书 inter.pem 验证 server.pem 确实为自己签发的有效证书; b.中间证书 inter.pem 的签发 CA 为 root，root 根据证书 root.pem 验证 inter.pem 为自己签发的合法证书; c.客户端内置信任 CA 的 root.pem 证书，因此服务器证书 server.pem 的被信任。 服务器证书、中间证书与根证书在一起组合成一条合法的证书链，证书链的验证是自下而上的信任传递的过程。 二级证书结构存在的优势： a.减少根证书结构的管理工作量，可以更高效的进行证书的审核与签发; b.根证书一般内置在客户端中，私钥一般离线存储，一旦私钥泄露，则吊销过程非常困难，无法及时补救; c.中间证书结构的私钥泄露，则可以快速在线吊销，并重新为用户签发新的证书; d.证书链四级以内一般不会对 HTTPS 的性能造成明显影响。 证书链有以下特点： a.同一本服务器证书可能存在多条合法的证书链。 因为证书的生成和验证基础是公钥和私钥对，如果采用相同的公钥和私钥生成不同的中间证书，针对被签发者而言，该签发机构都是合法的 CA，不同的是中间证书的签发机构不同; b.不同证书链的层级不一定相同，可能二级、三级或四级证书链。 中间证书的签发机构可能是根证书机构也可能是另一个中间证书机构，所以证书链层级不一定相同。 证书吊销CA 机构能够签发证书，同样也存在机制宣布以往签发的证书无效。证书使用者不合法，CA 需要废弃该证书;或者私钥丢失，使用者申请让证书无效。主要存在两类机制：CRL 与 OCSP。 CRLCertificate Revocation List, 证书吊销列表(什么是证书吊销列表(CRL)？吊销列表起什么作用)，一个单独的文件。该文件包含了 CA 已经吊销的证书序列号(唯一)与吊销日期，同时该文件包含生效日期并通知下次更新该文件的时间，当然该文件必然包含 CA 私钥的签名以验证文件的合法性。 证书中一般会包含一个 URL 地址 CRL Distribution Point，通知使用者去哪里下载对应的 CRL 以校验证书是否吊销。该吊销方式的优点是不需要频繁更新，但是不能及时吊销证书，因为 CRL 更新时间一般是几天，这期间可能已经造成了极大损失。 OCSPOnline Certificate Status Protocol, 证书状态在线查询协议，一个实时查询证书是否吊销的方式。请求者发送证书的信息并请求查询，服务器返回正常、吊销或未知中的任何一个状态。证书中一般也会包含一个 OCSP 的 URL 地址，要求查询服务器具有良好的性能。部分 CA 或大部分的自签 CA (根证书)都是未提供 CRL 或 OCSP 地址的，对于吊销证书会是一件非常麻烦的事情。 HTTPS性能与优化HTTPS性能损耗前文讨论了HTTPS原理与优势：身份验证、信息加密与完整性校验等，且未对TCP和HTTP协议做任何修改。但通过增加新协议以实现更安全的通信必然需要付出代价，HTTPS协议的性能损耗主要体现如下： 增加延时 分析前面的握手过程，一次完整的握手至少需要两端依次来回两次通信，至少增加延时2 RTT，利用会话缓存从而复用连接，延时也至少1 RTT* 消耗较多的CPU资源 除数据传输之外，HTTPS通信主要包括对对称加解密、非对称加解密(服务器主要采用私钥解密数据);压测 TS8 机型的单核 CPU：对称加密算法AES-CBC-256 吞吐量 600Mbps，非对称 RSA 私钥解密200次/s。不考虑其它软件层面的开销，10G 网卡为对称加密需要消耗 CPU 约17核，24核CPU最多接入 HTTPS 连接 4800; 静态节点当前10G 网卡的 TS8 机型的 HTTP 单机接入能力约为10w/s，如果将所有的HTTP连接变为HTTPS连接，则明显RSA的解密最先成为瓶颈。因此，RSA的解密能力是当前困扰HTTPS接入的主要难题。 HTTPS接入优化CDN接入HTTPS 增加的延时主要是传输延时 RTT，RTT 的特点是节点越近延时越小，CDN 天然离用户最近，因此选择使用 CDN 作为 HTTPS 接入的入口，将能够极大减少接入延时。CDN 节点通过和业务服务器维持长连接、会话复用和链路质量优化等可控方法，极大减少 HTTPS 带来的延时。 会话缓存虽然前文提到 HTTPS 即使采用会话缓存也要至少1*RTT的延时，但是至少延时已经减少为原来的一半，明显的延时优化;同时，基于会话缓存建立的 HTTPS 连接不需要服务器使用RSA私钥解密获取 Pre-master 信息，可以省去CPU 的消耗。如果业务访问连接集中，缓存命中率高，则HTTPS的接入能力讲明显提升。当前TRP平台的缓存命中率高峰时期大于30%，10k/s的接入资源实际可以承载13k/的接入，收效非常可观。 硬件加速为接入服务器安装专用的SSL硬件加速卡，作用类似 GPU，释放 CPU，能够具有更高的 HTTPS 接入能力且不影响业务程序的。测试某硬件加速卡单卡可以提供35k的解密能力，相当于175核 CPU，至少相当于7台24核的服务器，考虑到接入服务器其它程序的开销，一张硬件卡可以实现接近10台服务器的接入能力。 远程解密本地接入消耗过多的 CPU 资源，浪费了网卡和硬盘等资源，考虑将最消耗 CPU 资源的RSA解密计算任务转移到其它服务器，如此则可以充分发挥服务器的接入能力，充分利用带宽与网卡资源。远程解密服务器可以选择 CPU 负载较低的机器充当，实现机器资源复用，也可以是专门优化的高计算性能的服务器。当前也是 CDN 用于大规模HTTPS接入的解决方案之一。 SPDY/HTTP2前面的方法分别从减少传输延时和单机负载的方法提高 HTTPS 接入性能，但是方法都基于不改变 HTTP 协议的基础上提出的优化方法，SPDY/HTTP2 利用 TLS/SSL 带来的优势，通过修改协议的方法来提升 HTTPS 的性能，提高下载速度等。 作者：jackyshan_链接：https://juejin.im/post/5af557a3f265da0b9265a498?utm_source=gold_browser_extension來源：掘金著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。]]></content>
      <categories>
        <category>iOSInterview</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
        <tag>HTTPS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RunLoop与GCD 、Autorelease Pool之间的关系]]></title>
    <url>%2F2018%2F04%2F27%2FRunLoop%E4%B8%8EGCD-%E3%80%81Autorelease-Pool%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB%2F</url>
    <content type="text"><![CDATA[如果在面试中问到RunLoop相关的知识，很有可能也会问到RunLoop与GCD、Autorelease Pool有没有关系，哪些地方用到了GCD、Autorelease Pool等。So，本文就总结一下RunLoop与GCD和 Autorelease Pool 之间的关系，看看在RunLoop实现中，哪些地方间接或者直接使用、操作到了GCD 和Autorelease Pool。 RunLoop 与GCD 的关系在RunLoop 中大量使用到了GCD，首先来看一下 CFRrunLoop.c 中引入的其他头文件。 12345678910111213#include &lt;CoreFoundation/CFRunLoop.h&gt;#include &lt;CoreFoundation/CFSet.h&gt;#include &lt;CoreFoundation/CFBag.h&gt;#include &lt;CoreFoundation/CFNumber.h&gt;#include &lt;CoreFoundation/CFPreferences.h&gt;#include &quot;CFInternal.h&quot;#include &lt;math.h&gt;#include &lt;stdio.h&gt;#include &lt;limits.h&gt;#include &lt;pthread.h&gt;#include &lt;dispatch/dispatch.h&gt; // GCD 库······ 然后，如果我们在RunLoop中搜索一下 dispatch，可以搜索出来 130个结果。接下来，我们来看看RunLoop的主要实现逻辑中哪些地方用到的 GCD。 1.RunLoop 的超时时间我们在前面介绍过RunLoop 启动在 CoreFoudation 库中有两个API： 1234//mode默认为defaultMode、超时时间是100亿秒、falsevoid CFRunLoopRun(void)// 可以设置mode、runloop 超时时间、是否处理完source立刻返回SInt32 CFRunLoopRunInMode(CFStringRef modeName, CFTimeInterval seconds, Boolean returnAfterSourceHandled) 而RunLoop 的超时时间就是使用 GCD 中的 dispatch_source_t来实现的，摘自 __CFRunLoopRun中的源码： 12345678910111213141516171819202122dispatch_source_t timeout_timer = NULL;struct __timeout_context *timeout_context = (struct __timeout_context *)malloc(sizeof(*timeout_context));if (seconds &lt;= 0.0) &#123; // instant timeout seconds = 0.0; timeout_context-&gt;termTSR = 0ULL;&#125; else if (seconds &lt;= TIMER_INTERVAL_LIMIT) &#123; //超时时间在最大限制内，才创建timeout_timer dispatch_queue_t queue = pthread_main_np() ? __CFDispatchQueueGetGenericMatchingMain() : __CFDispatchQueueGetGenericBackground(); timeout_timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue); dispatch_retain(timeout_timer); timeout_context-&gt;ds = timeout_timer; timeout_context-&gt;rl = (CFRunLoopRef)CFRetain(rl); timeout_context-&gt;termTSR = startTSR + __CFTimeIntervalToTSR(seconds); dispatch_set_context(timeout_timer, timeout_context); // source gets ownership of context dispatch_source_set_event_handler_f(timeout_timer, __CFRunLoopTimeout); dispatch_source_set_cancel_handler_f(timeout_timer, __CFRunLoopTimeoutCancel); uint64_t ns_at = (uint64_t)((__CFTSRToTimeInterval(startTSR) + seconds) * 1000000000ULL); dispatch_source_set_timer(timeout_timer, dispatch_time(1, ns_at), DISPATCH_TIME_FOREVER, 1000ULL); dispatch_resume(timeout_timer);&#125; else &#123; // infinite timeout seconds = 9999999999.0; timeout_context-&gt;termTSR = UINT64_MAX;&#125; 如果看不懂这段源码，可以先去看看GCD API 记录 （三）中的 dispatch_source中的timer 2.执行GCD MainQueue 上的异步任务在__CFRunLoopRun方法的前几行，有一个变量dispatchPort，它的作用是保存Main_Queue的port，便于后面RunLoop拿到GCD 主线程中的异步任务来执行。 123456mach_port_name_t dispatchPort = MACH_PORT_NULL;······// 只有在MainRunLoop，才会有下面这行赋值，否则 dispatchPort 为NULLdispatchPort = _dispatch_get_main_queue_port_4CF(); 来看一下，RunLoop 是如何执行GCD中MainQueue上的任务的： 12345678// 中间去掉了一些宏判断相关的逻辑代码if (MACH_PORT_NULL != dispatchPort &amp;&amp; !didDispatchPortLastTime) &#123; msg = (mach_msg_header_t *)msg_buffer; if (__CFRunLoopServiceMachPort(dispatchPort, &amp;msg, sizeof(msg_buffer), &amp;livePort, 0, &amp;voucherState, NULL)) &#123; goto handle_msg; &#125;&#125;didDispatchPortLastTime = false; 看来，关键的逻辑都在 handle_msg中。 handle_msg 中的代码片段： 1234567891011121314151617181920212223......else if (livePort == dispatchPort) &#123; CFRUNLOOP_WAKEUP_FOR_DISPATCH(); __CFRunLoopModeUnlock(rlm); __CFRunLoopUnlock(rl); _CFSetTSD(__CFTSDKeyIsInGCDMainQ, (void *)6, NULL);#if DEPLOYMENT_TARGET_WINDOWS void *msg = 0;#endif // 获取GCDMainQ上的异步任务并执行 __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg); _CFSetTSD(__CFTSDKeyIsInGCDMainQ, (void *)0, NULL); __CFRunLoopLock(rl); __CFRunLoopModeLock(rlm); sourceHandledThisLoop = true; didDispatchPortLastTime = true;&#125;...... static void __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(void *msg) &#123; _dispatch_main_queue_callback_4CF(msg); asm __volatile__(&quot;&quot;); // thwart tail-call optimization&#125; 从上面的源码片段可以看出，有判断是否是在MainRunLoop，有获取Main_Queue 的port，并且有调用 Main_Queue 上的回调，这只能是是 GCD 主队列上的异步任务。即：dispatch_async(dispatch_get_main_queue(), block)产生的任务。 RunLoop 与 Autorelease Pool的关系RunLoop与 Autorelease Pool 有关系么？有。我们总是看到有文章说程序启动后，苹果在主线程 RunLoop 里注册了两个 Observer：第一个 Observer 监视的事件是 Entry(即将进入Loop)，其回调内会调用 _objc_autoreleasePoolPush() 创建自动释放池。其 order 是-2147483647，优先级最高，保证创建释放池发生在其他所有回调之前。第二个 Observer 监视了两个事件： BeforeWaiting(准备进入睡眠) 和 Exit(即将退出Loop)，BeforeWaiting(准备进入睡眠)时调用_objc_autoreleasePoolPop() 和 _objc_autoreleasePoolPush() 释放旧的池并创建新池；Exit(即将退出Loop) 时调用 _objc_autoreleasePoolPop() 来释放自动释放池。这个 Observer 的 order 是 2147483647，优先级最低，保证其释放池子发生在其他所有回调之后。 打印出MainRunLoop，可以看到MainRunLoop的 Common mode Items 中就有这两个观察者 由 Activity 的枚举值 12345678910/* Run Loop Observer Activities */typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123; kCFRunLoopEntry = (1UL &lt;&lt; 0), kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1), kCFRunLoopBeforeSources = (1UL &lt;&lt; 2), kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5), kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6), kCFRunLoopExit = (1UL &lt;&lt; 7), kCFRunLoopAllActivities = 0x0FFFFFFFU&#125;; activities = 0x1，对应的就是kCFRunLoopEntry；activities = 0xa0，对应的就是kCFRunLoopBeforeWaiting | kCFRunLoopExit 。 可能很多人看了上面的结论和Log 信息，都有这样的疑惑:_wrapRunLoopWithAutoreleasePoolHandler()内部是如何处理自动释放池的？你说它释放了旧的 AutoreleasePool，并新建了一个新的，就是这样？目前，我也不知道如何查看 _wrapRunLoopWithAutoreleasePoolHandler() 中的实现，如果你有方式获取到她的内部信息，或者调用堆栈，欢迎告知我！ AutoreleasePool原理扩展这一小节，全部摘自黑幕背后的Autorelease，你可以阅读原文，了解更多 Autorelease 内容。ARC下，我们使用@autoreleasepool{}来使用一个AutoreleasePool，随后编译器将其改写成下面的样子： 123void *context = objc_autoreleasePoolPush();// &#123;&#125;中的代码objc_autoreleasePoolPop(context); 而这两个函数都是对AutoreleasePoolPage的简单封装，所以自动释放机制的核心就在于这个类。 AutoreleasePoolPage是一个C++实现的类 AutoreleasePool并没有单独的结构，而是由若干个AutoreleasePoolPage以双向链表的形式组合而成（分别对应结构中的parent指针和child指针） AutoreleasePool是按线程一一对应的（结构中的thread指针指向当前线程） AutoreleasePoolPage每个对象会开辟4096字节内存（也就是虚拟内存一页的大小），除了上面的实例变量所占空间，剩下的空间全部用来储存autorelease对象的地址 上面的id *next指针作为游标指向栈顶最新add进来的autorelease对象的下一个位置 一个AutoreleasePoolPage的空间被占满时，会新建一个AutoreleasePoolPage对象，连接链表，后来的autorelease对象在新的page加入 所以，若当前线程中只有一个AutoreleasePoolPage对象，并记录了很多autorelease对象地址时内存如下图： 图中的情况，这一页再加入一个autorelease对象就要满了（也就是next指针马上指向栈顶），这时就要执行上面说的操作，建立下一页page对象，与这一页链表连接完成后，新page的next指针被初始化在栈底（begin的位置），然后继续向栈顶添加新对象。 所以，向一个对象发送- autorelease消息，就是将这个对象加入到当前AutoreleasePoolPage的栈顶next指针指向的位置。 ** AutoreleasePool释放**每当进行一次objc_autoreleasePoolPush调用时，runtime向当前的AutoreleasePoolPage中add进一个哨兵对象，值为0（也就是个nil），那么这一个page就变成了下面的样子： objc_autoreleasePoolPush的返回值正是这个哨兵对象的地址，被objc_autoreleasePoolPop(哨兵对象)作为入参，于是： 1.根据传入的哨兵对象地址找到哨兵对象所处的page 2.在当前page中，将晚于哨兵对象插入的所有autorelease对象都发送一次- release消息，并向回移动next指针到正确位置 3.补充2：从最新加入的对象一直向前清理，可以向前跨越若干个page，直到哨兵所在的page 刚才的objc_autoreleasePoolPop执行后，最终变成了下面的样子： Have Fun! 作者：Haley_Wong链接：https://www.jianshu.com/p/e259bf7ab297來源：简书著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。]]></content>
      <categories>
        <category>performance</category>
      </categories>
      <tags>
        <tag>runloop</tag>
        <tag>GCD</tag>
        <tag>Autoreleasepool</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RunLoop的应用场景（四）- App卡顿监测]]></title>
    <url>%2F2018%2F04%2F27%2FRunLoop%E6%80%BB%E7%BB%93%EF%BC%9ARunLoop%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%88%E5%9B%9B%EF%BC%89App%E5%8D%A1%E9%A1%BF%E7%9B%91%E6%B5%8B%2F</url>
    <content type="text"><![CDATA[今天要介绍的RunLoop使用场景很有意思，在做长期项目，需要跟踪解决用户问题非常有用。使用RunLoop 监测主线程的卡顿，并将卡顿时的线程堆栈信息保存下来，下次上传到服务器。 参考资料关于今天要介绍的使用RunLoop 监测主线程卡顿的资料如下： iOS应用UI线程卡顿监控 MrPeak写的关于监控UI线程卡顿的文章，其中介绍了两种监测方式。 微信iOS卡顿监控系统（这篇文章要首先阅读，了解有哪些情况会引起主线程卡顿，监测到卡顿后怎么处理等） 监控卡顿的方法（使用RunLoop监测卡顿的片段代码) 简单监测iOS卡顿的demo（使用RunLoop监测卡顿的例子） 原理官方文档说明了RunLoop的执行顺序： 12345678910111213141516171. Notify observers that the run loop has been entered.2. Notify observers that any ready timers are about to fire.3. Notify observers that any input sources that are not port based are about to fire.4. Fire any non-port-based input sources that are ready to fire.5. If a port-based input source is ready and waiting to fire, process the event immediately. Go to step 9.6. Notify observers that the thread is about to sleep.7. Put the thread to sleep until one of the following events occurs: * An event arrives for a port-based input source. * A timer fires. * The timeout value set for the run loop expires. * The run loop is explicitly woken up.8. Notify observers that the thread just woke up.9. Process the pending event. * If a user-defined timer fired, process the timer event and restart the loop. Go to step 2. * If an input source fired, deliver the event. * If the run loop was explicitly woken up but has not yet timed out, restart the loop. Go to step 2.10. Notify observers that the run loop has exited. 用伪代码来实现就是这样的： 12345678910111213141516171819202122232425262728293031323334353637383940414243&#123; /// 1. 通知Observers，即将进入RunLoop /// 此处有Observer会创建AutoreleasePool: _objc_autoreleasePoolPush(); __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopEntry); do &#123; /// 2. 通知 Observers: 即将触发 Timer 回调。 __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopBeforeTimers); /// 3. 通知 Observers: 即将触发 Source (非基于port的,Source0) 回调。 __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopBeforeSources); __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__(block); /// 4. 触发 Source0 (非基于port的) 回调。 __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__(source0); __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__(block); /// 6. 通知Observers，即将进入休眠 /// 此处有Observer释放并新建AutoreleasePool: _objc_autoreleasePoolPop(); _objc_autoreleasePoolPush(); __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopBeforeWaiting); /// 7. sleep to wait msg. mach_msg() -&gt; mach_msg_trap(); /// 8. 通知Observers，线程被唤醒 __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopAfterWaiting); /// 9. 如果是被Timer唤醒的，回调Timer __CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__(timer); /// 9. 如果是被dispatch唤醒的，执行所有调用 dispatch_async 等方法放入main queue 的 block __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(dispatched_block); /// 9. 如果如果Runloop是被 Source1 (基于port的) 的事件唤醒了，处理这个事件 __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__(source1); &#125; while (...); /// 10. 通知Observers，即将退出RunLoop /// 此处有Observer释放AutoreleasePool: _objc_autoreleasePoolPop(); __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopExit);&#125; 主线程的RunLoop是在应用启动时自动开启的，也没有超时时间，所以正常情况下，主线程的RunLoop 只会在 2—9 之间无限循环下去。那么，我们只需要在主线程的RunLoop中添加一个observer，检测从kCFRunLoopBeforeSources到kCFRunLoopBeforeWaiting花费的时间 是否过长。如果花费的时间大于某一个阙值，我们就认为有卡顿，并把当前的线程堆栈转储到文件中，并在以后某个合适的时间，将卡顿信息文件上传到服务器。 实现步骤在看了上面的两个监测卡顿的示例Demo后，我按照上面讲述的思路写了一个Demo，应该更容易理解吧。第一步，创建一个子线程，在线程启动时，启动其RunLoop。 123456789101112131415161718192021+ (instancetype)shareMonitor&#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; instance = [[[self class] alloc] init]; instance.monitorThread = [[NSThread alloc] initWithTarget:self selector:@selector(monitorThreadEntryPoint) object:nil]; [instance.monitorThread start]; &#125;); return instance;&#125;+ (void)monitorThreadEntryPoint&#123; @autoreleasepool &#123; [[NSThread currentThread] setName:@&quot;FluencyMonitor&quot;]; NSRunLoop *runLoop = [NSRunLoop currentRunLoop]; [runLoop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode]; [runLoop run]; &#125;&#125; 第二步，在开始监测时，往主线程的RunLoop中添加一个observer，并往子线程中添加一个定时器，每0.5秒检测一次耗时的时长。 12345678910111213141516171819202122232425262728293031323334- (void)start&#123; if (_observer) &#123; return; &#125; // 1.创建observer CFRunLoopObserverContext context = &#123;0,(__bridge void*)self, NULL, NULL, NULL&#125;; _observer = CFRunLoopObserverCreate(kCFAllocatorDefault, kCFRunLoopAllActivities, YES, 0, &amp;runLoopObserverCallBack, &amp;context); // 2.将observer添加到主线程的RunLoop中 CFRunLoopAddObserver(CFRunLoopGetMain(), _observer, kCFRunLoopCommonModes); // 3.创建一个timer，并添加到子线程的RunLoop中 [self performSelector:@selector(addTimerToMonitorThread) onThread:self.monitorThread withObject:nil waitUntilDone:NO modes:@[NSRunLoopCommonModes]];&#125;- (void)addTimerToMonitorThread&#123; if (_timer) &#123; return; &#125; // 创建一个timer CFRunLoopRef currentRunLoop = CFRunLoopGetCurrent(); CFRunLoopTimerContext context = &#123;0, (__bridge void*)self, NULL, NULL, NULL&#125;; _timer = CFRunLoopTimerCreate(kCFAllocatorDefault, 0.1, 0.01, 0, 0, &amp;runLoopTimerCallBack, &amp;context); // 添加到子线程的RunLoop中 CFRunLoopAddTimer(currentRunLoop, _timer, kCFRunLoopCommonModes);&#125; 第三步，补充观察者回调处理 1234567891011121314151617181920212223242526272829static void runLoopObserverCallBack(CFRunLoopObserverRef observer, CFRunLoopActivity activity, void *info)&#123; FluencyMonitor *monitor = (__bridge FluencyMonitor*)info; NSLog(@&quot;MainRunLoop---%@&quot;,[NSThread currentThread]); switch (activity) &#123; case kCFRunLoopEntry: NSLog(@&quot;kCFRunLoopEntry&quot;); break; case kCFRunLoopBeforeTimers: NSLog(@&quot;kCFRunLoopBeforeTimers&quot;); break; case kCFRunLoopBeforeSources: NSLog(@&quot;kCFRunLoopBeforeSources&quot;); monitor.startDate = [NSDate date]; monitor.excuting = YES; break; case kCFRunLoopBeforeWaiting: NSLog(@&quot;kCFRunLoopBeforeWaiting&quot;); monitor.excuting = NO; break; case kCFRunLoopAfterWaiting: NSLog(@&quot;kCFRunLoopAfterWaiting&quot;); break; case kCFRunLoopExit: NSLog(@&quot;kCFRunLoopExit&quot;); break; default: break; &#125;&#125; 从打印信息来看，RunLoop进入睡眠状态的时间可能会非常短，有时候只有1毫秒，有时候甚至1毫秒都不到，静止不动时，则会长时间进入睡觉状态。 因为主线程中的block、交互事件、以及其他任务都是在kCFRunLoopBeforeSources到kCFRunLoopBeforeWaiting之前执行，所以我在即将开始执行Sources 时，记录一下时间，并把正在执行任务的标记置为YES，将要进入睡眠状态时，将正在执行任务的标记置为NO。 第四步，补充timer 的回调处理 1234567891011121314151617static void runLoopTimerCallBack(CFRunLoopTimerRef timer, void *info)&#123; FluencyMonitor *monitor = (__bridge FluencyMonitor*)info; if (!monitor.excuting) &#123; return; &#125; // 如果主线程正在执行任务，并且这一次loop 执行到 现在还没执行完，那就需要计算时间差 NSTimeInterval excuteTime = [[NSDate date] timeIntervalSinceDate:monitor.startDate]; NSLog(@&quot;定时器---%@&quot;,[NSThread currentThread]); NSLog(@&quot;主线程执行了---%f秒&quot;,excuteTime); if (excuteTime &gt;= 0.01) &#123; NSLog(@&quot;线程卡顿了%f秒&quot;,excuteTime); [monitor handleStackInfo]; &#125;&#125; timer 每 0.01秒执行一次，如果当前正在执行任务的状态为YES，并且从开始执行到现在的时间大于阙值，则把堆栈信息保存下来，便于后面处理。为了能够捕获到堆栈信息，我把timer的间隔调的很小（0.01），而评定为卡顿的阙值也调的很小（0.01）。 实际使用时这两个值应该是比较大，timer间隔为1s，卡顿阙值为2s即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374752016-12-15 08:56:39.921 RunLoopDemo03[957:16300] lag happen, detail below: Incident Identifier: 68BAB24C-3224-46C8-89BF-F9AABA2E3530CrashReporter Key: TODOHardware Model: x86_64Process: RunLoopDemo03 [957]Path: /Users/harvey/Library/Developer/CoreSimulator/Devices/6ED39DBB-9F69-4ACB-9CE3-E6EB56BBFECE/data/Containers/Bundle/Application/5A94DEFE-4E2E-4D23-9F69-7B1954B2C960/RunLoopDemo03.app/RunLoopDemo03Identifier: com.Haley.RunLoopDemo03Version: 1.0 (1)Code Type: X86-64Parent Process: debugserver [958]Date/Time: 2016-12-15 00:56:38 +0000OS Version: Mac OS X 10.1 (16A323)Report Version: 104Exception Type: SIGTRAPException Codes: TRAP_TRACE at 0x1063da728Crashed Thread: 4Thread 0:0 libsystem_kernel.dylib 0x000000010a14341a mach_msg_trap + 101 CoreFoundation 0x0000000106f1e7b4 __CFRunLoopServiceMachPort + 2122 CoreFoundation 0x0000000106f1dc31 __CFRunLoopRun + 13453 CoreFoundation 0x0000000106f1d494 CFRunLoopRunSpecific + 4204 GraphicsServices 0x000000010ad8aa6f GSEventRunModal + 1615 UIKit 0x00000001073b7964 UIApplicationMain + 1596 RunLoopDemo03 0x00000001063dbf8f main + 1117 libdyld.dylib 0x0000000109d7468d start + 1Thread 1:0 libsystem_kernel.dylib 0x000000010a14be5e kevent_qos + 101 libdispatch.dylib 0x0000000109d13074 _dispatch_mgr_invoke + 2482 libdispatch.dylib 0x0000000109d12e76 _dispatch_mgr_init + 0Thread 2:0 libsystem_kernel.dylib 0x000000010a14b4e6 __workq_kernreturn + 101 libsystem_pthread.dylib 0x000000010a16e221 start_wqthread + 13Thread 3:0 libsystem_kernel.dylib 0x000000010a14341a mach_msg_trap + 101 CoreFoundation 0x0000000106f1e7b4 __CFRunLoopServiceMachPort + 2122 CoreFoundation 0x0000000106f1dc31 __CFRunLoopRun + 13453 CoreFoundation 0x0000000106f1d494 CFRunLoopRunSpecific + 4204 Foundation 0x00000001064d7ff0 -[NSRunLoop runMode:beforeDate:] + 2745 Foundation 0x000000010655f991 -[NSRunLoop runUntilDate:] + 786 UIKit 0x0000000107e3d539 -[UIEventFetcher threadMain] + 1187 Foundation 0x00000001064e7ee4 __NSThread__start__ + 12438 libsystem_pthread.dylib 0x000000010a16eabb _pthread_body + 1809 libsystem_pthread.dylib 0x000000010a16ea07 _pthread_body + 010 libsystem_pthread.dylib 0x000000010a16e231 thread_start + 13Thread 4 Crashed:0 RunLoopDemo03 0x00000001063dfae5 -[PLCrashReporter generateLiveReportWithThread:error:] + 6321 RunLoopDemo03 0x00000001063da728 -[FluencyMonitor handleStackInfo] + 1522 RunLoopDemo03 0x00000001063da2cf runLoopTimerCallBack + 3513 CoreFoundation 0x0000000106f26964 __CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__ + 204 CoreFoundation 0x0000000106f265f3 __CFRunLoopDoTimer + 10755 CoreFoundation 0x0000000106f2617a __CFRunLoopDoTimers + 2506 CoreFoundation 0x0000000106f1df01 __CFRunLoopRun + 20657 CoreFoundation 0x0000000106f1d494 CFRunLoopRunSpecific + 4208 Foundation 0x00000001064d7ff0 -[NSRunLoop runMode:beforeDate:] + 2749 Foundation 0x00000001064d7ecb -[NSRunLoop run] + 7610 RunLoopDemo03 0x00000001063d9cbd +[FluencyMonitor monitorThreadEntryPoint] + 25311 Foundation 0x00000001064e7ee4 __NSThread__start__ + 124312 libsystem_pthread.dylib 0x000000010a16eabb _pthread_body + 18013 libsystem_pthread.dylib 0x000000010a16ea07 _pthread_body + 014 libsystem_pthread.dylib 0x000000010a16e231 thread_start + 13Thread 4 crashed with X86-64 Thread State: rip: 0x00000001063dfae5 rbp: 0x000070000f53fc50 rsp: 0x000070000f53f9c0 rax: 0x000070000f53fa20 rbx: 0x000070000f53fb60 rcx: 0x0000000000005e0b rdx: 0x0000000000000000 rdi: 0x00000001063dfc6a rsi: 0x000070000f53f9f0 r8: 0x0000000000000014 r9: 0xffffffffffffffec r10: 0x000000010a1433f6 r11: 0x0000000000000246 r12: 0x000060800016b580 r13: 0x0000000000000000 r14: 0x0000000000000006 r15: 0x000070000f53fa40 rflags: 0x0000000000000206 cs: 0x000000000000002b fs: 0x0000000000000000 gs: 0x0000000000000000 剩下的工作就是将字符串保存进文件，以及上传到服务器了。 我们不能将卡顿的阙值定的太小，也不能将所有的卡顿信息都上传，原因有两点，一，太浪费用户流量；二、文件太多，App内存储和上传后服务器端保存都会占用空间。 可以参考微信的做法，7天以上的文件删除，随机抽取上传，并且上传前对文件进行压缩处理等。 文中的示例代码都来自：RunLoopDemos中的RunLoopDemo03 作者：Haley_Wong链接：https://www.jianshu.com/p/902741bcf707來源：简书著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。]]></content>
      <categories>
        <category>performance</category>
      </categories>
      <tags>
        <tag>runloop</tag>
        <tag>App卡顿监测</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RunLoop的应用场景（一）- 保证线程长久存活]]></title>
    <url>%2F2018%2F04%2F27%2FRunLoop%E6%80%BB%E7%BB%93%EF%BC%9ARunLoop%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%88%E4%B8%80%EF%BC%89%E4%BF%9D%E8%AF%81%E7%BA%BF%E7%A8%8B%E9%95%BF%E4%B9%85%E5%AD%98%E6%B4%BB%2F</url>
    <content type="text"><![CDATA[在iOS开发过程中，有时候我们不希望一些花费时间比较长的操作阻塞主线程，导致界面卡顿，那么我们就会创建一个子线程，然后把这些花费时间比较长的操作放在子线程中来处理。可是当子线程中的任务执行完毕后，子线程就会被销毁掉。 当子线程中的任务执行完毕后，线程就被立刻销毁了。如果程序中，需要经常在子线程中执行任务，频繁的创建和销毁线程，会造成资源的浪费。这时候我们就可以使用RunLoop来让该线程长时间存活而不被销毁。 说明因为RunLoop 里有很多新的平时基本很难接触到的概念或者对象，所以如果从RunLoop是啥，里面包含啥，为什么是这样讲起，难免太迷茫，太晦涩难懂。大多数关于RunLoop 的文章也是从基础讲起的，文章也比较长，可能看了三分之一，就已经懵了，没了技术看下去的动力。所以我决定先从RunLoop的使用场景和用法讲起，看到了一些用法和现象，再去看它的实现就要容易理解的多了。文章中的示例代码，我会在文章末提供一个关于RunLoop的示例Demo。 RunLoop的使用场景下面介绍一下，可以使用RunLoop的几个使用场景(本想一篇写完，无奈一个使用场景就让文章很长了，还是分几篇来讲吧)。 1.保证线程的长时间存活在iOS开发过程中，有时候我们不希望一些花费时间比较长的操作阻塞主线程，导致界面卡顿，那么我们就会创建一个子线程，然后把这些花费时间比较长的操作放在子线程中来处理。可是当子线程中的任务执行完毕后，子线程就会被销毁掉。** 怎么来验证上面这个结论呢？**首先，我们创建一个HLThread类，继承自NSThread，然后重写dealloc 方法。 123456789101112@interface HLThread : NSThread@end@implementation HLThread- (void)dealloc&#123; NSLog(@&quot;%s&quot;,__func__);&#125;@end 然后，在控制器中用HLThread创建一个线程，执行一个任务，观察任务执行完毕后，线程是否被销毁。 123456789101112131415161718192021- (void)viewDidLoad &#123; [super viewDidLoad]; // 1.测试线程的销毁 [self threadTest];&#125;- (void)threadTest&#123; HLThread *subThread = [[HLThread alloc] initWithTarget:self selector:@selector(subThreadOpetion) object:nil]; [subThread start];&#125;- (void)subThreadOpetion&#123; @autoreleasepool &#123; NSLog(@&quot;%@----子线程任务开始&quot;,[NSThread currentThread]); [NSThread sleepForTimeInterval:3.0]; NSLog(@&quot;%@----子线程任务结束&quot;,[NSThread currentThread]); &#125;&#125; 控制台输出的结果如下： 1232016-12-01 16:44:25.559 RunLoopDemo[4516:352041] &lt;HLThread: 0x608000275680&gt;&#123;number = 4, name = (null)&#125;----子线程任务开始2016-12-01 16:44:28.633 RunLoopDemo[4516:352041] &lt;HLThread: 0x608000275680&gt;&#123;number = 4, name = (null)&#125;----子线程任务结束2016-12-01 16:44:28.633 RunLoopDemo[4516:352041] -[HLThread dealloc] 当子线程中的任务执行完毕后，线程就被立刻销毁了。如果程序中，需要经常在子线程中执行任务，频繁的创建和销毁线程，会造成资源的浪费。这时候我们就可以使用RunLoop来让该线程长时间存活而不被销毁。 我们将上面的示例代码修改一下，修改后的代码过程为，创建一个子线程，当子线程启动后，启动runloop，点击视图，会在子线程中执行一个耗时3秒的任务（其实就是让线程睡眠3秒）。 修改后的代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; // 1.测试线程的销毁 [self threadTest];&#125;- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123; [self performSelector:@selector(subThreadOpetion) onThread:self.subThread withObject:nil waitUntilDone:NO];&#125;- (void)threadTest&#123; HLThread *subThread = [[HLThread alloc] initWithTarget:self selector:@selector(subThreadEntryPoint) object:nil]; [subThread setName:@&quot;HLThread&quot;]; [subThread start]; self.subThread = subThread;&#125;/** 子线程启动后，启动runloop */- (void)subThreadEntryPoint&#123; @autoreleasepool &#123; NSRunLoop *runLoop = [NSRunLoop currentRunLoop]; //如果注释了下面这一行，子线程中的任务并不能正常执行 [runLoop addPort:[NSMachPort port] forMode:NSRunLoopCommonModes]; NSLog(@&quot;启动RunLoop前--%@&quot;,runLoop.currentMode); [runLoop run]; &#125;&#125;/** 子线程任务 */- (void)subThreadOpetion&#123; NSLog(@&quot;启动RunLoop后--%@&quot;,[NSRunLoop currentRunLoop].currentMode); NSLog(@&quot;%@----子线程任务开始&quot;,[NSThread currentThread]); [NSThread sleepForTimeInterval:3.0]; NSLog(@&quot;%@----子线程任务结束&quot;,[NSThread currentThread]);&#125;@end 先看控制台输出结果： 12345672016-12-01 17:22:44.396 RunLoopDemo[4733:369202] 启动RunLoop前--(null)2016-12-01 17:22:49.285 RunLoopDemo[4733:369202] 启动RunLoop后--kCFRunLoopDefaultMode2016-12-01 17:22:49.285 RunLoopDemo[4733:369202] &lt;HLThread: 0x60000027cb40&gt;&#123;number = 4, name = HLThread&#125;----子线程任务开始2016-12-01 17:22:52.359 RunLoopDemo[4733:369202] &lt;HLThread: 0x60000027cb40&gt;&#123;number = 4, name = HLThread&#125;----子线程任务结束2016-12-01 17:22:55.244 RunLoopDemo[4733:369202] 启动RunLoop后--kCFRunLoopDefaultMode2016-12-01 17:22:55.245 RunLoopDemo[4733:369202] &lt;HLThread: 0x60000027cb40&gt;&#123;number = 4, name = HLThread&#125;----子线程任务开始2016-12-01 17:22:58.319 RunLoopDemo[4733:369202] &lt;HLThread: 0x60000027cb40&gt;&#123;number = 4, name = HLThread&#125;----子线程任务结束 有几点需要注意：1.获取RunLoop只能使用 [NSRunLoop currentRunLoop] 或 [NSRunLoop mainRunLoop];2.即使RunLoop开始运行，如果RunLoop 中的 modes 为空，或者要执行的mode里没有item，那么RunLoop会直接在当前loop中返回，并进入睡眠状态。3.自己创建的Thread中的任务是在kCFRunLoopDefaultMode这个mode中执行的。4.在子线程创建好后，最好所有的任务都放在AutoreleasePool中。 注意点一解释RunLoop官方文档中的第二段中就已经说明了，我们的应用程序并不需要自己创建RunLoop，而是要在合适的时间启动runloop。CF框架源码中有CFRunLoopGetCurrent(void)和CFRunLoopGetMain(void),查看源码可知，这两个API中，都是先从全局字典中取，如果没有与该线程对应的RunLoop，那么就会帮我们创建一个RunLoop（创建RunLoop的过程在函数_CFRunLoopGet0(pthread_t t)中）。 注意点二解释这一点，可以将示例代码中的[runLoop addPort:[NSMachPort port] forMode:NSRunLoopCommonModes];，可以看到注释掉后，无论我们如何点击视图，控制台都不会有任何的输出，那是因为mode 中并没有item任务。经过NSRunLoop封装后，只可以往mode中添加两类item任务：NSPort（对应的是source）、NSTimer，如果使用CFRunLoopRef,则可以使用C语言API,往mode中添加source、timer、observer。如果不添加[runLoop addPort:[NSMachPort port] forMode:NSRunLoopCommonModes];，我们把runloop的信息输出，可以看到： 添加port前的RunLoop 如果我们添加上[runLoop addPort:[NSMachPort port] forMode:NSRunLoopCommonModes];,再把RunLoop的信息输出，可以看到： 添加port后的RunLoop 注意点三解释怎么确认自己创建的子线程上的任务是在kCFRunLoopDefaultMode这个mode中执行的呢？我们只需要在执行任务的时候，打印出该RunLoop的currentMode即可。因为RunLoop执行任务是会在mode间切换，只执行该mode上的任务，每次切换到某个mode时，currentMode就会更新。源码请下载：CF框架源码CFRunLoopRun()方法中会调用CFRunLoopRunSpecific()方法，而CFRunLoopRunSpecific()方法中有这么两行关键代码： 123456CFRunLoopModeRef currentMode = __CFRunLoopFindMode(rl, modeName, false);......这中间还有好多逻辑代码CFRunLoopModeRef previousMode = rl-&gt;_currentMode;rl-&gt;_currentMode = currentMode;...... 这中间也有一堆的逻辑rl-&gt;_currentMode = previousMode; 我测试后，控制台输出的是： 1232016-12-02 11:09:47.909 RunLoopDemo[5479:442560] 启动RunLoop后--kCFRunLoopDefaultMode2016-12-02 11:09:47.910 RunLoopDemo[5479:442560] &lt;HLThread: 0x608000270a80&gt;&#123;number = 4, name = HLThread&#125;----子线程任务开始2016-12-02 11:09:50.984 RunLoopDemo[5479:442560] &lt;HLThread: 0x608000270a80&gt;&#123;number = 4, name = HLThread&#125;----子线程任务结束 注意点四解释关于AutoReleasePool的官方文档中有提到： 12345678910If you spawn a secondary thread.You must create your own autorelease pool block as soon as the thread begins executing; otherwise, your application will leak objects. (See Autorelease Pool Blocks and Threads for details.)Each thread in a Cocoa application maintains its own stack of autorelease pool blocks. If you are writing a Foundation-only program or if you detach a thread, you need to create your own autorelease pool block.If your application or thread is long-lived and potentially generates a lot of autoreleased objects, you should use autorelease pool blocks (like AppKit and UIKit do on the main thread); otherwise, autoreleased objects accumulate and your memory footprint grows. If your detached thread does not make Cocoa calls, you do not need to use an autorelease pool block. AFNetworking中的RunLoop案例在AFNetworking 2.6.3之前的版本，使用的还是NSURLConnection，可以在AFURLConnectionOperation中找到使用RunLoop的源码： 123456789101112131415161718+ (void)networkRequestThreadEntryPoint:(id)__unused object &#123; @autoreleasepool &#123; [[NSThread currentThread] setName:@&quot;AFNetworking&quot;]; NSRunLoop *runLoop = [NSRunLoop currentRunLoop]; [runLoop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode]; [runLoop run]; &#125;&#125;+ (NSThread *)networkRequestThread &#123; static NSThread *_networkRequestThread = nil; static dispatch_once_t oncePredicate; dispatch_once(&amp;oncePredicate, ^&#123; _networkRequestThread = [[NSThread alloc] initWithTarget:self selector:@selector(networkRequestThreadEntryPoint:) object:nil]; [_networkRequestThread start]; &#125;); return _networkRequestThread;&#125; AFNetworking都是通过调用 [NSObject performSelector:onThread:..] 将这个任务扔到了后台线程的 RunLoop 中。 12345678910- (void)start &#123; [self.lock lock]; if ([self isCancelled]) &#123; [self performSelector:@selector(cancelConnection) onThread:[[self class] networkRequestThread] withObject:nil waitUntilDone:NO modes:[self.runLoopModes allObjects]]; &#125; else if ([self isReady]) &#123; self.state = AFOperationExecutingState; [self performSelector:@selector(operationDidStart) onThread:[[self class] networkRequestThread] withObject:nil waitUntilDone:NO modes:[self.runLoopModes allObjects]]; &#125; [self.lock unlock];&#125; 我们在使用NSURLConnection或者NSStream时，也需要考虑到RunLoop问题，因为默认情况下这两个类的对象生成后，都是在当前线程的NSDefaultRunLoopMode模式下执行任务。如果是在主线程，那么就会出现滚动ScrollView以及其子视图时，主线程的RunLoop切换到UITrackingRunLoopMode模式，那么NSURLConnection或者NSStream的回调就无法执行了。 要解决这个问题，有两种方式：第一种方式是创建出NSURLConnection对象或者NSStream对象后，再调用- (void)scheduleInRunLoop:(NSRunLoop *)aRunLoop forMode:(NSRunLoopMode)mode,设置RunLoopMode即可。需要注意的是NSURLConnection必须使用其初始化构造方法- (nullable instancetype)initWithRequest:(NSURLRequest *)request delegate:(nullable id)delegate startImmediately:(BOOL)startImmediately来创建对象，设置Mode才会起作用。 第二种方式，就是所有的任务都在子线程中执行，并保证子线程的RunLoop正常运行即可（即上面AFNetworking的做法，因为主线程的RunLoop切换到UITrackingRunLoopMode，并不影响其他线程执行哪个mode中的任务，计算机CPU是在每一个时间片切换到不同的线程去跑一会，呈现出的多线程效果）。 文中的示例代码都来自：RunLoopDemos中的RunLoopDemo01 参考资料好的书籍都是值得反复看的，那好的文章，好的资料也值得我们反复看。我们在不同的阶段来相同的文章或资料或书籍都能有不同的收获，那它就是好文章，好书籍，好资料。关于iOS 中的RunLoop资料非常的少，以下这些资料都是非常好的。 CF框架源码（这是一份很重要的源码，可以看到CF框架的每一次迭代，我们可以下载最新的版本来分析，或与以下文章对比学习。目前最新的是CF-1153.18.tar.gz） RunLoop官方文档(学习iOS的任何技术，官方文档都是入门或深入的极好手册；我们也可以在Xcode—&gt;Help—&gt;Docementation and API Reference —&gt;搜索RunLoop—&gt; Guides（59）—&gt;《Threading Programming Guide:Run Loops》这篇即是） 深入理解RunLoop(不要看到右边滚动条很长，其实文章占篇幅2/5左右，下面有很多的评论，可见这篇文章的火热) RunLoop个人小结(这是一篇总结的很通俗容易理解的文章) sunnyxx线下分享RunLoop(这是一份关于线下分享与讨论RunLoop的视频，备用地址：https://pan.baidu.com/s/1pLm4Vf9） iPhonedevwiki中的CFRunLoop(commonModes中其实包含了三种Mode，我们通常知道两种，还有一种是啥，你知道么？) 维基百科中的Event loop（可以看看这篇文章了解一下事件循环） 作者：Haley_Wong链接：https://www.jianshu.com/p/902741bcf707來源：简书著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。]]></content>
      <categories>
        <category>performance</category>
      </categories>
      <tags>
        <tag>runloop</tag>
        <tag>线程保活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS-APP-运行时防Crash工具XXShield练就]]></title>
    <url>%2F2018%2F04%2F26%2FiOS-APP-%E8%BF%90%E8%A1%8C%E6%97%B6%E9%98%B2Crash%E5%B7%A5%E5%85%B7XXShield%E7%BB%83%E5%B0%B1%2F</url>
    <content type="text"><![CDATA[前言正在运行的 APP 突然 Crash，是一件令人不爽的事，会流失用户，影响公司发展，所以 APP 运行时拥有防 Crash 功能能有效降低 Crash 率，提升 APP 稳定性。但是有时候 APP Crash 是应有的表现，我们不让 APPCrash 可能会导致别的逻辑错误，不过我们可以抓取到应用当前的堆栈信息并上传至相关的服务器，分析并修复这些 BUG。 所以本文介绍的 XXShield 库有两个重要的功能: 防止Crash 捕获异常状态下的崩溃信息 类似的相关技术分析也有 网易iOS App运行时Crash自动防护实践 目前已经实现的功能 Unrecoginzed Selector Crash KVO Crash Container Crash NSNotification Crash NSNull Crash NSTimer Crash 野指针 Crash 1 Unrecoginzed Selector Crash出现原因由于 Objective-C 是动态语言，所有的消息发送都会放在运行时去解析，有时候我们把一个信息传递给了错误的类型，就会导致这个错误。 解决办法Objective-C 在出现无法解析的方法时有三部曲来进行消息转发。详见Objective-C Runtime 运行时之三：方法与消息 动态方法解析 备用接收者 完整转发 1 一般适用与 Dynamic 修饰的 Property2 一般适用与将方法转发至其他对象3 一般适用与消息可以转发多个对象，可以实现类似多继承或者转发中心的概念。 这里选择的是方案二，因为三里面用到了 NSInvocation 对象，此对象性能开销较大，而且这种异常如果出现必然频次较高。最适合将消息转发到一个备用者对象上。 这里新建一个智能转发类。此对象将在其他对象无法解析数据时，返回一个 0 来防止 Crash。返回 0 是因为这个通用的智能转发类做的操作接近向 nil 发送一个消息。 代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#import &lt;objc/runtime.h&gt;/** default Implement @param target trarget @param cmd cmd @param ... other param @return default Implement is zero */int smartFunction(id target, SEL cmd, ...) &#123; return 0;&#125;static BOOL __addMethod(Class clazz, SEL sel) &#123; NSString *selName = NSStringFromSelector(sel); NSMutableString *tmpString = [[NSMutableString alloc] initWithFormat:@&quot;%@&quot;, selName]; int count = (int)[tmpString replaceOccurrencesOfString:@&quot;:&quot; withString:@&quot;_&quot; options:NSCaseInsensitiveSearch range:NSMakeRange(0, selName.length)]; NSMutableString *val = [[NSMutableString alloc] initWithString:@&quot;i@:&quot;]; for (int i = 0; i &lt; count; i++) &#123; [val appendString:@&quot;@&quot;]; &#125; const char *funcTypeEncoding = [val UTF8String]; return class_addMethod(clazz, sel, (IMP)smartFunction, funcTypeEncoding);&#125;@implementation XXShieldStubObject+ (XXShieldStubObject *)shareInstance &#123; static XXShieldStubObject *singleton; if (!singleton) &#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; singleton = [XXShieldStubObject new]; &#125;); &#125; return singleton;&#125;- (BOOL)addFunc:(SEL)sel &#123; return __addMethod([XXShieldStubObject class], sel);&#125;+ (BOOL)addClassFunc:(SEL)sel &#123; Class metaClass = objc_getMetaClass(class_getName([XXShieldStubObject class])); return __addMethod(metaClass, sel);&#125;@end 我们这里需要 Hook NSObject的 - (id)forwardingTargetForSelector:(SEL)aSelector 方法启动消息转发。很多人不知道的是如果想要转发类方法，只需要实现一个同名的类方法即可，虽然在头文件中此方法并未声明。 12345678910111213141516171819202122232425262728293031XXStaticHookClass(NSObject, ProtectFW, id, @selector(forwardingTargetForSelector:), (SEL)aSelector) &#123; // 1 如果是NSSNumber 和NSString没找到就是类型不对 切换下类型就好了 if ([self isKindOfClass:[NSNumber class]] &amp;&amp; [NSString instancesRespondToSelector:aSelector]) &#123; NSNumber *number = (NSNumber *)self; NSString *str = [number stringValue]; return str; &#125; else if ([self isKindOfClass:[NSString class]] &amp;&amp; [NSNumber instancesRespondToSelector:aSelector]) &#123; NSString *str = (NSString *)self; NSNumberFormatter *formatter = [[NSNumberFormatter alloc] init]; NSNumber *number = [formatter numberFromString:str]; return number; &#125; BOOL aBool = [self respondsToSelector:aSelector]; NSMethodSignature *signatrue = [self methodSignatureForSelector:aSelector]; if (aBool || signatrue) &#123; return XXHookOrgin(aSelector); &#125; else &#123; XXShieldStubObject *stub = [XXShieldStubObject shareInstance]; [stub addFunc:aSelector]; NSString *reason = [NSString stringWithFormat:@&quot;*****Warning***** logic error.target is %@ method is %@, reason : method forword to SmartFunction Object default implement like send message to nil.&quot;, [self class], NSStringFromSelector(aSelector)]; [XXRecord recordFatalWithReason:reason userinfo:nil errorType:EXXShieldTypeUnrecognizedSelector]; return stub; &#125;&#125;XXStaticHookEnd 这里汇报了 Crash 信息，出现消息转发一般是一个 logic 错误，为必须修复的Bug，上报尤为重要。 2 KVO Crash出现原因KVOCrash总结下来有以下2大类。 不匹配的移除和添加关系。 观察者和被观察者释放的时候没有及时断开观察者关系。 解决办法 尼古拉斯赵四说过 : 赵四 对比到程序世界就是，程序世界没有什么难以解决的问题都是不可以通过抽象层次来解决的，如果有，那就两层。纵观程序的架构设计，计算机网络协议分层设计，操作系统内核设计等等都是如此。 问题1 ： 不成对的添加观察者和移除观察者会导致 Crash，以往我们使用 KVO，观察者和被观察者都是直接交互的。这里的设计方案是我们找一个 Proxy 用来做转发， 真正的观察者是 Proxy，被观察者出现了通知信息，由 Proxy 做分发。所以 Proxy 里面要保存一个数据结构 {keypath : [observer1, observer2,…]} 。 1234567891011@interface XXKVOProxy : NSObject &#123; __unsafe_unretained NSObject *_observed;&#125;/** &#123;keypath : [ob1,ob2](NSHashTable)&#125; */@property (nonatomic, strong) NSMutableDictionary&lt;NSString *, NSHashTable&lt;NSObject *&gt; *&gt; *kvoInfoMap;@end 我们需要 Hook NSObject的 �KVO 相关方法。 1234- (void)addObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath options:(NSKeyValueObservingOptions)options context:(void *)context;- (void)removeObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath; 在添加观察者时 123![addObserver](http://ompeszjl2.bkt.clouddn.com/iOS-APP-%E8%BF%90%E8%A1%8C%E6%97%B6%E9%98%B2Crash%E5%B7%A5%E5%85%B7XXShield%E7%BB%83%E5%B0%B1//KVO-Add.png)addObserver 在移除观察者时 removeObserver 问题2: 观察者和被观察者释放的时候没有断开观察者关系。对于观察者， 既然我们是自己用 Proxy 做的分发，我们自己就需要保存观察者，这里我们简单的使用 NSHashTable 指定指针持有策略为 weak 即可。 对于被观察者，我们使用 iOS 界的毒瘤-MethodSwizzling一文中到的方法。我们在被观察者上绑定一个关联对象，在关联对象的 dealloc 方法中做相关操作即可。 12345678910- (void)dealloc &#123; @autoreleasepool &#123; NSDictionary&lt;NSString *, NSHashTable&lt;NSObject *&gt; *&gt; *kvoinfos = self.kvoInfoMap.copy; for (NSString *keyPath in kvoinfos) &#123; // call original IMP __xx_hook_orgin_function_removeObserver(_observed,@selector(removeObserver:forKeyPath:),self, keyPath); &#125; &#125;&#125; 3 Container Crash出现原因容器在任何编程语言中都尤为重要，容器是数据的载体，很多容器对容器放空值都做了容错处理。不幸的是 Objective-C 并没有，容器插入了 nil 就会导致 Crash，容器还有另外一个最容易 Crash 的原因就是下标越界。 解决办法常见的容器有 NS(Mutable)Array , NS(Mutable)Dictionary, NSCache 等。我们需要 hook 常见的方法加入检测功能并且捕获堆栈信息上报。 例如 1234567891011121314151617181920XXStaticHookClass(NSArray, ProtectCont, id, @selector(objectAtIndex:),(NSUInteger)index) &#123;if (self.count == 0) &#123; NSString *reason = [NSString stringWithFormat:@&quot;target is %@ method is %@,reason : index %@ out of count %@ of array &quot;, [self class], XXSEL2Str(@selector(objectAtIndex:)), @(index), @(self.count)]; [XXRecord recordFatalWithReason:reason userinfo:nil errorType:EXXShieldTypeContainer]; return nil;&#125;if (index &gt;= self.count) &#123; NSString *reason = [NSString stringWithFormat:@&quot;target is %@ method is %@,reason : index %@ out of count %@ of array &quot;, [self class], XXSEL2Str(@selector(objectAtIndex:)), @(index), @(self.count)]; [XXRecord recordFatalWithReason:reason userinfo:nil errorType:EXXShieldTypeContainer]; return nil;&#125;return XXHookOrgin(index);&#125;XXStaticHookEnd 但是需要注意的是 NSArray 是一个 Class Cluster 的抽象父类，所以我们需要 Hook 到我们真正的子类。 这里给出一个辅助方法，获取一个类的所有直接子类： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152+ (NSArray *)findAllOf:(Class)defaultClass &#123; int count = objc_getClassList(NULL, 0); if (count &lt;= 0) &#123; @throw@&quot;Couldn&apos;t retrieve Obj-C class-list&quot;; return @[defaultClass]; &#125; NSMutableArray *output = @[].mutableCopy; Class *classes = (Class *) malloc(sizeof(Class) * count); objc_getClassList(classes, count); for (int i = 0; i &lt; count; ++i) &#123; if (defaultClass == class_getSuperclass(classes[i]))//子类 &#123; [output addObject:classes[i]]; &#125; &#125; free(classes); return output.copy;&#125;// 对于NSarray ：//[NSarray array] 和 @[] 的类型是__NSArray0//只有一个元素的数组类型 __NSSingleObjectArrayI,// 其他的大部分是//__NSArrayI,// 对于NSMutableArray ：//[NSMutableDictionary dictionary] 和 @[].mutableCopy__NSArrayM// 对于NSDictionary: ://[NSDictionary dictionary];。 @&#123;&#125;; __NSDictionary0// 其他一般是 __NSDictionaryI// 对于NSMutableDictionary: :// 一般用到的是 __NSDictionaryM 4 NSNotification Crash出现原因在 iOS8 及以下的操作系统中添加的观察者一般需要在 dealloc 的时候做移除，如果开发者忘记移除，则在发送通知的时候会导致 Crash，而在 iOS9 上即使移忘记除也无所谓，猜想可能是 iOS9 之后系统将通知中心持有对象由 assign 变为了weak。 解决办法所以这里两种解决办法 类似 KVO 中间加上 Proxy 层，使用 weak 指针来持有对象 在 dealloc 的时候将未被移除的观察者移除 这里我们使用 iOS 界的毒瘤-MethodSwizzling一文中到的方法。 5 NSNull Crash出现原因虽然 Objecttive-C 不允许开发者将 nil 放进容器内，但是另外一个代表用户态 空 的类 NSNull 却可以放进容器，但令人不爽的是这个类的实例，并不能响应任何方法。 容器中出现 NSNull 一般是 API 接口返回了含有 null 的 JSON �数据，调用方通常将其理解为 NSNumber，NSString，NSDictionary 和 NSArray。 这时开发者如果没有做好防御 一旦对 NSNull 这个类型调用任何方法都会出现 unrecongized selector 错误。 解决办法我们在 NSNull 的转发方法中可以判断�上面的四种类型是否可以解析。如果可以解析直接将其转发给�这几种对象，如果不能则调用父类的默认实现。 123456789101112131415XXStaticHookClass(NSNull, ProtectNull, id, @selector(forwardingTargetForSelector:), (SEL) aSelector) &#123; static NSArray *sTmpOutput = nil; if (sTmpOutput == nil) &#123; sTmpOutput = @[@&quot;&quot;, @0, @[], @&#123;&#125;]; &#125; for (id tmpObj in sTmpOutput) &#123; if ([tmpObj respondsToSelector:aSelector]) &#123; return tmpObj; &#125; &#125; return XXHookOrgin(aSelector);&#125;XXStaticHookEnd 6. NSTimer Crash出现原因在使用 + (NSTimer *)scheduledTimerWithTimeInterval:(NSTimeInterval)ti target:(id)aTarget selector:(SEL)aSelector userInfo:(nullable id)userInfo repeats:(BOOL)yesOrNo 创建定时任务的时候，target� 一般都会持有 timer，timer又会持有 target 对象，在我们没有正确关闭定时器的时候，timer 会一直持有target 导致内存泄漏。 解决办法同 KVO 一样，既然 timer 和 target 直接交互容易出现问题，我们就再找个代理将 target 和 selctor 等信息保存到 Proxy 里，并且是弱引用 target。这样避免因为循环引用造成的内存泄漏。然后在触发真正 target 事件的时候如果 target 置为 nil 了这时候手动去关闭定时器。 12345678910111213141516171819202122232425262728293031323334353637383940XXStaticHookMetaClass(NSTimer, ProtectTimer, NSTimer * ,@selector(scheduledTimerWithTimeInterval:target:selector:userInfo:repeats:), (NSTimeInterval)ti , (id)aTarget, (SEL)aSelector, (id)userInfo, (BOOL)yesOrNo ) &#123; if (yesOrNo) &#123; NSTimer *timer = nil ; @autoreleasepool &#123; XXTimerProxy *proxy = [XXTimerProxy new]; proxy.target = aTarget; proxy.aSelector = aSelector; timer.timerProxy = proxy; timer = XXHookOrgin(ti, proxy, @selector(trigger:), userInfo, yesOrNo); proxy.sourceTimer = timer; &#125; return timer; &#125; return XXHookOrgin(ti, aTarget, aSelector, userInfo, yesOrNo);&#125;XXStaticHookEnd@implementation XXTimerProxy- (void)trigger:(id)userinfo &#123; id strongTarget = self.target; if (strongTarget &amp;&amp; ([strongTarget respondsToSelector:self.aSelector])) &#123;#pragma clang diagnostic push#pragma clang diagnostic ignored &quot;-Warc-performSelector-leaks&quot; [strongTarget performSelector:self.aSelector withObject:userinfo];#pragma clang diagnostic pop &#125; else &#123; NSTimer *sourceTimer = self.sourceTimer; if (sourceTimer) &#123; [sourceTimer invalidate]; &#125; NSString *reason = [NSString stringWithFormat:@&quot;*****Warning***** logic error target is %@ method is %@, reason : an object dealloc not invalidate Timer.&quot;, [self class], NSStringFromSelector(self.aSelector)]; [XXRecord recordFatalWithReason:reason userinfo:nil errorType:(EXXShieldTypeTimer)]; &#125;&#125;@end 7. 野指针 Crash出现原因一般在单线程条件下使用 ARC 正确的处理引用关系野指针出现的并不频繁， 但是多线程下则不尽然，通常在一个线程中释放了对象，�另外一个线程还没有更新指针状态 后续访问就可能会造成随机性 bug。 之所以是随机 bug 是因为被回收的内存不一定立马被使用。而且崩溃的位置可能也与原来的逻辑相聚很远，因此收集的堆栈信息也可能是杂乱无章没有什么价值。具体的分类请看Bugly整理的脑图。 x 更多关于野指针的文章请参考: 如何定位Obj-C野指针随机Crash(一) 如何定位Obj-C野指针随机Crash(二) 如何定位Obj-C野指针随机Crash(三) 解决办法这里我们可以借用系统的NSZombies对象的设计。参考buildNSZombie 解决过程 建立白名单机制，由于系统的类基本不会出现野指针，而且 hook 所有的类开销较大。所以我们只过滤开发者自定义的类。 hook dealloc 方法 这些需要保护的类我们并不让其释放，而是调用objc_desctructInstance 方法释放实例内部所持有属性的引用和关联对象。 利用 object_setClass(id，Class) 修改 isa 指针将其指向一个Proxy 对象(类比�系统的 KVO 实现)，此 Proxy 实现了一个和前面所说的智能转发类一样的 return 0的函数。 在 Proxy 对象内的 - (void)forwardInvocation:(NSInvocation *)anInvocation 中收集 Crash 信息。 缓存的对象是有成本的，我们在缓存对象到达一定数量时候将其释放(object_dispose)。 存在问题 延迟释放内存会造成性能浪费，所以默认缓存会造成野指针的Class实例的对象限制是50，超出之后会释放，如果这时候再此触发了刚好释放掉的野指针，还是会造成Crash的， 建议使用的时候如果近期没有野指针的Crash可以不必开启，如果野指针类型的Crash突然增多，可以考虑在 hot Patch 中开启野指针防护，待收取异常信息之后，再关闭此开关。 收集信息由于希望此库没有任何外部依赖，所以并未实现响应的上报逻辑。使用者如果需要上报信息 只需要自行实现 XXRecordProtocol 即可，然后在开启 SDK 之前将其注册进入 SDK。在实现方法里面会接收到 XXShield 内部定义的错误信息。开发者无论可以使用诸如 CrashLytics，友盟， bugly等第三库，或者自行 dump堆栈信息都可。 12345@protocol XXRecordProtocol &lt;NSObject&gt;- (void)recordWithReason:(NSError * )reason userInfo:(NSDictionary *)userInfo;@end 使用方法示例工程12345git clone git@github.com:ValiantCat/XXShield.gitcd Examplepod install open XXShield.xcworkspace Install12pod &quot;XXShield&quot; Usage12345678910111213141516171819202122232425262728/** 注册汇报中心 @param record 汇报中心 */+ (void)registerRecordHandler:(id&lt;XXRecordProtocol&gt;)record;/** 注册SDK，默认只要开启就打开防Crash，如果需要DEBUG关闭，请在调用处使用条件编译 本注册方式不包含EXXShieldTypeDangLingPointer类型 */+ (void)registerStabilitySDK;/** 本注册方式不包含EXXShieldTypeDangLingPointer类型 @param ability ability */+ (void)registerStabilityWithAbility:(EXXShieldType)ability;/** ///注册EXXShieldTypeDangLingPointer需要传入存储类名的array，暂时请不要传入系统框架类 @param ability ability description @param classNames 野指针类列表 */+ (void)registerStabilityWithAbility:(EXXShieldType)ability withClassNames:(nonnull NSArray&lt;NSString *&gt; *)classNames; ChangeLogChangeLog 单元测试相关的单元测试在示例工程的Test Target下，有兴趣的开发者可以自行查看。并且已经接入 TrivisCI保证了�代码质量。 �Bug&amp;Feature如果有相关的 Bug 请提 Issue。 如果觉得可以扩充新的防护类型，请提 PR 给我。 作者�ValiantCat, 519224747@qq.com个人博客南栀倾寒的简书 LicenseXXShield 使用 Apache-2.0 开源协议. 作者：南栀倾寒链接：https://www.jianshu.com/p/f18876bbe2c4來源：简书著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。]]></content>
      <categories>
        <category>performance</category>
      </categories>
      <tags>
        <tag>crash防护</tag>
        <tag>XXShield</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SDWebImage4.0源码阅读]]></title>
    <url>%2F2018%2F04%2F24%2FSDWebImage4-0%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%2F</url>
    <content type="text"><![CDATA[参拜一下SDWebImage的源码。并不是说一定要读如何如何、只是觉得源码的阅读是一种很好的学习方式。无论从架构还是技术点方面。 目录 常见疑问(面试大全？) 磁盘目录位于哪里？ 最大并发数、超时时长？ 图片如何命名？ 如何识别图片类型? 所查找到的图片的来源? 所有下载的图片都将被写入缓存？磁盘呢？何时缓存的？ 磁盘缓存的时长？清理操作的时间点？ 磁盘清理的原则？ 下载图片时、会使用缓存协议么? 下载图片的URL必须是NSURL么？ 读取缓存以及读取磁盘的时候如何保证线程安全？ 相关知识点 NS_OPTIONS枚举与位运算 内联函数 准备工作 工作原理 业务层级 核心代码(正常读取下载图片) 最上层：UIView+WebCache 逻辑层：SDWebImageManager 业务层： 缓存&amp;&amp;磁盘操作(SDImageCache) 下载操作(SDWebImageDownloader) 一些启发 分层的接口API设计 线程安全 内联函数 精细的缓存管理原则 回调设计 常见疑问(面试大全？)虽然我更推荐阅读源码、可如果实在没时间。这一段只要花费几分钟。我还是比较喜欢把干货放在前面、方便伸手党(比如我)。不过也不能保证涵盖全部问题、欢迎留言。 磁盘目录位于哪里？ 缓存在磁盘沙盒目录下 Library/Caches二级目录为~/Library/Caches/default/com.hackemist.SDWebImageCache.default 12345678910111213141516171819202122232425- (instancetype)init &#123; return [self initWithNamespace:@&quot;default&quot;]; // ~Library/Caches/default&#125;- (nonnull instancetype)initWithNamespace:(nonnull NSString *)ns &#123; NSString *path = [self makeDiskCachePath:ns]; return [self initWithNamespace:ns diskCacheDirectory:path];&#125;- (nonnull instancetype)initWithNamespace:(nonnull NSString *)ns diskCacheDirectory:(nonnull NSString *)directory &#123; if ((self = [super init])) &#123; NSString *fullNamespace = [@&quot;com.hackemist.SDWebImageCache.&quot; stringByAppendingString:ns] // Init the disk cache if (directory != nil) &#123; _diskCachePath = [directory stringByAppendingPathComponent:fullNamespace]; &#125; else &#123; NSString *path = [self makeDiskCachePath:ns]; _diskCachePath = path; &#125;// _diskCachePath = ~/Library/Caches/default/com.hackemist.SDWebImageCache.default&#125; 你也可以通过[[SDImageCache sharedImageCache] addReadOnlyCachePath:bundledPath];来自定义一个路径。 但这个路径不会被存储使用、是给开发者自定义预装图片的路径。 最大并发数、超时时长？ 123_downloadQueue = [NSOperationQueue new];_downloadQueue.maxConcurrentOperationCount = 6;_downloadTimeout = 15.0; 图片如何命名？ 这里写入缓存和写入磁盘是不同的。写入缓存时、直接用图片url作为key 123//写入缓存NSUInteger cost = SDCacheCostForImage(image);[self.memCache setObject:image forKey:key cost:cost]; 写入磁盘时、用url的MD5编码作为key。可以防止文件名过长 12345678910111213141516- (nullable NSString *)cachedFileNameForKey:(nullable NSString *)key &#123; const char *str = key.UTF8String; if (str == NULL) &#123; str = &quot;&quot;; &#125; unsigned char r[CC_MD5_DIGEST_LENGTH]; CC_MD5(str, (CC_LONG)strlen(str), r); NSURL *keyURL = [NSURL URLWithString:key]; NSString *ext = keyURL ? keyURL.pathExtension : key.pathExtension; NSString *filename = [NSString stringWithFormat:@&quot;%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%@&quot;, r[0], r[1], r[2], r[3], r[4], r[5], r[6], r[7], r[8], r[9], r[10], r[11], r[12], r[13], r[14], r[15], ext.length == 0 ? @&quot;&quot; : [NSString stringWithFormat:@&quot;.%@&quot;, ext]]; return filename; //key == https://gss2.bdstatic.com/-fo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=034361ab922397ddc274905638ebd9d2/d31b0ef41bd5ad64dddebb.jpg; //filename == f029945f95894e152771806785bc4f18.jpg;&#125; 如何识别图片类型? 通过NSData数据的第一个字符进行判断。 1234567891011121314151617181920212223242526272829303132333435363738394041424344+ (SDImageFormat)sd_imageFormatForImageData:(nullable NSData *)data &#123; if (!data) &#123; return SDImageFormatUndefined; &#125; // File signatures table: http://www.garykessler.net/library/file_sigs.html uint8_t c; [data getBytes:&amp;c length:1]; switch (c) &#123; case 0xFF: return SDImageFormatJPEG; case 0x89: return SDImageFormatPNG; case 0x47: return SDImageFormatGIF; case 0x49: case 0x4D: return SDImageFormatTIFF; case 0x52: &#123; if (data.length &gt;= 12) &#123; //RIFF....WEBP NSString *testString = [[NSString alloc] initWithData:[data subdataWithRange:NSMakeRange(0, 12)] encoding:NSASCIIStringEncoding]; if ([testString hasPrefix:@&quot;RIFF&quot;] &amp;&amp; [testString hasSuffix:@&quot;WEBP&quot;]) &#123; return SDImageFormatWebP; &#125; &#125; break; &#125; case 0x00: &#123; if (data.length &gt;= 12) &#123; //....ftypheic ....ftypheix ....ftyphevc ....ftyphevx NSString *testString = [[NSString alloc] initWithData:[data subdataWithRange:NSMakeRange(4, 8)] encoding:NSASCIIStringEncoding]; if ([testString isEqualToString:@&quot;ftypheic&quot;] || [testString isEqualToString:@&quot;ftypheix&quot;] || [testString isEqualToString:@&quot;ftyphevc&quot;] || [testString isEqualToString:@&quot;ftyphevx&quot;]) &#123; return SDImageFormatHEIC; &#125; &#125; break; &#125; &#125; return SDImageFormatUndefined;&#125; 所查找到的图片的来源? 1234567891011121314typedef NS_ENUM(NSInteger, SDImageCacheType) &#123; /** * 从网上下载 */ SDImageCacheTypeNone, /** * 从磁盘获得 */ SDImageCacheTypeDisk, /** * 从内存获得 */ SDImageCacheTypeMemory&#125;; 所有下载的图片都将被写入缓存？磁盘呢？何时缓存的？ 磁盘不是强制写入。从枚举SDWebImageOptions可见 1234567typedef NS_OPTIONS(NSUInteger, SDWebImageOptions) &#123; /** * 禁用磁盘缓存 */ SDWebImageCacheMemoryOnly = 1 &lt;&lt; 2,&#125; 而Memory缓存应该是必须写入的(因为我并没找到哪里可以禁止)。缓存的时间点、有两个(开发者也可以主动缓存)、且都是由SDWebImageManager进行。其一是下载成功后、自动保存。或者开发者通过代理处理图片并返回后缓存 123456789101112131415- (nullable UIImage *)imageManager:(nonnull SDWebImageManager *)imageManager transformDownloadedImage:(nullable UIImage *)image withURL:(nullable NSURL *)imageURL;=========&gt;&gt;SDWebImageManager//获取转换用户后的图片UIImage *transformedImage = [self.delegate imageManager:self transformDownloadedImage:downloadedImage withURL:url];//用户处理成功if (transformedImage &amp;&amp; finished) &#123; BOOL imageWasTransformed = ![transformedImage isEqual:downloadedImage]; //用户处理的后若未生成新的图片、则保存下载的二进制文件。 //不然则由imageCache内部生成二进制文件保存 [self.imageCache storeImage:transformedImage imageData:(imageWasTransformed ? nil : downloadedData) forKey:key toDisk:cacheOnDisk completion:nil];&#125; 其二是当缓存中没有、但是从硬盘中查询到了图片。 12345678910111213141516@autoreleasepool &#123; //搜索硬盘 NSData *diskData = [self diskImageDataBySearchingAllPathsForKey:key]; UIImage *diskImage = [self diskImageForKey:key]; //缓存到内存、默认为YES if (diskImage &amp;&amp; self.config.shouldCacheImagesInMemory) &#123; NSUInteger cost = SDCacheCostForImage(diskImage); //使用NSChache缓存。 [self.memCache setObject:diskImage forKey:key cost:cost]; &#125; if (doneBlock) &#123; dispatch_async(dispatch_get_main_queue(), ^&#123; doneBlock(diskImage, diskData, SDImageCacheTypeDisk); &#125;); &#125;&#125; 磁盘缓存的时长？清理操作的时间点？ 默认为一周1static const NSInteger kDefaultCacheMaxCacheAge = 60 * 60 * 24 * 7; // 1 week 能够以时间清除磁盘的方法为 1- (void)deleteOldFilesWithCompletionBlock:(nullable SDWebImageNoParamsBlock)completionBlock; 调用的时机为 12345678[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(deleteOldFiles) name:UIApplicationWillTerminateNotification object:nil]; [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(backgroundDeleteOldFiles) name:UIApplicationDidEnterBackgroundNotification object:nil]; 也就是当程序退出到后台、或者被杀死的时候。这里、还有另外一个点。Long-Running Task任务 12345678910111213141516171819202122- (void)backgroundDeleteOldFiles &#123; Class UIApplicationClass = NSClassFromString(@&quot;UIApplication&quot;); if(!UIApplicationClass || ![UIApplicationClass respondsToSelector:@selector(sharedApplication)]) &#123; return; &#125; UIApplication *application = [UIApplication performSelector:@selector(sharedApplication)]; //后台任务标识--注册一个后台任务 __block UIBackgroundTaskIdentifier bgTask = [application beginBackgroundTaskWithExpirationHandler:^&#123; //超时（大概150秒？）自动结束后台任务 //结束后台任务 [application endBackgroundTask:bgTask]; bgTask = UIBackgroundTaskInvalid; &#125;]; [self deleteOldFilesWithCompletionBlock:^&#123; //结束后台任务 [application endBackgroundTask:bgTask]; bgTask = UIBackgroundTaskInvalid; &#125;];&#125; 正常程序在进入后台后、虽然可以继续执行任务。但是在时间很短内就会被挂起待机。Long-Running可以让系统为app再多分配一些时间来处理一些耗时任务。 磁盘清理的原则？ 首先、通过时间进行清理。（最后修改时间&gt;一周）然后、根据占据内存大小进行清理。（如果占据内存大于上限、则按时间排序、删除到上限的1/2。）这里我并没有看到使用频率优先级判断、所以应该是没有。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687- (void)deleteOldFilesWithCompletionBlock:(nullable SDWebImageNoParamsBlock)completionBlock &#123; //异步清理超时图片 dispatch_async(self.ioQueue, ^&#123; //获取磁盘目录 NSURL *diskCacheURL = [NSURL fileURLWithPath:self.diskCachePath isDirectory:YES]; //NSURLIsDirectoryKey 判断是否为目录 //NSURLContentModificationDateKey 判断最后修改时间 //NSURLTotalFileAllocatedSizeKey 判断文件大小 NSArray&lt;NSString *&gt; *resourceKeys = @[NSURLIsDirectoryKey, NSURLContentModificationDateKey, NSURLTotalFileAllocatedSizeKey]; //模具器--遍历磁盘路径下的文件 NSDirectoryEnumerator *fileEnumerator = [_fileManager enumeratorAtURL:diskCacheURL includingPropertiesForKeys:resourceKeys options:NSDirectoryEnumerationSkipsHiddenFiles errorHandler:NULL]; //计算一周前(需要释放)、的时间 NSDate *expirationDate = [NSDate dateWithTimeIntervalSinceNow:-self.config.maxCacheAge]; //保存缓存文件Dic NSMutableDictionary&lt;NSURL *, NSDictionary&lt;NSString *, id&gt; *&gt; *cacheFiles = [NSMutableDictionary dictionary]; //缓存总大小 NSUInteger currentCacheSize = 0; //需要删除的url路径 NSMutableArray&lt;NSURL *&gt; *urlsToDelete = [[NSMutableArray alloc] init]; //遍历磁盘文件枚举器 for (NSURL *fileURL in fileEnumerator) &#123; NSError *error; //获取每个文件所对应的三个参数（resourceKeys） NSDictionary&lt;NSString *, id&gt; *resourceValues = [fileURL resourceValuesForKeys:resourceKeys error:&amp;error]; // Skip directories and errors. if (error || !resourceValues || [resourceValues[NSURLIsDirectoryKey] boolValue]) &#123; //如果是文件夹则跳过 continue; &#125; // Remove files that are older than the expiration date; NSDate *modificationDate = resourceValues[NSURLContentModificationDateKey]; if ([[modificationDate laterDate:expirationDate] isEqualToDate:expirationDate]) &#123; //如果时间超过指定日期、加入删除数组。跳过 [urlsToDelete addObject:fileURL]; continue; &#125; //获取文件大小、并且把路径与大小存入字典。 // Store a reference to this file and account for its total size. NSNumber *totalAllocatedSize = resourceValues[NSURLTotalFileAllocatedSizeKey]; currentCacheSize += totalAllocatedSize.unsignedIntegerValue; cacheFiles[fileURL] = resourceValues; &#125; //遍历删除文件 for (NSURL *fileURL in urlsToDelete) &#123; [_fileManager removeItemAtURL:fileURL error:nil]; &#125; //如果剩余文件大小仍超过阈值 //优先删除最老的文件 if (self.config.maxCacheSize &gt; 0 &amp;&amp; currentCacheSize &gt; self.config.maxCacheSize) &#123; // Target half of our maximum cache size for this cleanup pass. const NSUInteger desiredCacheSize = self.config.maxCacheSize / 2; // 将剩余的文件按修改时间排序 NSArray&lt;NSURL *&gt; *sortedFiles = [cacheFiles keysSortedByValueWithOptions:NSSortConcurrent usingComparator:^NSComparisonResult(id obj1, id obj2) &#123; return [obj1[NSURLContentModificationDateKey] compare:obj2[NSURLContentModificationDateKey]]; &#125;]; // 删除文件 for (NSURL *fileURL in sortedFiles) &#123; if ([_fileManager removeItemAtURL:fileURL error:nil]) &#123; NSDictionary&lt;NSString *, id&gt; *resourceValues = cacheFiles[fileURL]; NSNumber *totalAllocatedSize = resourceValues[NSURLTotalFileAllocatedSizeKey]; currentCacheSize -= totalAllocatedSize.unsignedIntegerValue; //直到低于阈值的二分之一 if (currentCacheSize &lt; desiredCacheSize) &#123; break; &#125; &#125; &#125; &#125; //回调给主线程 if (completionBlock) &#123; dispatch_async(dispatch_get_main_queue(), ^&#123; completionBlock(); &#125;); &#125; &#125;);&#125; 下载图片时、会使用网络协议缓存逻辑么? 默认情况下不会、由以下代码可见。 1234NSURLRequestCachePolicy cachePolicy = options &amp; SDWebImageDownloaderUseNSURLCache ? NSURLRequestUseProtocolCachePolicy : NSURLRequestReloadIgnoringLocalCacheData; NSMutableURLRequest *request = [[NSMutableURLRequest alloc] initWithURL:url cachePolicy:cachePolicy timeoutInterval:timeoutInterval]; 除非将options配置成SDWebImageDownloaderUseNSURLCache、否则每次都会从原地址重新下载、而不是用网络协议的缓存逻辑。 下载图片的URL必须是NSURL么？ 不是、在SDWebImageManager中有过容错处理。所以即便你传入一个字符串、依旧可以正确的查找。 1234567if ([url isKindOfClass:NSString.class]) &#123; url = [NSURL URLWithString:(NSString *)url]; &#125; if (![url isKindOfClass:NSURL.class]) &#123; url = nil; &#125; 但是由于API暴露出的是(nullable NSURL *)、如果你传入字符串、会有黄色警告 读取缓存以及读取磁盘的时候如何保证线程安全？ 读取缓存读取缓存的时候是在主线程进行。由于使用NSCache进行存储、所以不需要担心单个value对象的线程安全。 读取磁盘磁盘的读取虽然创建了一个NSOperation对象、但据我所见这个对象只是用来标记该操作是否被取消、以及取消之后不再读取磁盘文件的作用。真正的磁盘缓存是在另一个IO专属线程中的一个串行队列下进行的。如果你搜索self.ioQueue还能发现、不只是读取磁盘内容。包括删除、写入等所有磁盘内容都是在这个IO线程进行、以保证线程安全。但计算大小、获取文件总数等操作。则是在主线程进行。 12345678910111213141516171819202122232425262728_ioQueue = dispatch_queue_create(&quot;com.hackemist.SDWebImageCache&quot;, DISPATCH_QUEUE_SERIAL);==========&gt;&gt;&gt;&gt;&gt;&lt;&lt;&lt;&lt;&lt;&lt;===========NSOperation *operation = [NSOperation new]; dispatch_async(self.ioQueue, ^&#123; if (operation.isCancelled) &#123; // do not call the completion if cancelled return; &#125; @autoreleasepool &#123; //搜索硬盘 NSData *diskData = [self diskImageDataBySearchingAllPathsForKey:key]; UIImage *diskImage = [self diskImageForKey:key]; //缓存到内存、默认为YES if (diskImage &amp;&amp; self.config.shouldCacheImagesInMemory) &#123; NSUInteger cost = SDCacheCostForImage(diskImage); //使用NSChache缓存。 [self.memCache setObject:diskImage forKey:key cost:cost]; &#125; if (doneBlock) &#123; dispatch_async(dispatch_get_main_queue(), ^&#123; doneBlock(diskImage, diskData, SDImageCacheTypeDisk); &#125;); &#125; &#125; &#125;); return operation; 相关知识点如果对一些知识点不了解、可能对代码理解造成困扰。列举一下。 NS_OPTIONS枚举与位运算 上文中的SDWebImageOptions便是一个位移枚举 123456789101112131415typedef NS_OPTIONS(NSUInteger, SDWebImageOptions) &#123; SDWebImageRetryFailed = 1 &lt;&lt; 0, SDWebImageLowPriority = 1 &lt;&lt; 1, SDWebImageCacheMemoryOnly = 1 &lt;&lt; 2, SDWebImageProgressiveDownload = 1 &lt;&lt; 3, SDWebImageRefreshCached = 1 &lt;&lt; 4, SDWebImageContinueInBackground = 1 &lt;&lt; 5, SDWebImageHandleCookies = 1 &lt;&lt; 6, SDWebImageAllowInvalidSSLCertificates = 1 &lt;&lt; 7, SDWebImageHighPriority = 1 &lt;&lt; 8, SDWebImageDelayPlaceholder = 1 &lt;&lt; 9, SDWebImageTransformAnimatedImage = 1 &lt;&lt; 10, SDWebImageAvoidAutoSetImage = 1 &lt;&lt; 11, SDWebImageScaleDownLargeImages = 1 &lt;&lt; 12&#125;; 和我们普通用的枚举 12345typedef NS_ENUM(NSInteger, SDImageCacheType) &#123; SDImageCacheTypeNone, SDImageCacheTypeDisk, SDImageCacheTypeMemory&#125;; 从表面看有两点不同： 枚举声明：NS_ENUM&amp;&amp; NS_OPTIONS其实从定义的效果上来讲、二者作用相同。更多的是语义化的角度。前者是普通枚举、后者是位移枚举。 枚举中的位运算符号&lt;&lt;.位运算中、有三种基本运算符号. 按位与”&amp;” 只有对应的两个二进位均为1时，结果位才为1，否则为0比如9&amp;5，其实就是1001&amp;0101=0001，因此9&amp;5=1&gt;二进制中，与1相&amp;就保持原位，与0相&amp;就为0 按位或”|” 只要对应的二个二进位有一个为1时，结果位就为1，否则为0。比如9|5，其实就是1001|0101=1101，因此9|5=13 左移”&lt;&lt;” 把整数a的各二进位全部左移n位，高位丢弃，低位补0。左移n位其实就是乘以2的n次方。例如1&lt;&lt;2 就是0001左移2为0100，因此1&lt;&lt;2=4 于是、在使用位移枚举的时候、我们就有了这种写法：1options:SDWebImageRetryFailed | SDWebImageCacheMemoryOnly]; 上面的意思是。这个操作是如果失败了需要重试、并且只写入缓存。其中 options=SDWebImageRetryFailed | SDWebImageCacheMemoryOnly也就是0b00000001| 0b00000100 = 0b00000101 十进制中 = 5. 在内部判断时候就有了如下写法：12//是否磁盘缓存BOOL cacheOnDisk = !(options &amp; SDWebImageCacheMemoryOnly); 等价于 0101 &amp; 0100 = 0100 结果为真。倘若 1BOOL lowPriority = !(options &amp; SDWebImageLowPriority); 等价于 0101 &amp; 0010 = 0000 结果为假。 内联函数 在写入缓存时、出现了这样一行代码 12NSUInteger cost = SDCacheCostForImage(diskImage);[self.memCache setObject:diskImage forKey:key cost:cost]; 其中SDCacheCostForImage指向一个静态内联函数 1234567FOUNDATION_STATIC_INLINE NSUInteger SDCacheCostForImage(UIImage *image) &#123;#if SD_MAC return image.size.height * image.size.width;#elif SD_UIKIT || SD_WATCH return image.size.height * image.size.width * image.scale * image.scale;#endif&#125; 其中FOUNDATION_STATIC_INLINE作为宏指向static inline、所以也等价于 1234567static __inline__ NSUInteger SDCacheCostForImage(UIImage *image) &#123;#if SD_MAC return image.size.height * image.size.width;#elif SD_UIKIT || SD_WATCH return image.size.height * image.size.width * image.scale * image.scale;#endif&#125; 用宏写方法、我们都用过。但是表达式形式的宏定义有一定的弊端。（比如参数检查、越界等等）。 内联函数完全可以取代表达式形式的宏定义。顺便谈谈为什么要用内联函数吧。 效率来看 函数之间调用，是内存地址之间的调用、当函数调用完毕之后还会返回原来函数执行的地址。函数调用将会有时间开销。 内联函数在汇编中没有call语句。取消了函数的参数压栈 相比表达式形式的宏定义 需要预编译.因为inline内联函数也是函数、不需要预编译。 调用时候会首先检查它的参数的类型、保证调用正确。 可以使用所在类的保护成员及私有成员。 需要注意的是 内联函数中尽量不要使用诸如循环语句等大量代码、可能会导致编译器放弃内联动作。 内联函数的定义须在调用之前。 准备工作随手下载了一个最新的 (4.2.3) GitHub1234567891011121314PODS:- SDWebImage (4.2.3):- SDWebImage/Core (= 4.2.3)- SDWebImage/Core (4.2.3)DEPENDENCIES:- SDWebImageSPEC CHECKSUMS:SDWebImage: 791bb72962b3492327ddcac4b1880bd1b5458431PODFILE CHECKSUM: 7fbc0b76fb4d0b0b2afa7d3a90b7bd68dea25abbCOCOAPODS: 1.3.1 工作原理引用GitHub上一个导图 1、外部API入口。通过UIImageView+WebCache 的 sd_setImageWithURL方法(等)作为入口来加载图片。 2、内部API汇总。通过UIView+WebCache的’sd_internalSetImageWithURL’对UIImageView、UIButton 、MKAnnotationView中图片的下载请求进行汇总。 3、开始加载图片。通过SDWebImageManager的loadImageWithURL对图片进行加载。 4、查找本地通过SDImageCache的queryCacheOperationForKey查找缓存中是否存在图片。如果不存在再通过diskImageDataBySearchingAllPathsForKey进行磁盘搜索。 5、返回本地图片给SDWebImageManager 6、下载图片如果本地查询不到对应图片、则通过SDImageDownloader的downloadImage进行图片下载。 7、下载完毕返回图片给SDWebImageManager 8、由UIView+WebCache通过storeImage将下载图片保存本地 9、返回图片给UIView+WebCache 10、设置图片其中。 业务层级 整个架构简单分为三层。 最上层：负责业务的接入、图片的插入 12345#import &quot;UIImageView+WebCache.h&quot;#import &quot;UIButton+WebCache.h&quot;#import &quot;UIImageView+HighlightedWebCache.h&quot;//以及其汇总的#import &quot;UIView+WebCache.h&quot; 逻辑层负责不同类型业务的分发。读取(或写入)缓存(或磁盘)、下载等具体逻辑处理。 1#import &quot;SDWebImageManager.h&quot; 业务层负责具体业务的实现 1234//缓存&amp;&amp;磁盘操作#import &quot;SDImageCache.h&quot;//下载操作#import &quot;SDWebImageDownloader.h&quot; 当然、还有其他的工具类。但主要的、就是上面几个。 核心代码（正常读取下载图片） 最上层：UIView+WebCache 所有的代码最终都会汇总到 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131#import &quot;UIView+WebCache.h&quot;/** * @param url 图片地址链接 * @param placeholder 占位图 * @param options 下载图片的枚举。包括优先级、是否写入硬盘等 * @param operationKey 一个记录当前对象正在加载操作的key、保证只有最新的操作在进行、默认为类名。 所以如果你想下载多个图片并且都展示一下、可以尝试自定义几个operationKey来操作。（我猜） * @param setImageBlock 给开发者自定义set图片的callback * @param progressBlock 下载进度callback * @param completedBlock 下载完成的callback（sd已经给你set好了、只是会把图片给你罢了） * @param context 一些额外的上下文字典。比如你可以搞一个专属的imageManager进来干活。 */- (void)sd_internalSetImageWithURL:(nullable NSURL *)url placeholderImage:(nullable UIImage *)placeholder options:(SDWebImageOptions)options operationKey:(nullable NSString *)operationKey setImageBlock:(nullable SDSetImageBlock)setImageBlock progress:(nullable SDWebImageDownloaderProgressBlock)progressBlock completed:(nullable SDExternalCompletionBlock)completedBlock context:(nullable NSDictionary *)context &#123; //以当前实例的class作为OperationKey NSString *validOperationKey = operationKey ?: NSStringFromClass([self class]); //清除当前OperationKey下正在进行的操作。节省无用功 [self sd_cancelImageLoadOperationWithKey:validOperationKey]; //给对象实例绑定imageURLKey = url objc_setAssociatedObject(self, &amp;imageURLKey, url, OBJC_ASSOCIATION_RETAIN_NONATOMIC); //是否先加载占位图 if (!(options &amp; SDWebImageDelayPlaceholder)) &#123; if ([context valueForKey:SDWebImageInternalSetImageGroupKey]) &#123; dispatch_group_t group = [context valueForKey:SDWebImageInternalSetImageGroupKey]; dispatch_group_enter(group); &#125; //到主线城更新UI dispatch_main_async_safe(^&#123; //set 占位图 [self sd_setImage:placeholder imageData:nil basedOnClassOrViaCustomSetImageBlock:setImageBlock]; &#125;); &#125; if (url) &#123; // 小菊花 if ([self sd_showActivityIndicatorView]) &#123; [self sd_addActivityIndicator]; &#125; // 允许开发者指定一个manager来进行操作 SDWebImageManager *manager; if ([context valueForKey:SDWebImageExternalCustomManagerKey]) &#123; manager = (SDWebImageManager *)[context valueForKey:SDWebImageExternalCustomManagerKey]; &#125; else &#123; manager = [SDWebImageManager sharedManager]; &#125; __weak __typeof(self)wself = self; id &lt;SDWebImageOperation&gt; operation = [manager loadImageWithURL:url options:options progress:progressBlock completed:^(UIImage *image, NSData *data, NSError *error, SDImageCacheType cacheType, BOOL finished, NSURL *imageURL) &#123; //图片下载||读取完成 __strong __typeof (wself) sself = wself; //小菊花 [sself sd_removeActivityIndicator]; if (!sself) &#123; return; &#125; BOOL shouldCallCompletedBlock = finished || (options &amp; SDWebImageAvoidAutoSetImage); //是否不插入图片 //1、有图片、但是主动配置 //2、没图片、设置了延迟加载占位图 BOOL shouldNotSetImage = ((image &amp;&amp; (options &amp; SDWebImageAvoidAutoSetImage)) || (!image &amp;&amp; !(options &amp; SDWebImageDelayPlaceholder))); SDWebImageNoParamsBlock callCompletedBlockClojure = ^&#123; // if (!sself) &#123; return; &#125; if (!shouldNotSetImage) &#123; [sself sd_setNeedsLayout]; &#125; if (completedBlock &amp;&amp; shouldCallCompletedBlock) &#123; //操作完成的回调 completedBlock(image, error, cacheType, url); &#125; &#125;; // case 1a: we got an image, but the SDWebImageAvoidAutoSetImage flag is set // OR // case 1b: we got no image and the SDWebImageDelayPlaceholder is not set if (shouldNotSetImage) &#123; //如果不显示图片、直接回调。 dispatch_main_async_safe(callCompletedBlockClojure); return; &#125; /**自动插入图片***/ UIImage *targetImage = nil; NSData *targetData = nil; if (image) &#123; // case 2a: we got an image and the SDWebImageAvoidAutoSetImage is not set targetImage = image; targetData = data; &#125; else if (options &amp; SDWebImageDelayPlaceholder) &#123; // case 2b: we got no image and the SDWebImageDelayPlaceholder flag is set targetImage = placeholder; targetData = nil; &#125; if ([context valueForKey:SDWebImageInternalSetImageGroupKey]) &#123; dispatch_group_t group = [context valueForKey:SDWebImageInternalSetImageGroupKey]; dispatch_group_enter(group); dispatch_main_async_safe(^&#123; [sself sd_setImage:targetImage imageData:targetData basedOnClassOrViaCustomSetImageBlock:setImageBlock]; &#125;); // ensure completion block is called after custom setImage process finish dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123; callCompletedBlockClojure(); &#125;); &#125; else &#123; dispatch_main_async_safe(^&#123; [sself sd_setImage:targetImage imageData:targetData basedOnClassOrViaCustomSetImageBlock:setImageBlock]; callCompletedBlockClojure(); &#125;); &#125; &#125;]; //在读取图片之前。向正在进行加载的HashMap中加入当前operation [self sd_setImageLoadOperation:operation forKey:validOperationKey]; &#125; else &#123; dispatch_main_async_safe(^&#123; [self sd_removeActivityIndicator]; if (completedBlock) &#123; NSError *error = [NSError errorWithDomain:SDWebImageErrorDomain code:-1 userInfo:@&#123;NSLocalizedDescriptionKey : @&quot;Trying to load a nil url&quot;&#125;]; completedBlock(nil, error, SDImageCacheTypeNone, url); &#125; &#125;); &#125;&#125; 一个简单的流程图 UIView+WebCache流程图 逻辑层：SDWebImageManager SDWebImage中最核心的类、调度这图片的下载(SDWebImageDownloader)以及缓存(SDImageCache)。 此外、SDWebImageManager并不依托于UIView+WebCache、完全可以单独使用。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169- (id &lt;SDWebImageOperation&gt;)loadImageWithURL:(nullable NSURL *)url options:(SDWebImageOptions)options progress:(nullable SDWebImageDownloaderProgressBlock)progressBlock completed:(nullable SDInternalCompletionBlock)completedBlock &#123; NSAssert(completedBlock != nil, @&quot;If you mean to prefetch the image, use -[SDWebImagePrefetcher prefetchURLs] instead&quot;); //所以、我们并不需要在外部把字符串变为NSURL。 if ([url isKindOfClass:NSString.class]) &#123; url = [NSURL URLWithString:(NSString *)url]; &#125; if (![url isKindOfClass:NSURL.class]) &#123; url = nil; &#125; //下载操作的对象 __block SDWebImageCombinedOperation *operation = [SDWebImageCombinedOperation new]; __weak SDWebImageCombinedOperation *weakOperation = operation; BOOL isFailedUrl = NO; if (url) &#123; @synchronized (self.failedURLs) &#123; //线程安全 isFailedUrl = [self.failedURLs containsObject:url]; &#125; &#125; //url为空 || (未设置失败重试 &amp;&amp; 这个url已经失败过) if (url.absoluteString.length == 0 || (!(options &amp; SDWebImageRetryFailed) &amp;&amp; isFailedUrl)) &#123; //发出一个获取失败的回调 [self callCompletionBlockForOperation:operation completion:completedBlock error:[NSError errorWithDomain:NSURLErrorDomain code:NSURLErrorFileDoesNotExist userInfo:nil] url:url]; return operation; &#125; //将操作添加到正在进行的操作数池 @synchronized (self.runningOperations) &#123; [self.runningOperations addObject:operation]; &#125; //默认就是url作为key、也可以自定义mananger的相关block NSString *key = [self cacheKeyForURL:url]; //通过key、查找本地图片 operation.cacheOperation = [self.imageCache queryCacheOperationForKey:key done:^(UIImage *cachedImage, NSData *cachedData, SDImageCacheType cacheType) &#123; if (operation.isCancelled) &#123; //操作被取消、移除操作池 [self safelyRemoveOperationFromRunning:operation]; return; &#125; //本地没有图片 || 刷新缓存 if ((!cachedImage || options &amp; SDWebImageRefreshCached) &amp;&amp; (![self.delegate respondsToSelector:@selector(imageManager:shouldDownloadImageForURL:)] || [self.delegate imageManager:self shouldDownloadImageForURL:url])) &#123; //有本地图片。但需要被刷新 if (cachedImage &amp;&amp; options &amp; SDWebImageRefreshCached) &#123; //先回调出去本地图片。再继续下载操作 [self callCompletionBlockForOperation:weakOperation completion:completedBlock image:cachedImage data:cachedData error:nil cacheType:cacheType finished:YES url:url]; &#125; //下面是根据调用者传进来的option，来匹配设置了哪些，就给downloaderOptions赋值哪些option SDWebImageDownloaderOptions downloaderOptions = 0; if (options &amp; SDWebImageLowPriority) downloaderOptions |= SDWebImageDownloaderLowPriority; if (options &amp; SDWebImageProgressiveDownload) downloaderOptions |= SDWebImageDownloaderProgressiveDownload; if (options &amp; SDWebImageRefreshCached) downloaderOptions |= SDWebImageDownloaderUseNSURLCache; if (options &amp; SDWebImageContinueInBackground) downloaderOptions |= SDWebImageDownloaderContinueInBackground; if (options &amp; SDWebImageHandleCookies) downloaderOptions |= SDWebImageDownloaderHandleCookies; if (options &amp; SDWebImageAllowInvalidSSLCertificates) downloaderOptions |= SDWebImageDownloaderAllowInvalidSSLCertificates; if (options &amp; SDWebImageHighPriority) downloaderOptions |= SDWebImageDownloaderHighPriority; if (options &amp; SDWebImageScaleDownLargeImages) downloaderOptions |= SDWebImageDownloaderScaleDownLargeImages; if (cachedImage &amp;&amp; options &amp; SDWebImageRefreshCached) &#123; // force progressive off if image already cached but forced refreshing downloaderOptions &amp;= ~SDWebImageDownloaderProgressiveDownload; // ignore image read from NSURLCache if image if cached but force refreshing downloaderOptions |= SDWebImageDownloaderIgnoreCachedResponse; &#125; //下载图片 SDWebImageDownloadToken *subOperationToken = [self.imageDownloader downloadImageWithURL:url options:downloaderOptions progress:progressBlock completed:^(UIImage *downloadedImage, NSData *downloadedData, NSError *error, BOOL finished) &#123; __strong __typeof(weakOperation) strongOperation = weakOperation; if (!strongOperation || strongOperation.isCancelled) &#123; // Do nothing if the operation was cancelled // See #699 for more details // if we would call the completedBlock, there could be a race condition between this block and another completedBlock for the same object, so if this one is called second, we will overwrite the new data &#125; else if (error) &#123; [self callCompletionBlockForOperation:strongOperation completion:completedBlock error:error url:url]; if ( error.code != NSURLErrorNotConnectedToInternet &amp;&amp; error.code != NSURLErrorCancelled &amp;&amp; error.code != NSURLErrorTimedOut &amp;&amp; error.code != NSURLErrorInternationalRoamingOff &amp;&amp; error.code != NSURLErrorDataNotAllowed &amp;&amp; error.code != NSURLErrorCannotFindHost &amp;&amp; error.code != NSURLErrorCannotConnectToHost &amp;&amp; error.code != NSURLErrorNetworkConnectionLost) &#123; @synchronized (self.failedURLs) &#123; //失败记录 [self.failedURLs addObject:url]; &#125; &#125; &#125; else &#123; if ((options &amp; SDWebImageRetryFailed)) &#123; //失败重新下载 @synchronized (self.failedURLs) &#123; //从失败记录移除 [self.failedURLs removeObject:url]; &#125; &#125; //是否磁盘缓存 BOOL cacheOnDisk = !(options &amp; SDWebImageCacheMemoryOnly); if (self != [SDWebImageManager sharedManager] &amp;&amp; self.cacheKeyFilter &amp;&amp; downloadedImage) &#123; //缩放 downloadedImage = [self scaledImageForKey:key image:downloadedImage]; &#125; if (options &amp; SDWebImageRefreshCached &amp;&amp; cachedImage &amp;&amp; !downloadedImage) &#123; //是否需要转换图片 //成功下载图片、自定义实现了图片处理的代理 &#125; else if (downloadedImage &amp;&amp; (!downloadedImage.images || (options &amp; SDWebImageTransformAnimatedImage)) &amp;&amp; [self.delegate respondsToSelector:@selector(imageManager:transformDownloadedImage:withURL:)]) &#123; dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^&#123; //获取转换用户后的图片 UIImage *transformedImage = [self.delegate imageManager:self transformDownloadedImage:downloadedImage withURL:url]; //用户处理成功 if (transformedImage &amp;&amp; finished) &#123; BOOL imageWasTransformed = ![transformedImage isEqual:downloadedImage]; //用户处理的后若未生成新的图片、则保存下载的二进制文件。 //不然则由imageCache内部生成二进制文件保存 [self.imageCache storeImage:transformedImage imageData:(imageWasTransformed ? nil : downloadedData) forKey:key toDisk:cacheOnDisk completion:nil]; &#125; //回调 [self callCompletionBlockForOperation:strongOperation completion:completedBlock image:transformedImage data:downloadedData error:nil cacheType:SDImageCacheTypeNone finished:finished url:url]; &#125;); &#125; else &#123; //下载成功且未自定义代理--默认保存 if (downloadedImage &amp;&amp; finished) &#123; [self.imageCache storeImage:downloadedImage imageData:downloadedData forKey:key toDisk:cacheOnDisk completion:nil]; &#125; [self callCompletionBlockForOperation:strongOperation completion:completedBlock image:downloadedImage data:downloadedData error:nil cacheType:SDImageCacheTypeNone finished:finished url:url]; &#125; &#125; if (finished) &#123; [self safelyRemoveOperationFromRunning:strongOperation]; &#125; &#125;]; @synchronized(operation) &#123; operation.cancelBlock = ^&#123; [self.imageDownloader cancel:subOperationToken]; __strong __typeof(weakOperation) strongOperation = weakOperation; [self safelyRemoveOperationFromRunning:strongOperation]; &#125;; &#125; &#125; else if (cachedImage) &#123; //本地有图片--回调、关闭当前操作 __strong __typeof(weakOperation) strongOperation = weakOperation; [self callCompletionBlockForOperation:strongOperation completion:completedBlock image:cachedImage data:cachedData error:nil cacheType:cacheType finished:YES url:url]; [self safelyRemoveOperationFromRunning:operation]; &#125; else &#123; //本地没有、也不下载--回调、关闭当前操作 __strong __typeof(weakOperation) strongOperation = weakOperation; [self callCompletionBlockForOperation:strongOperation completion:completedBlock image:nil data:nil error:nil cacheType:SDImageCacheTypeNone finished:YES url:url]; [self safelyRemoveOperationFromRunning:operation]; &#125; &#125;]; return operation;&#125; SDWebImageManager流程图 业务层: 缓存&amp;&amp;磁盘操作(SDImageCache)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146- (nullable NSOperation *)queryCacheOperationForKey:(nullable NSString *)key done:(nullable SDCacheQueryCompletedBlock)doneBlock &#123; if (!key) &#123; if (doneBlock) &#123; doneBlock(nil, nil, SDImageCacheTypeNone); &#125; return nil; &#125; // First check the in-memory cache... //搜索磁盘缓存 UIImage *image = [self imageFromMemoryCacheForKey:key]; if (image) &#123; NSData *diskData = nil; if (image.images) &#123; diskData = [self diskImageDataBySearchingAllPathsForKey:key]; &#125; if (doneBlock) &#123; doneBlock(image, diskData, SDImageCacheTypeMemory); &#125; return nil; &#125; NSOperation *operation = [NSOperation new]; dispatch_async(self.ioQueue, ^&#123; if (operation.isCancelled) &#123; // do not call the completion if cancelled return; &#125; @autoreleasepool &#123; //搜索硬盘 NSData *diskData = [self diskImageDataBySearchingAllPathsForKey:key]; UIImage *diskImage = [self diskImageForKey:key]; //缓存到内存、默认为YES if (diskImage &amp;&amp; self.config.shouldCacheImagesInMemory) &#123; NSUInteger cost = SDCacheCostForImage(diskImage); //使用NSChache缓存。 [self.memCache setObject:diskImage forKey:key cost:cost]; &#125; if (doneBlock) &#123; dispatch_async(dispatch_get_main_queue(), ^&#123; doneBlock(diskImage, diskData, SDImageCacheTypeDisk); &#125;); &#125; &#125; &#125;); return operation;&#125;//查询缓存- (nullable UIImage *)imageFromMemoryCacheForKey:(nullable NSString *)key &#123; //self.memCache 为NSCache实例 return [self.memCache objectForKey:key];&#125;//查询磁盘- (nullable UIImage *)diskImageForKey:(nullable NSString *)key &#123; NSData *data = [self diskImageDataBySearchingAllPathsForKey:key]; if (data) &#123; //图片解码、调整方向 UIImage *image = [[SDWebImageCodersManager sharedInstance] decodedImageWithData:data]; //调整图片缩放比例 @2x/@3x image = [self scaledImageForKey:key image:image]; //压缩图片 if (self.config.shouldDecompressImages) &#123; image = [[SDWebImageCodersManager sharedInstance] decompressedImageWithImage:image data:&amp;data options:@&#123;SDWebImageCoderScaleDownLargeImagesKey: @(NO)&#125;]; &#125; return image; &#125; else &#123; return nil; &#125;&#125;//写入缓存 &amp;&amp; 磁盘- (void)storeImage:(nullable UIImage *)image imageData:(nullable NSData *)imageData forKey:(nullable NSString *)key toDisk:(BOOL)toDisk completion:(nullable SDWebImageNoParamsBlock)completionBlock &#123; if (!image || !key) &#123; if (completionBlock) &#123; completionBlock(); &#125; return; &#125; // if memory cache is enabled if (self.config.shouldCacheImagesInMemory) &#123; //写入缓存 NSUInteger cost = SDCacheCostForImage(image); [self.memCache setObject:image forKey:key cost:cost]; &#125; if (toDisk) &#123; //写入磁盘 dispatch_async(self.ioQueue, ^&#123; @autoreleasepool &#123; NSData *data = imageData; if (!data &amp;&amp; image) &#123; // If we do not have any data to detect image format, check whether it contains alpha channel to use PNG or JPEG format SDImageFormat format; if (SDCGImageRefContainsAlpha(image.CGImage)) &#123; format = SDImageFormatPNG; &#125; else &#123; format = SDImageFormatJPEG; &#125; data = [[SDWebImageCodersManager sharedInstance] encodedDataWithImage:image format:format]; &#125; [self storeImageDataToDisk:data forKey:key]; &#125; if (completionBlock) &#123; dispatch_async(dispatch_get_main_queue(), ^&#123; completionBlock(); &#125;); &#125; &#125;); &#125; else &#123; if (completionBlock) &#123; completionBlock(); &#125; &#125;&#125;//正式写入磁盘- (void)storeImageDataToDisk:(nullable NSData *)imageData forKey:(nullable NSString *)key &#123; if (!imageData || !key) &#123; return; &#125; [self checkIfQueueIsIOQueue]; //如果文件中不存在磁盘缓存路径 则创建 if (![_fileManager fileExistsAtPath:_diskCachePath]) &#123; [_fileManager createDirectoryAtPath:_diskCachePath withIntermediateDirectories:YES attributes:nil error:NULL]; &#125; // get cache Path for image key 得到该key的缓存路径 NSString *cachePathForKey = [self defaultCachePathForKey:key]; // transform to NSUrl 将缓存路径转化为url NSURL *fileURL = [NSURL fileURLWithPath:cachePathForKey]; //将imageData存储起来 [_fileManager createFileAtPath:cachePathForKey contents:imageData attributes:nil]; // disable iCloud backup 如果调用者关闭icloud 关闭iCloud备份 if (self.config.shouldDisableiCloud) &#123; [fileURL setResourceValue:@YES forKey:NSURLIsExcludedFromBackupKey error:nil]; &#125;&#125; 由于此处只归纳正常读取下载流程的代码、所以其余关于图片过期&amp;&amp;释放流程的代码没有列出。后面会逐一进行归纳。 查找本地流程图 下载操作(SDWebImageDownloader)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117- (nullable SDWebImageDownloadToken *)downloadImageWithURL:(nullable NSURL *)url options:(SDWebImageDownloaderOptions)options progress:(nullable SDWebImageDownloaderProgressBlock)progressBlock completed:(nullable SDWebImageDownloaderCompletedBlock)completedBlock &#123; __weak SDWebImageDownloader *wself = self; return [self addProgressCallback:progressBlock completedBlock:completedBlock forURL:url createCallback:^SDWebImageDownloaderOperation *&#123; //创建下载operation __strong __typeof (wself) sself = wself; //超时时间 NSTimeInterval timeoutInterval = sself.downloadTimeout; if (timeoutInterval == 0.0) &#123; timeoutInterval = 15.0; &#125; // In order to prevent from potential duplicate caching (NSURLCache + SDImageCache) we disable the cache for image requests if told otherwise //创建下载策略 //SDWebImageDownloaderUseNSURLCache 则使用 NSURLRequestUseProtocolCachePolicy 缓存协议 //默认NSURLRequestReloadIgnoringLocalCacheData从原地址重新下载 NSURLRequestCachePolicy cachePolicy = options &amp; SDWebImageDownloaderUseNSURLCache ? NSURLRequestUseProtocolCachePolicy : NSURLRequestReloadIgnoringLocalCacheData; //创建下载请求 NSMutableURLRequest *request = [[NSMutableURLRequest alloc] initWithURL:url cachePolicy:cachePolicy timeoutInterval:timeoutInterval]; request.HTTPShouldHandleCookies = (options &amp; SDWebImageDownloaderHandleCookies); request.HTTPShouldUsePipelining = YES; if (sself.headersFilter) &#123; request.allHTTPHeaderFields = sself.headersFilter(url, [sself.HTTPHeaders copy]); &#125; else &#123; //默认 image/*;q=0.8 request.allHTTPHeaderFields = sself.HTTPHeaders; &#125; //创建下载操作 SDWebImageDownloaderOperation *operation = [[sself.operationClass alloc] initWithRequest:request inSession:sself.session options:options]; //是否解压 operation.shouldDecompressImages = sself.shouldDecompressImages; //证书 if (sself.urlCredential) &#123; operation.credential = sself.urlCredential; &#125; else if (sself.username &amp;&amp; sself.password) &#123; //默认 账号密码为空的通用证书 operation.credential = [NSURLCredential credentialWithUser:sself.username password:sself.password persistence:NSURLCredentialPersistenceForSession]; &#125; //优先级。默认都不是 if (options &amp; SDWebImageDownloaderHighPriority) &#123; operation.queuePriority = NSOperationQueuePriorityHigh; &#125; else if (options &amp; SDWebImageDownloaderLowPriority) &#123; operation.queuePriority = NSOperationQueuePriorityLow; &#125; //向下载队列 NSOperationQueue 中 添加本次下载操作 [sself.downloadQueue addOperation:operation]; //设置下载的顺序 是按照队列还是栈 if (sself.executionOrder == SDWebImageDownloaderLIFOExecutionOrder) &#123; // Emulate LIFO execution order by systematically adding new operations as last operation&apos;s dependency [sself.lastAddedOperation addDependency:operation]; sself.lastAddedOperation = operation; &#125; return operation; &#125;];&#125;//通过progressBlock&amp;&amp;completedBlock以及Url和SDWebImageDownloaderOperation对token进行包装- (nullable SDWebImageDownloadToken *)addProgressCallback:(SDWebImageDownloaderProgressBlock)progressBlock completedBlock:(SDWebImageDownloaderCompletedBlock)completedBlock forURL:(nullable NSURL *)url createCallback:(SDWebImageDownloaderOperation *(^)(void))createCallback &#123; // The URL will be used as the key to the callbacks dictionary so it cannot be nil. If it is nil immediately call the completed block with no image or data. if (url == nil) &#123; if (completedBlock != nil) &#123; completedBlock(nil, nil, nil, NO); &#125; return nil; &#125; __block SDWebImageDownloadToken *token = nil; dispatch_barrier_sync(self.barrierQueue, ^&#123; SDWebImageDownloaderOperation *operation = self.URLOperations[url]; if (!operation) &#123; operation = createCallback(); //将url作为key、对应的下载操作operation作为value保存。 self.URLOperations[url] = operation; __weak SDWebImageDownloaderOperation *woperation = operation; operation.completionBlock = ^&#123; dispatch_barrier_sync(self.barrierQueue, ^&#123; SDWebImageDownloaderOperation *soperation = woperation; if (!soperation) return; if (self.URLOperations[url] == soperation) &#123; //下载完成、移除操作 [self.URLOperations removeObjectForKey:url]; &#125;; &#125;); &#125;; &#125; //将成progressBlock以及completedBlock组装成SDCallbacksDictionary. id downloadOperationCancelToken = [operation addHandlersForProgress:progressBlock completed:completedBlock]; //生成下载任务标识。用于manager将来定位对应操作用 token = [SDWebImageDownloadToken new]; token.url = url; token.downloadOperationCancelToken = downloadOperationCancelToken; &#125;); return token;&#125; SDWebImageDownloaderOperation是具体下载操作、设计很多网络层的东西。将来可以单独开一篇、结合AFNetWorking没准会更好。一些启发 分层的接口API设计。 12345#import &quot;UIImageView+WebCache.h&quot;#import &quot;UIButton+WebCache.h&quot;#import &quot;UIImageView+HighlightedWebCache.h&quot;//以及其汇总的#import &quot;UIView+WebCache.h&quot; 所有外层API与具体业务无关。使得SDWebImageManager可以脱离View层单独运作。 线程安全 123456789@synchronized (self.runningOperations) &#123; [self.runningOperations addObject:operation]; &#125;if (url) &#123; @synchronized (self.failedURLs) &#123; isFailedUrl = [self.failedURLs containsObject:url]; &#125;&#125;..... 所有可能引起资源抢夺的对象操作、全部有条件锁保护。但是由于内嵌异常处理代码的存在、条件锁的性能是所有锁中最差的。不知道为什么SD中使用这么多。 内联函数 更高效的短函数执行、替代表达式形式的宏定义。 精细的缓存管理原则 详参上文提到的《磁盘清理的原则？》 回调设计 SDWebImage中使用了两种、Block以及Delegate。 Block使用的很多、举两个例子。 123456789101112131415======&gt;#import &quot;UIView+WebCache.h&quot;- (void)sd_internalSetImageWithURL:(nullable NSURL *)url placeholderImage:(nullable UIImage *)placeholder options:(SDWebImageOptions)options operationKey:(nullable NSString *)operationKey setImageBlock:(nullable SDSetImageBlock)setImageBlock progress:(nullable SDWebImageDownloaderProgressBlock)progressBlock completed:(nullable SDExternalCompletionBlock)completedBlock context:(nullable NSDictionary *)context;======&gt;SDWebImageDownloader- (nullable SDWebImageDownloadToken *)downloadImageWithURL:(nullable NSURL *)url options:(SDWebImageDownloaderOptions)options progress:(nullable SDWebImageDownloaderProgressBlock)progressBlock completed:(nullable SDWebImageDownloaderCompletedBlock)completedBlock; 再来看代理 1234567891011121314@protocol SDWebImageManagerDelegate &lt;NSObject&gt;@optional/** * Controls which image should be downloaded when the image is not found in the cache. * * @param imageManager The current `SDWebImageManager` * @param imageURL The url of the image to be downloaded * * @return Return NO to prevent the downloading of the image on cache misses. If not implemented, YES is implied. */- (BOOL)imageManager:(nonnull SDWebImageManager *)imageManager shouldDownloadImageForURL:(nullable NSURL *)imageURL;- (nullable UIImage *)imageManager:(nonnull SDWebImageManager *)imageManager transformDownloadedImage:(nullable UIImage *)image withURL:(nullable NSURL *)imageURL; 不难看出、SDWebImage对回调的使用倾向于： Block单个图片的分类、单个图片的下载。每个操作任务中必现的progress以及completed。所以、有很强的个体绑定需要或者使用次数不多时、倾向使用block DelegateSDWebImageManager下载完成之后的自定义图片处理、是否下载某个url。这两个方法如果需要的话都是将会调用多次的。所以、用Delegate更好、可以将方法常驻。 同理UITableView的使用Delegate、是用为在滚动途中、代理方法需要被不断的执行。UIButton也是将会被多次点击。UIView的动画/GCD则可以使用Block、因为只执行一次、用完释放。所以、在日常使用中、我们也可以参考上述原则进行设计。 NSMapTable 用NSMapTable代替字典来存储当前正在进行的操作、并且将value设置为NSMapTableWeakMemory。防止对应value因为强引用不能自动释放。 暂时想到的就这些、更多问题欢迎留言。作者：kirito_song链接：https://www.jianshu.com/p/3b8a7ae966d3來源：简书著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。]]></content>
      <categories>
        <category>sourcecode</category>
      </categories>
      <tags>
        <tag>SDWebImage</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解iOS Rendering Process]]></title>
    <url>%2F2018%2F04%2F20%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3iOS-Rendering-Process%2F</url>
    <content type="text"><![CDATA[前言iOS 最早名为 iPhone OS，是Apple公司专门为其硬件设备开发的操作系统，最初于 2007 年随第一代 iPhone 推出，后扩展为支持 Apple 公司旗下的其他硬件设备，如 iPod、iPad 等。作为一名 iOS Developer，相信大多数人都有写出过造成 iOS 设备卡顿的代码经历，相应的也有过想方设法优化卡顿代码的经验。本文将从 OpenGL 的角度结合 Apple 官方给出的部分资料，介绍 iOS Rendering Process 的概念及其整个底层渲染管道的各个流程。相信在理解了 iOS Rendering Process 的底层各个阶段之后，我们可以在平日的开发工作之中写出性能更高的代码，在解决帧率不足的显示卡顿问题时也可以多一些思路~ 索引iOS Rendering Process 概念iOS Rendering 技术框架OpenGL 主要渲染步骤OpenGL Render PipelineCore Animation PipelineCommit TransactionAnimation全文总结扩展阅读 iOS Rendering Process 概念iOS Rendering Process 译为 iOS 渲染流程，本文特指 iOS 设备从设置将要显示的图元数据到最终在设备屏幕成像的整个过程。在开始剖析 iOS Rendering Process 之前，我们需要对 iOS 的渲染概念有一个基本的认知： 基于平铺的渲染iOS 设备的屏幕分为 N * N 像素的图块，每个图块都适合于 SoC 缓存，几何体在图块内被大量拆分，只有在所有几何体全部提交之后才可以进行光栅化（Rasterization）。Note: 这里的光栅化指将屏幕上面被大量拆分出来的几何体渲染为像素点的过程。 iOS Rendering 技术框架事实上 iOS 渲染相关的层级划分大概如下： UIKit嘛~ 作为一名 iOS Developer 来说，应该对 UIKit 都不陌生，我们日常开发中使用的用户交互组件都来自于 UIKit Framework，我们通过设置 UIKit 组件的 Layout 以及 BackgroundColor 等属性来完成日常的界面绘画工作。其实 UIKit Framework 自身并不具备在屏幕成像的能力，它主要负责对用户操作事件的响应，事件响应的传递大体是经过逐层的视图树遍历实现的。那么我们日常写的 UIKit 组件为什么可以呈现在 iOS 设备的屏幕上呢？ Core AnimationCore Animation 其实是一个令人误解的命名。你可能认为它只是用来做动画的，但实际上它是从一个叫做Layer Kit这么一个不怎么和动画有关的名字演变而来的，所以做动画仅仅是 Core Animation 特性的冰山一角。Core Animation 本质上可以理解为是一个复合引擎，旨在尽可能快的组合屏幕上不同的显示内容。这些显示内容被分解成独立的图层，即 CALayer，CALayer 才是你所能在屏幕上看见的一切的基础。其实很多同学都应该知道 CALayer，UIKit 中需要在屏幕呈现的组件内部都有一个对应的 CALayer，也就是所谓的 Backing Layer。正是因为一一对应，所以 CALayer 也是树形结构的，我们称之为图层树。视图的职责就是创建并管理这个图层，以确保当子视图在层级关系中添加或者被移除的时候，他们关联的图层也同样对应在层级关系树当中有相同的操作。但是为什么 iOS 要基于 UIView 和 CALayer 提供两个平行的层级关系呢？为什么不用一个简单的层级关系来处理所有事情呢？原因在于要做职责分离，这样也能避免很多重复代码。在 iOS 和 Mac OS X 两个平台上，事件和用户交互有很多地方的不同，基于多点触控的用户界面和基于鼠标键盘的交互有着本质的区别，这就是为什么 iOS 有 UIKit 和 UIView，而 Mac OS X 有 AppKit 和 NSView 的原因。他们功能上很相似，但是在实现上有着显著的区别。Note: 实际上，这里并不是两个层级关系，而是四个，每一个都扮演不同的角色，除了视图树和图层树之外，还存在呈现树和渲染树。 OpenGL ES &amp; Core Graphics OpenGL ESOpenGL ES简称 GLES，即 OpenGL for Embedded Systems，是 OpenGL 的子集，通常面向图形硬件加速处理单元（GPU）渲染 2D 和 3D 计算机图形，例如视频游戏使用的计算机图形。OpenGL ES 专为智能手机，平板电脑，视频游戏机和 PDA 等嵌入式系统而设计 。OpenGL ES 是“历史上应用最广泛的 3D 图形 API”。 Core GraphicsCore GraphicsFramework 基于 Quartz 高级绘图引擎。它提供了具有无与伦比的输出保真度的低级别轻量级 2D 渲染。您可以使用此框架来处理基于路径的绘图，转换，颜色管理，离屏渲染，图案，渐变和阴影，图像数据管理，图像创建和图像遮罩以及 PDF 文档创建，显示和分析。Note: 在 Mac OS X 中，Core Graphics 还包括用于处理显示硬件，低级用户输入事件和窗口系统的服务。 Graphics HardwareGraphics Hardware译为图形硬件，iOS 设备中也有自己的图形硬件设备，也就是我们经常提及的 GPU。图形处理单元（GPU）是一种专用电子电路，旨在快速操作和改变存储器，以加速在用于输出到显示设备的帧缓冲器中创建图像。GPU 被用于嵌入式系统，手机，个人电脑，工作站和游戏控制台。现代 GPU 在处理计算机图形和图像方面非常高效，并且 GPU 的高度并行结构使其在大块数据并行处理的算法中比通用 CPU 更有效。 OpenGL 主要渲染步骤OpenGL全称 Open Graphics Library，译为开放图形库，是用于渲染 2D 和 3D 矢量图形的跨语言，跨平台的应用程序编程接口（API）。OpenGL 可以直接访问 GPU，以实现硬件加速渲染。 一个用来渲染图像的 OpenGL 程序主要可以大致分为以下几个步骤：设置图元数据着色器-shader 计算图元数据（位置·颜色·其他）光栅化-rasterization 渲染为像素fragment shader，决定最终成像其他操作（显示·隐藏·融合）Note: 其实还有一些非必要的步骤，与本文主题不相关，这里点到为止。我们日常开发时使用 UIKit 布局视图控件，设置透明度等等都属于设置图元数据这步，这也是我们日常开发中可以影响 OpenGL 渲染的主要步骤。 OpenGL Render Pipeline如果有同学看过 WWDC 的一些演讲稿或者接触过一些 OpenGL 知识，应该对 Render Pipeline 这个专业术语并不陌生。不过 Render Pipeline 实在是一个初次见面不太容易理解的词，它译为渲染管道，也有译为渲染管线的…其实 Render Pipeline 指的是从应用程序数据转换到最终渲染的图像之间的一系列数据处理过程。好比我们上文中提到的 OpenGL 主要渲染步骤一样，我们开发应用程序时在设置图元数据这步为视图控件的设定布局，背景颜色，透明度以及阴影等等数据。下面以 OpenGL 4.5 的 Render Pipeline 为例介绍一下：这些图元数据流入 OpenGL 中，传入顶点着色器（vetex shader），然后顶点着色器对其进行着色器内部的处理后流出。之后可能进入细分着色阶段（tessellation shading stage），其中又有可能分为细分控制着色器和细分赋值着色器两部分处理，还可能会进入几何着色阶段（geometry shading stage），数据从中传递。最后都会走片元着色阶段（fragment shading stage）。Note: 图元数据是以 copy 的形式流入 shader 的，shader 一般会以特殊的类似全局变量的形式接收数据。OpenGL 在最终成像之前还会经历一个阶段名为计算着色阶段（compute shaing stage），这个阶段 OpenGL 会计算最重要在屏幕中成像的像素位置以及颜色，如果在之前提交代码时用到了 CALayer 会引起blending的显示效果（例如 Shadow）或者视图颜色或内容图片的 alpha 通道开启，都将会加大这个阶段 OpenGL 的工作量。 Core Animation Pipeline上文说到了 iOS 设备之所以可以成像不是因为 UIKit 而是因为 LayerKit，即 Core Animation。Core Animation 图层，即 CALayer 中包含一个属性 contents，我们可以通过给这个属性赋值来控制 CALayer 成像的内容。这个属性的类型定义为 id，在程序编译时不论我们给 contents 赋予任何类型的值，都是可以编译通过的。但实践中，如果 contents 赋值类型不是 CGImage，那么你将会得到一个空白图层。Note: 造成 contents 属性的奇怪表现的原因是 Mac OS X 的历史包袱，它之所以被定义为 id 类型是因为在 Mac OS X 中这个属性对 CGImage 和 NSImage 类型的值都起作用。但是在 iOS 中，如果你赋予一个 UIImage 属性的值，仅仅会得到一个空白图层。说完 Core Animation 的 contents 属性，下面介绍一下 iOS 中 Core Animation Pipeline：在 Application 中布局 UIKit 视图控件间接的关联 Core Animation 图层Core Animation 图层相关的数据提交到 iOS Render Server，即 OpenGL ES &amp; Core GraphicsRender Server 将与 GPU 通信把数据经过处理之后传递给 GPUGPU 调用 iOS 当前设备渲染相关的图形设备 DisplayNote: 由于 iOS 设备目前的显示屏最大支持60 FPS的刷新率，所以每个处理间隔为 16.67 ms。可以看到从 Commit Transaction 之后我们的图元数据就将会在下一次 RunLoop 时被 Application 发送给底层的 Render Server，底层 Render Server 直接面向 GPU 经过一些列的数据处理将处理完毕的数据传递给 GPU，然后 GPU 负责渲染工作，根据当前 iOS 设备的屏幕计算图像像素位置以及像素 alpha 通道混色计算等等最终在当前 iOS 设备的显示屏中呈现图像。嘛~ 由于 Core Animation Pipeline 中 Render Server 包含 OpenGL ES &amp; Core Graphics，其中 OpenGL ES 的渲染可以参考上文 OpenGL Render Pipeline 理解。 Commit TransactionCore Animation Pipeline 的整个管线中 iOS 常规开发一般可以影响到的范围也就仅仅是在 Application 中布局 UIKit 视图控件间接的关联 Core Animation 图层这一级，即Commit Transaction 之前的一些操作。那么在 Commit Transaction 之前我们一般要做的事情有哪些？Layout，构建视图Display，绘制视图Prepare，额外的 Core Animation 工作Commit，打包图层并将它们发送到 Render Server Layout在 Layout 阶段我们能做的是把 constraint 写的尽量高效，iOS 的 Layout Constraint 类似于 Android 的 Relative Layout。Note: Emmmmm… 据观察 iOS 的 Layout Constraint 在书写时应该尽量少的依赖于视图树中同层级的兄弟视图节点，它会拖慢整个视图树的 Layout 计算过程。这个阶段的 Layout 计算工作是在 CPU 完成的，包括 layoutSubviews 方法的重载，addSubview: 方法填充子视图等 Display其实这里的 Display 仅仅是我们设置 iOS 设备要最终成像的图元数据而已，重载视图 drawRect: 方法可以自定义 UIView 的显示，其原理是在 drawRect: 方法内部绘制 bitmap。Note: 重载 drawRect: 方法绘制 bitmap 过程使用 CPU 和 内存。所以重载 drawRect: 使用不当会造成 CPU 负载过重，App 内存飙升等问题。 Prepare这个步骤属于附加步骤，一般处理图像的解码 &amp; 转换等操作。 CommitCommit 步骤指打包图层并将它们发送到 Render Server。Note: Commit 操作会递归执行，由于图层和视图一样是以树形结构存在的，当图层树过于复杂时 Commit 操作的开销也会非常大。 CATransactionCATransaction 是 Core Animation 中用于将多个图层树操作分配到渲染树的原子更新中的机制，对图层树的每个修改都必须是事务的一部分。CATransaction 类没有属性或者实例方法，并且也不能用 +alloc 和 -init 方法创建它，我们只能用类方法 +begin 和 +commit 分别来入栈或者出栈。事实上任何可动画化的图层属性都会被添加到栈顶的事务，你可以通过 +setAnimationDuration: 方法设置当前事务的动画时间，或者通过 +animationDuration 方法来获取时长值（默认 0.25 秒）。Core Animation 在每个 RunLoop 周期中自动开始一次新的事务，即使你不显式地使用 [CATransaction begin] 开始一次事务，在一个特定 RunLoop 循环中的任何属性的变化都会被收集起来，然后做一次 0.25 秒的动画（CALayer 隐式动画）。Note: CATransaction 支持嵌套。 Animation对于 App 用户交互体验提升最明显的工作莫过于使用动画了，那么 iOS 是如何处理动画的渲染过程的呢？日常开发中如果不是特别复杂的动画我们一般会使用 UIView Animation 实现，iOS 将 UIView Animation 的处理过程分为以下三个阶段：调用 animateWithDuration:animations: 方法在 Animation Block 中进行 Layout，Display，Prepare，CommitRender Server 根据 Animation 逐帧渲染Note: 原理是 animateWithDuration:animations: 内部使用了 CATransaction 来将整个 Animation Block 中的代码作为原子操作 commit 给了 RunLoop。 基于 CATransaction 实现链式动画事实上大多数的动画交互都是有动画执行顺序的，尽管 UIView Animation 很强大，但是在写一些顺序动画时使用 UIView Animation 只能在 + (void)animateWithDuration:delay:options:animations:completion: 方法的 completion block 中层级嵌套，写成一坨一坨 block 堆砌而成的代码，实在是难以阅读更别提后期维护了。在得知 UIView Animation 使用了 CATransaction 时，我们不禁会想到这个 completion block 是不是也是基于 CATransaction 实现的呢？Bingo！CATransaction 中有 +completionBlock 以及 +setCompletionBlock: 方法可以对应于 UIView Animation 的 completion block 的书写。Note: 我的一个开源库LSAnimator - 可多链式动画库在动画顺序链接时也用到了 CATransaction。 全文总结结合上下文不难梳理出一个iOS 最基本的完整渲染经过（Rendering pass）。 性能检测思路基于整篇文章的内容归纳一下我们在日常的开发工作中遇到性能问题时检测问题代码的思路：文章写得比较用心（是我个人的原创文章，转载请注明https://lision.me/），如果发现错误会优先在我的个人博客 中更新。如果有任何问题欢迎在我的微博 @Lision 联系我~希望我的文章可以为你带来价值~ 扩展阅读WWDC2014-Advanced Graphics and Animations for iOS AppsiOS 保持界面流畅的技巧iOS-Core-Animation-Advanced-Techniques 本文转载自Lision’s Blog | ELSEWHERE作者：Lision’s Blog | ELSEWHERE链接：https://lision.me/ios-rendering-process/著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。]]></content>
      <categories>
        <category>graphic</category>
      </categories>
      <tags>
        <tag>Rendering</tag>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[老司机 iOS 周报 #15]]></title>
    <url>%2F2018%2F04%2F16%2F%E8%80%81%E5%8F%B8%E6%9C%BA-iOS-%E5%91%A8%E6%8A%A5-15%2F</url>
    <content type="text"><![CDATA[老司机 iOS 周报，只为你呈现有价值的信息。你也可以为这个项目出一份力，如果发现有价值的信息、文章、工具等可以到 Issues 里提给我们，我们会尽快处理。记得写上推荐的理由哦。有建议和意见也欢迎到 Issues 提出。 ###文章🐢 🌟 深入浅出 GCD 系列文章这是 cocoa-chen 阅读 GCD 源码后分享的系列文章。该系列文章以常用的 5 个 GCD API 为切入点，从『使用场景』到『原理深究』再到『总结』循序渐进十分细致地阐述了 GCD 是怎么实现这些 API 来管理维护线程池的。系列文章一共有 6 篇，大家可以各取所需： 深入浅出 GCD 之基础篇 深入浅出 GCD 之 dispatch_queue 深入浅出 GCD 之 dispatch_semaphore 深入浅出 GCD 之 dispatch_group 深入浅出 GCD 之 dispatch_once 深入浅出 GCD 之 dispatch_source 🐢 深入理解 Swift 派发机制(英文原文)2016 年的一篇文章，主要内容是讲关于 Swift 各种类型的方法派发机制，以及 NSObject 与 Swift 原生类型的差异等等，读完这篇文章我才第一次对于 Swift 的派发机制有了比较清晰全面的认识，虽然有一小部分内容已经过时了，但还是强烈推荐大家看一下。 🐎 iOS App 连续闪退时如何上报 crash 日志如果是我们自己开发一套 crash 日志收集系统的话，可能就会发现在 App 启动阶段就连续闪退的场景下往往无法正确上报崩溃日志。Peak 从『如何检测连续闪退』和『如何在闪退后继续上传日志』两方面分析和解决了这个痛点。另外，微信读书团队以前也分享过类似的方案——iOS 启动连续闪退保护方案，并且该方案额外集成了自修复系统。 🐎 How To Keep Learning After 50 and Other Ways to Hack Your Brain at any Age这篇文章通过介绍了“神经可塑性”（Neuroplastcity）理论，论证了活到老、学到老是有科学依据的。不仅如此，该文还提出年龄逐渐变大之后如何“hack”自己的大脑来让自己更有效的学习的方法。有趣的是，文章为了讨论这个话题，还邀请了 25 名年长的艺术家、教练和程序员来参与调查，他们中几乎所有都在持续的学习，尤其是其中还有从 Fortran 一路写到 Swift 的程序员，可以说是相当资深了。作为焦虑的准中年程序员，这篇文章对我的触动可谓是很大的。除了内容本身值得思考之外，文风读起来就像《老人与海》那样充满力量感。值得收藏！ 🐢 Behind-the scenes improvements in Swift 4.1掌握编程语言的设计与实现一直以来都处于技术圈鄙视链的顶端，相信绝大多数程序员都曾经跃跃欲试。如果你是对 Swift 语言的实现原理感兴趣的同学，一定不要错过这篇文章。文章标题看上去好像也就是列举一下 Swift4.1 一些改进，但实际上是针对 Swift 语言设计上面临的诸多问题和解决方案进行了深入讨论，包括但不限于为什么 protocol 中默认实现的方法不能返回 self，OC 类桥接到 Swift 中都发生了什么，以及泛型参数支持中父子关系如何实现等等。看完后对于”为什么 4.1 的编译速度好像变快了？”以及”Swift 的 ABI 什么时候才能稳定？”这两个经典问题，你应该会有自己的答案。 🐕 ✨✨工程师如何在工作中提升自己？美团点评技术团队刘丁对工程师发展的一些思考和总结，写的很全面。文章第一部分阐述了一些学习的原则；二部分分析了作者在工作中碰到和看到的一些典型困惑；第三部分剖析架构师的能力模型，让大家对目标所需能力有一个比较清晰的认知。 🐎 如何快速成长为技术大牛技术人员天天写业务代码还加班，如何才能成为技术大牛？，文章列出了一些典型的误区及正确做法：Do more、Do better、Do exercise。 🐎 Swift Tip: Local Computed Variables本文介绍了一种通过在函数体内部声明计算属性从而实现局部代码复用的编码方法，不过也仅仅是代码复用，性能方面木有任何提升，类似于一个局部函数，感兴趣的同学可以了解一下。 🐕 读 SnapKit 和 Masonry 自动布局框架源码介绍了主流 AutoLayout 布局框架 SnapKit 和 Masonry 源码结构。SnapKit 的设计思路很好理解，也有值得学习的设计经验。如果自己先尝试读读源码再看这篇文章会比较好理解。 🐢 11 Tips for Working on the iPadMacStories 整理了 11 条指南和小窍门，帮你提高 iPad 在 iOS 11 下的生产力。从外接键盘推荐和快捷键到手势和 Siri，全都是 Federico Viticci 日常使用 iPad Pro 的小技巧。 🐕 iOS 中制作原型动画的一些方式介绍了两种动画原型的制作方式。利用 Xcode 的 playground 和 PaintCode。在我看来这两种方式其实都有缺点。playground 编译速度太慢并且调参还是用代码。效果基本靠蒙。PaintCode 适用范围太局限。基本都是绘制路径。现在最强的的原型工具应该是 Principle。 🐎 fastlane 发布 CI aplha 版本alpha 版本发布了。其实关于公司的自动化也是老生常谈的问题了。体验比较好的自动化配置在我看来是，Slack + Xcode server + Fastlane + Phabricator + Arcanist + Trello(jira)。有兴趣的同学可以研究一下。 ###工具IBM Watson Services for Core MLWatson Services 是 IBM 的人工智能实验室提供对外的 AI 服务，包含了聊天对话/视觉识别/语音处理/语言翻译等多方面能力，而 IBM Watson Services for Core ML 是 IBM 与苹果合作的，将 Watson Services 的 AI 能力与苹果的 CoreML 相结合移动端 AI 服务，以 SDK 的形式接入移动端，方便开发者快速构建具有 AI 能力的 App。 苹果产品购买时机建议苹果更新其产品的时候往往是该产品的最佳购买时机，如果错过了，那么可以在这个网站上找到购买建议，网站会根据该产品距离上次更新的时长，以及历史以来的平均更新周期给出指导，并收集了产品相关的最新传闻给与你作为参考。 ###内推奇志信息科技: 杭州/广州 iOS 工程师我（@没故事的卓同学）现在的公司，Swift 开发，应用支持从 iOS 10 开始，杭州和广州都有研发团队，无人机应用方向。iOS、Android、前端、UI 都招，感兴趣的朋友欢迎简历投到 hr@kiwiinc.net 。 上海享物说网络科技有限公司：上海 iOS 工程师我 (@EyreFree) 现在所在的公司，位于上海宜山路地铁站附近，主营内容为二手互送社区，Swift 开发，应用支持从 iOS 9 开始。除 iOS 职位以外，还有 Web 前端 / Android 工程师等岗位空缺，求三年左右经验的大佬，三餐供应，住宿补贴。感兴趣的朋友欢迎简历投到 eyrefree@eyrefree.org。 ###专栏onevcat 的小专栏：开发笔记簿记录了喵神日常开发时遇到的问题和解决方案，同时也会收藏一些学习时记录的笔记，随想等。定价 ¥99，因为至少会有一两年的长期更新，所以这个价格是非常良心的。而且目前已经更新了 9 篇，涉及的范围也比较广，值得订阅！ ###福利周报读者专属 Reveal 50 元优惠券我们和 Price Tag 的合作，给读者送一个小福利，点击上面链接可以领取 Reveal 14 优惠券。领取后到这里可以使用：购买链接 。 关注我们我们开通了公众号，每期发布时公众号会推送消息，欢迎关注。 作者：老司机iOS周报链接：https://juejin.im/post/5ad437596fb9a028d567933a来源：掘金著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。]]></content>
      <categories>
        <category>swiftOldDriver</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[一次iOS EXC_BAD_ACCESS 的分析解决过程]]></title>
    <url>%2F2018%2F02%2F08%2F%E4%B8%80%E6%AC%A1iOS-EXC-BAD-ACCESS-%E7%9A%84%E5%88%86%E6%9E%90%E8%A7%A3%E5%86%B3%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[游戏客户端在断线重连后需要调用SDK方法清空消息缓存数据，但是因为游戏在后台停留时间较长，部分内存被释放，导致出现EXC_BAD_ACCESS。 网上大部分关于EXC_BAD_ACCESS的文章都是写了如何检测，并没有说明如何处理这种问题。当然本文也是基于特定场景下解决了该问题。 什么是EXC_BAD_ACCESS？EXC_BAD_ACCESS简单的讲就是使用了已经被释放的内存，导致crash。 写Demo测试ClassA(单例对象) ， 一个 strong 的NSMutableArray *marr 吧。 @property (nonatomic, strong) NSMutableArray *marr; 1、场景：app1退到后台，使用其他app，经过几分钟后，重新进入app1，会调用 [[ClassA sharedIndstance] clean]。clean方法：123- (void)clean &#123; [self.marr removeAllObjects];&#125;2、分析：A1：ClassA单例对象被释放但是每次不是又[ClassA sharedIndstance] 了吗？A2：marr 属性被释放，这种怎么讲，单例没释放，反而里面的属性被释放？？经测试，原因为分析1. [ClassA sharedIndstance] 并不能重新init，即使能init，那也是新的内存对象了。3、测试过程：1. 新建单例类SingeTonClass，并在xcode设置为MRC.2. 初始化然后手动release，再初始化。￼￼￼又尝试了这种方式初始化：如果再dealloc之后重新以 alloc方式初始化，则并非以前的对象了，无意义。￼￼那么到此为止，可能看起来就暂时没办法解决了。冲突点：此类必须使用单例，因为工程里面全部用的这种方式；然后断线重连后必须调用clean方法。4、最后如何解决？ 其实也还是采用分析1的方式，重新初始化单例类[ClassA sharedIndstance]。 为何？问题发生的场景。 因为游戏本身断线重连后要清空缓存消息，相当于重新初始化一次单例类。之前一直在意重新初始化后并非原对象，没有考虑问题发生的场景。 那么重新初始化sharedIndstance时，需要先把原来的单例销毁，方法:￼ 自此，问题解决。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>EXC_BAD_ACCESS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[老司机 iOS 周报 #1]]></title>
    <url>%2F2018%2F01%2F08%2F%E8%80%81%E5%8F%B8%E6%9C%BA-iOS-%E5%91%A8%E6%8A%A5-1%2F</url>
    <content type="text"><![CDATA[老司机 iOS 周报，只为你呈现有价值的信息。有建议或者有信息推荐可以到我们 github 下面提 issue。 ###新闻致广大用户关于 iPhone 电池及性能的说明苹果对电池老化会导致 iPhone 性能下降做的沟通说明。表示 从来没有、也永远不会通过任何手段，来有意缩短任何 Apple 产品的使用寿命，更不会降低用户体验来迫使大家升级设备。为了安抚大家的不满，苹果将更换电池的费用下调了 390 元，从 608 元降到 218 元。不过这个降价不是永久性的，只持续到 18 年 12 月。Swift 快要可以和 Python 无缝交互了这是 Chris Lattner 大神到 Google 之后的第一个提案，让 Swift 可以和 Python 无缝交互，Chris 每次提案基本上都会带上 Demo，这一次也不例外，只用了不到一千行代码就把交互逻辑给实现了出来🤷‍♂️，大家可以直接下载这个 playground 试一下用 Swift 写 Python 是什么感觉。另外 Chris 还提出使用一套 DynamicMemberProtocol 去优化了 Python 交互的语法， 与 Python 的交互都是依赖于字符串，画风大概是这样的 let a = np.call(member: “arange”, args: 15).call(member: “reshape”, args: 3, 5)，如果实现了 DynamicMemberProtocol 的话，就可以在 Swift 里像 Python 代码一样调用 Python 的方法 np.arange(15).reshape(3, 5)，编译器不会给遵循了这个协议的对象做静态检查，但这本质上只是一个语法糖，编译时还是会转化为前者的格式去调用。 苹果宣布收购 BuddybuildBuddybuild 是著名的自动化 CI 托管服务平台，苹果收购后 Buddybuild 公司将会加入 Xcode 团队。期待 Xcode 对 CI 的支持将会更进一步。 Swift Weekly Brief 宣布停更Jesse Squires 宣布停止更新 Swift Weekly，一直以来这个 News Letter 都是我了解 Swift 开发进度最主要的途径，现在要停更了，确实很可惜。Jesse 提到停止更新的理由，主要是因为当初开始 Swift Weekly 的时候，Swift 刚刚开源，对于功能和设计的讨论非常非常多，并且 Mailing List 这种形式让人很难找到有价值的内容，所以这样一个 News Letter 在当时是非常有意义的。但现在 Swift 已经逐渐成熟，社区里的讨论变得越来越深入，而且 Swift 最近还从 Mailing List 迁移到了论坛上，相关资讯的获取已经变得越来越方便了，Swift Weekly 的存在价值也已经大不如前了，所以才打算停止更新。但停更只是个人意义上的停更，Jesse 欢迎社区的人接手过去继续更新，并且在原文介绍了一系列接手的注意事项。 Apple 更新 App Store Review Guidelines，增加 VPN 和 loot boxes 等条款Apple 于 2017.12.21 更新了其 App Store Review Guidelines. 主要变化集中在以下几个方面： 新上架 App 引入 pre-order 机制 虚拟物品抽奖必须公布各项概率(loot boxes) VPN 类应用如需在特定地区发布，必须提供相应许可信息 符合特定前提下，允许通过模板生成的 App 上架发布 LiberiOS jailbreak for iOS 11 officially released, includes support for the iPhone XLiberiOS 正式发布 iOS 11.0 - 11.1.2 的越狱工具，包括对 iPhone X 的支持。 ###文章iOS 知识小集国内知名开发者 @南峰子 把过去微博上发出来的 iOS 开发知识整理了出来，发在了 GitHub 上，据介绍这一系列的微博已经有 1000w 的阅读量了！！！ Swift Tips跟前面 iOS Tips 小集类似的项目，不同的是这个项目里讲的是一些 Swift 的小 Tips，里面 #7，#22 等技巧我都有实际用于项目中，推荐大家看一下。 Weak Arraysobjc.io 在这篇博客里简单介绍了在 Swift 中自定义弱引用数组的一种实现方式。 When and how to use Value and Reference Types in Swift全面介绍了 Swift 中的值类型和引用类型的使用区别。 Building an enum based analytics system in swift使用 enum 和 protocol 构建安全、高效、灵活的 Swift 事件统计系统。 Measuring Swift compile times in Xcode 9对 Xcode 进行一些配置看看哪些 Swift 代码拖慢了你的编译速度。 ###工具App Host一个轻量级的包托管网站，app-host 主要用于 iOS 和 Android 的包管理，作用类似于fir.im，不同之处是可以自由部署在内网，方便了公司项目保密。并且代码开源也可以方便根据各自需求进行定制化开发。 XcodeGenXcodeGen 是一个根据已有的代码文件 / 目录和简单的配置文件来生成 Xcode project 的开源工具，快速生成模板工程、将 .xcodeproj 从 Git 追踪中忽略、方便地和他人分享自己的工程配置等，无限可能，等你尝试。 ###代码WCDB SwiftWCDB 是微信团队开源的 SQLite 数据库，近日放出 WCDB Swift 的 1.0 正式版，WCDB Swift 使用纯 Swift 编写，几乎不包含 Cocoa 的代码，且与 ObjC 版保持完全一致的功能。其基于 Swift 4.0 的 Codable 协议实现模型绑定，通过建立 Swift 类型与数据库表之间的映射关系，使得开发者可以通过类对象直接操作数据库。虽然项目没有实际使用于微信中，但这只是第一步嘛，并且文章最后还表示测试用例的代码覆盖率已经达到了 91.34% 了🤑，所以大家真的可以考虑在项目中使用。 Task automation in Swift with SakeiOS 还没有使用 Swift 语言编写的自动化工具，目前流行的都是采用 bash、ruby 编写的。于是作者尝试利用 Swift 写了 Sake。这个项目目前还处于早期。 Fluid SliderRamotion 出品的滑动控件。微信跳一跳可以直接更改分数，POST 请求没有校验v2ex 上也有获得微信小游戏跳一跳源码的讨论。 ###书Swift 进阶Swift 经典书籍《Swift 进阶》更新了 Swift 4 的相关内容。 本期编辑@没故事的卓同学，@四娘，@mmoaay，@享耳先森，@EyreFree 作者：老司机iOS周报链接：https://juejin.im/post/5a5207bf6fb9a01c9c1ed94c来源：掘金著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。]]></content>
      <categories>
        <category>swiftOldDriver</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[cocos2d-x + Lua接入iOS原生SDK的实现方案]]></title>
    <url>%2F2017%2F09%2F21%2Fcocos2d-x-Lua%E6%8E%A5%E5%85%A5iOS%E5%8E%9F%E7%94%9FSDK%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[本文转载自cocos2d-x + Lua接入iOS原生SDK的实现方案-著作权归原作者所有 相信很多朋友在使用cocos2d-x+lua开发游戏时都遇到过接入iOS原生SDK的问题，比如常见的接应用内支付SDK，广告SDK或是一些社交平台SDK等等，我也没少接过这类SDK。这篇文章主要是对我做过项目中接入iOS原生SDK实现方案的一个总结，在这里分享给大家，希望对自己和大家的开发工作都有帮助。 在展开正文之前，先做几点说明： 1.我这里说的iOS原生SDK是指那些完全用Objective-C语言开发，为原生iOS程序设计的SDK。swift很好很强大，不过我还没用过，惭愧，不过语言终归只是表达方式而已，解决问题的思路都是一样的； 2.这里假设游戏的主要逻辑使用lua实现，对于主要逻辑使用C++实现的，用本文的思路一样可行，并且设计上更简单，接着往下看就知道了：） 3.本文以quick-cocos2d-x 2.1版本为例进行讲解，主要因为这个是我之前做项目用得最多的一个版本，-x新版本变动比较大，但是，还是那句话，解决问题的思路是相同的。 ——————-正式开始的分割线——————- 好了，我们正式开始。开门见山！ 解决这种接入问题，实际上最主要是解决不同语言交互的问题，一旦跨过语言交互的障碍，剩下的事情就so easy! 由于涉及到Lua,C++,Objective-C三种语言，这个问题表面上看起来错综复杂，但其实只要冷静地（=。=）梳理，我们便可以得到正确的思路。 因为我们游戏的逻辑主要是用Lua实现的（前面已经做过假设），而SDK是用Objective-C实现，所以这里我们需要解决Lua与Objective-C的交互问题，即最终希望达到的目标是，在Lua层面“调用”Objective-C的代码（注意这里的调用是加引号的，间接的调用），而当Objective-C层面收到SDK的回调，再通知Lua。我们知道，Lua并没有简单的方法直接和Objective-C交流，但是Lua可以通过Lua Binding和C/C++交流，而我们又知道，C++和Objective-C可以混编，即C++可以直接调用（这里调用没引号，是真的直接调用）Objective-C的代码。想到这里，思路就很明显了，我们可以使用C++为Lua和Objective-C的交互充当桥梁，进而实现Lua到Objective-C的交互。 根据上面的分析，我们可以用如下图表达我们的思路，我们这里将语言交互的过程分成了4个小部分： 整个语言交互的过程可以总结为：Lua调用Lua Binding的C++接口，C++接口调用混编的Objective-C接口，而Objective-C通过block形式的回调，将结果通知给C++，C++通过Lua的C API将最终结果返回给Lua。这样一趟下来，就完成了Lua与Objective-C的整个交互过程。 简单的说一下这4部分： 1.Lua Binding 将C/C++接口导出给Lua调用的方法，由于篇幅的原因这里就不展开了，具体可以参考Lua的文档，以及网上其他地方的文章。 2.混编 Objective-C的一大优点就是可以和C与C++混编使用，就像同一个语言一样共存在一个实现文件里面。具体混编规则也不说了，这里只提两个小细节： 一，在XCode下混编的实现文件后缀是.mm，而不能是.cpp或者是.m； 二，混编的实现文件引用头文件的地方，C++或者C的用#include，而Objective-C用#import，相互没有影响。 3.Block回调 Block是Objective-C一个非常棒的特性，更棒的是在Block里面还可以直接写C++代码：）具体想了解的可以看苹果官方文档。 其实在最初，我曾经尝试过使用发送通知的方式来实现Objective-C对C++的回调，即Objective-C收到SDK回调，给C++部分发送附带回调信息的通知，虽然cocos2d-x中有现成的NotificationCenter来帮助实现，但这种方式的一个显而易见的弊端是大大增加了C++代码和Objective-C代码的耦合度，Objective-C部分也要混编C++调用C++的NotificationCenter发通知，C++部分也要混编Objective-C代码，调用C++的NotificationCenter收通知，这种结构实在是有够烦躁的。 相比之下，使用Block回调就干净利落太多，Objective-C这边一切都是纯粹的，它并不需要知道自己要被C++调用还是Objective-C调用，也不需要花很多精力在返回回调上，只需要干好自己的本职工作，然后在适当的时候调用Block就一切搞定。 4.Lua C API Lua C API用于C/C++与Lua的交互，在cocos2d-x中这些C API已经被封装成了更加易用的C++ Class API。这里要提到的是，在用这套API调用Lua函数的时候，为了传参，需要参数入栈的操作，这个入栈的顺序影响到了Lua函数接受到参数的顺序，不过好在规则很简单：先入栈的参数排在前或者说是入栈顺序和实参顺序相同。举例，如果C++这边调用Lua函数func时，入栈的顺序是A，B，C，那么就是调用函数func(A,B,C) ——————-渐入佳境的分割线——————- 在整个语言交互的过程中，如果认为Lua是顶层，Objective-C是底层，那么在实际游戏中交互的过程就是一个自顶向下的过程，然而我们在实现各层级代码的时候，需要自底向上完成，因为在顶层Lua代码中的逻辑，是由底层Objective-C SDK的接口与功能决定的。即我们需要先根据SDK中原始的Objective-C的接口，做适合我们游戏Objective-C封装代理类，然后根据封装结果实现C++的bridge接口，最后再实现Lua的对应逻辑。 根据以上分析，从层级的角度，设计如下： 除过Lua的逻辑，我们最重要需要实现的两部分内容：C++ Bridge Class 和 Objective-C SDK Delegate Class。前者是起桥梁作用的接口类，原则上不做任何与游戏逻辑相关的数据处理，而后者负责封装原始的SDK接口，接收以及初步处理SDK回调数据。前者的实现依赖于后者的实现，而后者的实现又依赖于SDK。SDK取得的数据最终通过层层传递，交给Lua逻辑处理，最终保证对数据处理的游戏逻辑尽可能多的放到Lua层中。 这样设计的好处有很多，一方面，顶层的游戏逻辑变动，不影响下层多语言交互代码，另一方面，底层的SDK变动，如版本更新甚至更换，不影响上层游戏逻辑，多层次结构有效地降低了复杂度，隔离了变化，对于频繁的需求变更，这种结构也可以保证扩展的便利。 ——————-总结的分割线——————- 综上所述，解决接入iOS原生SDK的问题，主要需要4步： 根据SDK接口与功能实现Objective-C SDK Delegate Class； 根据Objective-C SDK Delegate Class实现对应的C++ Bridge Class； 根据C++ Bridge Class生成对应的Lua Binding代码； 写Lua层逻辑。 ——————-最后的分割线——————- 好了，最后，又到了激动人心的上代码的环节了：）下面就以某iOS第三方计费SDK为例，来说明下实现接入的步骤。 这个SDK只有一个头文件GameBilling.h，主要使用到的方法和Protocol如下：（为了避免篇幅过长等原因，把注释和不必要的代码都删掉了）。我用代码注释的方式说明了各方法的用途。 1234567891011121314 1 // 初始化计费SDK 2 + (GameBilling *)initializeGameBilling; 3 4 // 告诉SDK游戏屏幕的Orientation，以便SDK展示正确的UI 5 - (void)setDialogOrientationMask:(UIInterfaceOrientationMask)orientationMask; 6 7 // 确认付费，显示付费UI 8 - (void)doBillingWithUIAndBillingIndex:(NSString *)billingIndex isRepeated:(BOOL)isRepeated cpParam:(NSString*)cpParam; 9 10 // Delegate回调，告诉调用者付费是否成功等信息11 @protocol GameBillingDelegate&lt;NSObject&gt;12 @required13 - (void)onBillingResult:(BillingResultType)resultCode billingIndex:(NSString *)index message:(NSString *)message;14 @end 以上前两个方法用于初始化SDK，并且和游戏的逻辑没什么太大关系，所以我们把对他们的调用放在程序开始的位置，不必导出给Lua。第三个方法在用户确认付费时使用，需要导出给Lua，当用户在游戏界面做相应操作时候调用。最后的delegate的回调，我们用前面提到的Objective-C SDK Delegate Class来接收，并作初步处理，再用Block传给C++ Bridge Class. 好的，那我们先来完成Objective-C SDK Delegate Class。这里这个Objective-C做成了个简单的单例来使用，实际可能不需要这么做。 先完成头文件，这里命名为CMGCIAPiOS.h，如下： 12345678910111213141516171819202122 1 #import "GameBilling.h" 2 3 // 声明Block 4 typedef void (^BillingResultCallback)(BOOL success, NSString *index,NSString *message); 5 6 @interface CMGCIAPiOS : NSObject&lt;GameBillingDelegate&gt; 7 &#123; 8 GameBilling *_sdk; 9 NSString *_billingIndex;10 BillingResultCallback _callback;11 &#125;12 13 +(id)sharedInstance;14 15 -(void)setDialogOrientationMask:(UIInterfaceOrientationMask)orientationMask;16 17 -(void)doBillingWithUIAndBillingIndex:(NSString *)billingIndex 18 isRepeated:(BOOL)isRepeated 19 cpParam:(NSString*)cpParam20 resultCallback:(BillingResultCallback)callback;21 22 @end 应该很清楚，就不多做说明了。 下面是实现文件CMGCIAPiOS.m，如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071 1 #import "CMGCIAPiOS.h" 2 3 @implementation CMGCIAPiOS 4 5 static CMGCIAPiOS *_sharedInstance = nil; 6 7 + (id)sharedInstance 8 &#123; 9 @synchronized(self)10 &#123;11 if (_sharedInstance == nil)12 &#123;13 _sharedInstance = [[CMGCIAPiOS alloc] init];14 &#125;15 &#125;16 return _sharedInstance;17 &#125;18 19 -(id) init20 &#123;21 if( (self = [super init]) ) 22 &#123;23 _sdk = [GameBilling initializeGameBilling];24 _sdk.delegate = self;25 &#125;26 return self;27 &#125;28 29 -(void)setDialogOrientationMask:(UIInterfaceOrientationMask)orientationMask30 &#123;31 [_sdk setDialogOrientationMask:orientationMask];32 &#125;33 34 - (void)doBillingWithUIAndBillingIndex:(NSString *)billingIndex 35 isRepeated:(BOOL)isRepeated 36 cpParam:(NSString*)cpParam37 resultCallback:(BillingResultCallback)callback38 &#123;39 40 if (_callback != nil)41 &#123;42 [_callback release];43 _callback = nil;44 &#125;45 46 _callback = [callback copy]; // 注意要copy47 48 [_sdk doBillingWithUIAndBillingIndex:billingIndex 49 isRepeated:isRepeated 50 cpParam:cpParam];51 &#125;52 53 #pragma mark - GameBillingDelegate54 - (void)onBillingResult:(BillingResultType)resultCode55 billingIndex:(NSString *)index 56 message:(NSString *)message57 &#123;58 BOOL b = (resultCode == BillingResultType_PaySuccess || resultCode == BillingResultType_PaySuccess_Activated);59 NSLog(@"billing = %@ %@ %@", b ? @"yes":@"no", index, message);60 61 if (_callback != nil)62 &#123;63 _callback(b,index,message);64 65 // 调用完成就释放掉66 [_callback release];67 _callback = nil;68 &#125;69 &#125;70 71 @end 可以看到对提到的几个方法都做了封装，并且接收了回调。 下面是C++ Bridge Class部分，头文件CMGCIAP.h: 123456789101112131415161718192021222324 1 #include &lt;iostream&gt; 2 3 class CMGCIAP 4 &#123; 5 public: 6 CMGCIAP(); 7 ~CMGCIAP(); 8 9 public:10 static CMGCIAP *sharedInstance();11 12 bool init();13 14 void setDoBillingCallbackScriptHandler(int scriptHandler); // for lua callback15 16 void doBillingWithUI(const char* billingIndex,17 bool isRepeated,18 const char* cpParam);19 20 private:21 22 int m_doBillingCallbackScriptHandler;23 24 &#125;; 由于用cocos2d-x的tolua工具做Lua Binding的原因，我把设置Lua回调的方法单独提出来了，如下： 1 void setDoBillingCallbackScriptHandler(int scriptHandler);更好的做法是把这个scriptHandler放到下面这个函数中，这样接口就可以和Objective的保持一致了。 1 void doBillingWithUI(const char billingIndex,2 bool isRepeated,3 const char cpParam);不过也没关系，独立设置Lua回调函数也有更灵活的优点。 注意，C++ Bridge Class头文件一定保持“纯洁性”，做纯粹的C++文件，不能出现Objective-C的任何代码，否则就破坏了上面讲到的层次结构。 下面是实现文件CMGCIAP.mm: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071 1 #include "CMGCIAP.h" 2 #include "cocos2d.h" 3 #include "script_support/CCScriptSupport.h" 4 5 #import "CMGCIAPiOS.h" 6 #import &lt;Foundation/Foundation.h&gt; 7 #import &lt;UIKit/UIKit.h&gt; 8 9 USING_NS_CC;10 11 static CMGCIAP* s_sharedInstance = NULL;12 13 CMGCIAP::CMGCIAP()14 &#123;15 m_doBillingCallbackScriptHandler = 0;16 &#125;17 18 CMGCIAP::~CMGCIAP()19 &#123;20 21 &#125;22 23 CMGCIAP *CMGCIAP::sharedInstance()24 &#123;25 if (s_sharedInstance == NULL)26 &#123;27 s_sharedInstance = new CMGCIAP();28 &#125;29 30 return s_sharedInstance;31 &#125;32 33 // init方法封装了对SDK的初始化34 bool CMGCIAP::init()35 &#123;36 // 由于是竖屏的游戏，所以这里直接设置好了37 [[CMGCIAPiOS sharedInstance] setDialogOrientationMask:UIInterfaceOrientationMaskPortrait];38 39 return true;40 &#125;41 42 void CMGCIAP::setDoBillingCallbackScriptHandler(int scriptHandler)43 &#123;44 m_doBillingCallbackScriptHandler = scriptHandler;45 &#125;46 47 void CMGCIAP::doBillingWithUI(const char* billingIndex,48 bool isRepeated,49 const char* cpParam)50 &#123;51 52 NSString *billingIndexString = [NSString stringWithUTF8String:billingIndex];53 54 NSString *cpParamString = [NSString stringWithUTF8String:cpParam];55 56 [[CMGCIAPiOS sharedInstance] doBillingWithUIAndBillingIndex:billingIndexString57 isRepeated:isRepeated58 cpParam:cpParamString59 resultCallback:^(BOOL success, NSString *index,NSString *message)&#123;60 61 //通过Block将返回结果传给Lua，Objective-C到C++的无缝连接：）62 63 CCLuaStack *stack = CCLuaEngine::defaultEngine()-&gt;getLuaStack();64 stack-&gt;clean();65 stack-&gt;pushBoolean(success);66 stack-&gt;pushString([index UTF8String]);67 stack-&gt;pushString([message UTF8String]);68 stack-&gt;executeFunctionByHandler(m_doBillingCallbackScriptHandler, 3);69 70 &#125;];71 &#125; 好了，接下来只需要对C++ Bridge Class做Lua Binding，生成绑定文件，如果用tolua做绑定，绑定配置文件如下： 12345678910 1 class CMGCIAP 2 &#123; 3 static CMGCIAP *sharedInstance(); 4 5 void setDoBillingCallbackScriptHandler(LUA_FUNCTION nHandler); 6 7 void doBillingWithUI(const char* billingIndex, 8 bool isRepeated, 9 const char* cpParam);10 &#125; OK，到这里主要的编码工作就完成了，记得要在程序的适当位置做好Lua Binding初始化工作。 如果一切顺利，在以上工作完成后，在Lua里面已经可以直接调用SDK的接口了，接下来的事情就靠你们了：）]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>SDK</tag>
        <tag>Lua</tag>
        <tag>cocos2d</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发ARC内存管理技术要点]]></title>
    <url>%2F2017%2F09%2F21%2FiOS%E5%BC%80%E5%8F%91ARC%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%8A%80%E6%9C%AF%E8%A6%81%E7%82%B9%2F</url>
    <content type="text"><![CDATA[本文转载自iOS开发ARC内存管理技术要点-著作权归原作者所有 “本文来源于我个人的ARC学习笔记，旨在通过简明扼要的方式总结出iOS开发中ARC(Automatic Reference Counting，自动引用计数)内存管理技术的要点，所以不会涉及全部细节。这篇文章不是一篇标准的ARC使用教程，并假定读者已经对ARC有了一定了解和使用经验。详细的关于ARC的信息请参见苹果的官方文档与网上的其他教程：）” 本文的主要内容： ARC的本质 ARC的开启与关闭 ARC的修饰符 ARC与Block ARC与Toll-Free Bridging ARC的本质ARC是编译器（时）特性，而不是运行时特性，更不是垃圾回收器(GC)。Automatic Reference Counting (ARC) is a compiler-level feature that simplifies the process of managing object lifetimes (memory management) in Cocoa applications. ARC只是相对于MRC（Manual Reference Counting或称为非ARC，下文中我们会一直使用MRC来指代非ARC的管理方式）的一次改进，但它和之前的技术本质上没有区别。具体信息可以参考ARC编译器官方文档。 ARC的开启与关闭不同于XCode4可以在创建工程时选择关闭ARC，XCode5在创建的工程是默认开启ARC，没有可以关闭ARC的选项。 如果需要对特定文件开启或关闭ARC，可以在工程选项中选择Targets -&gt; Compile Phases -&gt; Compile Sources，在里面找到对应文件，添加flag: 打开ARC：-fobjc-arc 关闭ARC：-fno-objc-arc如图： ARC的修饰符ARC主要提供了4种修饰符，他们分别是:__strong,__weak,__autoreleasing,__unsafe_unretained。 __strong 表示引用为强引用。对应在定义property时的”strong”。所有对象只有当没有任何一个强引用指向时，才会被释放。 注意：如果在声明引用时不加修饰符，那么引用将默认是强引用。当需要释放强引用指向的对象时，需要将强引用置nil。 __weak 表示引用为弱引用。对应在定义property时用的”weak”。弱引用不会影响对象的释放，即只要对象没有任何强引用指向，即使有100个弱引用对象指向也没用，该对象依然会被释放。不过好在，对象在被释放的同时，指向它的弱引用会自动被置nil，这个技术叫zeroing weak pointer。这样有效得防止无效指针、野指针的产生。__weak一般用在delegate关系中防止循环引用或者用来修饰指向由Interface Builder编辑与生成的UI控件。 __autoreleasing 表示在autorelease pool中自动释放对象的引用，和MRC时代autorelease的用法相同。定义property时不能使用这个修饰符，任何一个对象的property都不应该是autorelease型的。 一个常见的误解是，在ARC中没有autorelease，因为这样一个“自动释放”看起来好像有点多余。这个误解可能源自于将ARC的“自动”和autorelease“自动”的混淆。其实你只要看一下每个iOS App的main.m文件就能知道，autorelease不仅好好的存在着，并且变得更fashion了：不需要再手工被创建，也不需要再显式得调用[drain]方法释放内存池。 以下两行代码的意义是相同的。12NSString *str = [[[NSString alloc] initWithFormat:@"hehe"] autorelease]; // MRCNSString *__autoreleasing str = [[NSString alloc] initWithFormat:@"hehe"]; // ARC 这里关于autoreleasepool就不做展开了，详细地信息可以参考官方文档或者其他文章。 __autoreleasing在ARC中主要用在参数传递返回值（out-parameters）和引用传递参数（pass-by-reference）的情况下。 __autoreleasing is used to denote arguments that are passed by reference (id *) and are autoreleased on return. 比如常用的NSError的使用：12345NSError *__autoreleasing error; ￼if (![data writeToFile:filename options:NSDataWritingAtomic error:&amp;error]) ￼&#123; NSLog(@"Error: %@", error); &#125; （在上面的writeToFile方法中error参数的类型为(NSError __autoreleasing )） 注意，如果你的error定义为了strong型，那么，编译器会帮你隐式地做如下事情，保证最终传入函数的参数依然是个__autoreleasing类型的引用。 1234567NSError *error; NSError *__autoreleasing tempError = error; // 编译器添加 if (![data writeToFile:filename options:NSDataWritingAtomic error:&amp;tempError]) ￼&#123; error = tempError; // 编译器添加 NSLog(@"Error: %@", error); &#125; 所以为了提高效率，避免这种情况，我们一般在定义error的时候将其（老老实实地=。=）声明为__autoreleasing类型的： NSError *__autoreleasing error;在这里，加上__autoreleasing之后，相当于在MRC中对返回值error做了如下事情： *error = [[[NSError alloc] init] autorelease]; error指向的对象在创建出来后，被放入到了autoreleasing pool中，等待使用结束后的自动释放，函数外error的使用者并不需要关心error指向对象的释放。 另外一点，在ARC中，所有这种指针的指针 （NSError **）的函数参数如果不加修饰符，编译器会默认将他们认定为__autoreleasing类型。 比如下面的两段代码是等同的：12345678- (NSString *)doSomething:(NSNumber **)value&#123; // do something &#125;- (NSString *)doSomething:(NSNumber * __autoreleasing *)value&#123; // do something &#125; 除非你显式得给value声明了__strong，否则value默认就是__autoreleasing的。 最后一点，某些类的方法会隐式地使用自己的autorelease pool，在这种时候使用__autoreleasing类型要特别小心。 比如NSDictionary的[enumerateKeysAndObjectsUsingBlock]方法： 123456789101112- (void)loopThroughDictionary:(NSDictionary *)dict error:(NSError **)error&#123; [dict enumerateKeysAndObjectsUsingBlock:^(id key, id obj, BOOL *stop)&#123; // do stuff if (there is some error &amp;&amp; error != nil) &#123; *error = [NSError errorWithDomain:@"MyError" ￼code:1 userInfo:nil]; &#125;￼ &#125;];￼&#125; 会隐式地创建一个autorelease pool，上面代码实际类似于： 123456789101112131415- (void)loopThroughDictionary:(NSDictionary *)dict error:(NSError **)error&#123; [dict enumerateKeysAndObjectsUsingBlock:^(id key, id obj, BOOL *stop)&#123; @autoreleasepool // 被隐式创建 &#123; if (there is some error &amp;&amp; error != nil) &#123; *error = [NSError errorWithDomain:@"MyError" ￼code:1 userInfo:nil]; &#125;￼ &#125; &#125;]; // *error 在这里已经被dict的做枚举遍历时创建的autorelease pool释放掉了 ：( ￼&#125; 为了能够正常的使用*error，我们需要一个strong型的临时引用，在dict的枚举Block中是用这个临时引用，保证引用指向的对象不会在出了dict的枚举Block后被释放，正确的方式如下： 1234567891011121314151617- (void)loopThroughDictionary:(NSDictionary *)dict error:(NSError **)error&#123; __block NSError* tempError; // 加__block保证可以在Block内被修改 [dict enumerateKeysAndObjectsUsingBlock:^(id key, id obj, BOOL *stop) &#123; if (there is some error) &#123; *tempError = [NSError errorWithDomain:@"MyError" ￼code:1 userInfo:nil]; &#125; ￼ &#125;] if (error != nil) &#123; *error = tempError; &#125; ￼&#125; __unsafe_unretained ARC是在iOS 5引入的，而这个修饰符主要是为了在ARC刚发布时兼容iOS 4以及版本更低的设备，因为这些版本的设备没有weak pointer system，简单的理解这个系统就是我们上面讲weak时提到的，能够在weak引用指向对象被释放后，把引用值自动设为nil的系统。这个修饰符在定义property时对应的是”unsafe_unretained”，实际可以将它理解为MRC时代的assign：纯粹只是将引用指向对象，没有任何额外的操作，在指向对象被释放时依然原原本本地指向原来被释放的对象（所在的内存区域）。所以非常不安全。 现在可以完全忽略掉这个修饰符了，因为iOS 4早已退出历史舞台很多年。 *使用修饰符的正确姿势（方式=。=） 这可能是很多人都不知道的一个问题，包括之前的我，但却是一个特别要注意的问题。 苹果的文档中明确地写道：You should decorate variables correctly. When using qualifiers in an object variable declaration, the correct format is: ClassName * qualifier variableName; 按照这个说明，要定义一个weak型的NSString引用，它的写法应该是： NSString * __weak str = @&quot;hehe&quot;; // 正确！而不应该是：__weak NSString *str = @&quot;hehe&quot;; // 错误！我相信很多人都和我一样，从开始用ARC就一直用上面那种错误的写法。 那这里就有疑问了，既然文档说是错误的，为啥编译器不报错呢？文档又解释道：Other variants are technically incorrect but are “forgiven” by the compiler. To understand the issue, seehttp://cdecl.org/. 好吧，看来是苹果爸爸（=。=）考虑到很多人会用错，所以在编译器这边贴心地帮我们忽略并处理掉了这个错误：）虽然不报错，但是我们还是应该按照正确的方式去使用这些修饰符，如果你以前也常常用错误的写法，那看到这里记得以后不要这么写了，哪天编译器怒了，再不支持错误的写法，就要郁闷了。 栈中指针默认值为nil 无论是被strong，weak还是autoreleasing修饰，声明在栈中的指针默认值都会是nil。所有这类型的指针不用再初始化的时候置nil了。虽然好习惯是最重要的，但是这个特性更加降低了“野指针”出现的可能性。 在ARC中，以下代码会输出null而不是crash:)12345- (void)myMethod &#123; NSString *name; NSLog(@"name: %@", name);&#125; ARC与Block在MRC时代，Block会隐式地对进入其作用域内的对象（或者说被Block捕获的指针指向的对象）加retain，来确保Block使用到该对象时，能够正确的访问。 这件事情在下面代码展示的情况中要更加额外小心。 12345678910MyViewController *myController = [[MyViewController alloc] init…];// 隐式地调用[myController retain];造成循环引用myController.completionHandler = ^(NSInteger result) &#123; [myController dismissViewControllerAnimated:YES completion:nil];&#125;;[self presentViewController:myController animated:YES completion:^&#123; [myController release]; // 注意，这里调用[myController release];是在MRC中的一个常规写法，并不能解决上面循环引用的问题&#125;]; 在这段代码中，myController的completionHandler调用了myController的方法[dismissViewController…]，这时completionHandler会对myController做retain操作。而我们知道，myController对completionHandler也至少有一个retain（一般准确讲是copy），这时就出现了在内存管理中最糟糕的情况：循环引用！简单点说就是：myController retain了completionHandler，而completionHandler也retain了myController。循环引用导致了myController和completionHandler最终都不能被释放。我们在delegate关系中，对delegate指针用weak就是为了避免这种问题。 不过好在，编译器会及时地给我们一个警告，提醒我们可能会发生这类型的问题： 对这种情况，我们一般用如下方法解决：给要进入Block的指针加一个__block修饰符。 这个__block在MRC时代有两个作用： 说明变量可改说明指针指向的对象不做这个隐式的retain操作一个变量如果不加__block ，是不能在Block里面修改的，不过这里有一个例外：static的变量和全局变量不需要加__block就可以在Block中修改。 使用这种方法，我们对代码做出修改，解决了循环引用的问题：123456MyViewController * __block myController = [[MyViewController alloc] init…];// ...myController.completionHandler = ^(NSInteger result) &#123; [myController dismissViewControllerAnimated:YES completion:nil];&#125;;//之后正常的release或者retain 在ARC引入后，没有了retain和release等操作，情况也发生了改变：在任何情况下，__block修饰符的作用只有上面的第一条：说明变量可改。即使加上了__block修饰符，一个被block捕获的强引用也依然是一个强引用。这样在ARC下，如果我们还按照MRC下的写法，completionHandler对myController有一个强引用，而myController对completionHandler有一个强引用，这依然是循环引用，没有解决问题：（ 于是我们还需要对原代码做修改。简单的情况我们可以这样写：123456__block MyViewController * myController = [[MyViewController alloc] init…];// ...myController.completionHandler = ^(NSInteger result) &#123; [myController dismissViewControllerAnimated:YES completion:nil]; myController = nil; // 注意这里，保证了block结束myController强引用的解除&#125;; 在completionHandler之后将myController指针置nil，保证了completionHandler对myController强引用的解除，不过也同时解除了myController对myController对象的强引用。这种方法过于简单粗暴了，在大多数情况下，我们有更好的方法。 这个更好的方法就是使用weak。（或者为了考虑iOS4的兼容性用unsafe_unretained，具体用法和weak相同，考虑到现在iOS4设备可能已经绝迹了，这里就不讲这个方法了）（关于这个方法的本质我们后面会谈到） 为了保证completionHandler这个Block对myController没有强引用，我们可以定义一个临时的弱引用weakMyViewController来指向原myController的对象，并把这个弱引用传入到Block内，这样就保证了Block对myController持有的是一个弱引用，而不是一个强引用。如此，我们继续修改代码：123456MyViewController *myController = [[MyViewController alloc] init…];// ...MyViewController * __weak weakMyViewController = myController;myController.completionHandler = ^(NSInteger result) &#123; [weakMyViewController dismissViewControllerAnimated:YES completion:nil];&#125;; 这样循环引用的问题就解决了，但是却不幸地引入了一个新的问题：由于传入completionHandler的是一个弱引用，那么当myController指向的对象在completionHandler被调用前释放，那么completionHandler就不能正常的运作了。在一般的单线程环境中，这种问题出现的可能性不大，但是到了多线程环境，就很不好说了，所以我们需要继续完善这个方法。 为了保证在Block内能够访问到正确的myController，我们在block内新定义一个强引用strongMyController来指向weakMyController指向的对象，这样多了一个强引用，就能保证这个myController对象不会在completionHandler被调用前释放掉了。于是，我们对代码再次做出修改： 123456789101112131415MyViewController *myController = [[MyViewController alloc] init…];// ...MyViewController * __weak weakMyController = myController;myController.completionHandler = ^(NSInteger result) &#123; MyViewController *strongMyController = weakMyController; if (strongMyController) &#123; // ... [strongMyController dismissViewControllerAnimated:YES completion:nil]; // ... &#125; else &#123; // Probably nothing... &#125;&#125;; 到此，一个完善的解决方案就完成了：） 官方文档对这个问题的说明到这里就结束了，但是可能很多朋友会有疑问，不是说不希望Block对原myController对象增加强引用么，这里为啥堂而皇之地在Block内新定义了一个强引用，这个强引用不会造成循环引用么？理解这个问题的关键在于理解被Block捕获的引用和在Block内定义的引用的区别。为了搞得明白这个问题，这里需要了解一些Block的实现原理，但由于篇幅的缘故，本文在这里就不展开了，详细的内容可以参考其他的文章，这里特别推荐唐巧的文章和另外2位作者的博文：这个和这个，讲的都比较清楚。 这里假设大家已经对Block的实现原理有所了解了。我们就直入主题了！注意前方高能（=。=） 为了更清楚地说明问题，这里用一个简单的程序举例。比如我们有如下程序： 123456789101112131415161718#include &lt;stdio.h&gt;int main()&#123; int b = 10; int *a = &amp;b; void (^blockFunc)() = ^()&#123; int *c = a; &#125;; blockFunc(); return 1;&#125; 程序中，同为int型的指针，a是被Block捕获的变量，而c是在Block内定义的变量。我们用clang -rewrite-objc处理后，可以看到如下代码： 原main函数： 123456789101112int main()&#123; int b = 10; int *a = &amp;b; void (*blockFunc)() = (void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, a); ((void (*)(__block_impl *))((__block_impl *)blockFunc)-&gt;FuncPtr)((__block_impl *)blockFunc); return 1;&#125; Block的结构： 12345678910111213struct __main_block_impl_0 &#123; struct __block_impl impl; struct __main_block_desc_0* Desc; int *a; // 被捕获的引用 a 出现在了block的结构体里面 __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int *_a, int flags=0) : a(_a) &#123; impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; &#125;&#125;; 实际执行的函数： 1234567static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123; int *a = __cself-&gt;a; // bound by copy int *c = a; // 在block中声明的引用 c 在函数中声明，存在于函数栈上 &#125; 我们可以清楚得看到，a和c存在的位置完全不同，如果Block存在于堆上（在ARC下Block默认在堆上），那么a作为Block结构体的一个成员，也自然会存在于堆上，而c无论如何，永远位于Block内实际执行代码的函数栈内。这也导致了两个变量生命周期的完全不同：c在Block的函数运行完毕，即会被释放，而a呢，只有在Block被从堆上释放的时候才会释放。 回到我们的MyViewController的例子中，同上理，如果我们直接让Block捕获我们的myController引用，那么这个引用会被复制后（引用类型也会被复制）作为Block的成员变量存在于其所在的堆空间中，也就是为Block增加了一个指向myController对象的强引用，这就是造成循环引用的本质原因。对于MyViewController的例子，Block的结构体可以理解是这个样子：（准确的结构体肯定和以下这个有区别，但也肯定是如下这种形式：） 12345678910111213struct __main_block_impl_0 &#123; struct __block_impl impl; struct __main_block_desc_0* Desc; MyViewController * __strong myController; // 被捕获的强引用myController __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int *_a, int flags=0) : a(_a) &#123; impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; &#125;&#125;; 而反观我们给Block传入一个弱引用weakMyController，这时我们Block的结构： 12345678910111213struct __main_block_impl_0 &#123; struct __block_impl impl; struct __main_block_desc_0* Desc; MyViewController * __weak weakMyController; // 被捕获的弱引用weakMyController __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int *_a, int flags=0) : a(_a) &#123; impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; &#125;&#125;; 再看在Block内声明的强引用strongMyController，它虽然是强引用，但存在于函数栈中，在函数执行期间，它一直存在，所以myController对象也一直存在，但是当函数执行完毕，strongMyController即被销毁，于是它对myController对象的强引用也被解除，这时Block对myController对象就不存在强引用关系了！加入了strongMyController的函数大体会是这个样子： 1234567static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123; MyViewController * __strong strongMyController = __cself-&gt;weakMyController; // .... &#125; 综上所述，在ARC下（在MRC下会略有不同），Block捕获的引用和Block内声明的引用无论是存在空间与生命周期都是截然不同的，也正是这种不同，造成了我们对他们使用方式的区别。 以上就解释了之前提到的所有问题，希望大家能看明白：） 好的，最后再提一点，在ARC中，对Block捕获对象的内存管理已经简化了很多，由于没有了retain和release等操作，实际只需要考虑循环引用的问题就行了。比如下面这种，是没有内存泄露的问题的： 123456789TestObject *aObject = [[TestObject alloc] init]; aObject.name = @"hehe";self.aBlock = ^()&#123; NSLog(@"aObject's name = %@",aObject.name); &#125;; 我们上面提到的解决方案，只是针对Block产生循环引用的问题，而不是说所有的Block捕获引用都要这么处理，一定要注意！ ARC与Toll-Free BridgingThere are a number of data types in the Core Foundation framework and the Foundation framework that can be used interchangeably. This capability, called toll-free bridging, means that you can use the same data type as the parameter to a Core Foundation function call or as the receiver of an Objective-C message. Toll-Free Briding保证了在程序中，可以方便和谐的使用Core Foundation类型的对象和Objective-C类型的对象。详细的内容可参考官方文档。以下是官方文档中给出的一些例子： 12345678910111213NSLocale *gbNSLocale = [[NSLocale alloc] initWithLocaleIdentifier:@"en_GB"];CFLocaleRef gbCFLocale = (CFLocaleRef) gbNSLocale;CFStringRef cfIdentifier = CFLocaleGetIdentifier (gbCFLocale);NSLog(@"cfIdentifier: %@", (NSString *)cfIdentifier);// logs: "cfIdentifier: en_GB"CFRelease((CFLocaleRef) gbNSLocale); CFLocaleRef myCFLocale = CFLocaleCopyCurrent();NSLocale * myNSLocale = (NSLocale *) myCFLocale;[myNSLocale autorelease];NSString *nsIdentifier = [myNSLocale localeIdentifier];CFShow((CFStringRef) [@"nsIdentifier: " stringByAppendingString:nsIdentifier]);// logs identifier for current locale 在MRC时代，由于Objective-C类型的对象和Core Foundation类型的对象都是相同的release和retain操作规则，所以Toll-Free Bridging的使用比较简单，但是自从ARC加入后，Objective-C类型的对象内存管理规则改变了，而Core Foundation依然是之前的机制，换句话说，Core Foundation不支持ARC。 这个时候就必须要要考虑一个问题了，在做Core Foundation与Objective-C类型转换的时候，用哪一种规则来管理对象的内存。显然，对于同一个对象，我们不能够同时用两种规则来管理，所以这里就必须要确定一件事情：哪些对象用Objective-C（也就是ARC）的规则，哪些对象用Core Foundation的规则（也就是MRC）的规则。或者说要确定对象类型转换了之后，内存管理的ownership的改变。 If you cast between Objective-C and Core Foundation-style objects, you need to tell the compiler about the ownership semantics of the object using either a cast (defined in objc/runtime.h) or a Core Foundation-style macro (defined inNSObject.h) 于是苹果在引入ARC之后对Toll-Free Bridging的操作也加入了对应的方法与修饰符，用来指明用哪种规则管理内存，或者说是内存管理权的归属。 这些方法和修饰符分别是： __bridge（修饰符） 只是声明类型转变，但是不做内存管理规则的转变。 比如： CFStringRef s1 = (__bridge CFStringRef) [[NSString alloc] initWithFormat:@&quot;Hello, %@!&quot;, name];只是做了NSString到CFStringRef的转化，但管理规则未变，依然要用Objective-C类型的ARC来管理s1，你不能用CFRelease()去释放s1。 __bridge_retained（修饰符） or CFBridgingRetain（函数） 表示将指针类型转变的同时，将内存管理的责任由原来的Objective-C交给Core Foundation来处理，也就是，将ARC转变为MRC。 比如，还是上面那个例子12345NSString *s1 = [[NSString alloc] initWithFormat:@"Hello, %@!", name];￼CFStringRef s2 = (__bridge_retained CFStringRef)s1;￼// do something with s2//...￼CFRelease(s2); // 注意要在使用结束后加这个 我们在第二行做了转化，这时内存管理规则由ARC变为了MRC，我们需要手动的来管理s2的内存，而对于s1，我们即使将其置为nil，也不能释放内存。 等同的，我们的程序也可以写成：123456NSString *s1 = [[NSString alloc] initWithFormat:@"Hello, %@!", name];￼CFStringRef s2 = (CFStringRef)CFBridgingRetain(s1);￼// do something with s2//...￼CFRelease(s2); // 注意要在使用结束后加这个__bridge_transfer（修饰符） or CFBridgingRelease（函数） 这个修饰符和函数的功能和上面那个__bridge_retained相反，它表示将管理的责任由Core Foundation转交给Objective-C，即将管理方式由MRC转变为ARC。 比如：1234CFStringRef result = CFURLCreateStringByAddingPercentEscapes(. . .);￼NSString *s = (__bridge_transfer NSString *)result;//or NSString *s = (NSString *)CFBridgingRelease(result);￼return s; 这里我们将result的管理责任交给了ARC来处理，我们就不需要再显式地将CFRelease()了。 对了，这里你可能会注意到一个细节，和ARC中那个4个主要的修饰符（__strong,__weak,…）不同，这里修饰符的位置是放在类型前面的，虽然官方文档中没有说明，但看官方的头文件可以知道。小伙伴们，记得别把位置写错哦：）呼~ 好了，以上就是本篇文章的主要内容。这次采用了新的排版，感觉比以前有条理得多，希望的大家看的舒服。 文章中如果有任何错误或者问题，可以在下面留言或者给我发信，期待你们的回复。 感谢大家的收看。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>ARC</tag>
        <tag>内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[知乎上某人的iOS面试题]]></title>
    <url>%2F2017%2F09%2F15%2F%E7%9F%A5%E4%B9%8E%E4%B8%8A%E6%9F%90%E4%BA%BA%E7%9A%84iOS%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[这是前年在知乎上总结回答MrPeak的问题，现在搬运到自己的blog中。知乎链接：http://www.zhihu.com/question/19604641 ###1.什么是arc？（arc是为了解决什么问题诞生的？）首先解释ARC: automatic reference counting自动引用计数。ARC几个要点：在对象被创建时 retain count +1，在对象被release时 retain count -1.当retain count 为0 时，销毁对象。程序中加autoreleasepoo的对象会由系统自动加上autorelease方法，如果该对象引用计数为0，则销毁。那么ARC是为了解决什么问题诞生的呢？这个得追溯到MRC手动内存管理时代说起。MRC下内存管理的缺点： 当我们要释放一个堆内存时，首先要确定指向这个堆空间的指针都被release了。（避免提前释放） 释放指针指向的堆空间，首先要确定哪些指针指向同一个堆，这些指针只能释放一次。（MRC下即谁创建，谁释放，避免重复释放） 模块化操作时，对象可能被多个模块创建和使用，不能确定最后由谁去释放。 多线程操作时，不确定哪个线程最后使用完毕 ###2.请解释以下keywords的区别： assign vs weak, __block vs __weakassign适用于基本数据类型，weak是适用于NSObject对象，并且是一个弱引用。assign其实也可以用来修饰对象，那么我们为什么不用它呢？因为被assign修饰的对象在释放之后，指针的地址还是存在的，也就是说指针并没有被置为nil。如果在后续的内存分配中，刚好分到了这块地址，程序就会崩溃掉。而weak修饰的对象在释放之后，指针地址会被置为nil。所以现在一般弱引用就是用weak。 首先__block是用来修饰一个变量，这个变量就可以在block中被修改（参考block实现原理）__block：使用 block修饰的变量在block代码快中会被retain（ARC下，MRC下不会retain）`weak` ：使用 weak修饰的变量不会在block代码块中被retain同时，在ARC下，要避免block出现循环引用 ``weak typedof(self)weakSelf = self``; ###3.block在arc和非arc下含义一样吗？是不一样的。在MRC中 block variable 在block中使用是不會retain的,但是ARC中 block則是會Retain的。取而代之的是用 `weak或是__unsafe_unretained` 來更精確的描述weak reference的目的其中前者只能在iOS5之後可以使用，但是比較好 (該物件release之後，此pointer會自動設成nil)而後者是ARC的環境下為了相容4.x的解決方案。所以上面的範例中123__block MyClass* temp = …; // MRC環境下使用__weak MyClass* temp = …; // ARC但只支援iOS5.0以上的版本__unsafe_retained MyClass* temp = …; //ARC且可以相容4.x以後的版本 ###4.使用nonatomic一定是线程安全的吗？（）不是的。atomic原子操作，系统会为setter方法加锁。 具体使用 @synchronized(self){//code }nonatomic不会为setter方法加锁。atomic：线程安全，需要消耗大量系统资源来为属性加锁nonatomic：非线程安全，适合内存较小的移动设备 ###5.描述一个你遇到过的retain cycle例子。block中的循环引用：一个viewController123456@property (nonatomic,strong)HttpRequestHandler * handler;@property (nonatomic,strong)NSData *data;_handler = [httpRequestHandler sharedManager];[ downloadData:^(id responseData)&#123; _data = responseData;&#125;]; self 拥有_handler, _handler 拥有block, block拥有self（因为使用了self的_data属性，block会copy 一份self）解决方法：1234__weak typedof(self)weakSelf = self[ downloadData:^(id responseData)&#123; weakSelf.data = responseData;&#125;]; 6.+(void)load; +(void)initialize；有什么用处？在Objective-C中，runtime会自动调用每个类的两个方法。+load会在类初始加载时调用，+initialize会在第一次调用类的类方法或实例方法之前被调用。这两个方法是可选的，且只有在实现了它们时才会被调用。共同点：两个方法都只会被调用一次。7.为什么其他语言里叫函数调用， objective c里则是给对象发消息（或者谈下对runtime的理解）先来看看怎么理解发送消息的含义：曾经觉得Objc特别方便上手，面对着 Cocoa 中大量 API，只知道简单的查文档和调用。还记得初学 Objective-C 时把[receiver message]当成简单的方法调用，而无视了“发送消息”这句话的深刻含义。于是[receiver message]会被编译器转化为：objc_msgSend(receiver, selector)如果消息含有参数，则为：objc_msgSend(receiver, selector, arg1, arg2, ...)如果消息的接收者能够找到对应的selector，那么就相当于直接执行了接收者这个对象的特定方法；否则，消息要么被转发，或是临时向接收者动态添加这个selector对应的实现内容，要么就干脆玩完崩溃掉。现在可以看出[receiver message]真的不是一个简简单单的方法调用。因为这只是在编译阶段确定了要向接收者发送message这条消息，而receive将要如何响应这条消息，那就要看运行时发生的情况来决定了。Objective-C 的 Runtime 铸就了它动态语言的特性，这些深层次的知识虽然平时写代码用的少一些，但是却是每个 Objc 程序员需要了解的。Objc Runtime使得C具有了面向对象能力，在程序运行时创建，检查，修改类、对象和它们的方法。可以使用runtime的一系列方法实现。顺便附上OC中一个类的数据结构 /usr/include/objc/runtime.h12345678910111213141516 struct objc_class &#123;Class isa OBJC_ISA_AVAILABILITY; //isa指针指向Meta Class，因为Objc的类的本身也是一个Object，为了处理这个关系，r untime就创造了Meta Class，当给类发送[NSObject alloc]这样消息时，实际上是把这个消息发给了Class Object#if !__OBJC2__Class super_class OBJC2_UNAVAILABLE; // 父类const char *name OBJC2_UNAVAILABLE; // 类名long version OBJC2_UNAVAILABLE; // 类的版本信息，默认为0long info OBJC2_UNAVAILABLE; // 类信息，供运行期使用的一些位标识long instance_size OBJC2_UNAVAILABLE; // 该类的实例变量大小struct objc_ivar_list *ivars OBJC2_UNAVAILABLE; // 该类的成员变量链表struct objc_method_list **methodLists OBJC2_UNAVAILABLE; // 方法定义的链表struct objc_cache *cache OBJC2_UNAVAILABLE; // 方法缓存，对象接到一个消息会根据isa指针查找消息对象，这时会在method Lists中遍历，如果cache了，常用的方法调用时就能够提高调用的效率。struct objc_protocol_list *protocols OBJC2_UNAVAILABLE; // 协议链表#endif&#125; OBJC2_UNAVAILABLE;OC中一个类的对象实例的数据结构（/usr/include/objc/objc.h）:12345678910111213typedef struct objc_class *Class;/// Represents an instance of a class.struct objc_object &#123; Class isa OBJC_ISA_AVAILABILITY;&#125;;/// A pointer to an instance of a class.typedef struct objc_object *id;向object发送消息时，Runtime库会根据object的isa指针找到这个实例object所属于的类，然后在类的方法列表以及父类方法列表寻找对应的方法运行。id是一个objc_object结构类型的指针，这个类型的对象能够转换成任何一种对象。然后再来看看消息发送的函数：objc_msgSend函数在引言中已经对objc_msgSend进行了一点介绍，看起来像是objc_msgSend返回了数据，其实objc_msgSend从不返回数据而是你的方法被调用后返回了数据。下面详细叙述下消息发送步骤：检测这个 selector 是不是要忽略的。比如 Mac OS X 开发，有了垃圾回收就不理会 retain,release 这些函数了。检测这个 target 是不是 nil 对象。ObjC 的特性是允许对一个 nil 对象执行任何一个方法不会 Crash，因为会被忽略掉。如果上面两个都过了，那就开始查找这个类的 IMP，先从 cache 里面找，完了找得到就跳到对应的函数去执行。如果 cache 找不到就找一下方法分发表。如果分发表找不到就到超类的分发表去找，一直找，直到找到NSObject类为止。如果还找不到就要开始进入动态方法解析了，后面会提到。后面还有：动态方法解析resolveThisMethodDynamically消息转发forwardingTargetForSelector详情可参考 http://www.jianshu.com/p/620022378e978.什么是method swizzling?Method Swizzling 原理（方法交换？）在Objective-C中调用一个方法，其实是向一个对象发送消息，查找消息的唯一依据是selector的名字。利用Objective-C的动态特性，可以实现在运行时偷换selector对应的方法实现，达到给方法挂钩的目的。每个类都有一个方法列表，存放着selector的名字和方法实现的映射关系。IMP有点类似函数指针，指向具体的Method实现。方法指向我们可以利用 method_exchangeImplementations 来交换2个方法中的IMP，我们可以利用 class_replaceMethod 来修改类，我们可以利用 method_setImplementation 来直接设置某个方法的IMP，……归根结底，都是偷换了selector的IMP，如下图所示：方法交换详情：http://blog.csdn.net/yiyaaixuexi/article/details/93744119.UIView和CALayer是啥关系？ 1.UIView是iOS系统中界面元素的基础，所有的界面元素都继承自它。它本身完全是由CoreAnimation来实现的 （Mac下似乎不是这样）。它真正的绘图部分，是由一个叫CALayer（Core Animation Layer）的类来管理。 UIView本身，更像是一个CALayer的管理器，访问它的跟绘图和跟坐标有关的属性，例如frame，bounds等 等，实际上内部都是在访问它所包含的CALayer的相关属性。 2.UIView有个layer属性，可以返回它的主CALayer实例，UIView有一个layerClass方法，返回主layer所使用的 类，UIView的子类，可以通过重载这个方法，来让UIView使用不同的CALayer来显示，例如通过123- (class) layerClass &#123; return ([CAEAGLLayer class]);&#125; 使某个UIView的子类使用GL来进行绘制。 3.UIView的CALayer类似UIView的子View树形结构，也可以向它的layer上添加子layer，来完成某些特殊的表 示。例如下面的代码12345grayCover = [[CALayer alloc] init];grayCover.backgroundColor = [[[UIColor blackColor] colorWithAlphaComponent:0.2] CGColor];[self.layer addSubLayer: grayCover]; 会在目标View上敷上一层黑色的透明薄膜。 4.UIView的layer树形在系统内部，被系统维护着三份copy（这段理解有点吃不准）。 逻辑树，就是代码里可以操纵的，例如更改layer的属性等等就在这一份。 动画树，这是一个中间层，系统正在这一层上更改属性，进行各种渲染操作。 显示树，这棵树的内容是当前正被显示在屏幕上的内容。 这三棵树的逻辑结构都是一样的，区别只有各自的属性。 10. 如何高性能的给UIImageView加个圆角？（不准说layer.cornerRadius!） 我觉得应该是使用Quartz2D直接绘制图片,得把这个看看。步骤： a、创建目标大小(cropWidth，cropHeight)的画布。 b、使用UIImage的drawInRect方法进行绘制的时候，指定rect为(-x，-y，width，height)。 c、从画布中得到裁剪后的图像。1234567891011121314151617- (UIImage*)cropImageWithRect:(CGRect)cropRect&#123; CGRect drawRect = CGRectMake(-cropRect.origin.x , -cropRect.origin.y, self.size.width * self.scale, self.size.height * self.scale); UIGraphicsBeginImageContext(cropRect.size); CGContextRef context = UIGraphicsGetCurrentContext(); CGContextClearRect(context, CGRectMake(0, 0, cropRect.size.width, cropRect.size.height)); [self drawInRect:drawRect]; UIImage *image = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); return image;&#125;@end 11. 使用drawRect有什么影响？（这个可深可浅，你至少得用过。。）drawRect方法依赖Core Graphics框架来进行自定义的绘制，但这种方法主要的缺点就是它处理touch事件的方式：每次按钮被点击后，都会用setNeddsDisplay进行强制重绘；而且不止一次，每次单点事件触发两次执行。这样的话从性能的角度来说，对CPU和内存来说都是欠佳的。特别是如果在我们的界面上有多个这样的UIButton实例。 12. ASIHttpRequest或者SDWebImage里面给UIImageView加载图片的逻辑是什么样的？详见SDWebImage的实现流程 http://www.cnblogs.com/6duxz/p/4159572.html 13. 麻烦你设计个简单的图片内存缓存器（移除策略是一定要说的）图片的内存缓存:数据结构：双向链表。 移除策略：LRU：least resently used,最近淘汰算法。释放数据模型对象。可参考YYCache 源码解析 14. 讲讲你用Instrument优化动画性能的经历吧（别问我什么是Instrument）可以参考iOS App性能优化 15. loadView是干嘛用的？当你访问一个ViewController的view属性时，如果此时view的值是nil，那么，ViewController就会自动调用loadView这个方法。这个方法就会加载或者创建一个view对象，赋值给view属性。loadView默认做的事情是：如果此ViewController存在一个对应的nib文件，那么就加载这个nib。否则，就创建一个UIView对象。 如果你用Interface Builder来创建界面，那么不应该重载这个方法。 如果你想自己创建view对象，那么可以重载这个方法。此时你需要自己给view属性赋值。你自定义的方法不应该调用super。如果你需要对view做一些其他的定制操作，在viewDidLoad里面去做。 ========================================= 根据上面的文档可以知道，有两种情况： 1、如果你用了nib文件，重载这个方法就没有太大意义。因为loadView的作用就是加载nib。如果你重载了这个方法不调用super，那么nib文件就不会被加载。如果调用了super，那么view已经加载完了，你需要做的其他事情在viewDidLoad里面做更合适。 2、如果你没有用nib，这个方法默认就是创建一个空的view对象。如果你想自己控制view对象的创建，例如创建一个特殊尺寸的view，那么可以重载这个方法，自己创建一个UIView对象，然后指定 self.view = myView; 但这种情况也没有必要调用super，因为反正你也不需要在super方法里面创建的view对象。如果调用了super，那么就是浪费了一些资源而已参考：http://www.cnblogs.com/dyllove98/archive/2013/06/06/3123005.html 16. viewWillLayoutSubView你总是知道的。横竖屏切换的时候，系统会响应一些函数，其中 viewWillLayoutSubviews 和 viewDidLayoutSubviews。 1234567891011121314- (void)viewWillLayoutSubviews&#123; [self _shouldRotateToOrientation:(UIDeviceOrientation)[UIApplication sharedApplication].statusBarOrientation];&#125;- (void)_shouldRotateToOrientation:(UIDeviceOrientation)orientation &#123; if (orientation == UIDeviceOrientationPortrait ||orientation == UIDeviceOrientationPortraitUpsideDown) &#123; // 竖屏&#125;else &#123; // 横屏 &#125;&#125; 通过上述一个函数就知道横竖屏切换的接口了。注意：viewWillLayoutSubviews只能用在ViewController里面，在view里面没有响应。 17. GCD里面有哪几种Queue？你自己建立过串行queue吗？背后的线程模型是什么样的？1.主队列 dispatch_main_queue(); 串行 ，更新UI2.全局队列 dispatch_global_queue(); 并行，四个优先级：background，low，default，high3.自定义队列 dispatch_queue_t queue ; 可以自定义是并行：DISPATCH_QUEUE_CONCURRENT或者串行DISPATCH_QUEUE_SERIAL 18. 用过coredata或者sqlite吗？读写是分线程的吗？遇到过死锁没？咋解决的？参考：CoreData与SQLite的线程安全 19. http的post和get啥区别？（区别挺多的，麻烦多说点）1.GET请求的数据会附在URL之后（就是把数据放置在HTTP协议头中），以?分割URL和传输数据，参数之间以&amp;相连，如：login.action?name=hyddd&amp;password=idontknow&amp;verify=%E4%BD%A0%E5%A5%BD。如果数据是英文字母/数字，原样发送，如果是空格，转换为+，如果是中文/其他字符，则直接把字符串用BASE64加密，得出如：%E4%BD%A0%E5%A5%BD，其中％XX中的XX为该符号以16进制表示的ASCII。 POST把提交的数据则放置在是HTTP包的包体中。 2.”GET方式提交的数据最多只能是1024字节，理论上POST没有限制，可传较大量的数据，IIS4中最大为80KB，IIS5中为100KB”？？！ 以上这句是我从其他文章转过来的，其实这样说是错误的，不准确的： (1).首先是”GET方式提交的数据最多只能是1024字节”，因为GET是通过URL提交数据，那么GET可提交的数据量就跟URL的长度有直接关系了。而实际上，URL不存在参数上限的问题，HTTP协议规范没有对URL长度进行限制。这个限制是特定的浏览器及服务器对它的限制。IE对URL长度的限制是2083字节(2K+35)。对于其他浏览器，如Netscape、FireFox等，理论上没有长度限制，其限制取决于操作系统的支持。 注意这是限制是整个URL长度，而不仅仅是你的参数值数据长度。[见参考资料5] (2).理论上讲，POST是没有大小限制的，HTTP协议规范也没有进行大小限制，说“POST数据量存在80K/100K的大小限制”是不准确的，POST数据是没有限制的，起限制作用的是服务器的处理程序的处理能力。 3.在ASP中，服务端获取GET请求参数用Request.QueryString，获取POST请求参数用Request.Form。在JSP中，用request.getParameter(\”XXXX\”)来获取，虽然jsp中也有request.getQueryString()方法，但使用起来比较麻烦，比如：传一个test.jsp?name=hyddd&amp;password=hyddd，用request.getQueryString()得到的是：name=hyddd&amp;password=hyddd。在PHP中，可以用$_GET和$_POST分别获取GET和POST中的数据，而$_REQUEST则可以获取GET和POST两种请求中的数据。值得注意的是，JSP中使用request和PHP中使用$_REQUEST都会有隐患，这个下次再写个文章总结。 4.POST的安全性要比GET的安全性高。注意：这里所说的安全性和上面GET提到的“安全”不是同个概念。上面“安全”的含义仅仅是不作数据修改，而这里安全的含义是真正的Security的含义，比如：通过GET提交数据，用户名和密码将明文出现在URL上，因为(1)登录页面有可能被浏览器缓存，(2)其他人查看浏览器的历史纪录，那么别人就可以拿到你的账号和密码了，除此之外，使用GET提交数据还可能会造成Cross-site request forgery攻击。 总结一下，Get是向服务器发索取数据的一种请求，而Post是向服务器提交数据的一种请求，在FORM（表单）中，Method默认为”GET”，实质上，GET和POST只是发送机制不同，并不是一个取一个发！ 20. 我知道你大学毕业过后就没接触过算法数据结构了，但是请你一定告诉我什么是Binary search tree? search的时间复杂度是多少？Binary search tree:二叉搜索树。搜索,插入,删除的复杂度等于树高，O(log(n))1.search：时间复杂度为O(h)，h为树的高度 2.traversal：时间复杂度为O(n)，n为树的总结点数。 3.insert：时间复杂度为O(h)，h为树的高度。 4.delete：最坏情况下，时间复杂度为O(h)+指针的移动开销。 可以看到，二叉搜索树的dictionary operation的时间复杂度与树的高度h相关。所以需要尽可能的降低树的高度，由此引出平衡二叉树Balanced binary tree。它要求左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。这样就可以将搜索树的高度尽量减小。常用算法有红黑树、AVL、Treap、伸展树等。]]></content>
      <categories>
        <category>iOSInterview</category>
      </categories>
      <tags>
        <tag>知乎</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[腾讯SNG某部门iOS面试经历]]></title>
    <url>%2F2017%2F09%2F05%2F%E8%85%BE%E8%AE%AFSNG%E6%9F%90%E9%83%A8%E9%97%A8iOS%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%8E%86%2F</url>
    <content type="text"><![CDATA[腾讯SNG面试，算是积攒一次面试经验了。可以看出，高级工程师不仅要会用一些常用库，还要懂得它们的原理。 1.APP性能优化：内存泄露检测、卡顿检测,自己做应该怎么做？内存泄露检测： 1. Instruments工具：Leaks，Allocation. 2. MLeakFinder工具。MLeaksFinder：精准 iOS 内存泄露检测工具iOS内存泄漏自动检测工具PLeakSniffer卡顿检测： 1. 开发阶段可以用CADisplayLink，添加到runloop中. 2. 线上监测，除了用第三方SDK之外，可以使用 “在子线程添加observer监测主线程”的方式.微信读书 iOS 性能优化总结卡顿检测的实现代码可以在这里找到：检测iOS的APP性能的一些方法开源工具：- FBRetainCycleDetector- MLeaksFinder- PLCrashreporter2.AsycDisplayKit 原理。 AsyncDisplayKit是 Facebook 推出的用于保持界面流畅性的框架，其原理大致如下：UI 线程中一旦出现繁重的任务就会导致界面卡顿，这类任务通常分为3类：排版，绘制，UI对象操作。排版通常包括计算视图大小、计算文本高度、重新计算子式图的排版等操作。 绘制一般有文本绘制 (例如 CoreText)、图片绘制 (例如预先解压)、元素绘制 (Quartz)等操作。UI对象操作通常包括 UIView/CALayer 等 UI 对象的创建、设置属性和销毁。 其中前两类操作可以通过各种方法扔到后台线程执行，而最后一类操作只能在主线程完成，并且有时后面的操作需要依赖前面操作的结果 （例如TextView创建时可能需要提前计算出文本的大小）。ASDK 所做的，就是尽量将能放入后台的任务放入后台，不能的则尽量推迟 (例如视图的创建、属性的调整)。为此，ASDK 创建了一个名为 ASDisplayNode 的对象，并在内部封装了 UIView/CALayer，它具有和 UIView/CALayer 相似的属性，例如 frame、backgroundColor等。所有这些属性都可以在后台线程更改，开发者可以只通过 Node 来操作其内部的 UIView/CALayer，这样就可以将排版和绘制放入了后台线程。但是无论怎么操作，这些属性总需要在某个时刻同步到主线程的 UIView/CALayer 去。 ASDK 仿照 QuartzCore/UIKit 框架的模式，实现了一套类似的界面更新的机制：即在主线程的 RunLoop 中添加一个 Observer，监听了 kCFRunLoopBeforeWaiting 和 kCFRunLoopExit 事件，在收到回调时，遍历所有之前放入队列的待处理的任务，然后一一执行。 具体的代码可以看这里：_ASAsyncTransactionGroup。 3.Crash ，Bug收集 SDK的原理，自己做应该怎么做？ 注册NSSetUncaughtExceptionHandler，包括两种： HandleException SignalHandler 漫谈iOS Crash收集框架 iOS崩溃捕获以及收集原理 4.Core animation 动画与UIView动画的区别,动画执行过程中是否响应事件？ UIView animation 由CPU执行，Core Animation由GPU执行。 CALayer本身不能响应事件，UIView是在CAlayer之上，增加了触摸响应,手势识别等事件响应。 Core Animation is not executed on the CPU. Their commands are more offloaded to the GPU and used to create the graphics that are shown on the screen, powered by the GPU hardware. Core Graphics is entirely done on the CPU, and cannot be performed on the GPU. Because it is an entirely CPU-bound operation, it is sometimes slower on older devices (e.g. the iPad 2 or the iPad 3rd Generation). This is something you need to keep in mind when using it in your apps. But, the good thing about Core Graphics is you can combine it with Core Animation. Advanced Graphics with Core Animation Core Animation does the rest, handing most of the actual drawing work off to the onboard graphics hardware to accelerate the rendering. This automatic graphics acceleration results in high frame rates and smooth animations without burdening the CPU and slowing down your app. Core Animation Programming Guide 动画执行过程中是否响应事件？12345678910111213- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123; NSLog(@"%s",__func__); UITouch *touch = [touches anyObject]; CGPoint point = [touch locationInView:self.view]; if (CGRectContainsPoint(self.colorLayer.presentationLayer.frame, point)) &#123; [self startAnimation]; &#125; if (CGRectContainsPoint(self.myView.frame, point)) &#123; [self startUIViewAnimation:nil]; &#125;&#125; 经过测试，CALayer是可以响应touch事件的,而UIView的block animation在执行过程中不能响应其自身的触摸事件。 注意CALayer在动画执行过程中要是用presentationLayer属性才能获取到中间状态的layerCore Animation 的removedOnCompletion 属性默认是YES，即动画结束之后会移除动画，CALayer会回到原来的状态 可以查看Core Animation Programming Guide 的显式动画一章。 另外附一篇有意思的文章 UIDynamics, UIKit or OpenGL? 3 Types of iOS Animations for the Star Wars,值得一读。 5.Https概念，iOS中设置https。略6.100W数据中找到最大的1W个数，使用什么数据结构？ 最小堆 先拿10000个数建堆，然后一次添加剩余元素，如果大于堆顶的数（10000中最小的），将这个数替换堆顶，并调整结构使之仍然是一个最小堆，这样，遍历完后，堆中的10000个数就是所需的最大的10000个。建堆时间复杂度是O（mlogm），算法的时间复杂度为O（nmlogm）（n为10亿，m为10000）。 优化的方法：可以把所有10亿个数据分组存放，比如分别放在1000个文件中。这样处理就可以分别在每个文件的10^6个数据中找出最大的10000个数，合并到一起在再找出最终的结果。 海量数据处理 - 10亿个数中找出最大的10000个数（top K问题） 7.音视频开发，没做过，然后提到简历上的二维码扫描库 - AVFoundation。影响二维码扫描速度的难点是什么？我回答是二维码图像的清晰度，面试官还提到了二维码图像的角度，该如何优化。对于AVFoundation来说，有两个因素：1. 图像分辨率 AVCaptureSession 可以设置 sessionPreset 属性，这个决定了视频输入每一帧图像质量的大小。 AVCaptureSessionPreset320x240 AVCaptureSessionPreset352x288 AVCaptureSessionPreset640x480 AVCaptureSessionPreset960x540 AVCaptureSessionPreset1280x720 AVCaptureSessionPreset1920x10802. 扫描范围 AVCaptureMetadataOutput 的 rectOfInterest 属性来配置解析范围8.离屏渲染问题的本质是什么？ 首先离屏渲染指的是在GPU在当前屏幕缓冲区以外开辟一个缓冲区进行渲染操作. 当使用圆角，阴影，遮罩的时候，图层属性的混合体被指定为在未预合成之前(下一个HSync信号开始前)不能直接在屏幕中绘制，所以就需要屏幕外渲染。 具体参考这篇文章：iOS-离屏渲染详解 总结： 本次面试问题侧重于实际项目，很多东西之前有看过，但都忘了大概，用到但没有深入研究是一大劣势。 所以说多多面试还是有帮助的😆！ 面试必看文章：iOS 保持界面流畅的技巧iOS 应用稳定性监测和指标问题 iOS 性能监控方案（上篇）iOS 性能监控方案（下篇）]]></content>
      <categories>
        <category>iOSInterview</category>
      </categories>
      <tags>
        <tag>腾讯</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MVVM in Practice]]></title>
    <url>%2F2017%2F08%2F30%2FMVVM-in-Practice%2F</url>
    <content type="text"><![CDATA[MVVM in Practice - RWDevCon Session - raywenderlich.com MVVM已经被谈论很多了，却一直没有深入理解和实践，本篇是在观看该视频后的小结。 该视频中讲解了MVC到MVVM的迁移重构和重点，并没有涉及到FRP，初学者可以很快进入MVVM中。 概念MVVM： Model-View-ViewModel。通过分离ViewController中逻辑代码到独立的ViewModel中，实现业务逻辑分离和VC瘦身。 重点：Data BindingiOS中的数据绑定方式： KVO Delegate Funtional Reactive Programming Property Observer 1234567 var str = "Hello, playground" &#123; didSet &#123; print("new str : \(str)") &#125;&#125;str = "hello swift" 实现一个Data Binding类:Box 123456789101112131415161718192021222324252627class Box&lt;T&gt; &#123; typealias Listener = (T) -&gt; Void var listener : Listener? var value:T &#123; didSet &#123; listener?(value) &#125; &#125; init(_ value:T) &#123; self.value = value &#125; func bind(listener:Listener?) &#123; self.listener = listener listener?(value) &#125;&#125;var bindedObj = Box("")bindedObj.bind &#123; print("new value:\($0)")&#125;bindedObj.value = "2017" 可以看出是使用了closure来实现bingding的。同理，Cocoa中的其他类都可以写一个extension实现绑定。 提问环节（只给出回答中的重点内容） 为什么ViewModel使用的是class而不是struct？ Ash：说是因为他认为这个ViewModel中不仅是数据逻辑，还包含有其他功能逻辑代码。 为什么dispatchAfter中使用weak self，而viewController中使用unowned self？ Ash：通常来说，weak修饰的变量有可能是为nil的，而unowned修饰的变量你会保证它不是optional的。 MVVM的Benifits和Limitation Benifits: Breaks up code by responsibility Simplifies Testing Code reusablibity Limitation: Requires binding(or other workarounds) Potential for boilerplate code Sometimes feels like overkill Doesn’t cover every case 延伸阅读 ReactiveCocoa/RxSwift Getting Started With RxSwift and RxCocoa]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>swift</tag>
        <tag>MVVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简记 - 记录你的生活]]></title>
    <url>%2F2017%2F03%2F11%2F%E7%AE%80%E8%AE%B0-%E8%AE%B0%E5%BD%95%E4%BD%A0%E7%9A%84%E7%94%9F%E6%B4%BB%2F</url>
    <content type="text"><![CDATA[简记 —— 记录你的生活最简单的文字记录app，带给你清新，简约的气息。 没什么特点的文字编辑app。 ———我是分割线———–特点：(⊙v⊙)嗯，就是简单。 文集分类管理日记。快速创建日记。分享给好友啦。 联系邮箱: hanangellove@icloud.com]]></content>
      <categories>
        <category>app</category>
      </categories>
      <tags>
        <tag>简记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发技术栈]]></title>
    <url>%2F2016%2F12%2F12%2FiOS%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF%E6%A0%88%2F</url>
    <content type="text"><![CDATA[提醒自己： Objective-C• objective-c语言基础• library,framework的制作• Runtime编程• LLVM原理和调优 操作系统• iOS内存管理和调优• iOS的文件系统和沙盒机制• iOS多线程编程（Thread,GCD,NSOperation）• iOS网络和服务器编程（NSURLConnection,NSURLSession）• iOS系统的各种安全机制 网络编程• iOS网络发送机制调整和优化（NSURLSession）• Socket编程•网络传输中的各种保障•对传输协议的调整优化 数据库&amp;持久化方案• 常规持久化方案（Keychain,NSUserDefaults,Sqlite,CoreData）•数据库的使用和设计（Sqlite）•数据结构优化，Sql调优 图形图像编程• UIKit,Core Animation和Core Text的绘制• Core Graphics, Quartz 2D, Media Player, AV Foundation• OpenGL ES, GLKit, SpriteKit, SceneKit, Metal 数据结构 &amp; 算法•基本的算法和数据结构（排序搜索算法, 数组, 队列）•较复杂数据结构的灵活应用（二叉树, 图等）•复杂的专项算法（图像识别算法, 拓扑定位等等） 安全方案• 本地数据存储安全（Keychain）•授权和身份验证•传输安全（对称, 非对称, SSL）• App代码安全 业务能力•一般性业务功能需求分析及实现•重要业务模块的需求分析及实现•中小规模产品的架构，系统设计和实现•大规模产品或产品线的架构，系统设计和实现•平台级产品的架构，系统设计和实现]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>skills</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS自动打包脚本]]></title>
    <url>%2F2016%2F11%2F30%2FiOS%E8%87%AA%E5%8A%A8%E6%89%93%E5%8C%85%E8%84%9A%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[使用Xcodebuild和xcrun命令生成。具体参数可以自己配置。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#!/bin/bash#Author hanliu#Global declarationSCHEMENAME="hongmeng"#if use git#BRANCHNAME = masterDATE=`date "+%Y%m%d"`SOURCEPATH=$(CD "$(dirname $0)" &amp;&amp; pwd)BUILDPATH=$(dirname $(dirname $SOURCEPATH))/AutoBuildIPABUILDAPPPATH=$BUILDPATH/Build/Products/Debug-iphoneosIPAPATH=$(dirname $(dirname $SOURCEPATH))/IPAIPANAME=$SCHEMENAME_$DATE.ipaecho "DATE is " $DATEecho "SOURCEPATH:"$SOURCEPATHecho "BUILDPATH:"$BUILDPATHecho "IPAPATH:"$IPAPATHecho "Press any key to continue!"read -p "press any " cif $c;then xcodebuild -listelse echo "ddd"fi##Information about project "xxxxx":# Targets:# xxxxxx## Build Configurations:# Debug# Release## If no build configuration is specified and -scheme is not passed then "Release" is used.## Schemes:# xxxxxx##不指定configuration，打包为debug模式#xcodebuild -workspace hongmeng.xcworkspace -scheme hongmeng -configuration Debug clean build -derivedDataPath $BUILDPATHxcodebuild -workspace $SCHEMENAME.xcworkspace -scheme $SCHEMENAME -configuration Debug clean build -derivedDataPath $BUILDPATHif [ -e $BUILDPATH ]; then echo "xcodebuild Successful!"else echo "xcodebuild failure!" exit 1fi#打包ipa#xcrun -sdk iphoneos PackageApplication -v AutoBuildIPA/Build/Products/Debug-iphoneos/$SCHEMENAME.app -o $BUILDPATH/$SCHEMENAME_$DATE.ipaxcrun -sdk iphoneos PackageApplication -v $BUILDAPPPATH/$SCHEMENAME.app -o $IPAPATH/$IPANAMEif [ -e $IPAPATH/$IPANAME ]; then echo "\n--------------\n\n" echo "Congratulations! Build Successful!" open $IPAPATHelse echo "Build failure!"fi]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Objc Runtime 再次实践]]></title>
    <url>%2F2016%2F11%2F22%2FOBJC-RUNTIME-%E5%86%8D%E6%AC%A1%E5%AE%9E%E8%B7%B5%2F</url>
    <content type="text"><![CDATA[好久不用，再次使用runtime重写代码。就用高性能添加图片圆角来再一次实践一下runtime的基本用法。 runtime使用场景： category添加关联属性 MethodSwizzle替换/交换系统方法 平常使用cornerRadius和maskToBounds组合设置圆角 category添加关联属性废话不多说，直接上代码创建一个NSError的category，添加一个errorMsg的属性。因为category本身不能添加属性，这里是使用runtime动态添加关联属性 MethodSwizzle交换系统方法创建一个UIImageView的category，在分类中交换（exchange，注意这里不是替换replace）系统的setImage: 方法. 我们要交换一个类的系统方法，那么首先想想在哪个方法中交换最合适呢？我们知道app在启动之后，会进行类注册，调用类的+load()方法，且只调用一次。（注意与+initialize的区别）第51条:load与initialize的区别所以我们在分类中重写load方法中添加交换方法。 首先我们借用AFNetworking中AFURLSessionManager中定义的swizzle的内联函数123456789101112static inline void hl_swizzleSelector(Class theClass, SEL originalSelector, SEL swizzledSelector) &#123; Method originalMethod = class_getInstanceMethod(theClass, originalSelector); Method swizzledMethod = class_getInstanceMethod(theClass, swizzledSelector); method_exchangeImplementations(originalMethod, swizzledMethod);&#125;static inline BOOL hl_addMethod(Class theClass, SEL selector, Method method) &#123; /* YES if the method was added successfully, otherwise NO (for example, the class already contains a method implementation with that name) */ return class_addMethod(theClass, selector, method_getImplementation(method), method_getTypeEncoding(method));&#125;然后在+load方法中添加如下代码：1hl_swizzleSelector([self class], @selector(setImage:), @selector(hl_setImage:)); /* 这里参考的是AFURLSessionManager中的方式来添加方法，但是实际上在这个情况下是永远返回NO的 原因：因为我们是在UIImageView的category中添加了hl_setImage:，所以在UIImageView中已经存在了该方法，再调用class_addMethod就会返回NO。 因此下面这些代码如果写在category中是不需要的了。*/123456Method hlSetImageMethod = class_getInstanceMethod([self class],@selector(hl_setImage:));BOOL result = hl_addMethod([self class],@selector(hl_setImage:), hlSetImageMethod);NSLog(@"%d",result);if (result) &#123;&#125; 测试一下代码：123456789101112131415UIImageView * v = [[UIImageView alloc]initWithFrame:CGRectMake(0, 0, 240, 240)];v.center = self.view.center;[self.view addSubview:v];UIImage * image = [UIImage imageNamed:@"IMG_0730.jpg"];//会产生混合图层v.layer.cornerRadius = v.frame.size.width / 2;v.layer.masksToBounds = YES;//采用UIGraphicImageContext重绘后,解决混合图层问题[v setImage:[image hl_imageByCroppingForSize:CGSizeMake(240, 240) fillColor:[UIColor whiteColor]]];//使用Method swizzle交换setImage和hl_setImage:之后：v.image = image; 其中的性能问题我们在UIImage+HLAdd分类中使用UIGraphicImageContext来重新绘图，这肯定是要耗时的操作。12345CFTimeInterval start = CACurrentMediaTime();...//绘图...NSLog(@"%f",CACurrentMediaTime() - start); 12016-11-22 17:53:42.614 iOS-Kick-On[47630:2598373] 0.003525 大概耗时在0.003~0.006之间，以纳秒进行运算的cpu来说，还是一个稍微耗时的操作，因为我们可以把它放在后台线程来做，然后采用回调来获取返回的image12345678910dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; UIImage * result = [self hl_imageByCroppingCorner:radius forSize:targetSize fillColor:[UIColor whiteColor]]; dispatch_async(dispatch_get_main_queue(), ^&#123; if (completion) &#123; completion(result); &#125; &#125;);&#125;); 本篇文章代码]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>runtime</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一起唱，团结就是力量]]></title>
    <url>%2F2016%2F11%2F18%2F%E4%B8%80%E8%B5%B7%E5%94%B1%EF%BC%8C%E5%9B%A2%E7%BB%93%E5%B0%B1%E6%98%AF%E5%8A%9B%E9%87%8F%2F</url>
    <content type="text"><![CDATA[两个人来到河边，想要渡河，于是同乘一条船。一人船尾，一人船艏，各自拿起一对桨奋力地划着。可是过了老半天也不见小船驶向对岸，两人转头一看，原来各自把自己的位置当成船艏了，朝着相反的方向划去了。他们互相指责对方的过失，到了太阳落山依然还停留在原地。]]></content>
      <categories>
        <category>生活</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Xcode8中NavigationBar插入背景出错的解决方法]]></title>
    <url>%2F2016%2F10%2F05%2FXcode8%E4%B8%ADNavigationBar%E6%8F%92%E5%85%A5%E8%83%8C%E6%99%AF%E5%87%BA%E9%94%99%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[insertSubview是把backgroundView插入到UINavigationBar中，UINavigationBar作为其superview。每次跳转回来之后，会重新赋值（可能）所以我们要把backgroundView放入到UIBarBackground中。 以前写过一个导航栏中插入背景改变导航栏背景色的类。 1insertSubview(backgroundView!, at: 0) 在xcode8 的view hierarchay表现为： 但是现在出现的问题是返回到首页后，导航栏被背景view遮盖了 解决方法：1self.subviews[0].insertSubview(backgroundView!, at: 0)]]></content>
      <tags>
        <tag>swift</tag>
        <tag>Xcode8</tag>
        <tag>NavigationBar</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python代码运行在iOS工程中的方案]]></title>
    <url>%2F2016%2F07%2F11%2Fpython%E4%BB%A3%E7%A0%81%E8%BF%90%E8%A1%8C%E5%9C%A8iOS%E5%B7%A5%E7%A8%8B%E4%B8%AD%E7%9A%84%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[一种Xcode工程内执行python脚本的方法，详见下文。 1.下载解压Python-iOS.zip文件，打开python-ios.xcworkspace。2.Command+R运行，此时在模拟器上会有app生成；并且Xcode的console中会有log打印3.可以点击Send Msg按钮，会有如下log 当然，也可以打开浏览器，输入127.0.0.1:8000 实现方法：1.主要集成了python基础库libPython和静态库liblibpython.a2.include python.h,以及python 函数的使用方式：红色框中server.py脚本被放到了其他线程执行，解决了卡住主线程的问题。 3.同时我也给出了一个在用户界面向本地服务器消息交互的例子，使用socket。 例子比较简单，实现了最基础的在用户界面与本地服务器通信的例子。并且不影响iOS相关代码的编写。 由于附件较大，上传到了Github。https://github.com/koalahl/PythonIniOS]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《程序员的自我修养》读书笔记-编译和链接]]></title>
    <url>%2F2016%2F05%2F10%2F%E3%80%8A%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%BC%96%E8%AF%91%E5%92%8C%E9%93%BE%E6%8E%A5%2F</url>
    <content type="text"><![CDATA[一个HelloWorld.c程序是如何被处理，得到一个a.out可执行程序的呢？$gcc HelloWorld.c命令，得到a.out$./a.out 执行 该过程可分为四个步骤：预处理（Preprocess）或者叫预编译、编译（Compile）、汇编（Assembly）和链接（Linking）。 预编译 预编译的命令$gcc -E HelloWorld.c -o HelloWorld.i。预编译中的主要规则： 将所有的#define删除，展开所有的宏定义 处理所有的条件预编译指令，比如#if,#ifdef,#endif,#elif,#else. 处理#include指令，将被包含的文件插入到该预编译指令的位置。这个过程是递归进行的 删除所有的注释//和/**/. 添加行号和文件名标识。 保留所有的#pragma编译器指令，因为编译器要使用它。 编译 编译器 ：cc1程序编译过程就是把预处理完的.i文件进行一系列的词法分析、语法分析、语义分析以及代码优化后产生相应的汇编代码编译的命令$gcc -S HelloWorld.c -o HelloWorld.s。 汇编 汇编器 as汇编过程将汇编代码转换成机器代码。根据汇编指令和机器代码的对照表一一翻译。汇编的命令$gcc -c HelloWorld.c -o HelloWorld.o。 链接 链接器 ld从图中可以看出，链接器主要是把代码的.o文件与静态库链接在一起。]]></content>
      <categories>
        <category>程序员的自我修养</category>
      </categories>
      <tags>
        <tag>编译</tag>
        <tag>链接</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《程序员的自我修养》读书笔记-温故知新]]></title>
    <url>%2F2016%2F05%2F10%2F%E3%80%8A%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E6%B8%A9%E6%95%85%E7%9F%A5%E6%96%B0%2F</url>
    <content type="text"><![CDATA[基础篇回顾一下两个基础：内存线程 内存早期的计算机，程序直接运行在物理内存上。那么久存在一个问题：如何尽可能的将有限的物理内存分配给多个程序使用。内存使用存在的问题： 1.地址空间不足 2.内存使用效率低 3.程序运行的地址不确定-重定位问题。那么针对这三个问题，利用中间层,让程序间接的访问物理地址，来解决以上几个问题。- 分段：（segment）将程序需要的地址空间映射到一段虚拟空间上。以此将程序间隔离。此方法解决第一个和第三个问题。- 分页：（paging）将地址空间人为分为固定大小的页（page）。一般为4KB大小。虚拟内存的实现需要依靠硬件支持。通常采用MMU(Memory Management Unit)来进行page mapping，将CPU使用的虚拟地址映射为实际的物理地址。线程 线程结构：线程ID、指令指针PC、线程内栈和寄存器 现在基本都是多线程。 线程的访问权限。 线程私有 线程间共享 - 局部变量 全局变量 - 函数的参数 堆上的数据 - TLS数据 函数中的静态变量 程序代码 打开的文件。线程A打开的文件可以由线程B读写 线程安全 单指令操作称为原子的Atomic。简单情况下可保证线程安全，但是在复杂的数据结构中，就有可能不能保证。此时需要更加通用的手段：锁 同步与锁。但是还是有可能出现问题，原因来自于CPU执行指令的换序（CPU有可能将后面的代码先执行）。 barrier阻塞机制。barrier指令会阻止CPU将barrier指令之前的指令交换到barrier之后，反之亦然。]]></content>
      <categories>
        <category>程序员的自我修养</category>
      </categories>
      <tags>
        <tag>内存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LearnSwift-小白学习map，reduce方法]]></title>
    <url>%2F2016%2F05%2F06%2FLearnSwift-%E5%B0%8F%E7%99%BD%E5%AD%A6%E4%B9%A0map%EF%BC%8Creduce%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[数组的map、reduce方法 map方法将遍历序列中每个元素123[1,2,3,4,5,6].map &#123; (i) -&gt; Int in return i * 2&#125; 简化版1[1,2,3,4,5,6].map(&#123;$0 * 2&#125;) reduce: i 这里是一个累加器（并不表示相加），保存了前一次运算的结果。1234[1,2,3,4,5,6].reduce(1) &#123; (i, element) -&gt; Int in print(i,element) return i * element&#125; 上面的reduce方法可以简化为1[1,2,3,4,5,6].reduce(1, combine: *) 下面来看看flatMap,该函数会忽略为nil的集合元素。123456789101112let persons: [[String: AnyObject]] = [["name": "Carl Saxon", "city": "New York, NY", "age": 44], ["name": "Travis Downing", "city": "El Segundo, CA", "age": 34], ["name": "Liz Parker", "city": "San Francisco, CA", "age": 32], ["name": "John Newden", "city": "New Jersey, NY", "age": 21], ["name": "Hector Simons", "city": "San Diego, CA", "age": 37], ["name": "Brian Neo", "age": 27]] //注意这家伙没有 city 键值//找到住在CA的居民。func peopleFromState(state:String,persons:[[String:AnyObject]]) -&gt; Int&#123; return persons.flatMap &#123; $0["city"]?.componentsSeparatedByString(", ").last&#125;.filter &#123; $0 == state&#125;.count&#125;peopleFromState("CA", persons: persons) 用reduce实现map、flatMap123456789func rmap(element:[Int],transform:(Int)-&gt;Int ) -&gt;[Int]&#123; return element.reduce([Int](), combine: &#123; (var accemulator:[Int], obj:Int) -&gt; [Int] in print(accemulator,obj) accemulator.append(transform(obj)) return accemulator &#125;)&#125;rmap([1,2,3,4,5,6], transform: &#123;$0 * 2&#125;) 1234567func rmap2(element:[Int],transform:(Int)-&gt;Int) -&gt; [Int] &#123; return element.reduce([Int](), combine: &#123;$0 + [transform($1)]&#125;)&#125;let array = rmap2([1,2,3,4,5,6], transform: &#123;$0 * 2&#125;)print(array)结果都是[2, 4, 6, 8, 10, 12] 理解 $0, $1$0,$1是一个常量，类型根据所在函数的参数类型决定。为何它们是这个类型呢？其所在函数是combine，那么$0和$1的类型都是由combine这个(函数/闭包/方法)的第二个参数类型决定的。所以我们来看看reduce函数的定义：1public func reduce&lt;T&gt;(initial: T, @noescape combine: (T, Self.Generator.Element) throws -&gt; T) rethrows $0代表第一个参数，其类型这里是[Int],$1代表的是combine内的第二个参数，所以其类型就是Int的。 用reduce实现filter123456789101112131415161718192021222324func rfilter(element:[Int],filter:(Int)-&gt;Bool)-&gt; [Int]&#123; return element.reduce([Int](), combine: &#123; (var acc:[Int], value:Int) -&gt; [Int] in if filter(value)&#123; acc.append(value) &#125; return acc &#125;)&#125;let xxc = rfilter([1,2,3,4,5,6], filter: &#123; $0 &gt; 3&#125;)print(xxc)func rfilter2(element:[Int],filter:(Int)-&gt;Bool)-&gt; [Int]&#123; return element.reduce([Int](), combine: &#123; guard filter($1) else&#123; return $0&#125; return $0 + [$1] &#125;)&#125;let oos = rfilter2([1,2,3,4,5,6], filter: &#123;$0 &gt; 3 &#125;)print(oos) 再看前面提过的问题：找到住在CA的居民。并且计算他们的平均年龄123456789101112131415161718func peopleFromState(state:String,persons:[[String:AnyObject]]) -&gt; (population:Int,averageAge:CGFloat)&#123; //return persons.flatMap &#123; $0["city"]?.componentsSeparatedByString(", ").last&#125;.filter &#123; $0 == state&#125;.count typealias Result = (population:Int,averageAge:CGFloat) let u = persons.reduce((populatoin:0,averageAge:0.0)) &#123; (var result:Result, dic:[String:AnyObject]) -&gt; Result in guard let locationStr = dic["city"]?.componentsSeparatedByString(", ").last,let personAge = dic["age"] where locationStr == state else&#123; return result&#125; return (result.population + 1,result.averageAge + CGFloat(personAge as! NSNumber)) &#125; return (u.populatoin,u.averageAge / CGFloat(u.populatoin))&#125;let result = peopleFromState("CA", persons: persons)result.population // 3result.averageAge // 34.333333334]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>LearnSwift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Learn Swift - Section 4th 扩展、协议、泛型]]></title>
    <url>%2F2016%2F04%2F28%2FLearn-Swift-Section-Four-%E6%89%A9%E5%B1%95%E3%80%81%E5%8D%8F%E8%AE%AE%E3%80%81%E6%B3%9B%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[扩展 Extension扩展Extension就是向一个已有的类、结构体、枚举类型或者协议类型添加新功能（functionality）。这包括在没有权限获取原始源代码的情况下扩展类型的能力（即逆向建模）。扩展和 Objective-C 中的分类（categories）类似。（不过与 Objective-C 不同的是，Swift 的扩展没有名字。）Swift 中的扩展可以：- 添加计算型属性和计算型静态属性- 定义实例方法和类型方法- 提供新的构造器- 定义下标- 定义和使用新的嵌套类型- 使一个已有类型符合某个协议- 也可以对一个协议进行扩展123456789101112131415161718192021222324extension Int&#123; //转换成小时 var hours : Int&#123; return self/3600 &#125; var ago : Int&#123; return -self &#125; //x之前的时间 func ago(x:Int) -&gt; Int &#123; return self - x &#125;&#125;let currentTime = 72003.hours3.hours.ago3.ago + currentTime//5秒之前currentTime.ago(5)//1小时之前currentTime.hours.ago(1)currentTime.hours.ago(3600.hours)print(3.ago)协议 Protocol协议定义了一个蓝图，规定了用来实现某一特定工作或者功能所必需的方法和属性。类，结构体或枚举类型都可以遵循协议，并提供具体实现来完成协议定义的方法和功能。任意能够满足协议要求的类型被称为遵循(conform)这个协议。除了遵循协议的类型必须实现那些指定的规定以外，还可以对协议进行扩展，实现一些特殊的规定或者一些附加的功能，使得遵循的类型能够收益。1234567891011121314151617181920212223242526272829303132333435363738394041424344protocol SellProducts&#123; func sellProducts(product:String)&#125;class Person &#123; var name:String weak var delegate:Seller? lazy var someClosure:(Int,String)-&gt;String = &#123; //在闭包中将self修饰为无主引用。将delegate 修饰为 弱引用 [unowned self,weak delegate = self.delegate!]//捕获列表 (index:Int,strToProcess:String)-&gt;String in return "\(self.name),\(self.delegate),\(delegate)" &#125; init(name:String,delegate:Seller?)&#123; self.name = name; self.delegate = delegate; &#125; func giveSellerProducts(product:String ) -&gt; Bool &#123; self.delegate?.sellProducts(product) return true &#125;&#125;class Seller : SellProducts&#123; var product:String? func sellProducts( product: String) &#123; self.product = product &#125;&#125;let seller = Seller()var person = Person (name: "Hanliu", delegate: seller)//刚开始seller是没有商品的，要等到Person给sellerprint(seller.product)//person告诉seller，帮我卖苹果person.giveSellerProducts("apple")//现在seller手中就有了商品了print(seller.product!)person.someClosure(1,"haha")协议中的属性一定要指明读写状态1234567891011121314151617protocol SomeProtocol &#123; var mustBeSettable:Int&#123;get set&#125;//表示该属性是可读可写 var notNeededForSetable:String&#123;get&#125;//表示只读 static var someTypedProperty:String&#123;get set&#125;//类属性(当协议遵循者是class是，可以用class关键字)&#125;protocol FullyName &#123; var fullname:String&#123;get&#125;&#125;struct PersonName:FullyName &#123; var fullname: String var shortName :String&#125;let person = PersonName(fullname: "Levi John",shortName: "LJ")person.fullname协议本身并不实现任何功能，但是协议可以被作为类型使用。就是与String、Int这些类型的作用相同。- 作为函数、方法或构造器中的参数类型或返回值类型- 作为常量、变量或属性的类型- 作为数组、字典或其他容器中的元素的类型1234567891011121314151617181920protocol RandomGenerator &#123; func random()-&gt;Double&#125;class LinerGenerator:RandomGenerator &#123; func random() -&gt; Double &#123; return 11.0011 &#125;&#125;class Dice&#123; let slides:Int var generator:RandomGenerator//作为属性类型 init(slides:Int,generator:RandomGenerator)&#123;//作为参数类型 self.slides = slides self.generator = generator &#125; func roll() -&gt; Int &#123; return Int(self.generator.random() * Double(slides))+1 &#125;&#125;在扩展中遵循协议，增加协议成员（这种方法与直接在类后面遵循协议的效果相同）。123456789101112protocol TextRepresentable &#123; var textDescription :String&#123;get&#125;&#125;extension Dice:TextRepresentable&#123; var textDescription:String &#123; return "\(slides) - slides" &#125;&#125;let dice = Dice(slides: 8, generator: LinerGenerator())dice.textDescription//现在Dice的所有实例都可以使用textDescription属性了。协议类型的集合1234567let sir = Dice(slides: 1, generator: LinerGenerator())let sime = Dice(slides: 2, generator: LinerGenerator())let arrayOfProtocolElements:[TextRepresentable] = [dice,sir,sime]for element in arrayOfProtocolElements&#123; print(element.textDescription)&#125;协议能够继承.123456789protocol TextGo:TextRepresentable&#123; var prettyTextDescription:String&#123;get&#125;&#125;extension Dice:TextGo&#123; var prettyTextDescription:String&#123; return textDescription + "hello"//可以使用上层协议的属性 &#125;&#125;类专属协议.在协议继承列表中的首位添加class关键字,然后这个协议就只能被类遵循，而不能被结构体或者枚举遵循。123protocol ClassOnlyProtocol:class&#123; var mylove:String&#123;get&#125;&#125;检查协议一致性使用is、as?、as!协议本身也可以被扩展12345extension TextRepresentable&#123;//TextRepresentable是个协议 var longTextDescription:String&#123; return "\(textDescription) + long" &#125;&#125;为协议扩展添加限制条件 where扩展CollectionType协议，让其遵循者的元素必须遵循TextRepresentable协议123456789101112131415161718192021222324extension CollectionType where Generator.Element:TextRepresentable&#123; var textDescription:String&#123; let items = self.map&#123;$0.textDescription&#125; return "A hamster named \(items)" &#125;&#125;struct Hamster &#123; var name: String var textDescription: String &#123; return "a hamster named \(name)" &#125;&#125;extension Hamster: TextRepresentable &#123;&#125;//让Hamster遵循TextRepresentable协议let murrayTheHamster = Hamster(name: "Murray")let morganTheHamster = Hamster(name: "Morgan")let mauriceTheHamster = Hamster(name: "Maurice")let hamsters = [murrayTheHamster, morganTheHamster, mauriceTheHamster]因为Array遵循了`CollectionType`协议，而hamster又遵循了`TextRepresentable`协议，所以就满足了条件，此时 array可以使用`textDescription`属性print(hamsters.textDescription)结果：A hamster named ["a hamster named Murray", "a hamster named Morgan", "a hamster named Maurice"]泛型 Generics 泛型代码可以让你写出根据自我需求定义、适用于任何类型的，灵活且可重用的函数和类型。它的可以让你避免重复的代码，用一种清晰和抽象的方式来表达代码的意图。 泛型是 Swift 强大特征中的其中一个，许多 Swift 标准库是通过泛型代码构建出来的。事实上，泛型的使用贯穿了整本语言手册，只是你没有发现而已。例如，Swift 的数组和字典类型都是泛型集。你可以创建一个Int数组，也可创建一个String数组，或者甚至于可以是任何其他 Swift 的类型数据数组。同样的，你也可以创建存储任何指定类型的字典（dictionary），而且这些类型可以是没有限制的 泛型函数12345func swapTwoValues&lt;T&gt;(inout a:T,inout b:T)&#123; let tempValue = a a = b b = tempValue&#125; T 表示一个占位命名类型 尖括号表示它里面的T是由函数swapTwoValues定义的一个类型，swift不会去查找命名为T的实际类型 参数列表中的T没有实际类型，仅表示两个参数的类型需要相同 实现一个泛型版本的栈123456789101112struct Stack&lt;T&gt;&#123; var items = [T]() mutating func push(item:T)&#123; items.append(item) &#125; mutating func pop()&#123; items.removeLast() &#125;&#125;//泛型实例的创建,都必须指定T的类型var stack = Stack(items: [""])var stack2 = Stack&lt;String&gt;() //扩展一个泛型类型:添加一个属性1234567extension Stack&#123; var topItem:T?&#123; return items.isEmpty ? nil : items[items.count - 1] &#125;&#125;stack2.topItem 关联类型（Associated Type） swift2.2貌似修改了。声明的时候用associatedtype 实现的时候用typealias123456789101112131415161718192021protocol Container&#123; associatedtype ItemType var count:Int&#123;get&#125; mutating func append(item:ItemType) subscript (i:Int)-&gt;ItemType&#123;get&#125;&#125;//让泛型Stack遵循Container协议extension Stack:Container&#123; //typealias ItemType = T //这一行也是可以去掉，因为swift通过类型推断可以判断出T的类型 mutating func append(item: T) &#123; return self.push(item)//或者：items.append(item) &#125; var count:Int&#123; return items.count &#125; subscript(i:Int)-&gt;T&#123; return items[i] &#125;&#125;]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>LearnSwift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Learn Swift - Section 3rd 类与结构体]]></title>
    <url>%2F2016%2F04%2F26%2FLearn-Swift-Section-Three%2F</url>
    <content type="text"><![CDATA[类与结构体的共同点： 定义属性用于存储值 定义方法用于提供功能 定义附属脚本用于访问值 定义构造器用于生成初始化值 通过扩展以增加默认实现的功能 实现协议以提供某种标准功能 与结构体相比，类还有如下的附加功能： 继承允许一个类继承另一个类的特征 类型转换允许在运行时检查和解释一个类实例的类型 解构器允许一个类实例释放任何其所被分配的资源 引用计数允许对一个类的多次引用 更多信息请参见继承，类型转换，析构过程，和自动引用计数。 注意 结构体总是通过被复制的方式在代码中传递，不使用引用计数。 1.值类型与引用类型值类型被赋予给一个变量、常量或者被传递给一个函数的时候，其值会被拷贝。 在之前的章节中，我们已经大量使用了值类型。实际上，在 Swift 中，所有的基本类型：整数（Integer）、浮点数（floating-point）、布尔值（Boolean）、字符串（string)、数组（array）和字典（dictionary），都是值类型，并且在底层都是以结构体的形式所实现。 在 Swift 中，所有的结构体和枚举类型都是值类型。这意味着它们的实例，以及实例中所包含的任何值类型属性，在代码中传递的时候都会被复制。 “与值类型不同，引用类型在被赋予到一个变量、常量或者被传递到一个函数时，其值不会被拷贝。因此，引用的是已存在的实例本身而不是其拷贝。” 1234567var marray = ["lopl","liu","han"]func modifyArray() &#123; var saray = marray saray.removeAtIndex(2)&#125;modifyArray()marray//并没有变，说明是值拷贝 2.将结构体实例赋值给一个常量，则无法修改结构体中的属性，即使属性是变量。123456789101112131415161718192021222324252627struct Cars &#123; var name = ""&#125;let car = Cars()car.name = "Audi"//而类则可以修改，因为类是引用类型。class CreateNewLife&#123; var name = ""&#125;class Animals &#123; var kind = "" let planet = "Earth" lazy var createNewLife = CreateNewLife()&#125;let life = CreateNewLife()let anAnimal = Animals()anAnimal.kind = "Human"print(anAnimal,life)if life === anAnimal &#123; print("same class")&#125;else&#123; print("Different class")&#125;print(anAnimal.createNewLife.name)//这时CreateNewLife实例才会被创建anAnimal.createNewLife.name = "liven"print(anAnimal.kind,anAnimal.createNewLife.name) 3.结构体和类中的属性定义-getter和setter12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758struct Point&#123; var x = 0.0,y = 0.0&#125;struct Size &#123; var width = 0.0,height = 0.0&#125;struct Rect &#123; var origin = Point() var size = Size() var center:Point&#123;//计算属性:即写了get或set的属性。如果只有get，就是只读属性 get&#123; let centerX = origin.x + size.width/2 let centerY = origin.y + size.height/2 return Point(x: centerX, y: centerY) &#125; set(newCenter)&#123; origin.x = newCenter.x - size.width/2 origin.y = newCenter.y - size.height/2 &#125; &#125; var arcPoint:Point&#123;//属性观察器didSet,willSet willSet(newValue)&#123;//会将新的值传入 print("will set arcPoint \(newValue)") &#125; didSet(oldValue)&#123;//会将旧的值传入 //arcPoint = Point(x: 8, y: 9) print("did set arcPoint \(arcPoint) \(oldValue)") &#125; &#125; static var name = "my rect"//Type property类型属性 //值类型属性一般不能在它自己的实例方法中修改；如果非要修改，需要加关键字mutating mutating func bigger(x:Double,y:Double) &#123; size.width += x size.height += y &#125;&#125;Rect.nameRect.name = "xxxx"Rect.namevar rect = Rect(origin: Point(x: 10,y: 10), size: Size(width: 20,height: 30), arcPoint: Point(x: 1, y: 1))print(rect.arcPoint)rect.arcPoint = Point(x: 3, y: 4)print(rect.arcPoint)var rect2 = rectrect2.arcPoint = Point(x: 6, y: 6)print(rect.arcPoint,rect2.arcPoint)rect.bigger(20, y: 20)print(rect.size)class SomeClass &#123; class var overrideProperty:Int&#123;//get省略了。class关键字表示重写父类的getter实现 return 10 &#125;&#125; 4.方法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647struct LevelTraker &#123; static var highestUnlockedLevel = 1 static func unlockLevel(level:Int)&#123; if (level == highestUnlockedLevel + 1) &#123;highestUnlockedLevel = level&#125; &#125; static func levelIsUnlocked(level:Int)-&gt;Bool&#123; return level &lt;= highestUnlockedLevel &#125; var currentLevel = 1 mutating func advanceLevel(level:Int)-&gt;Bool&#123; if LevelTraker.levelIsUnlocked(level) &#123; currentLevel = level return true &#125;else&#123; return false &#125; &#125;&#125;class Player &#123; var traker = LevelTraker() var playerName:String func completeLevel(level:Int) -&gt;Bool&#123; LevelTraker.unlockLevel(level+1) if traker.advanceLevel(level+1)&#123; return true &#125;else&#123; print("Level \(level) hasn't been unlocked") return false &#125; &#125; init(name:String)&#123; playerName = name &#125;&#125;var level111 = LevelTraker()var level121 = LevelTraker()level121.currentLevel = 2print(level111.currentLevel, level121.currentLevel)var player = Player(name:"han")player.traker.currentLevelplayer.completeLevel(1)player.traker.currentLevelLevelTraker.highestUnlockedLevelplayer.completeLevel(5) 5.构造过程123456789101112131415161718class Cars&#123; var brand:String var usage:String //构造函数 init()&#123; brand = "BMW" usage = "Family" &#125; init(_brand:String,_usage:String)&#123; brand = _brand usage = _usage &#125;&#125;let audi = Cars(_brand: "Audi", _usage: "Sports")print(audi.brand,audi.usage)let car2 = Cars()print(car2.brand,car2.usage) 6.当属性有默认值，且没有构造方法时，结构体和类拥有默认构造方法。但是结构体可以有带属性参数的默认构造方法（逐一成员构造器），而类没有。12345678910111213struct People &#123; var name:String? var sex:String?&#125;class Books &#123; var type:String? var category:String? var available = true&#125;let p = People()let semdsd = People(name: "han", sex: "famale")let book = Books()//var book2 = Books(type:"epub",category:"Computer",available:true) 7.析构过程/** 析构器只适用于类类型，不能用于结构体。析构器用deinit关键字。*/1234567891011121314class Telephones &#123; var type:String? var category:String? var available = true init() &#123; // &#125; deinit&#123; //析构代码。。。 print("\(type)") available = false &#125;&#125; / 析构过程会在ARC回收实例时被系统调用，不需要手动调用。 / 8.类实例之间的循环强引用解决方式：1.使用weak关键字，弱引用2.使用unowned，无主引用 9.解决闭包引起的循环引用–定义捕获列表1234567891011121314151617181920212223242526272829303132333435363738394041424344protocol SellProducts&#123; func sellProducts(product:String)&#125;class Person &#123; var name:String weak var delegate:Seller? lazy var someClosure:(Int,String)-&gt;String = &#123; //在闭包中将self修饰为无主引用。将delegate 修饰为 弱引用 [unowned self,weak delegate = self.delegate!]//捕获列表 (index:Int,strToProcess:String)-&gt;String in return "\(self.name),\(self.delegate),\(delegate)" &#125; init(name:String,delegate:Seller?)&#123; self.name = name; self.delegate = delegate; &#125; func giveSellerProducts(product:String ) -&gt; Bool &#123; self.delegate?.sellProducts(product) return true &#125;&#125;class Seller : SellProducts&#123; var product:String? func sellProducts( product: String) &#123; self.product = product &#125;&#125;let seller = Seller()var person = Person (name: "Hanliu", delegate: seller)//刚开始seller是没有商品的，要等到Person给sellerprint(seller.product)//person告诉seller，帮我卖苹果person.giveSellerProducts("apple")//现在seller手中就有了商品了print(seller.product!)person.someClosure(1,"haha")]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>LearnSwift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Learn Swift - Section 2nd 集合类型和枚举]]></title>
    <url>%2F2016%2F04%2F26%2FLearn-Swift-Section-Two%2F</url>
    <content type="text"><![CDATA[Arra、Dictionary、Set和枚举 //Array的map()方法let digitNames = [ 0: “Zero”, 1: “One”, 2: “Two”, 3: “Three”, 4: “Four”, 5: “Five”, 6: “Six”, 7: “Seven”, 8: “Eight”, 9: “Nine”]let numbers = [132,11,87,90,49,87,22,29,5,10,87]//map方法会读取数组中的每一个元素，let strings = numbers.map { (element) -&gt; String in var output = “” var number = element while number &gt; 0 { output = digitNames[number % 10]! + output number /= 10 } return output}//把每个元素都+1let so = numbers.map{(element)-&gt;Int in return element + 1}let lo = numbers.flatMap{(element)-&gt;Int in return element + 3 }let split1 = numbers.split(70)let split2 = numbers.split(87)let split3 = numbers.split(87, maxSplit: 1, allowEmptySlices: true)let split4 = numbers.split(87, maxSplit: 6, allowEmptySlices: true)let split5 = numbers.split(87, maxSplit: 6, allowEmptySlices: false) //过滤出满足条件的子序列。条件由闭包定义numbers.filter { (element) -&gt; Bool in return element &gt; 50}numbers.filter{(element) in element &gt; 50}numbers.filter{ $0 &gt; 50} let scores = [“xiaoming”:66,”li”:89,”han”:78,”ming”:100,”xiag”:34]scores.filter { (name,score) in score &gt; 60} //“将闭包标注为@noescape使你能在闭包中隐式地引用self”func functionWithNoescapeClosure(@noescape closure:()-&gt;Void){ closure()}var completionHandlers:[() -&gt; Void] = []func functionWithEscapeClosure(completionHandler:()-&gt;Void){ completionHandler() completionHandlers.append(completionHandler)} class SomeClass { var x = 200 func doSomething(){ functionWithEscapeClosure({self.x = 100}) functionWithNoescapeClosure({x = 300})//隐式引用self } }let some = SomeClass()some.doSomething()print(some.x) completionHandlers.first?()print(some.x) //自动闭包 使用@autoclosure，就可以不用加闭包的{}var names = [“charis”,”levis”,”luos”,”deric”,”htome”]let customerProvider = {names.removeAtIndex(0)}//注意类型是()-&gt;Stringfunc customName(@autoclosure customerProvider:()-&gt;String) { print(“costomer’s name is (customerProvider())”)} customName(names.removeAtIndex(0))//闭包体不需要加{}，就好像是参数一样。 //枚举-一等公民 与类class一样enum Compose{ case North case South case West case East}//成员值的类型为枚举的名字Composelet directionToHead = Compose.East //带有关联值的枚举enum Barcode { case UPCA(Int,Int,Int)//关联了Int类型的值 case QRCode(String)//关联了String类型的值} var productorCode = Barcode.QRCode(“kasdjfiwoeklf”) productorCode = .UPCA(2,5,1) switch productorCode{ case let .UPCA(first,second,third): print(“(first) (second) (third)”) case var .QRCode(code): print(“code is (code)”)} //原始值 Raw Valuesenum ASCII:Character{//带有初始类型的枚举 case Tab = “\t” case Return = “\r” case changeLine = “\n”} //关联值可以使枚举的嵌套成为可能.如果嵌套，则需要添加indirect关键字enum Add{ case Number(Int) indirect case Addition(Add,Add)}func evaluate(add:Add) -&gt; Int { switch add { case .Number(let i): return i case .Addition(let left, let right): return evaluate(left) + evaluate(right) }} let a = Add.Number(10)let b = Add.Number(2)let c = Add.Addition(a,b) evaluate(a)evaluate(c)]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>LearnSwift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Learn Swift - Section 1st 基础知识]]></title>
    <url>%2F2016%2F04%2F26%2FLearn-Swift-Section-One%2F</url>
    <content type="text"><![CDATA[import UIKit var str = “Hello, playground” //常量和变量let maxLoginCount = 10var currentLoginCount = 5 //类型标注var message = “welcome”//类型推断为Stringvar messageWithTypeAnnotation:String message = “welcome here”messageWithTypeAnnotation = “welcome go” print(“Big world (message)”)//(message) 字符串转义print(“Big world”, message)// let newString = “Big world “ + “(message) “ + messageprint(newString)//多行语句用分号let cat = “🐱”; print(cat) let a:Int32 = 10let uintb:UInt8 = 255 //类型别名typealias SLInt = UInt64let i:SLIntvar maxInt64 = SLInt.max //元组let HttpErrorCode = (404,”NotFound”)print(HttpErrorCode) typealias HttpStateCode = (Int32,String)var errorMsg = HttpErrorCodevar normal: HttpStateCode = (200,”OK”)print(normal) let (stateCode,stateMsg) = HttpErrorCodeprint(“HTTP code is (stateCode)”)//通过下标访问元组元素print(HttpErrorCode.1) //隐式解析可选类型 let possibleString:String? = “an optional string”let forcedString:String = possibleString! let possibleString2:String! = “an implicitly optional stirng”let forcedString2:String = possibleString2 //可选绑定if let bingStr = possibleString2{ print(bingStr)} //错误处理 func canThrowAnError() throws{ } func makeASanwich() -&gt; Bool { return false}func buyNewDishes() -&gt; Void { } do{ try canThrowAnError() makeASanwich()}catch Error.MissingNeededMetarail{ buyNewDishes()} //断言let num = 4assert(num&gt;0, “a大于0”) //空合运算符 ??let defaultColor:String = “red”var userDefinedColor:String? //userDefinedColor = “orange”var currentColorToUse = userDefinedColor ?? defaultColor//等价于var currentColorToUse2 = userDefinedColor != nil ? userDefinedColor! : defaultColor //区间运算符//1.闭区间 (a…b) 包含a和bfor index in (1…5){ print(index) print(“(index) 5 = (index 5)”)}//2.半开区间 (a..&lt;b)for index in (1..&lt;5){ print(index) print(“(index) 5 = (index 5)”)} //字符串 String//String是值类型for charactor in “You R A🐶”.characters{ print(charactor)}//独立的字符常量或变量let singleCharactor:Character = “!” //通过值类型为character的数组来创建字符串let characters:[Character] = [“c”,”a”,”t”,”🐱”]let catString = String(characters)print(catString) //插值运算 反斜杠\let multiplier = 4print(“(multiplier) times 5.12 = (Double(multiplier) * 5.12)”)print(“\r message”+” \u{E9}”) //Unicodelet ccc1:Character = “\u{65}”let ccc2:Character = “\u{65}\u{301}” print(message)message.startIndexmessage.endIndex//前一个indexmessage.endIndex.predecessor()//后一个indexmessage.startIndex.successor()//从starIndex开始 后面的第i个indexlet xx = message.startIndex.advancedBy(4)message.removeAtIndex(message.startIndex.advancedBy(4))print(message)//indices 获取字符串的全部索引 。空格不算。。。for index in message.characters.indices{ print(“(message[index])”)} message.insert(“u”, atIndex: xx) message = “http:”+messageprint(message)//前后缀var hasPrefix = message.hasPrefix(“http”)var hasSuffix = message.hasSuffix(“png”) //集合类型：数组Array 集合Set 字典Dictionary //不可变和可变/“如果创建一个Arrays、Sets或Dictionaries并且把它分配成一个变量，这个集合将会是可变的。这意味着我们可以在创建之后添加更多或移除已存在的数据项来改变这个集合的大小。如果我们把Arrays、Sets或Dictionaries分配成常量，那么它就是不可变的，它的大小不能被改变。” /let immutableArray = Intvar mutableArray = Int let strArray = [“world”] mutableArray.append(1)var array1:[String] = Array()array1.append(“hello”)array1.appendContentsOf(strArray)array1.insert(“gogogog”, atIndex: 1)array1.countarray1.isEmpty array1[0…1] = [“apple”,”pear”];array1//数组的遍历for item in array1{ print(item)} for (index,item) in array1.enumerate(){ print(item,array1[index])} //集合var asset = Set()asset.countasset.insert(“hash string”)asset.remove(“hash”)//set类型必须显式声明,具体元素类型可以省略let asset2:Set = [“a”]let asset3:Set = [“a”,”v”]asset2.hashValue == asset3.hashValueasset.hashValue == asset2.hashValue let asset4 = Set.init(arrayLiteral: “a”,”b”,”c”)let asset5 = Set.init(array1)//集合操作：交集、外集、合集,减集 asset3.intersect(asset4)asset3.exclusiveOr(asset4)asset3.union(asset4)asset3.subtract(asset4) asset3 == asset4asset3.isSubsetOf(asset4)asset3.isSupersetOf(asset3)asset3.isStrictSupersetOf(asset3)//是否是超集，并且不是同一集合asset3.isStrictSubsetOf(asset3)//是否是子集，并且不是同一集合 asset3.isDisjointWith(asset4)//判断集合是否不含有相同的值。false说明包含相同的值 //字典 Dictionaryvar dic1 = Dictionary()var dic2 = Int:Stringdic1.updateValue(“value”, forKey: 0)//updateValue方法返回值是该key的旧值dic1.updateValue(“newValue”, forKey: 0)print(dic1)dic1[1] = “ahao”dic1[2] = “dddd”print(dic1) for (key,value) in dic1{ print(key ,value)} print(dic1.keys.sort())print(dic1.values.sort()) //控制流程 //gamelet finalSqura = 25var board = Intboard[03] = +08; board[06] = +11; board[09] = +09; board[10] = +02board[14] = -10; board[19] = -11; board[22] = -02; board[24] = -08var square = 0var diceRoll = 0 gameLoop:while square != finalSqura{ //if ++diceRoll == 7 { diceRoll = 1 } switch square + diceRoll { case finalSqura: break gameLoop case let newSquare where newSquare &gt; finalSqura: coutinue gameLoop default: square += diceRoll square += board[square] }}print(“game over”) //检查API可用性if #available(iOS 9, *){ }else{ }func checkOSVersion() -&gt; NSString { //必须在函数体内使用；必须跟着else；必须能跳出else guard #available(OSX 10.11, *) else { return “10.10” } return “10.11”} checkOSVersion() //函数嵌套func stepForword(input:Int)-&gt;Int{ return input - 1}func stepBackword(input:Int)-&gt;Int{ return input + 1}func chooseStep(value:Int) -&gt; (Int)-&gt;Int { return value &gt; 0 ? stepForword : stepBackword}func xxxx(tempFunction:(Int)-&gt;Int) -&gt;Int { return 1}//如果我再加一个函数嵌套func nextStep(tempFunction:((Int)-&gt;Int)-&gt;Int) -&gt; Int{ return 0}let number = 3let myFunction = chooseStep(number)myFunction(number) let names = [“Chris”, “Alex”, “Ewa”, “Barry”, “Daniella”]func absendOrdesend(s1:String,s2:String) -&gt; Bool { return s1&gt;s2}//使用函数的返回值作为参数names.sort()names.sort(absendOrdesend)//闭包表达式 {(parameter:Type)-&gt;ReturnType in }Objective-C中的blockReturnType ^(parameter){ return } //使用闭包的返回值作为参数names.sort({(s1:String,s2:String) -&gt; Bool in return s1 &gt; s2}) //因为names数组参数类型确定，所以根据类型推断,省略参数类型和返回值类型names.sort({s1,s2 in return s1&gt;s2})names.sort({s1,s2 in s1&gt;s2})names.sort({$0&gt;$1})names.sort(&gt;)//根据String对&gt;这个符号的定义推断 //尾随闭包//先定义一个closurelet bigger = {(a:Int,b:Int)-&gt;Bool in return a&gt;b}//声明一个函数，参数是一个闭包func exchangeNumerWithClosure(bigger:(Int,Int)-&gt;Bool){ if bigger(2,3) { print(“bigger”) }else{ print(“lower”) }}//函数调用时//没有使用尾随闭包//exchangeNumerWithClosure({(a:Int,b:Int)-&gt;Bool in// return a&gt;b//}) //使用尾随闭包//exchangeNumerWithClosure(){(a:Int,b:Int)-&gt;Bool in return a&gt;b }exchangeNumerWithClosure(){(a:Int,b:Int) -&gt;Bool in a&gt;b}//同理，尾随闭包names.sort(){$0&gt;$1}names.sort{$0&gt;$1}//如果函数只需要闭包表达式一个参数，当您使用尾随闭包时,可以省略()]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>LearnSwift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈iOS中的userAgent]]></title>
    <url>%2F2016%2F04%2F10%2F%E6%B5%85%E8%B0%88iOS%E4%B8%AD%E7%9A%84userAgent%2F</url>
    <content type="text"><![CDATA[User-Agent（用户代理）字符串是Web浏览器用于声明自身型号版本并随HTTP请求发送给Web服务器的字符串，在Web服务器上可以获取到该字符串。 在公司产品中，在userAgent中增加了NetType字段，用于标识客户端当前的网络环境。 NetType/WIFI NetType/3Gweb服务器端根据NetType类型加载不同分辨率的商品图片。我们只有两种，WIFI下高清图，非WIFI低分辨率图。 获取WebView的userAgentiOS客户端中获取webView的userAgent的方法：1NSMutableString *userAgent = [NSMutableString stringWithString:[[UIWebView new] stringByEvaluatingJavaScriptFromString:@"navigator.userAgent"]];根据需要添加不同的标识到新的userAgent中,这里添加一个WMall标识。123NSString *newUagent = [NSString stringWithFormat:@"%@ WMall/%@", userAgent, [SystemInfo appShortVersion]];NSDictionary *dictionnary = [[NSDictionary alloc] initWithObjectsAndKeys:newUagent, @"UserAgent", nil];[[NSUserDefaults standardUserDefaults] registerDefaults:dictionnary];newUagent 为Mozilla/5.0 (iPhone; CPU iPhone OS 9_3 like Mac OS X) AppleWebKit/601.1.46 (KHTML, like Gecko) Mobile/13E230 WMall/3.0根据网络类型设置不同的NetType标识 iOS中判断网络状态一般用AFNetWorking中的方法：在appDelegate的application didFinishLaunchingWithOptions方法中启动网络状态监听：12[[AFNetworkReachabilityManager sharedManager] startMonitoring];[[AFNetworkActivityIndicatorManager sharedManager] setEnabled:YES]; 然后在基类BaseViewController中监听网络更新通知1[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(networkReachabilityStatusDidChange:) name:AFNetworkingReachabilityDidChangeNotification object:nil]; 12345678910111213141516171819202122- (void)networkReachabilityStatusDidChange:(NSNotification *)notify&#123; NSLog(@"网络变化通知：%@",notify.userInfo[AFNetworkingReachabilityNotificationStatusItem]); AFNetworkReachabilityStatus status = [notify.userInfo[AFNetworkingReachabilityNotificationStatusItem] integerValue]; NSString *net = nil; switch (status) &#123; case AFNetworkReachabilityStatusNotReachable: net = @"无网络"; break; case AFNetworkReachabilityStatusReachableViaWiFi: net = @"WIFI"; [self changeUserAgentWithType:@"WIFI"]; break; case AFNetworkReachabilityStatusReachableViaWWAN: net = @"2G/3G/4G"; [self changeUserAgentWithType:@"3G"]; break; default: net = @"xxx"; break; &#125; [Error showError:[NSString stringWithFormat:@"当前网络状态%@",net]];&#125; 注意先判断userAgent中是否存在NetType12345678910111213141516171819202122//更新NetType- (void)changeUserAgentWithType:(NSString *)type&#123; NSMutableString *userAgent = [NSMutableString stringWithString:[[UIWebView new] stringByEvaluatingJavaScriptFromString:@"navigator.userAgent"]]; NSString *newUagent = nil; NSString *temp = nil; if ([userAgent containsString:@"NetType"]) &#123; if ([userAgent containsString:@"WIFI"]) &#123; temp = @"WIFI"; &#125;else if([userAgent containsString:@"3G"])&#123; temp = @"3G"; &#125; newUagent = [userAgent stringByReplacingOccurrencesOfString:temp withString:type]; &#125;else&#123; newUagent = [NSString stringWithFormat:@"%@ NetType/%@", userAgent, type]; &#125; NSDictionary *dictionnary = [[NSDictionary alloc] initWithObjectsAndKeys:newUagent, @"UserAgent", nil]; NSLog(@"new useragent:%@",newUagent); [[NSUserDefaults standardUserDefaults] registerDefaults:dictionnary];&#125; newUagent 为Mozilla/5.0 (iPhone; CPU iPhone OS 9_3 like Mac OS X) AppleWebKit/601.1.46 (KHTML, like Gecko) Mobile/13E230 WMall/3.0 NetType/WIFI 参考微信6.0内嵌浏览器User-Agent字符串增加了NetType字段获取 UIWebview 的 Useragent，以及附加自定义字段到 Useragent]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>userAgent</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UIButton设置文字图片居中、UIView相关方法以及UI切图的重要性]]></title>
    <url>%2F2016%2F03%2F31%2FUIButton%E8%AE%BE%E7%BD%AE%E6%96%87%E5%AD%97%E5%9B%BE%E7%89%87%E5%B1%85%E4%B8%AD-%E8%AE%BAUI%E5%88%87%E5%9B%BE%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7%2F</url>
    <content type="text"><![CDATA[又是一个老生常谈的问题，o(╯□╰)o。UIButton作为最最常用的控件，想必都是很熟悉的。如下图所示的控件中 如此设计在很多电商客户端中都有涉及，也没有什么难度。 但是我遇到的问题就是任凭如何设置边距，就是对不齐，其中还要考虑屏幕适配的问题。Orz…最后去工程里查看相应的图片大小，才发现每个图片的尺寸宽高都不同，很随意。 这搞半天，原来是图片尺寸的问题，想想这UI，唉！ UIButton设置文字图片居中 UIButton图片、文字居中的调整主要就是四个参数：（``） contentHorizontalAlignment:设置真个Button内容（包括imageView和titleLabel）的水平位置。 contentVerticalAlignment:设置整个Button内容（包括imageView和titleLabel）的垂直位置，这里用不到。 imageEdgeInsets:设置imageView的边距。 titleEdgeInsets:设置titleLabel的边距。 1234567891011121314typedef NS_ENUM(NSInteger, UIControlContentVerticalAlignment) &#123; UIControlContentVerticalAlignmentCenter = 0, UIControlContentVerticalAlignmentTop = 1, UIControlContentVerticalAlignmentBottom = 2, UIControlContentVerticalAlignmentFill = 3,&#125;;typedef NS_ENUM(NSInteger, UIControlContentHorizontalAlignment) &#123; UIControlContentHorizontalAlignmentCenter = 0, UIControlContentHorizontalAlignmentLeft = 1, UIControlContentHorizontalAlignmentRight = 2, UIControlContentHorizontalAlignmentFill = 3,&#125;; 在这里给出我用的通用方法，button高度为50为例：1.设置button的contentHorizontalAlignment为UIControlContentHorizontalAlignmentLeft,这样便于根据button大小计算。当然非要用center计算也可！2.设置imageView的Edge： kButtonImageViewEdgeInsets(btn) UIEdgeInsetsMake(0,(kOptionBtnWidth - btn.imageView.frame.size.width)/2, 20, 0);3.设置titleLabel的Edge： #define kButtonTitleEdgeInsets(btn) UIEdgeInsetsMake(30, (kOptionBtnWidth - btn.titleLabel.frame.size.width)/2-btn.titleLabel.frame.origin.x, 0, 20);。 只要传入相应的button就可以了，其中button的宽度由此得来#define kOptionBtnWidth (CGRectGetWidth(frame)/kOptionBtnCount)。 UIView的相关方法 直接采用上述设置button的方法是有条件的，即确定了当前Button的宽度。我们看到要计算button的宽度，得通过读取屏幕宽度得知。app中初始化UIView的方式通常有两种：1.xib/Storyboard，然后关联.h,.m文件。2.自定义UIView子类,通过initWithFrame方法设置。 当在UIView的子类中实现时，因为此时屏幕宽度已经通过初始化方法中得知，所以不需要再多设置。而通过xib/sb关联的子类初始化方法中，若打印self.frame，就是当前xib的宽度，而不是实际屏幕宽度。所以不能再初始化方法中设置button的属性。 第一步重写父类方法，下面两个任选其一。12- (void)updateConstraints;-需要重写父类的updateConstraints方法。- (void)layoutSubviews; 第二步对每个button调用layoutIfNeeded方法，让其立即刷新布局。 这个是没有调用layoutIfNeeded的情况： 以上。 参考文档UIView Class ReferenceUIView)]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>UIView</tag>
        <tag>UIButton</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Effective-Objective C 2.0 要点]]></title>
    <url>%2F2016%2F03%2F23%2FEffective-Objective-C-2-0-%E8%A6%81%E7%82%B9%2F</url>
    <content type="text"><![CDATA[Effective-Ojective C 2.0 读书笔记 第一章的内容比较基础，就没有列在笔记当中了。另外该笔记只记录每一个要点之后的总结，重点地方会另外探讨。 第二章 消息、对象、运行期 7.在对象内部尽量直接访问实例变量 在对象内部读取数据时，应该直接通过实例变量来读取；而写入数据时，应该通过属性的设置方法来写。 在初始化方法多及dealloc方法中，总是通过实例变量来读写数据。 有时会使用lazy initializition方式来初始化某数据，这种情况下，需要通过属性来读取数据。 8.理解“对象同等性”这一概念 若想检测对象的等同性，请提供isEqual:与hash方法。 相同的对象必须具有相同的哈希码，但是两个哈希码相同的对象却未必相同。 编写hash方法时，应该使用计算速度快而且哈希吗碰撞几率低的算法。 9.以类簇模式隐藏实现细节 类簇模式可以把实现细节隐藏在一套简单的公共接口后面。 系统框架中经常使用类簇。 从类簇的公共抽象基类中继承子类时要当心，若有开发文档，则应首先阅读。 10.在既有类中使用关联对象存放自定义数据 1.关联对象的存储策略：枚举值 OBJC_ASSOCIATION_ASSIGN —&gt;assignOBJC_ASSOCIATION_RETAIN_NONATOMIC —&gt;nonatomic,retainOBJC_ASSOCIATION_COPY_NONATOMIC —&gt;nonatomic,copyOBJC_ASSOCIATION_RETAIN —&gt;retainOBJC_ASSOCIATION_COPY —&gt;copy 创建关联对象方法：void objc_setAssociatedObject(id object,void *key,id value,objc_AssociationPolicy policy) 以给定的键获取某对象的关联对象的值id objc_getAssociatedObject(id object,void *key) 移除该对象的所有关联对象void objc_removeAssociatedObjects(id object) Note:设置关联对象时的key是一个“不透明指针”（opaque pointer：其所指向的数据结构不局限与某种特定类型指针）； 在设置关联对象时，通常使用静态全局变量作为key。 可以通过“associateObject”机制来吧两个对象连起来。 定义关联对象时可指定内存管理语义，用于模仿定义属性时所在用的拥有关系和非拥有关系。 只有在其他做法不可行时才选用关联对象，因为这种做法通常会引入难以查找的bug。 11.理解objc_msgSend的作用。 消息由接受者、选择器及参数构成。给某对象发送消息（invoke a message），也就相当于在该对象上调用方法（calla method） 发给某对象的全部消息都要有动态消息派发系统（dynamic message dispatch system）来处理，该系统会查出对应的方法，并执行其代码。 12.理解消息转发机制。 若对象无法响应某个选择器中的消息，则进入消息转发过程。 通过运行期的动态方法解析机制，我们可以在需要用到某个方法时再将其加入类中。 对象可以把其无法解读的消息转交给其他对象来处理。 若经过上述两步还是没办法处理消息，则启动完整的消息转发机制。 13.使用方法调配技术Method Swizzling调试黑盒方法void method_exchangeImplementations(Method m1,Method m2) 在运行期，可以响雷中新增或替换选择器所对应的方法实现。 使用另一份实现来替换原有的方法实现，叫做方法调配，开发者可以用此技术向原有实现中添加新功能。 一般来说，只有调试程序的时候才需要在运行期修改方法实现，这种做法不宜滥用。 14.理解“类对象”的用意 每个实例都有一个指向Class对象的指针（isa），用意表明其类型，而这些Class对象则构成了类的继承体系（super_class指针）。 如果对象类型无法再编译期确定，那么久应该使用类型信息查询方法来探知。isMemberOfClass（特定类型的类），isKindOfClass（该类及其派生类） 尽量使用类型信息查询方法来确定对象类型，而不要直接比较类对象，因为某些对象可能实现了消息转发功能。 第三章 接口与API设计 15.使用前缀避免命名空间冲突，解决duplicate symbol问题。16.使用全能初始化方法，即带有特定参数的初始化方法。17.实现description方法用来调试程序。并且最好用字典的方式输出类的属性，条理清晰。18.尽量使用不可变对象。19.使用清晰而协调的命名方式。参考Objective C编程规范。20.为私有方法名添加前缀。21.理解OC的错误模型。OC在遇到极其严重的错误后，会抛出异常，程序会退出（crash），所以不用太考虑异常安全。如果不太严重的错误，可以通过设置返回nil/0，或者NSError。22.理解NSCopying协议。 实现NSCopying协议。 重写copyWithZone方法。 如果类中有可变属性，则在copyWithZone方法中同时需要对可变属性进行mutableCopy。举个例子： 1234567891011121314151617181920212223242526272829303132#import &lt;Foundation/Foundation.h&gt;@interface EOCPerson : NSObject&lt;NSCopying&gt;@property (nonatomic,copy)NSString * firstname;@property (nonatomic,copy)NSString * lastname;- (id)initWithFirstName:(NSString *)fisrtname lastName:(NSString *)lastname;@end#import "EOCPerson.h"@implementation EOCPerson&#123; NSMutableSet * _friends;&#125;- (id)initWithFirstName:(NSString *)fisrtname lastName:(NSString *)lastname&#123; if (self == [super init]) &#123; _firstname = firstname; _lastname = lastname; &#125; return self;&#125;- (id)copyWithZone:(NSZone *)zone&#123; EOCPerson *copy = [[[self class] allocWithZone:zone] initWithFirstName:_firstname lastName:_lastname]; copy-&gt;_friends = [_friends mutableCopy]; return copy;&#125;@end 要点： 自定义对象若想要进行copy操作，需实现NSCopying协议。 自定义对象若分为可变和不可变版本，则需实现NSCopying和NSMutableCopying协议。 复制对象时需要考虑使用浅拷贝还是深拷贝。一般应该尽量使用浅拷贝。 自定义对象若需要深拷贝，则可以新增一个专门执行深拷贝的方法。 第四章 协议与分类 23.通过委托与数据源协议进行对象间通信24.将类的实现代码分散到数个分类（category）之中。25.总是为第三方分类名称前加前缀。26.尽量不要在分类中声明属性（当然非要做也可）27.使用class-continuation分类（匿名分类）隐藏实现细节28.通过协议提供匿名对象。例如 id,id。任意一个遵守了上述协议的对象都可以赋值给这个属性。 第五章 内存管理 29.理解引用计数。30.以ARC简化引用计数。31.在dealloc方法中只释放引用并解除监听。32.编写“异常安全代码”时应留意内存管理问题。33.以弱引用避免循环引用。34.以“自动释放池”降低内存峰值。35.使用Zombie Object调试内存问题。36.不要使用retainCount。ARC下已废弃。 第六章 GCD 37.理解block。重点看一下block的内部结构那一节。 block中的invoke变量，是一个函数指针，类型为void(*)(void *,_)指向了block的实现代码（需要执行的函数）。 block中的descriptor是一个结构体指针。该结构体中包含了这个block的一些信息，如block的size。 block还会把从外部捕获的变量拷贝一份，放在descriptor变量的后面。拷贝的并不是对象本身，而是这些对象的指针变量。invoke函数把block对象本身作为参数传递进来，就是为了能 拿到block捕获的这些变量。 block被定义时是分配在栈内存中。所以需要copy一份，复制到堆内存中，就可以在外部使用。1234567891011121314151617181920//栈block：void(^block)(); if (/* condition */) &#123; block = ^()&#123; NSLog(@"Block in Stack"); &#125; &#125;else&#123; block = ^()&#123; NSLog(@"Block in Stack still"); &#125; &#125; block();//堆block：void(^block)(); if (/* condition */) &#123; block = [^()&#123; NSLog(@"Block in Heap"); &#125; copy]; &#125;else&#123; block = [^()&#123; NSLog(@"Block in Heap"); &#125; copy]; &#125; block();//全局block： void (^block)() = ^()&#123; NSLog(@"I'm a global block");&#125; 38.为常用的block创建typedef。39.用handler块来降低代码分散。常用于异步任务时。40.使用block时注意不要出现循环引用。41.多用dispatch queue，少用同步锁。例如涉及到数据的存取。 GCD以前，有两种实现锁的方式： 1.@synchronized(self){ … }.这种方式会降低代码执行效率，因为花括号内的代码都共用一个同步锁，且顺序执行。 2.使用NSLock。lock()方法和unlock()方法。也可以使用递归锁NSRecursiveLock,线程能够多次持有该锁，而不会出现死锁现象。 例子：属性的读取和设置中。 42.多用GCD，少用performeSelector. performSelector系列方法在内存管理方面容易有陷阱。编译器无法确定其将要执行的SEL具体是什么，因此无法通过ARC在编译期插入内存管理方法。 performSelector能够处理的SEL有点局限，选择器的返回类型和参数个数都有限制。 43.掌握GCD和OperationQueue操作队列的使用时机。 执行后台任务时，操作队列更有优势。 使用NSOperation和NSOperationQueue的好处： 取消某个操作。注意：可以取消的是队列中还没有执行的任务。 指定操作间的依赖关系。 通过KVO监测NSOperation对象的属性。 指定Operation的优先级。 重用operations。 44.通过Dispatch_group机制，根据系统资源状况来执行任务 dispatch_apply. 这个会阻塞当前线程。所以不能把主线程作为该方法执行的线程参数。 45.使用dispatch_once来执行只需要运行一次的线程安全代码。常用于单例模式。46.不要使用dispatch_get_current_queue 第七章 系统框架 47.熟悉系统框架。 Fundation 和 CoreFoundation。 无缝桥接，toll-free-bridging,可以将CoreFoundation中的C语言数据结构转换为Foundation中的对象，也可以反向转换。 48.多用块枚举，少用for循环。 for(int i=0;i&lt;max;i++){} NSEnumerator. allObjects() 和nextObject()方法。 快速遍历 fast enumeration. for in基于block的遍历方式- enumerateObjectesUsingBlock:(void(^)(id object,NSUInteger index,BOOL *stop))block…其他方法 49.对自定义内存管理语义的collection集合类使用无缝桥接。 __bridge __bridge_retained __bridge_transfer 1234567891011121314151617NSArray *nameArray = @[@"g",@"c",@"d"];//正向桥接：Foundation对象-&gt;CoreFoundation数据结构CFArrayRef aCFArray = (__bridge CFArrayRef)nameArray ;NSLog(@"CFArray's count is %li",CFArrayGetCount(aCFArray));CFArrayRef bCFArray = (__bridge_retained CFArrayRef)nameArray;//或者用bCFArray = CFBridgingRetain(nameArray);NSLog(@"CFArray's count is %li",CFArrayGetCount(bCFArray));CFRelease(bCFArray);NSArray *names = (NSArray *)(__bridge_transfer NSArray *)aCFArray;// //或者用// NSArray * names = CFBridgingRelease(aCFArray);//NSLog(@"%@",names); 50.构建缓存时使用NSCache而不是NSDictionary。 51.精简initialize和load的实现代码。 两个都是类的初始化方法。 1.load() 对于加入运行时的类class和分类category来说，当包含类和分类的程序库载入系统时，必定会调用+ (void)load方法，且只调用一次。 对于iOS系统，是在应用程序启动的时候。对于Mac OS X来说更自由，因为可以使用动态加载dynamic loading这种特性,等应用程序启动完成之后再去加载程序库。若分类和类中都定义了load方法，则先调用类的，再调用分类的。 load方法一般只用来调试程序，而不是在其中做什么操作。 2.initialize 对于每个类来说，该方法会在首次使用该类之前调用，且只调用一次。它是由运行时系统来调用，而不是由代码调用。 与load的区别： 惰性调用。只有当用到这个类时，才会被调用。如果某个类没有被使用，则不会被调用。而程序必须阻塞把所有类的load方法执行完才能继续。 执行方法时运行时系统的状态。initializer被执行时，runtime system是正常状态的。而load被执行时，runtime system是脆弱状态的。(这个脆弱状态是指最好不要在load方法中使用别的类) initialize方法遵循继承调用。即子类即使没有实现initialize方法，也会调用父类的initialize方法。而load方法则不会，子类若没有实现load方法，也不会去调用父类的load。 52.别忘了NSTimer会保留其目标对象。 NSTimer对象会引用其目标对象，直到计时器本身失效为止，调用invalidate方法可令计时器失效，另外，一次性的计时器在触发完任务之后也会失效。 反复执行任务的计时器，很容易引起循环引用。 可以扩充NSTimer的功能，用block来打破这种循环引用。必须创建分类，将相关实现代码加入其中。 123456789101112131415161718192021222324252627282930313233343536//分类文件.h/.m #import &lt;Foundation/Foundation.h&gt; @interface NSTimer (BlockTimer) + (NSTimer *)bt_scheduledTimerWithTimeInterval:(NSTimeInterval)interval block:(void(^)())block repeats:(BOOL)repeats; @end #import "NSTimer+BlockTimer.h" @implementation NSTimer (BlockTimer) + (NSTimer *)bt_scheduledTimerWithTimeInterval:(NSTimeInterval)interval block:(void(^)())block repeats:(BOOL)repeats&#123; return [self scheduledTimerWithTimeInterval:interval target:self selector:@selector(bt_doSomething:) userInfo:[block copy] repeats:repeats]; &#125; + (void)bt_doSomething:(NSTimer *)timer&#123; void(^block)() = timer.userInfo; if (block) &#123; block(); &#125; &#125; @end//在调用时 __weak typeof(self)weakSelf = self; _timer = [NSTimer bt_scheduledTimerWithTimeInterval:1 block:^&#123; //不需要再转成strong也可以啊！？ [weakSelf printName:@"hello"]; ViewController * strongSelf = weakSelf; [strongSelf printName:@"world"]; &#125; repeats:YES];]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Effective-Ojective C 2.0</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 蓝牙4.0开发]]></title>
    <url>%2F2016%2F03%2F08%2FiOS-%E8%93%9D%E7%89%994-0%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[iOS 蓝牙4.0开发 背景：1.iOS的蓝牙不能用来传输文件。2.iOS与iOS设备之间进行数据通信，使用gameKit.framework3.iOS与其他非iOS设备进行数据通信，使用coreBluetooth.frameworkiOS中蓝牙的实现方案 iOS中提供了4个框架用于实现蓝牙连接GameKit.framework（用法简单）只能用于iOS设备之间的连接，多用于游戏（比如五子棋对战），从iOS7开始过期 MultipeerConnectivity.framework只能用于iOS设备之间的连接，从iOS7开始引入，主要用于文件共享（仅限于沙盒的文件） ExternalAccessory.framework可用于第三方蓝牙设备交互，但是蓝牙设备必须经过苹果MFi认证（国内较少） CoreBluetooth.framework（时下热门）可用于第三方蓝牙设备交互，必须要支持蓝牙4.0硬件至少是4s，系统至少是iOS6蓝牙4.0以低功耗著称，一般也叫BLE（BluetoothLowEnergy）目前应用比较多的案例：运动手坏、嵌入式设备、智能家居 下面具体介绍使用CoreBluetooth.framework的代码步骤： 12345678910111213141516171819202122232425//蓝牙系统库#import &lt;CoreBluetooth/CoreBluetooth.h&gt;//必须要由UUID来唯一标示对应的service和characteristic#define kServiceUUID @"5C476471-1109-4EBE-A826-45B4F9D74FB9"#define kCharacteristicHeartRateUUID @"82C7AC0F-6113-4EC9-92D1-5EEF44571398"#define kCharacteristicBodyLocationUUID @"537B5FD6-1889-4041-9C35-F6949D1CA034"@interface ViewController ()&lt;CBCentralManagerDelegate,CBPeripheralDelegate&gt;@property (nonatomic,strong)CBCentralManager * centralManager;@property (nonatomic,strong)CBPeripheral * peripheral;@end 创建中心角色1234567891011121314#import &lt;CoreBluetooth/CoreBluetooth.h&gt; - (void)viewDidLoad&#123; [super viewDidLoad]; //初始化蓝牙 central manager _centralManager = [[CBCentralManager alloc]initWithDelegate:self queue:dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0) options:nil]; &#125; 扫描外设1[manager scanForPeripheralsWithServices:nil options:@&#123;CBCentralManagerRestoredStateScanOptionsKey:@(YES)&#125;]; 连接外设12345678910111213- (void)centralManager:(CBCentralManager *)central didDiscoverPeripheral:(CBPeripheral *)peripheral advertisementData:(NSDictionary *)advertisementData RSSI:(NSNumber *)RSSI &#123; if([peripheral.name isEqualToString:BLE_SERVICE_NAME])&#123; [self connect:peripheral]; &#125;s); &#125; -(BOOL)connect:(CBPeripheral *)peripheral&#123; self.manager.delegate = self; [self.manager connectPeripheral:peripheral options:[NSDictionary dictionaryWithObject:[NSNumber numberWithBool:YES] forKey:CBConnectPeripheralOptionNotifyOnDisconnectionKey]];&#125; 扫描外设中的服务和特征1234567891011- (void)centralManager:(CBCentralManager *)central didConnectPeripheral:(CBPeripheral *)peripheral &#123; NSLog(@"Did connect to peripheral: %@", peripheral); _testPeripheral = peripheral; [peripheral setDelegate:self]; &lt;br&gt;//查找服务 [peripheral discoverServices:nil]; &#125; 发现服务：123456789101112131415161718192021222324252627282930- (void)peripheral:(CBPeripheral *)peripheral didDiscoverServices:(NSError *)error &#123; NSLog(@"didDiscoverServices"); if (error) &#123; NSLog(@"Discovered services for %@ with error: %@", peripheral.name, [error localizedDescription]); if ([self.delegate respondsToSelector:@selector(DidNotifyFailConnectService:withPeripheral:error:)]) [self.delegate DidNotifyFailConnectService:nil withPeripheral:nil error:nil]; return; &#125; for (CBService *service in peripheral.services) &#123; //发现服务 if ([service.UUID isEqual:[CBUUID UUIDWithString:UUIDSTR_ISSC_PROPRIETARY_SERVICE]]) &#123; NSLog(@"Service found with UUID: %@", service.UUID); &lt;br&gt;//查找特征 [peripheral discoverCharacteristics:nil forService:service]; break; &#125; &#125; &#125; 发现服务中的特征：12345678910111213141516171819202122- (void)peripheral:(CBPeripheral *)peripheral didDiscoverCharacteristicsForService:(CBService *)service error:(NSError *)error&#123; if (error) &#123; NSLog(@"Discovered characteristics for %@ with error: %@", service.UUID, [error localizedDescription]); [self error]; return; &#125; NSLog(@"服务：%@",service.UUID); for (CBCharacteristic *characteristic in service.characteristics) &#123; //发现特征 if ([characteristic.UUID isEqual:[CBUUID UUIDWithString:@"xxxxxxx"]]) &#123; NSLog(@"监听：%@",characteristic);&lt;br&gt;//监听特征 [self.peripheral setNotifyValue:YES forCharacteristic:characteristic]; &#125; &#125;&#125; 与外设进行数据交互读取数据：12345678910111213- (void)peripheral:(CBPeripheral *)peripheral didUpdateValueForCharacteristic:(CBCharacteristic *)characteristic error:(NSError *)error&#123; if (error) &#123; NSLog(@"Error updating value for characteristic %@ error: %@", characteristic.UUID, [error localizedDescription]); self.error_b = BluetoothError_System; [self error]; return; &#125; // NSLog(@"收到的数据：%@",characteristic.value); [self decodeData:characteristic.value];&#125;写数据：123NSData *d2 = [[PBABluetoothDecode sharedManager] HexStringToNSData:@"0x02"]; [self.peripheral writeValue:d2 forCharacteristic:characteristic type:CBCharacteristicWriteWithoutResponse];]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>蓝牙</tag>
        <tag>CoreBluetooth</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SDWebImage内部实现过程]]></title>
    <url>%2F2016%2F03%2F08%2FSDWebImage%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[SDWebImage内部实现过程(新版本在各方法前加上了sd_前缀，以区分UIImageView+AFNetworking中的方法) 1.入口 setImageWithURL:placeholderImage:options:会先把 placeholderImage 显示，然后 SDWebImageManager 根据 URL 开始处理图片。 2.进入 SDWebImageManager-downloadWithURL:delegate:options:userInfo:，交给 SDImageCache 从缓存查找图片是否已经下载 queryDiskCacheForKey:delegate:userInfo:. 3.先从内存图片缓存查找是否有图片，如果内存中已经有图片缓存，SDImageCacheDelegate 回调 imageCache:didFindImage:forKey:userInfo: 到 SDWebImageManager。 4.SDWebImageManagerDelegate 回调 webImageManager:didFinishWithImage:到 UIImageView+WebCache 等前端展示图片。 5.如果内存缓存中没有，生成 NSInvocationOperation 添加到队列开始从硬盘查找图片是否已经缓存。 6.根据 URLKey 在硬盘缓存目录下尝试读取图片文件。这一步是在 NSOperation 进行的操作，所以回主线程进行结果回调 notifyDelegate:。 7.如果上一操作从硬盘读取到了图片，将图片添加到内存缓存中（如果空闲内存过小，会先清空内存缓存）。SDImageCacheDelegate 回调 imageCache:didFindImage:forKey:userInfo:。进而回调展示图片。 8.如果从硬盘缓存目录读取不到图片，说明所有缓存都不存在该图片，需要下载图片，回调 imageCache:didNotFindImageForKey:userInfo:。 9.共享或重新生成一个下载器 SDWebImageDownloader 开始下载图片。 10.图片下载由 NSURLConnection 来做，实现相关 delegate 来判断图片下载中、下载完成和下载失败。 11.connection:didReceiveData:中利用 ImageIO 做了按图片下载进度加载效果。 12.connectionDidFinishLoading:数据下载完成后交给 SDWebImageDecoder 做图片解码处理。 13.图片解码处理在一个 NSOperationQueue 完成，不会拖慢主线程 UI。如果有需要对下载的图片进行二次处理，最好也在这里完成，效率会好很多。 14.在主线程 notifyDelegateOnMainThreadWithInfo: 宣告解码完成，imageDecoder:didFinishDecodingImage:userInfo: 回调给 SDWebImageDownloader。 15.imageDownloader:didFinishWithImage: 回调给 SDWebImageManager 告知图片下载完成。 16.通知所有的 downloadDelegates 下载完成，回调给需要的地方展示图片。 17.将图片保存到 SDImageCache 中，内存缓存和硬盘缓存同时保存。写文件到硬盘也在以单独 NSInvocationOperation 完成，避免拖慢主线程。 18.SDImageCache 在初始化的时候会注册一些消息通知，在内存警告或退到后台的时候清理内存图片缓存，应用结束的时候清理过期图片。 19.SDWI 也提供了 UIButton+WebCache 和 MKAnnotationView+WebCache，方便使用。 20.SDWebImagePrefetcher 可以预先下载图片，方便后续使用。 从上面流程可以看出，当你调用setImageWithURL:方法的时候，他会自动去给你干这么多事，当你需要在某一具体时刻做事情的时候，你可以覆盖这些方法。比如在下载某个图片的过程中要响应一个事件，就覆盖这个方法： 覆盖方法，指哪打哪，这个方法是下载imagePath2的时候响应12345678910SDWebImageManager *manager = [SDWebImageManager sharedManager]; [manager downloadImageWithURL:imagePath2 options:SDWebImageRetryFailed progress:^(NSInteger receivedSize, NSInteger expectedSize) &#123; NSLog(@"显示当前进度"); &#125; completed:^(UIImage *image, NSError *error, SDImageCacheType cacheType, BOOL finished, NSURL *imageURL) &#123; NSLog(@"下载完成");&#125;]; 当服务器更新了某一张图片资源时，客户端需要重新加载，那么就可以设置SDWebImageOption为SDWebImageRefreshCached；附上全部的SDWebImageOptions：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172typedef NS_OPTIONS(NSUInteger, SDWebImageOptions) &#123; /** * By default, when a URL fail to be downloaded, the URL is blacklisted so the library won't keep trying. * This flag disable this blacklisting. */ SDWebImageRetryFailed = 1 &lt;&lt; 0, /** * By default, image downloads are started during UI interactions, this flags disable this feature, * leading to delayed download on UIScrollView deceleration for instance. */ SDWebImageLowPriority = 1 &lt;&lt; 1, /** * This flag disables on-disk caching */ SDWebImageCacheMemoryOnly = 1 &lt;&lt; 2, /** * This flag enables progressive download, the image is displayed progressively during download as a browser would do. * By default, the image is only displayed once completely downloaded. */ SDWebImageProgressiveDownload = 1 &lt;&lt; 3, /** * Even if the image is cached, respect the HTTP response cache control, and refresh the image from remote location if needed. * The disk caching will be handled by NSURLCache instead of SDWebImage leading to slight performance degradation. * This option helps deal with images changing behind the same request URL, e.g. Facebook graph api profile pics. * If a cached image is refreshed, the completion block is called once with the cached image and again with the final image. * * Use this flag only if you can't make your URLs static with embeded cache busting parameter. */ SDWebImageRefreshCached = 1 &lt;&lt; 4, /** * In iOS 4+, continue the download of the image if the app goes to background. This is achieved by asking the system for * extra time in background to let the request finish. If the background task expires the operation will be cancelled. */ SDWebImageContinueInBackground = 1 &lt;&lt; 5, /** * Handles cookies stored in NSHTTPCookieStore by setting * NSMutableURLRequest.HTTPShouldHandleCookies = YES; */ SDWebImageHandleCookies = 1 &lt;&lt; 6, /** * Enable to allow untrusted SSL ceriticates. * Useful for testing purposes. Use with caution in production. */ SDWebImageAllowInvalidSSLCertificates = 1 &lt;&lt; 7, /** * By default, image are loaded in the order they were queued. This flag move them to * the front of the queue and is loaded immediately instead of waiting for the current queue to be loaded (which * could take a while). */ SDWebImageHighPriority = 1 &lt;&lt; 8, /** * By default, placeholder images are loaded while the image is loading. This flag will delay the loading * of the placeholder image until after the image has finished loading. */ SDWebImageDelayPlaceholder = 1 &lt;&lt; 9, /** * We usually don't call transformDownloadedImage delegate method on animated images, * as most transformation code would mangle it. * Use this flag to transform them anyway. */ SDWebImageTransformAnimatedImage = 1 &lt;&lt; 10,&#125;;]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>SDWebImage</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[QRCode与Core Image]]></title>
    <url>%2F2016%2F03%2F05%2FQRCode%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF%2F</url>
    <content type="text"><![CDATA[网上已经有很多关于二维码方面的文章了，写这篇文章的目的是因为要记录一个关于保存二维码图片到相册的问题，顺便回顾一下iOS开发中使用二维码的历史。好了，废话少说，让我们开始吧！ 要讨论的问题在参考Building a QR Code Generator with Core Image Filters这篇文章，完成了二维码生成的栗子。二维码的扫描则是用了AVFoundation框架来编写的Github·HLQRCode。最后想把生成的二维码图片保存到相册中却没有成功。参考了网上的代码，使用了CIImag-&gt;CGImage-&gt;writeImageToAlbum的方式。代码如下：1234567891011121314151617181920CIContext * context = [CIContext contextWithOptions:nil];CGImageRef cgimg = [context createCGImage:self.qrcodeImg fromRect:[self.qrcodeImg extent] ];ALAssetsLibrary *library = [[ALAssetsLibrary alloc] init];[library writeImageToSavedPhotosAlbum:cgimg metadata:[self.qrcodeImg properties] completionBlock:^(NSURL *assetURL, NSError *error) &#123; if(error != NULL)&#123; msg = @"保存图片失败" ; &#125;else&#123; NSLog(@"%@",assetURL); msg = @"保存图片成功" ; &#125; UIAlertView *alert = [[UIAlertView alloc] initWithTitle:nil message:msg delegate:self cancelButtonTitle:@"确定" otherButtonTitles:nil]; [alert show];&#125;];但是这样无论怎么样都无法在相册中看到保存的二维码图片。还报错message &quot;BSXPCMessage received error for message: Connection interrupted&quot;。对比参考的代码都是一样的，却找不出原因。我就在文章评论中留言问了这个问题，后来一个朋友提出了解决方案，仔细一看顿时恍然大悟。解决方式及要点 1CIContext * context = [CIContext contextWithOptions:@&#123;kCIContextUseSoftwareRenderer:@YES&#125;]; 看到区别了吗？是的，多了一个option参数kCIContextUseSoftwareRenderer.然后在development doc中查看了关于contextWithOptions方法的描述：contextWithOptions:You can create a CPU-based context by providing the key kCIContextUseSoftwareRenderer. A CPU-based context supports larger input and output images than a GPU-based context. It also allows your app to perform processing in the background, such as when saving the rendered output to the Photo Library. GPU rendering is faster than CPU rendering, but the resulting image is not displayed on the device until after is it copied to CPU memory and converted to another image type, such as a UIImage object. @Apple Development Docdeveloper.apple.com/library/prerelease/ios/documentation/GraphicsImaging/Reference/QuartzCoreFramework/Classes/CIContext_Class/index.html#//apple_ref/occ/clm/CIContext/contextWithOptions: 顿时觉得自己当时好笨，都没有想到去查一下开发文档。o(╯□╰)o NSString *kCIContextOutputColorSpace; - A key for the color space to use for images before they are rendered to the context. 使用OpenGLES NSString *kCIContextWorkingColorSpace; - A key for the color space to use for image operations. 使用OpenGLES NSString *kCIContextUseSoftwareRenderer; - A key for enabling software renderer use. If the associated NSNumber object is YES, then the software renderer is required. 使用CPU NSString *kCIContextPriorityRequestLow; - A key for enabling low-priority GPU use. NSString *kCIContextWorkingFormat; - An option for the color format to use for intermediate results when rendering with the context. contextWithOptions方法默认是在GPU上处理图像。根据不同的参数设置不同的处理方式。以上这些其实不是很理解，囧。具体参考Context Options 二维码的历史在iOS7以前，iOS开发使用二维码都是使用第三方库。比较流行的就是ZXing和Zbar了。不说它们的实现原理了，遇到最多的问题就是与其他第三方库（比如支付宝SDK，百度地图SDK）继承在一起时出现duplicate symbol了。解决方法也很麻烦：修改源码，重新编译静态库.a文件。 不过现在很少用到二维码了，要用也要用系统自带的框架哟~！ 总结1.遇到问题先查看开发文档，再Google！2.研究问题要深入！后面学习一下Core Image的东西，还有与之的GPUImage库！ 参考文章Core Image Programming GuideBSXPCMessage received error for message: Connection interrupted]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>QRCode</tag>
        <tag>AVFoundation</tag>
        <tag>CoreImage</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Xib与之关联的自定义Class]]></title>
    <url>%2F2016%2F03%2F04%2FXib%E4%B8%8E%E4%B9%8B%E5%85%B3%E8%81%94%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89Class%2F</url>
    <content type="text"><![CDATA[最近遇到了一个问题：点击【猜你喜欢】视图进入商品详情后，再返回到首页时，没有原先的数据了。 打开Reveal看了下层级关系，原来是被二次生成的界面覆盖了。再细看一下，上面的视图都被二次生成了。真是哔了狗了！ drawRect方法好吧，修改代码吧。因为这些视图都是在xib上创建好了，另外新建了与之对应的自定义类，所以都直接用的drawRect方法去初始化UI元素。1234- (void)drawRect:(CGRect)rect &#123; [self initSubViews];&#125; The default implementation of this method does nothing. Subclasses that use technologies such as Core Graphics and UIKit to draw their view’s content should override this method and implement their drawing code there. You do not need to override this method if your view sets its content in other ways. For example, you do not need to override this method if your view just displays a background color or if your view sets its content directly using the underlying layer object. If you subclass UIView directly, your implementation of this method does not need to call super. However, if you are subclassing a different view class, you should call super at some point in your implementation.This method is called when a view is first displayed or when an event occurs that invalidates a visible part of the view. You should never call this method directly yourself. To invalidate part of your view, and thus cause that portion to be redrawn, call the setNeedsDisplay or setNeedsDisplayInRect: method instead. @Apple Developdeveloper.apple.com/library/prerelease/ios/documentation/UIKit/Reference/UIView_Class/index.html#//apple_ref/swift/instm/UIView/c:objc(cs)UIView(im)drawRect: 这里就出现了问题。在每次重新返回到首页后，drawRect方法又被重新调用了一次，所以生成了新的视图覆盖了原来的视图，但是又没有请求数据，所以就看不到了。drawRect方法只被重新调用了一次，在这之后就不会再被调用。 因为为了解决这个问题，我就不用drawRect去初始化页面元素了，而是用了initWithCorder方法。注意因为视图是被直接创建在xib上的，并没有执行initWithFrame方法。 12345678- (instancetype)initWithCoder:(NSCoder *)aDecoder&#123; self = [super initWithCoder:aDecoder]; if (self) &#123; [self initSubViews]; &#125; return self;&#125; 总结1.尽量不要使用drawRect方法，性能下降厉害撒。2.已经在xib上创建的视图，与其关联的子类中initWithFrame方法不会被调用。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>xib</tag>
        <tag>drawRect</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动IM开发要点]]></title>
    <url>%2F2016%2F02%2F28%2F%E7%A7%BB%E5%8A%A8IM%E5%BC%80%E5%8F%91%E8%A6%81%E7%82%B9%2F</url>
    <content type="text"><![CDATA[个人对于IM开发中客户端与服务器之间的连接比较感兴趣，网搜一篇好文，记录下来。转载于 移动IM开发那些事 通讯方式选择IM通讯方式无非两种选择:设备直连(P2P)和通过服务器中转。P2PP2P多见于局域网内聊天工具，典型的应用有:飞鸽传书，天网Maze(你懂的)等。这类软件在启动后一般做两件事情 进行UDP广播:发送自己信息和接受同局域网内其他端信息 开启TCP监听:等待其他端进行连接详细的流程可以参考飞鸽传书源码。但是这种方式在有种种限制和不便:一方面它只适合在线的点对点消息传输，对离线，群组等业务支持不够。另一方面由于 NAT 的存在，使得不同局域网内机器互联难度大大上升，在某些网络类型(对称NAT)下无法建立连接。服务器中转几乎所有互联网IM产品都采用服务器中转这种方式进行消息传输，相对于P2P的方式，它有如下的优点: 能够支持更多P2P无法支持或支持不好的业务，如离线消息，群组，聊天室服务 方便业务逻辑的拓展和新旧版本的兼容当然它也有自己的问题:服务器架构复杂，并发要求高。网络连接方式IM主流网络连接方式有两种: 基于TCP的长连接 基于HTTP短连接PULL的方式后者常见于WEB IM系统(当然现在很多WEB IM都是基于WebSocket实现)，它的优点是实现简单，方便开发上手，问题是流量大，服务器负载较大，消息及时性无法很好地保证，对大规模的用户量支持不够，比较适合小型的IM系统,如小网站的客户系统。基于TCP长连接则能够更好地支持大批量用户，问题是客户端和服务器的实现比较复杂。当然也还有一些变种，如下行使用MQTT进行服务器通知/消息的下发，上行使用HTTP短连接进行指令和消息的上传。这种方式能够保证下行消息/指令的及时性，但是在弱网络下上行慢的问题还是比较严重。早期的来往就是基于这种方式。协议选择 IM协议选择原则一般是:易于拓展，方便覆盖各种业务逻辑，同时又比较节约流量。后一点的需求在移动端IM上尤其重要。 常见的协议有: XMPP SIP MQTT 私有协议 XMPP协议的优点在于:协议开源，可拓展性强，在各个端(包括服务器)有各种语言的实现，开发者接入方便。但是缺点也是不少:XML表现力弱，有太多冗余信息，流量大，实际使用时有大量天坑。 SIP协议多用于VOIP相关的模块，是一种文本协议，由于我并没有实际用过，所以不做评论，但从它是文本协议这一点几乎可以断定它的流量不会小。 MQTT的优点是协议简单，流量少，但是它并不是一个专门为IM设计的协议，多使用于推送。 而市面上几乎所有主流IM APP都是是使用私有协议，一个被良好设计的私有协议一般有如下优点:高效，节约流量(一般使用二进制协议)，安全性高，难以破解。缺点则是在开发初期没有现有样列可以参考，对于设计者的要求比较高。 一个好的协议需要满足如下条件:高效，简洁，可读性好，节约流量，易于拓展，同时又能够匹配当前团队的技术堆栈。基于如上原则，我们可以推出:如果团队小，团队技术在IM上积累不够可以考虑使用XMPP或者MQTT+HTTP短连接的实现。反之可以考虑自己设计和实现私有协议。 私有协议的设计 序列化选择移动互联网相对于有线网络最大特点是:带宽低，延迟高，丢包率高和稳定性差，流量费用高。所以在私有协议的序列化上一般使用二进制协议，而不是文本协议。常见的二进制序列化库有protobuf和MessagePack，当然你也可以自己实现自己的二进制协议序列化和反序列的过程，比如蘑菇街的TeamTalk。但是前面二者无论是可拓展性还是可读性都完爆TeamTalk(TeamTalk连Variant都不支持，一个int传输时固定占用4个字节)，所以大部分情况下还是不推荐自己去实现二进制协议的序列化和反序列化过程。协议格式设计 基于TCP的应用层协议一般都分为包头和包体(如HTTP)，IM协议也不例外。包头一般用于表示每个请求/反馈的公共部分，如包长，请求类型，返回码等。而包头则填充不同请求/反馈对应的信息。 一个最简单的包头可以定义为 1234567struct PackHeader&#123; int32_t length_; //包长度 int32_t serial_; //包序列号 int32_t command_; //包请求类型 int32_t code_; //返回码&#125;; 以心跳包为例，假设当前的serial为1，心跳包的command为10，那么使用MessagePack做序列化时:length=4，serial=1，command=10，code=0，每个字段各占一个字节，包体为空，仅需要4个字节。 当然这是最简单的一个例子，面对真正的业务逻辑时，包体里面会需要塞入更多地信息，这个需要开发根据自己的业务逻辑总结公共部分,如为了兼容加入的协议版本号,为了负载均衡加入的模块id等。 其他问题上面就是一个IM系统大致的选型过程:通讯方式，连接方式，协议选择，协议设计。但是实际开发过程中还有大量的问题需要处理。 协议加密为了保证协议不容易被破解，市面上几乎所有主流IM都会对协议进行加密传输。常见的流程和HTTPS加密相似:建立连接后，客户端和服务器进行进行协商，最终客户端获得一个当前Sessino的秘钥，后续的数据传输都通过这个秘钥进行加解密。一般出于效率的考虑都会采用流式加密，如RC4。而前期协商过程则推荐使用RSA等非对称加密以增加破解难度。 快速连接(登录)对iOS APP而言，因为没有真后台的存在，APP每次启动基本都需要一次重连登录(短时间内切换除外)，所以如何快速重连重登就非常重要。常见的优化思路如下: 本地缓存服务器IP并定期刷新。移动网络调优可以参考《iOS移动网络调优那些事》。 合并部分请求。如加密和登录操作可以合并为同一个操作，这样就可以减少一次不必要的网络请求来回的时间。 简化登录后的同步请求，部分同步请求可以推迟到UI操作时进行，如群成员信息刷新。 连接保持一般APP实现连接保持的方式无非是采用应用层的心跳，通过心跳包的超时和其他条件(网络切换)来执行重连操作。那么问题来了:为什么要使用应用层心跳和如何设计应用层心跳。 众所周知TCP协议是有KEEPALIVE这个设置选项，设置为KEEPALIVE后，客户端每隔N秒(默认是7200s)会向服务器发送一个发送心跳包。但实际操作中我们更多的时是使用应用层心跳。原因如下: KEEPALIVE对服务器负载压力比较大(服务器大大是这么说的…) socks代理对KEEPALIVE并不支持 部分复杂情况下KEEPALIVE会失效，如路由器挂掉，网线(移动端没有网线…)直接被拔除 移动端在实际操作时为了节约流量和电量一般会在心跳包上做一些小优化 精简心跳包，保证一个心跳包大小在10字节之内 心跳包只在空闲时发送 根据APP前后台状态调整心跳包间隔 (主要是安卓) 消息可达在移动网络下，丢包，网络重连等情况非常之多，为了保证消息的可达，一般需要做消息回执和重发机制。参考易信，每条消息会最多会有3次重发，超时时间为15秒，同时在发送之前会检测当前连接状态，如果当前连接并没有正确建立，缓存消息且定时检查(每隔2秒检查一次，检查15次)。所以一条消息在最差的情况下会有2分钟左右的重试时间，以保证消息的可达。 因为重发的存在，接受端偶尔会收到重复消息，这种情况下就需要接收端进行去重。通用的做法是每条消息都带上自己唯一的message id(一般是uuid)。 文件上传优化IM消息(包括SNS模块)内包含大量的文件上传的需求，如何优化文件的上传就成了一个比较大的主题。常见有下面这些优化思路: 将上传流程提前:音频提供边录边传。朋友圈的图片进行预上传，选择图片后用户一般会进行文本输入，在这段时间内后台就可以默默将选好的图片进行上传。 提供闪电上传的方式:服务器根据MD5进行文件去重。 优化和上传服务器的连接(参考快速连接)，提供连接重用的功能。 文件分块上传:因为移动网络丢包严重，将文件分块上传可以使得一个分组包含合理数量的TCP包，使得重试概率下降，重试代价变小，更容易上传到服务器。 在分包的前提下支持上传的pipeline，避免不必要的网络等待时间。 支持断点续传 总结此处是软文，请全选阅读:一个大型IM系统涉及到东西实在太多，如果IM模块只是APP的附属功能，并不推荐自己去从头实现IM模块或者使用XMPP这种有天坑的开源实现，直接使用市面上的第三方SDK即可，比如我们的云信。毕竟，我们，是，专业的！~~~~]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>IM</tag>
        <tag>xmpp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何做一个圆形的音量旋钮]]></title>
    <url>%2F2016%2F01%2F17%2F%E5%A6%82%E4%BD%95%E5%81%9A%E4%B8%80%E4%B8%AA%E5%9C%86%E5%BD%A2%E7%9A%84%E9%9F%B3%E9%87%8F%E6%97%8B%E9%92%AE%2F</url>
    <content type="text"><![CDATA[最近在Medium上浏览一些国外的iOS开发相关的文章，看到感兴趣的便实践一番，记录下来。一来算是学习swift，另一方面则是为了拓宽技术面。 这篇文章来自Karthik Keyan Balan的How to create a circular seek bar in iOS主要展示了一个圆形的类似音量旋钮的UI控件，用swift实现。如下图， 如何画出圆形旋钮 使用CAShapeLayer，并将其path设置为自定义的贝塞尔曲线的path。 1234567891011121314151617181920212223lazy var seekerBarLayer = CAShapeLayer()...private func addSeekerBar() &#123; let center = CGPointMake(self.bounds.size.width/2, self.bounds.size.height/2) //弧度 let sAngle = degreeToRadian(Double(startAngle)) let eAngle = degreeToRadian(Double(endAngle)) let path = UIBezierPath(arcCenter: center, radius: (self.bounds.size.width - 18)/2, startAngle:CGFloat(sAngle) , endAngle:CGFloat(eAngle) , clockwise: true) seekerBarLayer.path = path.CGPath; seekerBarLayer.lineWidth = 4.0 seekerBarLayer.lineCap = kCALineCapRound seekerBarLayer.strokeColor = seekBarColor.CGColor seekerBarLayer.fillColor = UIColor.clearColor().CGColor if seekerBarLayer.superlayer == nil &#123; self.layer.addSublayer(seekerBarLayer) &#125; &#125; 根据touch位置移动旋钮位置 重载touch相关的三个方法，重点是在continueTrackingWithTouch方法中，根据touch的坐标计算按钮需要移动的位置的moveToPoint方法。 获取touch位置 计算旋钮对应的坐标 获取touch位置 12345678910111213141516171819202122232425262728293031//MARK: Touch Eventoverride func beginTrackingWithTouch(touch: UITouch, withEvent event: UIEvent?) -&gt; Bool &#123; let point = touch.locationInView(self) let rect = CGRectInset(self.thumbButton.frame, -20, -20) let canBegin = CGRectContainsPoint(rect, point) if canBegin &#123; UIView.animateWithDuration(0.2, delay: 0.0, options: .CurveEaseIn, animations: &#123; () -&gt; Void in self.thumbButton.transform = CGAffineTransformMakeScale(1.2, 1.2) &#125;, completion: nil) &#125; return canBegin&#125;override func continueTrackingWithTouch(touch: UITouch, withEvent event: UIEvent?) -&gt; Bool &#123; if #available(iOS 9,*)&#123; guard let coalescedTouches = event?.coalescedTouchesForTouch(touch) else&#123; return moveToPoint(touch.locationInView(self)) &#125; let result = true for cTouch in coalescedTouches&#123; let result = moveToPoint(cTouch.locationInView(self)) if result == false &#123;break&#125; &#125; return result &#125; return true&#125;override func endTrackingWithTouch(touch: UITouch?, withEvent event: UIEvent?) &#123; thumbMoveDidComplete()&#125; 计算旋钮对应的坐标 1234567891011121314151617181920212223242526272829303132func moveToPoint(point:CGPoint) -&gt;Bool&#123; var degree = degreeForLocation(point) func moveToClosestEdge(degree:Double)&#123; let startDistance = fabs(CGFloat(degree) - startAngle) let endDistance = fabs(CGFloat(degree) - endAngle) if startDistance &lt; endDistance&#123; currentAngle = startAngle &#125;else&#123; currentAngle = endAngle &#125; &#125; if startAngle &gt; endAngle &#123; if degree &lt; Double(startAngle) &amp;&amp; degree &gt; Double(endAngle)&#123; moveToClosestEdge(degree) thumbMoveDidComplete() return false &#125; &#125; else &#123; if degree &gt; Double(endAngle) || degree &lt; Double(startAngle)&#123; moveToClosestEdge(degree) thumbMoveDidComplete() return false &#125; &#125; currentAngle = CGFloat(degree) return true&#125; 手动发送action由于这个控件是继承自UIControl的，正如其他继承与UIControl的控件一样，我们可以自定义一个控件的状态事件。例如valueChanged、TouchUpInside、TouchOutSide。这里我们需要的是控件的位置信息，所以当endTouch的时候发送一个valueChanged事件：1self.sendActionsForControlEvents(.ValueChanged) 其中有一个小细节，当点击到按钮时，会有一个变大的动画效果，其实也是用到了一个基本的拉伸效果：123UIView.animateWithDuration(0.2, delay: 0.0, options: .CurveEaseIn, animations: &#123; () -&gt; Void in self.thumbButton.transform = CGAffineTransformMakeScale(1.2, 1.2) &#125;, completion: nil) 总结 利用CAShapeLayer+贝塞尔曲线画出UI。 根据角度计算弧度，并导出按钮对应的坐标点。 touch事件的处理。- 手动发送action。 参考代码：CircularSeek On GitHub]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NSURLSession初探]]></title>
    <url>%2F2016%2F01%2F10%2FNSURLSession%E5%88%9D%E6%8E%A2%2F</url>
    <content type="text"><![CDATA[NSURLSession是Apple自iOS7.0之后加入到Cocoa SDK中，用以替代NSURLConnection。它拥有更简洁易懂的API方法。iOS中常用的网络库例如AFNetworking在3.0版本中就全部替换为了NSURLSession。之前项目中一直使用的AFNetworking2.x版本，也没有花时间去仔细研究NSURLSession，特此周末粗略的看了看，一些方法也是试了试。 NSURLSession继承结构： NSURLSession - session对象。 NSURLSessionConfiguration - 当初始化session对象时设置session的配置信息。 NSURLSessoinTask - task基类 NSURLSessionDataTask - 获取url内容，返回NSData对象。 NSURLSessionUploadTask - 上传文件的task，并取回对应url内容，返回NSData对象。 NSURLSessionDownloadTask - 获取url内容，并返回一个临时文件在沙盒中（tmp目录下）。 NSURLSession也提供了四组代理方法： NSURLSessionDelegate — Defines delegate methods to handle session-level events NSURLSessionTaskDelegate — Defines delegate methods to handle task-level events common to all task types NSURLSessionDataDelegate — Defines delegate methods to handle task-level events specific to data and upload tasks NSURLSessionDownloadDelegate — Defines delegate methods to handle task-level events specific to download tasks 首先来看看普通的sessoin请求方法。在completionHandler中返回的是NSData。 123456789NSURLSession *session = [NSURLSession sharedSession];NSURLSessionDataTask * dataTask = [session dataTaskWithRequest:[NSURLRequest requestWithURL:[NSURL URLWithString:url]] completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) &#123; self.fileName = response.suggestedFilename; [self saveToFile]; [self.fileHandler seekToEndOfFile]; [self.fileHandler writeData:data]; [self.fileHandler closeFile];&#125;];[dataTask resume];//开始任务。resume有继续、恢复、重新开始的意思，当处理断点续传时就能体会到此含义了。 再来看看download task的请求方式，上面提到过，download task最后返回的是一个临时文件，所以需要我们手动将其保存到其他沙盒目录中，就需要用到NSFileManager了。123456789NSURLSessionDownloadTask * downloadTask = [session downloadTaskWithRequest:[NSURLRequest requestWithURL:[NSURL URLWithString:url]] completionHandler:^(NSURL * _Nullable location, NSURLResponse * _Nullable response, NSError * _Nullable error) &#123; self.fileName = response.suggestedFilename; NSString * directory = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) lastObject]; NSString * filePath = [directory stringByAppendingPathComponent:self.fileName]; NSFileManager * fileManager = [NSFileManager defaultManager]; [fileManager moveItemAtPath:location.path toPath:filePath error:nil];&#125;]; [downloadTask resume]; 那有时候我们想取得下载进度信息，用block方式就不行了，所以就需要用到系统提供的代理方法了。这里我们用NSURLSessionDownloadDelegate.此时session的创建方式就是另一种方式，设置delegate为self。 12345NSURLSession * session = [NSURLSession sessionWithConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration] delegate:self delegateQueue:[NSOperationQueue mainQueue]];self.downloadTask = [session downloadTaskWithRequest:[NSURLRequest requestWithURL:[NSURL URLWithString:url]]];[self.downloadTask resume]; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#pragma mark - NSURLSessionDownloadDelegate/** * 下载完毕 * * @param location 文件临时地址 */- (void)URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTaskdidFinishDownloadingToURL:(NSURL *)location&#123; NSLog(@"文件存放位置%@",location.path);// [self.startOrPauseOfSession setTitle:@"开始" forState:UIControlStateNormal]; self.fileName = @"QQ4.1.0.dmg"; NSString * directory = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) lastObject]; NSString * filePath = [directory stringByAppendingPathComponent:self.fileName]; NSFileManager * fileManager = [NSFileManager defaultManager]; [fileManager moveItemAtPath:location.path toPath:filePath error:nil];&#125;/** * 每次写入沙盒完毕 * 在这里面监听下载进度，totalBytesWritten/totalBytesExpectedToWrite * * @param bytesWritten 这次写入的大小 * @param totalBytesWritten 已经写入沙盒的大小 * @param totalBytesExpectedToWrite 文件总大小 */- (void)URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTask didWriteData:(int64_t)bytesWritten totalBytesWritten:(int64_t)totalBytesWrittentotalBytesExpectedToWrite:(int64_t)totalBytesExpectedToWrite&#123; self.progressView.progress = (double)totalBytesWritten/totalBytesExpectedToWrite; self.progressLabel.text = [NSString stringWithFormat:@"%.1f%%",(double)totalBytesWritten/totalBytesExpectedToWrite * 100];&#125;/** * 恢复下载后调用， */- (void)URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTask didResumeAtOffset:(int64_t)fileOffsetexpectedTotalBytes:(int64_t)expectedTotalBytes&#123;&#125; 12345678910#pragma mark - PrivateMethod- (void)saveToFile&#123; NSString * cacheDirectory = [NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) lastObject]; NSLog(@"%@",cacheDirectory); NSString * filePath = [cacheDirectory stringByAppendingPathComponent:self.fileName]; NSFileManager * fileManager = [NSFileManager defaultManager]; [fileManager createFileAtPath:filePath contents:nil attributes:nil]; //创建操作数据的文件handler self.fileHandler = [NSFileHandle fileHandleForWritingAtPath:filePath];&#125; 更多信息请查看NSURLSession官方文档]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>NSURLSession</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NS_ENUM与NSString]]></title>
    <url>%2F2016%2F01%2F07%2FNS-ENUM%E4%B8%8ENSString%2F</url>
    <content type="text"><![CDATA[NS_ENUM与NSString 在项目中经常会使用到枚举类型：NS_ENUM,enum,但是系统提供的枚举类型只能设置为NSInteger类型，不能保存对象类型入NSString。传统的用#define 方式，Switch case 转换方式，另外还发现了如下几种方式： 12typedef enum &#123;value1, value2, value3&#125; myValue;#define myValueString(enum) [@[@"value1",@"value2",@"value3"] objectAtIndex:enum] 12345678910111213141516171819202122typedef enum &#123; a, b, c &#125; FirstThreeAlpha;- (NSString*) convertToString:(FirstThreeAlpha) whichAlpha &#123; NSString *result = nil; switch(whichAlpha) &#123; case a: result = @"a"; break; case b: result = @"b"; break; case c: result = @"c"; break; default: result = @"unknown"; &#125; return result;&#125; 12345678910111213typedef NS_ENUM(NSInteger,CabinetOperationType)&#123; CabinetOperationTypeNothing = 0, CabinetOperationTypeAdd = 1, //加入酒柜 CabinetOperationTypeTake = 2, //从酒柜提酒 CabinetOperationTypeAddAndSend = 3 //加入酒柜付款并直接赠予某人 &#125;;NSString *const CabinetOperationTypeString[] = &#123; [CabinetOperationTypeNothing] = @"", [CabinetOperationTypeAdd] = @"1", [CabinetOperationTypeTake] = @"2", [CabinetOperationTypeAddAndSend] = @"3"&#125;; 此法和上面的定义NSString数组相似，但是是用了函数思想。123456789101112131415161718192021222324typedef enum &#123; UIImageOrientationUp = 0, // default orientation, set to 0 so that it always starts from 0 UIImageOrientationDown, // 180 deg rotation UIImageOrientationLeft, // 90 deg CCW UIImageOrientationRight, // 90 deg CW UIImageOrientationUpMirrored, // as above but image mirrored along other axis. horizontal flip UIImageOrientationDownMirrored, // horizontal flip UIImageOrientationLeftMirrored, // vertical flip UIImageOrientationRightMirrored, // vertical flip&#125; UIImageOrientation;NSString *stringWithUIImageOrientation(UIImageOrientation input) &#123; NSArray *arr = @[ @"UIImageOrientationUp", // default orientation @"UIImageOrientationDown", // 180 deg rotation @"UIImageOrientationLeft", // 90 deg CCW @"UIImageOrientationRight", // 90 deg CW @"UIImageOrientationUpMirrored", // as above but image mirrored along other axis. horizontal flip @"UIImageOrientationDownMirrored", // horizontal flip @"UIImageOrientationLeftMirrored", // vertical flip @"UIImageOrientationRightMirrored", // vertical flip ]; return (NSString *)[arr objectAtIndex:input];&#125; 综合众多方案得出，要熟练使用typedef、#define 就可以提高效率。更多可以参考stackoverflow：enum Values to NSString (iOS)]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>NS_ENUM</tag>
        <tag>NSString</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何在swift项目中创建Objective-C Bridging header]]></title>
    <url>%2F2015%2F12%2F30%2F%E5%A6%82%E4%BD%95%E5%9C%A8swift%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%88%9B%E5%BB%BAObjective-C-Bridging-header%2F</url>
    <content type="text"><![CDATA[在swift工程中，有时候我们也需要使用OBJC代码写的第三方库或者工具类等，这时就需要创建objc文件到swift的桥接header。现在有两种方法创建Objective-C Bridging Header: Create Objective-C File as HeaderGo to File &gt; New &gt; File and Select Objective-C: 然后一直next，最后出现如下图时，点击yes： 这种方式会创建出.h和.m文件。 Create Objective-C Header File DirectlyGo to File &gt; New &gt; File and Select Objective-C Header File: 最后，两种方法创建的.h文件中import你将使用的类。1#import "xxxx" 一般在项目中我们使用第二种方法。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>swift</tag>
        <tag>Objc Bridging Header</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[修改UIBarButtonItem标题文字大小、颜色、阴影等]]></title>
    <url>%2F2015%2F12%2F29%2F%E4%BF%AE%E6%94%B9UIBarButtonItem%E6%A0%87%E9%A2%98%E6%96%87%E5%AD%97%E5%A4%A7%E5%B0%8F%E3%80%81%E9%A2%9C%E8%89%B2%E3%80%81%E9%98%B4%E5%BD%B1%E7%AD%89%2F</url>
    <content type="text"><![CDATA[修改UIBarButtonItem的标题文字大小、颜色、阴影等有时候我们需要设置一下导航栏右侧按钮标题的大小、颜色等等，但是UIBarButtonItem没有直接提供相关方法。通过查看UIbarButtonItem官方文档，总结出有以下两种方法第一种：使用initWithCustomView方法创建UIBarButtonItem。第二种：通过KVC来修改相关属性。 那么先看看第一种方法：1234567891011UIButton * edit = [UIButton buttonWithType:UIButtonTypeCustom];edit.frame = CGRectMake(0, 0, 80, 30);[edit setTitle:@"批量管理" forState:UIControlStateNormal];[edit setTitleColor:[UIColor blackColor] forState:UIControlStateNormal];[edit addTarget:self action:@selector(edit) forControlEvents:UIControlEventTouchUpInside];edit.titleLabel.font = [UIFont systemFontOfSize:13];edit.titleLabel.textAlignment = NSTextAlignmentRight;UIBarButtonItem * rightBtn = [[UIBarButtonItem alloc]initWithCustomView:edit];[rightBtn setTintColor:COLOR(black)];self.navigationItem.rightBarButtonItem = rightBtn; 这种方法比较简便，能够快速理解。 第二种方法：12345678UIBarButtonItem * submitComment = [[UIBarButtonItem alloc] initWithTitle:@"提交评价" style:UIBarButtonItemStylePlain target:self action:@selector(submitComment:)];submitComment.tintColor = [UIColor darkGrayColor];[[UIBarButtonItem appearance] setTitleTextAttributes: [NSDictionary dictionaryWithObjectsAndKeys:[UIFont boldSystemFontOfSize:15], NSFontAttributeName, nil] forState:UIControlStateNormal]; Also,可以使用如下方法：1234[[UIBarButtonItem appearanceWhenContainedIn:[UINavigationController class], nil] setTitleTextAttributes:[NSDictionary dictionaryWithObjectsAndKeys: [UIFont boldSystemFontOfSize:15], NSFontAttributeName, nil] forState:UIControlStateNormal]; 其中对于这些key需要看一下，常用的几个key已经被NSFontAttributeName, NSForegroundColorAttributeName, NSShadowAttributeName代替:123456789101112/* Keys for text attributes dictionaries. These keys are superseded by the corresponding attribute name keys (NSFontAttributeName, NSForegroundColorAttributeName, NSShadowAttributeName) in NSAttributedString.h. */// Key to the font in the text attributes dictionary. A UIFont instance is expected. Use a font with size 0.0 to get the default font size for the situation.UIKIT_EXTERN NSString *const UITextAttributeFont NS_DEPRECATED_IOS(5_0, 7_0, "Use NSFontAttributeName") __TVOS_PROHIBITED;// Key to the text color in the text attributes dictionary. A UIColor instance is expected.UIKIT_EXTERN NSString *const UITextAttributeTextColor NS_DEPRECATED_IOS(5_0, 7_0, "Use NSForegroundColorAttributeName") __TVOS_PROHIBITED;// Key to the text shadow color in the text attributes dictionary. A UIColor instance is expected.UIKIT_EXTERN NSString *const UITextAttributeTextShadowColor NS_DEPRECATED_IOS(5_0, 7_0, "Use NSShadowAttributeName with an NSShadow instance as the value") __TVOS_PROHIBITED;// Key to the offset used for the text shadow in the text attributes dictionary. An NSValue instance wrapping a UIOffset struct is expected.UIKIT_EXTERN NSString *const UITextAttributeTextShadowOffset NS_DEPRECATED_IOS(5_0, 7_0, "Use NSShadowAttributeName with an NSShadow instance as the value") __TVOS_PROHIBITED; 12345678910111213141516171819202122232425262728/************************ Attributes ************************/// Predefined character attributes for text. If the key is not in the dictionary, then use the default values as described below.UIKIT_EXTERN NSString * const NSFontAttributeName NS_AVAILABLE(10_0, 6_0); // UIFont, default Helvetica(Neue) 12UIKIT_EXTERN NSString * const NSParagraphStyleAttributeName NS_AVAILABLE(10_0, 6_0); // NSParagraphStyle, default defaultParagraphStyleUIKIT_EXTERN NSString * const NSForegroundColorAttributeName NS_AVAILABLE(10_0, 6_0); // UIColor, default blackColorUIKIT_EXTERN NSString * const NSBackgroundColorAttributeName NS_AVAILABLE(10_0, 6_0); // UIColor, default nil: no backgroundUIKIT_EXTERN NSString * const NSLigatureAttributeName NS_AVAILABLE(10_0, 6_0); // NSNumber containing integer, default 1: default ligatures, 0: no ligaturesUIKIT_EXTERN NSString * const NSKernAttributeName NS_AVAILABLE(10_0, 6_0); // NSNumber containing floating point value, in points; amount to modify default kerning. 0 means kerning is disabled.UIKIT_EXTERN NSString * const NSStrikethroughStyleAttributeName NS_AVAILABLE(10_0, 6_0); // NSNumber containing integer, default 0: no strikethroughUIKIT_EXTERN NSString * const NSUnderlineStyleAttributeName NS_AVAILABLE(10_0, 6_0); // NSNumber containing integer, default 0: no underlineUIKIT_EXTERN NSString * const NSStrokeColorAttributeName NS_AVAILABLE(10_0, 6_0); // UIColor, default nil: same as foreground colorUIKIT_EXTERN NSString * const NSStrokeWidthAttributeName NS_AVAILABLE(10_0, 6_0); // NSNumber containing floating point value, in percent of font point size, default 0: no stroke; positive for stroke alone, negative for stroke and fill (a typical value for outlined text would be 3.0)UIKIT_EXTERN NSString * const NSShadowAttributeName NS_AVAILABLE(10_0, 6_0); // NSShadow, default nil: no shadowUIKIT_EXTERN NSString *const NSTextEffectAttributeName NS_AVAILABLE(10_10, 7_0); // NSString, default nil: no text effectUIKIT_EXTERN NSString * const NSAttachmentAttributeName NS_AVAILABLE(10_0, 7_0); // NSTextAttachment, default nilUIKIT_EXTERN NSString * const NSLinkAttributeName NS_AVAILABLE(10_0, 7_0); // NSURL (preferred) or NSStringUIKIT_EXTERN NSString * const NSBaselineOffsetAttributeName NS_AVAILABLE(10_0, 7_0); // NSNumber containing floating point value, in points; offset from baseline, default 0UIKIT_EXTERN NSString * const NSUnderlineColorAttributeName NS_AVAILABLE(10_0, 7_0); // UIColor, default nil: same as foreground colorUIKIT_EXTERN NSString * const NSStrikethroughColorAttributeName NS_AVAILABLE(10_0, 7_0); // UIColor, default nil: same as foreground colorUIKIT_EXTERN NSString * const NSObliquenessAttributeName NS_AVAILABLE(10_0, 7_0); // NSNumber containing floating point value; skew to be applied to glyphs, default 0: no skewUIKIT_EXTERN NSString * const NSExpansionAttributeName NS_AVAILABLE(10_0, 7_0); // NSNumber containing floating point value; log of expansion factor to be applied to glyphs, default 0: no expansionUIKIT_EXTERN NSString * const NSWritingDirectionAttributeName NS_AVAILABLE(10_6, 7_0); // NSArray of NSNumbers representing the nested levels of writing direction overrides as defined by Unicode LRE, RLE, LRO, and RLO characters. The control characters can be obtained by masking NSWritingDirection and NSTextWritingDirection values. LRE: NSWritingDirectionLeftToRight|NSWritingDirectionEmbedding, RLE: NSWritingDirectionRightToLeft|NSWritingDirectionEmbedding, LRO: NSWritingDirectionLeftToRight|NSWritingDirectionOverride, RLO: NSWritingDirectionRightToLeft|NSWritingDirectionOverride,UIKIT_EXTERN NSString * const NSVerticalGlyphFormAttributeName NS_AVAILABLE(10_7, 6_0); // An NSNumber containing an integer value. 0 means horizontal text. 1 indicates vertical text. If not specified, it could follow higher-level vertical orientation settings. Currently on iOS, it's always horizontal. The behavior for any other value is undefined.]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>UIBarButtonItem</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Block实现原理]]></title>
    <url>%2F2015%2F12%2F16%2FBlock%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[Block一直是iOS开发中常用的技巧，类似于C语言中的指针函数。多用于参数回调，异步加载等。下面就来探究以下block是如何实现的。这篇是记录根据网上的文章进行的实际操作。C函数的生成中间编译代码的编译方法是clang -rewrite-objc xxxx.c。由于编译文件中内容较多，这里我们只截取有关block的部分。 首先，看看没有block的C函数以及编译后的结果：12345#include &lt;stdio.h&gt;int main()&#123; return 0;&#125; 编译代码中的block：这里我们可以看到一个block的C实现。12345678#ifndef BLOCK_IMPL#define BLOCK_IMPLstruct __block_impl &#123; void *isa; int Flags; int Reserved; void *FuncPtr;&#125;; *isa说明block也可以作为对象使用（例如我们定义一个myBlock类型的block1），指针变量FunPtr应该就是指向了block代码块的函数首地址接着我们加一个block到.c文件中，并进行编译。12345678910111213#include &lt;stdio.h&gt;int main()&#123;int i = 10;void(^myBlock)(void) = ^(void)&#123; printf("hello world! %d\n",i);&#125;;myBlock();return 0;&#125; 编译后：12345678910111213141516171819202122232425262728293031struct __main_block_impl_0 &#123; struct __block_impl impl; struct __main_block_desc_0* Desc; int i; __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int _i, int flags=0) : i(_i) &#123; impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; &#125;&#125;;static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123; int i = __cself-&gt;i; // bound by copy printf("hello world! %d\n",i); &#125;static struct __main_block_desc_0 &#123; size_t reserved; size_t Block_size;&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0)&#125;;int main()&#123; int i = 10; void(*myBlock)(void) = (void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, i); ((void (*)(__block_impl *))((__block_impl *)myBlock)-&gt;FuncPtr)((__block_impl *)myBlock); return 0;&#125; 3.假如我们要修改函数中局部变量的值，则需要加上__block修饰符，后面我们来看看为什么这样才可以修改。1234567891011121314#include &lt;stdio.h&gt;int main()&#123;__block int i = 10;void(^myBlock)(void) = ^(void)&#123;i = 12; printf("hello world! %d\n",i);&#125;;myBlock();return 0;&#125; 编译后的cpp代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445struct __Block_byref_i_0 &#123; void *__isa;__Block_byref_i_0 *__forwarding; int __flags; int __size; int i;&#125;;struct __main_block_impl_0 &#123; struct __block_impl impl; struct __main_block_desc_0* Desc; __Block_byref_i_0 *i; // by ref __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, __Block_byref_i_0 *_i, int flags=0) : i(_i-&gt;__forwarding) &#123; impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; &#125;&#125;;static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123; __Block_byref_i_0 *i = __cself-&gt;i; // bound by ref (i-&gt;__forwarding-&gt;i) = 12; printf("hello world! %d\n",(i-&gt;__forwarding-&gt;i)); &#125;static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) &#123;_Block_object_assign((void*)&amp;dst-&gt;i, (void*)src-&gt;i, 8/*BLOCK_FIELD_IS_BYREF*/);&#125;static void __main_block_dispose_0(struct __main_block_impl_0*src) &#123;_Block_object_dispose((void*)src-&gt;i, 8/*BLOCK_FIELD_IS_BYREF*/);&#125;static struct __main_block_desc_0 &#123; size_t reserved; size_t Block_size; void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*); void (*dispose)(struct __main_block_impl_0*);&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0&#125;;int main()&#123; __attribute__((__blocks__(byref))) __Block_byref_i_0 i = &#123;(void*)0,(__Block_byref_i_0 *)&amp;i, 0, sizeof(__Block_byref_i_0), 10&#125;; void(*myBlock)(void) = (void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, (__Block_byref_i_0 *)&amp;i, 570425344); ((void (*)(__block_impl *))((__block_impl *)myBlock)-&gt;FuncPtr)((__block_impl *)myBlock); return 0;&#125;]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>block</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TableViewCell根据内容自适应高度的方法]]></title>
    <url>%2F2015%2F12%2F16%2FTableViewCell%E6%A0%B9%E6%8D%AE%E5%86%85%E5%AE%B9%E8%87%AA%E9%80%82%E5%BA%94%E9%AB%98%E5%BA%A6%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[本文同时参考 http://blog.sunnyxx.com/2015/05/17/cell-height-calculation/ 一：根据cell内容手动计算cell高度 无论使用xib还是代码写控件，核心思想都是根据cell中content内容的高度来计算cell的高度。1.在获取到cell数据源的时候计算内容高度。可以设置一个size属性，用来记录。2.如果是xib，去掉autolayout3.在cellForRowAtIndexPath方法中填充cell数据的时候，根据内容高度，设置控件高度4.在heightForRowAtIndexpath方法中，设置每一个cell 的高度 二：Self sizing cell + autolayout Self sizing cell 是iOS8中添加一个新特性，用来自适应cell高度。同时打开以下参数：12self.tableView.estimatedRowHeight = 213;//添加估算高度，要不然自动算高失效？self.tableView.rowHeight = UITableViewAutomaticDimension; 三：UITableView+FDTemplateLayoutCell 使用的API:12345678#import &lt;UITableView+FDTemplateLayoutCell.h&gt; - (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath &#123; return [tableView fd_heightForCellWithIdentifier:@"identifer" cacheByIndexPath:indexPath configuration:^(id cell) &#123; // 配置 cell 的数据源，和 "cellForRow" 干的事一致，比如： cell.entity = self.feedEntities[indexPath.row]; &#125;]; &#125; https://github.com/forkingdog/UITableView-FDTemplateLayoutCell 下面给出第一种手动计算高度的代码思路：详细步骤： 12345678HLComment *comment = [HLComment new]; comment.floor = obj[@"floor"]; comment.commentId = obj[@"id"]; comment.content = obj[@"content"]; //计算content内容高度12345 NSDictionary *atrri = @&#123;NSFontAttributeName: [UIFont systemFontOfSize:15]&#125;; CGRect rect = [comment.content boundingRectWithSize:CGSizeMake(220, 1000) options:NSStringDrawingUsesLineFragmentOrigin attributes:atrri context:nil];comment.size = rect.size;//保存这个高度 //填充cell内容时，根据content高度来设置label高度12345678910111213- (void)fillCellWithModel:(HLItem *)item&#123; …. CGRect frame = _content.frame;//_content 是内容label frame.size = item.size; _content.frame = frame; …..&#125; 另外在heightForRowAtIndexPath 中添加一定的余量。123456789101112131415161718//自适应cell高度- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath&#123; //NSLog(@"计算cell高度");; if (indexPath.row == 0) &#123; return self.item.size.height+140; &#125; HLComment *item = _dataSource[indexPath.row-1]; return item.size.height+60;&#125;]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>tableViewCell</tag>
        <tag>cell高度</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理解Objective-C中的消息发送]]></title>
    <url>%2F2015%2F12%2F16%2F%E7%90%86%E8%A7%A3Objective-C%E4%B8%AD%E7%9A%84%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81%2F</url>
    <content type="text"><![CDATA[消息发送首先来看看怎么理解发送消息的含义：面对着 Cocoa 中大量 API，只知道简单的查文档和调用。还记得初学 Objective-C 时把[receiver message]当成简单的方法调用，而无视了“发送消息”这句话的深刻含义。于是[receiver message]会被编译器转化为： objc_msgSend(receiver, selector)如果消息含有参数，则为： objc_msgSend(receiver, selector, arg1, arg2, ...)如果消息的接收者能够找到对应的selector，那么就相当于直接执行了接收者这个对象的特定方法；否则，消息要么被转发，或是临时向接收者动态添加这个selector对应的实现内容，要么就干脆玩完崩溃掉。现在可以看出[receiver message]真的不是一个简简单单的方法调用。因为这只是在编译阶段确定了要向接收者发送message这条消息，而receive将要如何响应这条消息，那就要看运行时发生的情况来决定了。Objective-C 的 Runtime 铸就了它动态语言的特性，这些深层次的知识虽然平时写代码用的少一些，但是却是每个 Objc 程序员需要了解的。Objc Runtime使得C具有了面向对象能力，在程序运行时创建，检查，修改类、对象和它们的方法。可以使用runtime的一系列方法实现。C语言中的动态方法由于Objective-C是C语言的超集，所以最好先理解C语言的函数调用方式。C语言使用“静态绑定（static binding）”，也就是说，在编译器就能决定运行时所应调用的函数。示例代码：123456789101112131415161718#import &lt;stdio.h&gt;void printHello() &#123; printf("Hello,world\n");&#125;void printGoodBye() &#123; printf("GoodBye,world\n");&#125;void doThings(int type) &#123; if(type == 0)&#123; printHello(); &#125;else&#123; printGoodBye(); &#125; return 0;&#125;编译器在编译代码的时候就知道程序中有printHello,printGoodBye两个函数了，函数地址也硬编码在指令之中。1234567891011121314151617181920#import &lt;stdio.h&gt;void printHello() &#123; printf("Hello,world\n");&#125;void printGoodBye() &#123; printf("GoodBye,world\n");&#125;void doThings(int type) &#123; void (*func)(); if(type == 0)&#123; func = printHello; &#125;else&#123; func = printGoodBye; &#125; func(); return 0;&#125;这样就是动态绑定（dynamic binding）了，因为索要调用的函数直到运行期才能确定。顺便附上OC中一个类的底层数据结构mac电脑上的路径/usr/include/objc/runtime.h12345678910111213141516 struct objc_class &#123; Class isa OBJC_ISA_AVAILABILITY; //isa指针指向Meta Class，因为Objc的类的本身也是一个Object，为了处理这个关系，r untime就创造了Meta Class，当给类发送[NSObject alloc]这样消息时，实际上是把这个消息发给了Class Object #if !__OBJC2__ Class super_class OBJC2_UNAVAILABLE; // 父类 const char *name OBJC2_UNAVAILABLE; // 类名 long version OBJC2_UNAVAILABLE; // 类的版本信息，默认为0 long info OBJC2_UNAVAILABLE; // 类信息，供运行期使用的一些位标识 long instance_size OBJC2_UNAVAILABLE; // 该类的实例变量大小 struct objc_ivar_list *ivars OBJC2_UNAVAILABLE; // 该类的成员变量链表 struct objc_method_list **methodLists OBJC2_UNAVAILABLE; // 方法定义的链表 struct objc_cache *cache OBJC2_UNAVAILABLE; // 方法缓存，对象接到一个消息会根据isa指针查找消息对象，这时会在method Lists中遍历，如果cache了，常用的方法调用时就能够提高调用的效率。 struct objc_protocol_list *protocols OBJC2_UNAVAILABLE; // 协议链表 #endif&#125; OBJC2_UNAVAILABLE;OC中一个类的对象实例的数据结构（/usr/include/objc/objc.h），就是定义了一个12345678910111213typedef struct objc_class *Class;/// Represents an instance of a class.struct objc_object &#123; Class isa OBJC_ISA_AVAILABILITY;&#125;;/// A pointer to an instance of a class.typedef struct objc_object *id;向object发送消息时，Runtime库会根据object的isa指针找到这个实例object所属于的类，然后在类的方法列表以及父类方法列表寻找对应的方法运行。id是一个objc_object结构类型的指针，这个类型的对象能够转换成任何一种对象。然后再来看看消息发送的函数：objc_msgSend函数在引言中已经对objc_msgSend进行了一点介绍，看起来像是objc_msgSend返回了数据，其实objc_msgSend从不返回数据而是你的方法被调用后返回了数据。下面详细叙述下消息发送步骤：1.检测这个 selector 是不是要忽略的。比如 Mac OS X 开发，有了垃圾回收就不理会 retain,release 这些函数了。2.检测这个 target 是不是 nil 对象。ObjC 的特性是允许对一个 nil 对象执行任何一个方法不会 Crash，因为会被忽略掉。3.如果上面两个都过了，那就开始查找这个类的 IMP，先从 cache 里面找，完了 找得到就跳到对应的函数去执行。4.如果 cache 找不到就找一下方法分发表。5.如果分发表找不到就到超类的分发表去找，一直找，直到找到NSObject类为止。6.如果还找不到就要开始进入动态方法解析了，后面会提到。这么一想，调用一个方法似乎需要很多步骤。不过objc_msgSend会将匹配结果缓存在fast map快速映射表里面，每个类都有这样一块缓存。当然这种fast path 还是不如静态绑定的函数调用那样迅速，不过只要把Selector缓存起来，也就不会慢很多，实际上，这并不是瓶颈。消息转发机制 当一个对象接收到无法解读的消息时，就会启动消息转发（message forwording）机制。coder可经由此过程告诉对象应该如何处理位置消息。例如给某一个对象实例发送了一个该对象不存在的方法，最后就会crash掉。-[NSCFDictionary indexOfObject:]: unrecognized selector sent to instance 0x10773929356消息转发分为两大阶段。 第一阶段先询问接受对象所属的类是否能够动态添加方法，以处理这个unknown selector，这叫做动态方法解析（dynamic method resolution）. 第二阶段设计完整的消息转发机制（full forwording mechanism）。如果在运行期，系统已经把第一阶段执行完了，那么接受者自己就无法再以动态添加方法的方式来响应包含该unknown selector的消息了。此时，运行期系统会请求接受者以其他手段来处理与消息相关的方法调用。这里又分为两小步： 2.1 首先，接受者查看是否有其他对象能处理这条消息，若有，则运行时系统会将消息转给那个对象，一切如常。 2.2 若没有可替代的接受者（replacement receiver），则启动完整的消息转发机制，运行时系统会把与消息有关的全部细节都封装到NSInvocation对象中，再给接受者最后一次机会，令其设法解决当前还未处理的消息。 a.动态方法解析12+ (Bool)resolveInstanceMethod:(SEL)Selector+ (Bool)resolveClassMethod:(SEL)Selector b.消息转发给可替代接受者，尝试找到一个能响应该消息的对象（replacement receiver）1- (id)forwardingTargetForSelector:(SEL)Selector c.下一步，构造NSInvocation对象1234//尝试获得一个方法签名- (id)methodSignatureForSelector:(SEL)selector //将上一步获取到的方法签名包装成 Invocation 传入，如何处理就在这里面了，并返回非ni- (id)forwardInvocation:(NSInvocation *)invocation 总结 消息由接受者、选择器及参数构成。给某对象发送消息（invoke a message），也就相当于在该对象上调用方法（calla method） 发给某对象的全部消息都要有动态消息派发系统（dynamic message dispatch system）来处理，该系统会查出对应的方法，并执行其代码。 若对象无法响应某个选择器中的消息，则进入消息转发过程。 通过运行期的动态方法解析机制，我们可以在需要用到某个方法时再将其加入类中。 对象可以把其无法解读的消息转交给其他对象来处理。 若经过上述两步还是没办法处理消息，则启动完整的消息转发机制。 详情可参考 Objective-C Runtime]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Runtime</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于CoreData和SQLite多线程访问时的线程安全问题]]></title>
    <url>%2F2015%2F12%2F14%2F%E5%85%B3%E4%BA%8ECoreData%E5%92%8CSQLite%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AE%BF%E9%97%AE%E6%97%B6%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[数据库读取操作一般都是多线程访问的。在对数据进行读取时，我们要保证其当前状态不能被修改，即读取时加锁，否则就会出现数据错误混乱。IOS中常用的两种数据持久化存储方式：CoreData和SQLite，两者都需要设置线程安全，在这里以FMDB来解释对SQLite的线程安全访问。 一:FMDB的线程安全：（以读取图片为例） 1.没有线程安全的执行方式：123456789101112131415161718192021222324252627282930313233343536373839404142434445//************** 数据库保存图片 ******************// FMDatabase *database = [FMDatabase databaseWithPath:[self getDatabasePath]]; //打开数据库 [database open]; NSString *sql = @"create table if not exists Test (id integer primary key autoincrement,name text,image blob);"; //创建表 [database executeUpdate:sql]; //把UIImage对象转化为NSData NSData *data = UIImagePNGRepresentation([UIImage imageNamed:@"user_browse"]); //写入数据 sql = @"insert into Test (name,image) values (?,?)"; [database executeUpdate:sql,@"张三",data]; //读取显示 sql = @"select * from Test;"; FMResultSet *resultSet = [database executeQuery:sql]; while (resultSet.next) &#123; //[resultSet dataForColumn:@"image"]; NSData *imageData = [resultSet dataForColumnIndex:2]; UIImageView *imageView = [[UIImageView alloc] initWithFrame:CGRectMake(0, 0, 300, 300)]; imageView.image = [UIImage imageWithData:imageData]; [self.view addSubview:imageView]; &#125;2，使用线程队列1234567891011121314151617181920212223242526272829303132333435363738394041424344//************** 数据库线程安全 ***********// FMDatabaseQueue *queue = [[FMDatabaseQueue alloc] initWithPath:[self getDatabasePath]]; [queue inDatabase:^(FMDatabase *db) &#123; //线程安全的 __block NSString *sql = @"create table if not exists Test (id integer primary key autoincrement,name text,image blob);"; //创建表 [database executeUpdate:sql]; &#125;]; //插入数据 [queue inDatabase:^(FMDatabase *db) &#123; //写入数据 sql = @"insert into Test (name,image) values (?,?)"; [database executeUpdate:sql,@"张三",data]; &#125;]; //读取 [queue inDatabase:^(FMDatabase *db) &#123; //读取显示 sql = @"select * from Test;"; FMResultSet *resultSet = [database executeQuery:sql]; while (resultSet.next) &#123; //[resultSet dataForColumn:@"image"]; NSData *imageData = [resultSet dataForColumnIndex:2]; UIImageView *imageView = [[UIImageView alloc] initWithFrame:CGRectMake(0, 0, 300, 300)]; imageView.image = [UIImage imageWithData:imageData]; [self.view addSubview:imageView]; &#125; &#125;]; 分析一下线程安全下的FMDB的实现：在当使用FMDBDatabaseQueue创建数据库时，会使用GCD创建一个线程队列：12345。。。 _queue = dispatch_queue_create([[NSString stringWithFormat:@"fmdb.%@", self] UTF8String], NULL); dispatch_queue_set_specific(_queue, kDispatchQueueSpecificKey, (__bridge void *)self, NULL); _openFlags = openFlags;。。。 然后在读取时调用[queue inDatabase:^(FMDatabase *db)方法，在block中会锁定当前数据库12345dispatch_sync(_queue, ^() &#123; FMDatabase *db = [self database]; block(db); ……&#125; 我们可以看到实际上这里是对整个数据库进行加锁，以此来保证线程安全的。 二、CoreData的线程安全 1.没有线程安全的coredata数据读取： NSManagedObjectContext对象的创建：_managedObjectContext = [[NSManagedObjectContext alloc] init]; 插入数据操作：（AppDetailModal为数据模型） context 为返回的 _managedObjectContext1AppDetailModal *newapp = [NSEntityDescription insertNewObjectForEntityForName:TableName inManagedObjectContext:context]; 其他查询、更新、删除操作//获取Entity1NSEntityDescription *entity = [NSEntityDescription entityForName:TableName inManagedObjectContext:context]; 2.线程安全的coreData操作： 首先创建并行的NSManagedObjectContext对象1NSManagedObjectContext* context=[[NSManagedObjectContext alloc] initWithConcurrencyType:NSPrivateQueueConcurrencyType]; 然后在执行读取操作时使用一下两个方法： -(void)performBlock:(void (^)(void))block -(void)performBlockAndWait:(void (^)(void))block 12345[context performBlock:^&#123; //要执行的读取操作 &#125;];]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>CoreData</tag>
        <tag>SQLite</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《iOS开发进阶》阅读笔记（二）——开发技巧]]></title>
    <url>%2F2015%2F12%2F13%2F%E3%80%8AiOS%E5%BC%80%E5%8F%91%E8%BF%9B%E9%98%B6%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[收起键盘 在UIViewController中收起键盘，处了调用相应控件的resignFirstResponder方法外，还有另外三种方法： 重载UIViewController的touchBegin方法，然后在里面执行[self.view endEditing:YES];,这样单击UIViewController的任意地方，就可以收起键盘； 直接执行[[UIApplicatoin sharedApplication] sendAction:@selector(resignFirstResponder) to:nil from:nil forEvent:nil];,用于在获得当前UIViewController比较困难的时候使用。 直接执行[[[UIApplicatoin sharedApplication] keyWindow] endEditing:YES];。 NSJSONSerialization比NSKeyedArchiver更好 在选择持久化方案时，系统提供的NSJSONSerialization比NSKeyedArchiver在效率和体积上都更优，更详细的测试参考：https://github.com/randomsequence/NSSerialisationTests; 设置应用内的系统控件语言 在工程的info.plist文件中增加如下内容：12345&lt;key&gt;CFBundleLocalizations&lt;/key&gt;&lt;array&gt; &lt;string&gt;zh_CN&lt;/string&gt; &lt;string&gt;en&lt;/string&gt;&lt;/array&gt; 巧用系统的截屏功能 iOS7以后，apple提供的系统的截屏API：- (UIView *)snapshotViewAfterScreenUpdates:(BOOL)afterUpdates来实现截屏功能。而对于iOS7以前的系统，可以用过代码来实现截屏功能： 123456789+ (UIImage *)captureImageFromView:(UIView *)view&#123; CGRect screenRect = [view bounds]; UIGraphicsBeginImageContext(screenRect.size); CGContextRef ctx = UIGraphicsGetCurrentContext(); [view.layer renderInContext:ctx]; UIImage *image = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); return image;&#125; Javascript文件设置调整 Javascript的js后缀的文件默认被拖动到工程中后，是在编译列表中，而不是资源列表中。需要手动调整期位置，否则它就不能打包到ipa文件中。 注：xcode7已经修改此问题，如下图： 忽略编译警告 在Build Phase中对应的文件中添加 -w参数。 定制NSLog12345#ifdef DEBUG#define NSLog(args,...) NSLog(@"-%d%s:%@",__LINE__,__FUNCTION__,[NSString stringWithFormat:(args), ##__VA_ARGS__])#else#define NSLog(...)#endif 导航栏上的一些设置1234567去掉导航栏阴影黑线。setBackGroundImage中也可以直接使用[UIImage new]UINavigationBar *navBar = self.navigationController.navigationBar;[navBar setBackgroundImage:[UIImage imageNamed:@&quot;white_backgroud&quot;] forBarPosition:UIBarPositionAny barMetrics:UIBarMetricsDefault];[navBar setShadowImage:[UIImage new]];去掉searchBar的阴影[self.searchBar setBackgroundImage:[UIImage new]];]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>《iOS开发进阶》阅读笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《iOS开发进阶》阅读笔记（一）内存管理释疑]]></title>
    <url>%2F2015%2F12%2F12%2F%E3%80%8AiOS%E5%BC%80%E5%8F%91%E8%BF%9B%E9%98%B6%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E9%87%8A%E7%96%91%2F</url>
    <content type="text"><![CDATA[ARC ARC能够解决iOS开发中90%的内存管理问题，但是另外还有10%的内存管理是需要手动管理的，主要就是与底层Core Foundation对象交互的部分，因为底层Core Foundation对象由于不在ARC的管理下。 使用ARC需要额外注意的两个问题： 1.过度使用block产生的循环引用问题。 2.底层Core Foundation对象需要手动进行内存管理。 Core Foundation对象的内存管理 底层的Core Foundation对象的创建，大多数以XxxCreateWithXxx这样的方式创建，例如： 12//创建一个CFStringRef对象 CFStringRef str = CFStringCreateWithCString(kCFAllocatorDefault,"hello world",kCFStringEncodingUTF8); 或者123456789//设置字间距+ (NSAttributedString *)setLabelAttributeString:(NSString*)labelText withCharactorSpace:(CGFloat)charactorSpace&#123; NSMutableAttributedString * string =[[NSMutableAttributedString alloc]initWithString:labelText]; long number = charactorSpace; CFNumberRef num = CFNumberCreate(kCFAllocatorDefault,kCFNumberSInt8Type,&amp;number); [string addAttribute:(id)kCTKernAttributeName value:(__bridge id)num range:NSMakeRange(0,[string length])]; CFRelease(num); return string;&#125; 对于这种对象的修改和释放，需要相应的使用CFRetain和CFRelease。除此之外，还有另外一个问题需要解决。在ARC下，我们有时需要将一个Core Foundation对象转换成Objective-C对象，这个时候我们需要告诉编译器，转换过程中的引用计数如何调整。这就引入了与bridge相关的关键字： __bridge:只做类型转换，不修改相关对象的引用计数，原来的Core Foundation对象在不用时，需要调用CFRelease方法。 __bridge_retained:类型转换后，将相关对象的引用计数+1，原来的Core Foundation对象在不用时，需要调用CFRelease方法。 __bridge_transfer:类型转换后，将该对象的引用计数交给ARC管理，Core Foundation对象在不用时，不再需要调用CFRelease方法。 我们根据业务逻辑，合理使用上面三种转换关键字，就可以解决Core Foundation对象与Objc对象相互转换的问题了。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>《iOS开发进阶》阅读笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS中处理四舍五入的问题]]></title>
    <url>%2F2015%2F12%2F05%2FiOS%E4%B8%AD%E5%A4%84%E7%90%86%E5%9B%9B%E8%88%8D%E4%BA%94%E5%85%A5%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[处理四舍五入主要使用下面这个方法：12345678910-(NSString *)notRounding:(float)price afterPoint:(int)position&#123; NSDecimalNumberHandler* roundingBehavior = [NSDecimalNumberHandler decimalNumberHandlerWithRoundingMode:NSRoundDown scale:position raiseOnExactness:NO raiseOnOverflow:NO raiseOnUnderflow:NO raiseOnDivideByZero:NO]; NSDecimalNumber *ouncesDecimal; NSDecimalNumber *roundedOunces; ouncesDecimal = [[NSDecimalNumber alloc] initWithFloat:price]; roundedOunces = [ouncesDecimal decimalNumberByRoundingAccordingToBehavior:roundingBehavior]; [ouncesDecimal release]; return [NSString stringWithFormat:@"%@",roundedOunces];&#125;介绍一下参数：price:需要处理的数字，position：保留小数点第几位，然后调用1234float s =0.126; NSString *sb = [self notRounding:s afterPoint:2]; NSLog(@"sb = %@",sb);输出结果为：sb = 0.12 接下来介绍NSDecimalNumberHandler初始化时的关键参数：decimalNumberHandlerWithRoundingMode：NSRoundDown，NSRoundDown代表的就是 只舍不入。scale的参数position代表保留小数点后几位。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>skills</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Category添加属性所想到的]]></title>
    <url>%2F2015%2F12%2F03%2FCategory%E6%B7%BB%E5%8A%A0%E5%B1%9E%E6%80%A7%E6%89%80%E6%83%B3%E5%88%B0%E7%9A%84%2F</url>
    <content type="text"><![CDATA[iOS中category和extension相辅相成，长得也很相似。category与extension的主要区别： Category：分类、类别 category主要用来增加类的方法，并且适用于子类。 category不能添加实例变量（这个并不是属性），可以添加readonly的属性。 如果要添加readwrite的属性的话，需要用到runtime方法。 Extension：扩展 可以增加被扩展类的属性和方法。 Extension可以理解为匿名类别。 定义的方法必须在implementation中实现。 下面主要看看category的使用：1.添加readonly属性 12345678@interface UITableViewCell (AccessoryView)///在Cell右侧添加的一个自定义label@property (nonatomic,strong,readonly)UILabel *accessoryLabel;@property (nonatomic,strong,readonly)UIImageView *accessoryImageView;@end .m文件中重写getter方法 123456789101112131415161718192021222324252627282930313233@implementation UITableViewCell (AccessoryView)- (UILabel *)accessoryLabel&#123; for (id obj in self.subviews) &#123; if ([obj class] == [UILabel class]) &#123; [obj removeFromSuperview];//因为accessoryLabel是添加在cell上的，而没有在cell.contentView上。 &#125; &#125; UILabel * accessoryLabel = [[UILabel alloc]initWithFrame:CGRectMake(kWidth-200, 0, 160, CGRectGetHeight(self.frame))]; accessoryLabel.textColor = [UIColor lightGrayColor]; accessoryLabel.font = [UIFont systemFontOfSize:12]; accessoryLabel.textAlignment = NSTextAlignmentRight; [self addSubview:accessoryLabel]; return accessoryLabel;&#125;- (UIImageView *)accessoryImageView&#123; for (id obj in self.subviews) &#123; if ([obj class] == [UIImageView class]) &#123; [obj removeFromSuperview]; &#125; &#125; UIImageView *accessoryImageView = [[UIImageView alloc]initWithFrame:CGRectMake(kWidth-100, 10, 60, 60)]; accessoryImageView.layer.cornerRadius = 30; accessoryImageView.layer.masksToBounds = YES; [self addSubview:accessoryImageView]; return accessoryImageView; &#125;@end 如果我们添加一个普通的属性@property (nonatomic,strong)NSString * name;,那么implementation中会报warning： 2.运行时添加属性： 12345@interface NSError (Message)@property (nonatomic,copy)NSString * errorMsg;@end .m 1234567891011121314static void * strKey = &amp;strKey;@implementation NSError (Message)- (void)setErrorMsg:(NSString *)errorMsg&#123; objc_setAssociatedObject(self, &amp; strKey, errorMsg, OBJC_ASSOCIATION_COPY_NONATOMIC);&#125;- (NSString *)errorMsg&#123; return objc_getAssociatedObject(self, &amp;strKey);&#125;@end 在实际使用中，大多数时候还是用的category较多。后面会给出一些常用的类的category。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>category</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用排序算法]]></title>
    <url>%2F2015%2F11%2F30%2F%E5%B8%B8%E7%94%A8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[在此总结一下常用排序算法的代码实现 #include &lt;iostream&gt;using namespace std;typedef int ElemType; /*1、插入排序（1）直接插入排序算法算法思想：将等排序列划分为有序与无序两部分，然后再依次将无序部分插入到已经有序的部分，最后 就可以形成有序序列。操作步骤如下：1）查找出元素L（i）在表中的插入位置K；2）将表中的第K个元素之前的元素依次后移一个位置；3）将L（i）复制到L（K）。 */时间复杂度为：O(n^2) 1234567891011121314151617181920void InsertSort(ElemType arr[], int length)&#123; int i, j; ElemType guard; // 哨兵 for (i = 1; i &lt; length; ++i) &#123; if (arr[i]() &lt; arr[i-1]()) // 在无序部分寻找一个元素，使之插入到有序部分后仍然有序 &#123; guard = arr[i]();// 复制到“哨兵” // 将第i个元素之前的元素依次后移一个位置 for (j = i - 1; arr[j]() &gt; guard; j--) &#123; arr[j + 1]() = arr[j](); &#125; arr[j + 1]() = guard; // 复制到插入位置 &#125; &#125;&#125; 2、折半插入排序 使用于排序表为顺序存储的线性表 在查找插入位置时，采用折半查找 算法思想是： 1）设置折半查找范围； 2）折半查找 3）移动元素 4）插入元素 5）继续操作1）、2）、3）、4）步，直到表成有序。 123456789101112131415161718192021222324252627282930313233void BinaryInsertSort(ElemType arr[], int length)&#123; int i, j, low, high, mid; ElemType tmp; for ( i = 1; i &lt; length; ++i ) &#123; tmp = arr[i](); // 复制到哨兵 // 设置折半查找范围 low = 0; high = i; while (low &lt;= high) // 折半查找 &#123; mid = (low + high) / 2; if (arr[mid]() &gt; tmp) // 在左半部分查找 &#123; high = mid - 1; &#125; else &#123; low = mid + 1; // 在右半部分查找 &#125; &#125; // 移动元素 for ( j = i - 1; j &gt;= high + 1; --j ) &#123; arr[j + 1]() = arr[j](); &#125; arr[j + 1]() = tmp; &#125;&#125; /*3、希尔(Shell)排序 基本思想： 先将待排序的表分割成若干个形若L[i, i+d, i+2d, …, i+kd]的“特殊”子表，分别进行直接插入排序， 当整个表已呈“基本有序”时，再对全体记录进行一次直接插入排序。 算法过程： 1）先取一个小于n的步长d1,把表中全部记录分成d1个组，所有距离为d1的倍数的记录放在同一组中，在各 组中进行直接插入排序； 2）然后取第二个步长d2 \&lt; d1, 重复步骤1 3）直到dk = 1，再进行最后一次直接插入排序*/ 12345678910111213141516171819202122232425void ShellSort(ElemType arr[], int length)&#123; int i, j, dk = length / 2; ElemType tmp; while (dk &gt;= 1)// 控制步长 &#123; for (i = dk; i &lt; length; ++i) &#123; if (arr[i]() &lt; arr[i - dk]()) &#123; tmp = arr[i](); // 暂存 // 后移 for (j = i - dk; j &gt;= 0 &amp;&amp; tmp &lt; arr[j](); j -= dk) &#123; arr[j + dk]() = arr[j](); &#125; arr[j + dk]() = tmp; &#125; &#125; dk /= 2; &#125;&#125; *4、冒泡排序算法 基本思想： 假设待排序的表长为n， 从后向前或从前向后两两比较相邻元素的值，若为逆序，则交换之，直到序列比较完。 这样一回就称为一趟冒泡。这样值较大的元素往下“沉”，而值较小的元素入上“浮”。 时间复杂度为O(n^2)*/ 123456789101112131415161718void BubbleSort(ElemType arr[], int length)&#123;int i, j,k; ElemType tmp; for (k = 0; k &lt; length; ++i)// 趟次总共循环length次 &#123; for (i = 0; i &lt; length - 1; ++i)//两两比较 &#123; j = i + 1; if (arr[j]() &gt; arr[i]()) &#123; tmp = arr[i](); arr[i]() = arr[j](); arr[j]() = tmp; &#125; &#125; &#125;&#125; /*5、快速排序算法 基本思想：基于分治法，在待排序的n个元素中任取一个元素pivot作为基准，通过一趟排序将待排序表划分为独立的 两部分L[1..k-1]和L[k+1 .. n],使得第一部分中的所有元素值都小于pivot，而第二部分中的所有元素值都大于pivot， 则基准元素放在了其最终位置L（K）上，这个过程为一趟快速排序。而后分别递归地对两个子表重复上述过程，直到每 部分内只有一个元素或为空为止，即所有元素都放在了其最终位置上。*/ 12345678910111213141516171819202122232425262728293031323334353637int Partition(ElemType arr[], int left, int right)&#123; ElemType pivot = arr[left]; // 以当前表中第一个元素为枢轴值 while (left \&lt; right) &#123; // 从右向左找一个比枢轴值小的元素的位置 while (left \&lt; right &amp;&amp; arr[right]() \&gt;= pivot) &#123; --right; &#125; arr[left]() = arr[right](); // 将比枢轴值小的元素移动到左端 // 从左向右查找比枢轴值大的元素的位置 while (left \&lt; right &amp;&amp; arr[left]() \&lt;= pivot) &#123; ++left; &#125; arr[right]() = arr[left]();// 将比枢轴值大的元素移动到右端 &#125; arr[left]() = pivot; // 将枢轴元素放在最终位置 return left;&#125;void QuickSort(ElemType arr[], int left, int right)&#123; if (left \&lt; right) &#123; int pivotPos = Partition(arr, left, right); // 划分 QuickSort(arr, left, pivotPos - 1); // 快速排序左半部分 QuickSort(arr, pivotPos + 1, right); // 快速排序右半部分 &#125;&#125; /*6、简单选择排序算法 基本思想： 假设排序表为L[1…n],第i趟排序从表中选择关键字最小的元素与Li交换，第一趟排序可以确定一个元素的 最终位置，这样经过n-1趟排序就可以使得整个排序表有序。*/ 12345678910111213141516171819202122232425void SelectSort(ElemType arr[], int length)&#123; int i, j, min; ElemType tmp; for (i = 0; i \&lt; length - 1; ++i) // 需要n-1趟 &#123; min = i; for (j = i + 1; j \&lt; length; ++j) &#123; if (arr[j]() \&lt; arr[min]()) // 每一趟选择元素值最小的下标 &#123; min = j; &#125; &#125; if (min != i) // 如果第i趟的Li元素值该趟找到的最小元素值，则交换，以使Li值最小 &#123; tmp = arr[i](); arr[i]() = arr[min](); arr[min]() = tmp; &#125; &#125;&#125; /*7、堆排序算法 堆的定义如下：n个关键字序列号L1..n称为堆，仅当该序列满足：1）L(i) \&lt;= L(2i)且L(i) \&lt;= L(2i+1) 或 2)L(i) >= L(2i)且L(i) >= L(2i+1)满足第一种情况的堆，称为小根堆（小顶堆）；满足第二种情况的堆，称为大根堆（大顶堆）。*/ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071void HeapAdjust(ElemType \*a,int i,int size) //调整堆&#123; int lchild = 2 \* i; //i的左孩子节点序号 int rchild = 2 \* i + 1; //i的右孩子节点序号 int max = i; //临时变量 if(i \&lt;= size / 2) //如果i是叶节点就不用进行调整&#123;if (lchild \&lt;= size &amp;&amp; a[lchild]() \&gt; a[max]())&#123;max = lchild; // 左孩子比双亲值还大，需要调整&#125;if (rchild \&lt;= size &amp;&amp; a[rchild]() \&gt; a[max]())&#123;max = rchild;// 右孩子比双亲值还大，需要调整&#125;if (max != i) // 需要调整&#123;ElemType tmp = a[max]();a[max]() = a[i]();a[i]() = tmp;HeapAdjust(a, max, size); //避免调整之后以max为父节点的子树不是堆&#125;&#125;&#125;void BuildHeap(ElemType \*a,int size) //建立堆&#123; for (int i = size / 2; i \&gt;= 0; i--) //非叶节点最大序号值为size/2 &#123; HeapAdjust(a, i, size); &#125;&#125;void HeapSort(ElemType \*a, int size) //堆排序&#123; BuildHeap(a,size);for(int i = size - 1; i \&gt;= 0; i--)&#123;swap(a[0](), a[i]()); //交换堆顶和最后一个元素，即每次将剩余元素中的最大者放到最后面BuildHeap(a, i-1); //将余下元素重新建立为大顶堆HeapAdjust(a,1,i-1); //重新调整堆顶节点成为大顶堆&#125;&#125;void Display(ElemType arr[], int length)&#123; for ( int i = 0; i \&lt; length; ++i ) &#123; cout \&lt;\&lt; arr[i] \&lt;\&lt; " "; &#125; cout \&lt;\&lt; endl;&#125;int main()&#123; ElemType arr[] = &#123;2, 1, 5, 3, 4, 0, 6, 9, -1, 4, 12&#125;;//InsertSort(arr, sizeof(arr) / sizeof(ElemType));//BinaryInsertSort(arr, sizeof(arr) / sizeof(ElemType));//ShellSort(arr, sizeof(arr) / sizeof(ElemType));//BubbleSort(arr, sizeof(arr) / sizeof(ElemType));//QuickSort(arr, 0, sizeof(arr) / sizeof(ElemType) - 1);HeapSort(arr, sizeof(arr) / sizeof(ElemType));Display(arr, sizeof(arr) / sizeof(ElemType));return 0;&#125;]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
</search>
