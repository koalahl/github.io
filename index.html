<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>寒流‘s Blog | 编程与生活</title>

  
  <meta name="author" content="Han Liu">
  

  
  <meta name="description" content="Think in Different">
  

  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  

  <meta property="og:site_name" content="寒流‘s Blog"/>

  
  <meta property="og:image" content="/favicon.ico"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="寒流‘s Blog" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
</head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">寒流‘s Blog</a>
    </h1>
    <p class="site-description">编程与生活</p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/">首页</a></li>
      
        <li><a href="/categories/algorithm">算法</a></li>
      
        <li><a href="/categories/principle">原理</a></li>
      
        <li><a href="/categories/graphic">图形图像</a></li>
      
        <li><a href="/categories/performance">性能</a></li>
      
        <li><a href="/categories/iOSInterview">面试集</a></li>
      
        <li><a href="/categories/sourcecode">读源码</a></li>
      
        <li><a href="/link">博客</a></li>
      
        <li><a href="/categories">分类</a></li>
      
        <li><a href="/about">关于</a></li>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    
  <article>

  
    
    <h3 class="article-title"><a href="/2018/07/27/Mapkit基本开发指南/"><span>Mapkit基本开发指南</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/07/27/Mapkit基本开发指南/" rel="bookmark">
        <time class="entry-date published" datetime="2018-07-27T06:29:49.000Z">
          2018-07-27
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>MapKit是iOS自带的地图库。可以实现定位，地理编码，地图标注等功能。 </p>
<p>一：查看是否导入MapKit.framework。 xcode5.1之后会自动导入<br>二：创建地图<br>        创建地图对象：<br>        <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.打开地图时的初始位置</span><br><span class="line">	1.1 设置地图中心点center</span><br></pre></td></tr></table></figure></p>
<pre><code>    CLLocationCoordinate2D center = CLLocationCoordinate2DMake(latitude, longitude);
    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.2设置地图可视范围 数字越小，可现实范围越小</span><br></pre></td></tr></table></figure>

        MKCoordinateSpan span = MKCoordinateSpanMake(53-3, 135-73);
    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.3设置region= cente+span</span><br></pre></td></tr></table></figure>

        CLLocationCoordinate2D center2 = CLLocationCoordinate2DMake(22.54387,113.950339);
           MKCoordinateSpan span2 = MKCoordinateSpanMake(0.1, 0.1);
          MKCoordinateRegion region2 = MKCoordinateRegionMake(center2, span2);
        [_mapView setRegion:region2 animated:YES];
    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2.地图类型</span><br></pre></td></tr></table></figure>

    MKMapTypeStandard = 0,
    MKMapTypeSatellite,
    MKMapTypeHybrid

    _mapView.mapType = MKMapTypeStandard;
    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3.设置地图上显示内容</span><br></pre></td></tr></table></figure>

    showsPointsOfInterest
    showsBuildings
    showsTraffic
    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">三： 获取当前点击位置的经纬度</span><br><span class="line">3.1给地图对象添加手势：</span><br></pre></td></tr></table></figure>

//长按放置大头针，并获取当前点击位置的经纬度
UILongPressGestureRecognizer *longPress = [[UILongPressGestureRecognizer alloc]initWithTarget:self action:@selector(whereAmI:)];
[_mapView addGestureRecognizer:longPress];
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">3.2创建地图编码器 CLGeocoder——地图编码器分为正向编码和反向编码。两种需要创建两个编码对象，不能公用。</span><br><span class="line">	``_coder = [[CLGeocoder alloc]init];``</span><br><span class="line">3.2.1正向地理编码：：将中文地址--&gt;经纬度</span><br></pre></td></tr></table></figure>

[_coder geocodeAddressString:name completionHandler:^(NSArray *placemarks, NSError *error) {
    NSLog(@&quot;Error:%@&quot;,[error localizedDescription]);
    NSLog(@&quot;------------正向地理编码------------&quot;);
    for (CLPlacemark * mark in placemarks) {
        CLLocation *location = mark.location;//是对CLLocationCoordinate2D的封装
        NSLog(@&quot;(纬度：%f,经度：%f)&quot;,location.coordinate.latitude,location.coordinate.longitude);
        NSLog(@&quot;%@&quot;,mark.name);//位置的完整名称
        NSLog(@&quot;%@&quot;,mark.thoroughfare);//位置名称
        NSLog(@&quot;%@&quot;,mark.locality);//城市
        NSLog(@&quot;%@&quot;,mark.subLocality);//区
        NSLog(@&quot;%@&quot;,mark.administrativeArea);//省

        //1.添加标注（大头针）
</code></pre><p>//            MKPointAnnotation *ann = [[MKPointAnnotation alloc]init];<br>//            //2.设置标注位置<br>//            ann.coordinate = CLLocationCoordinate2DMake(location.coordinate.latitude,location.coordinate.longitude);<br>//            ann.title = mark.thoroughfare;<br>//            ann.subtitle = mark.name;</p>
<pre><code>        /*也可以使用自定义的Annotation*/
        HLAnnotation *ann = [[HLAnnotation alloc]initWithTitle:mark.thoroughfare subtitle:mark.name coordinate:CLLocationCoordinate2DMake(location.coordinate.latitude, location.coordinate.longitude)];
        //3.将标注添加到地图上
        [_mapView addAnnotation:ann];
    }
}];
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3.2.2 反向地理编码：将经纬度—》中文地址信息</span><br></pre></td></tr></table></figure>

[_coder reverseGeocodeLocation:location completionHandler:^(NSArray *placemarks, NSError *error) {
    NSLog(@&quot;Error:%@&quot;,[error localizedDescription]);
    NSLog(@&quot;------------反向地理编码------------&quot;);
    for (CLPlacemark * mark in placemarks) {
        CLLocation *location = mark.location;//是对CLLocationCoordinate2D的封装
        NSLog(@&quot;(纬度：%f,经度：%f)&quot;,location.coordinate.latitude,location.coordinate.longitude);
        NSLog(@&quot;%@&quot;,mark.name);//位置的完整名称
        NSLog(@&quot;%@&quot;,mark.thoroughfare);//位置名称
        NSLog(@&quot;%@&quot;,mark.locality);//城市
        NSLog(@&quot;%@&quot;,mark.subLocality);//区
        NSLog(@&quot;%@&quot;,mark.administrativeArea);//省

        //1.添加标注（大头针）
        MKPointAnnotation *ann = [[MKPointAnnotation alloc]init];
        //2.设置标注位置
        ann.coordinate = CLLocationCoordinate2DMake(location.coordinate.latitude,location.coordinate.longitude);
        ann.title = mark.thoroughfare;
        ann.subtitle = mark.name;
        //3.将标注添加到地图上
        [_mapView addAnnotation:ann];

    }
}];
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3.3 获取当前点击位置-------主要方法是 [tap locationInView：_mapView];获取当前点击的位置</span><br></pre></td></tr></table></figure>

#pragma mark - 点击地图，添加标注大头针
- (void)whereAmI:(UITapGestureRecognizer *)tap{
    //1.获取点击点的位置
    CGPoint point =  [tap locationInView:_mapView];
    //将点位置转换为当前经纬度
    CLLocationCoordinate2D locationCor = [_mapView convertPoint:point toCoordinateFromView:_mapView];

    //NSLog(@&quot;(纬度：%f,经度：%f)&quot;,locationCor.latitude,locationCor.longitude);
    CLLocation *location = [[CLLocation alloc]initWithLatitude:locationCor.latitude longitude:locationCor.longitude];
    [self reverseGeocodeLocation:location];
}
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4.设置大头针的样式和状态—----需要遵守MKMapViewDelegate协议</span><br></pre></td></tr></table></figure>

#pragma  mark - MKMapViewDelegate
//也是有复用机制
- (MKAnnotationView *)mapView:(MKMapView *)mapView viewForAnnotation:(id&lt;MKAnnotation&gt;)annotation;
//设置大头针的状态——重点两个：1.设置大头针（pin）的拖拽状态为end。2.更新大头针的标注（annotation）内容
- (void)mapView:(MKMapView *)mapView annotationView:(MKAnnotationView *)view didChangeDragState:(MKAnnotationViewDragState)newState fromOldState:(MKAnnotationViewDragState)oldState;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">        </span><br><span class="line">//具体代码：</span><br></pre></td></tr></table></figure>

- (MKAnnotationView *)mapView:(MKMapView *)mapView viewForAnnotation:(id&lt;MKAnnotation&gt;)annotation{

    NSLog(@&quot;annotation的类型：%@&quot;,[annotation class]);

    //1.先从复用队列中取出可用的大头针，如果没有，则创建
    MKAnnotationView *annView =  [mapView dequeueReusableAnnotationViewWithIdentifier:@&quot;ann&quot;];
    //判断一下当前annotation的数据类型，如果是用户定位MKUserLocation类，则直接返回，这样当前位置的view就是一个蓝色小圆圈，而不是大头针。
    if ([annotation isKindOfClass:[MKUserLocation class]])
    {
        return annView;
    }
    if (annView == nil) {

        annView = [[MKPinAnnotationView alloc]initWithAnnotation:annotation reuseIdentifier:@&quot;ann&quot;];
    }
    //MKPinAnnotationView是MKAnnotationView的子类
    //如果使用 annView = [MKPinAnnotationView alloc]
    MKPinAnnotationView *pin = (MKPinAnnotationView *)annView;
    //pin.pinColor = MKPinAnnotationColorGreen;
    pin.animatesDrop = YES;

    //2.设置大头针
    //2.1设置大头针图片
    //annView.image = [UIImage imageNamed:@&quot;map&quot;];
    //2.2设置拖拽
    annView.draggable = YES;
    //2.3设置弹出泡泡
    annView.canShowCallout = YES;
    //2.4设置左右视图

    UIButton * right = [UIButton buttonWithType:UIButtonTypeDetailDisclosure];
    right.frame = CGRectMake(0, 0, 30, 30);
    annView.rightCalloutAccessoryView = right;
//    annView.leftCalloutAccessoryView
    return annView;
}
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//设置大头针的状态</span><br></pre></td></tr></table></figure>

- (void)mapView:(MKMapView *)mapView annotationView:(MKAnnotationView *)view didChangeDragState:(MKAnnotationViewDragState)newState fromOldState:(MKAnnotationViewDragState)oldState{
    if (newState == MKAnnotationViewDragStateEnding) {
        //结束大头针View的拖拽状态
        [view setDragState:MKAnnotationViewDragStateNone animated:YES];
        //更新当前大头针的标注内容
        HLAnnotation *ann = view.annotation;
        NSLog(@&quot;(%f,%f)&quot;,ann.coordinate.latitude,ann.coordinate.longitude);
        CLLocation *location = [[CLLocation alloc]initWithLatitude:ann.coordinate.latitude longitude:ann.coordinate.longitude];
        //反向获取位置信息
        [_coder reverseGeocodeLocation:location completionHandler:^(NSArray *placemarks, NSError *error) {
            NSLog(@&quot;Error:%@&quot;,[error localizedDescription]);
            NSLog(@&quot;------------反向地理编码------------&quot;);
            for (CLPlacemark * mark in placemarks) {
                CLLocation *location = mark.location;//是对CLLocationCoordinate2D的封装

                //2.设置标注位置
                ann.coordinate = CLLocationCoordinate2DMake(location.coordinate.latitude,location.coordinate.longitude);
                [ann setTitle:mark.thoroughfare];
                [ann setSubtitle:mark.name];
                //3.将标注添加到地图上
                [_mapView addAnnotation:ann];
            }
        }];
    }
}
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">四：定位</span><br><span class="line">用户定位与位置相关，所以使用的是CLLocationManager类。</span><br><span class="line">1.打开用户位置显示开关</span><br><span class="line">2.创建位置管理对象</span><br><span class="line">3.设置精度和更新频率</span><br><span class="line">4.启动位置更新</span><br></pre></td></tr></table></figure>

//创建位置管理对象
_manager = [[CLLocationManager alloc]init];
_mapView.showsUserLocation = YES;//显示用户当前位置
//设置精度和更新频率
_manager.desiredAccuracy = kCLLocationAccuracyNearestTenMeters;//精度
_manager.distanceFilter = 100.0;//更新频率，每经过100m更新一次

//启动定位，用完应该马上停止，定位结果在代理方法中获取
_manager.delegate = self;
[_manager startUpdatingLocation];
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line">那么如何让地图自动跳转到定位的位置呢？这里需要实现协议CLLocationManagerDelegate。定位结果就是从协议方法中取得</span><br></pre></td></tr></table></figure>

#pragma mark - CLLocationManagerDelegate
- (void)locationManager:(CLLocationManager *)manager didUpdateLocations:(NSArray *)locations{
    CLLocation *currentLocation = [locations lastObject];
    //将地图移动到当前定位的位置
    CLLocationCoordinate2D  currentCoordinate = currentLocation.coordinate;
    MKCoordinateSpan span = _mapView.region.span;//当前地图缩放比例
    MKCoordinateRegion region = {currentCoordinate,span};
    [_mapView setRegion:region];

    NSLog(@&quot;定位结束%@&quot;,currentLocation);

}
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">五：多个经纬度做反向地理编码。</span><br><span class="line"></span><br><span class="line">有个需求要求我们先把策划给的一张包含2664个城市经纬度的表，通过反向地理编码得出对应的城市名，在做的过程中遇到并处理了以下问题：</span><br><span class="line">流程：</span><br><span class="line">1.读取CVS文件，并写入数组中。</span><br><span class="line">2.每次从数组中拿出50个数据，并判断是否finish。</span><br><span class="line">3.创建定时器timer，实现一直循环第2步。</span><br><span class="line">4.每次反向编码后的城市名写入文件中。</span><br><span class="line"></span><br><span class="line">由于reverseGeocodeLocation处理经纬度的请求有限制：</span><br><span class="line">``reverseGeocodeLocation``方法有如下描述</span><br><span class="line">    &#123;%blockquote%&#125;</span><br><span class="line">    Submits a reverse-geocoding request for the specified location.</span><br><span class="line">This method submits the specified location data to the geocoding server asynchronously and returns. When the request completes, the geocoder executes the provided completion handler on the main thread.</span><br><span class="line">After initiating a reverse-geocoding request, do not attempt to initiate another reverse- or forward-geocoding request. Geocoding requests are rate-limited for each app, so making too many requests in a short period of time may cause some of the requests to fail. When the maximum rate is exceeded, the geocoder passes an error object with the value kCLErrorNetwork to your completion handler.</span><br><span class="line">&#123;%endblockquote%&#125;</span><br><span class="line"></span><br><span class="line">划重点：</span><br><span class="line">1. 这个方法是异步的。</span><br><span class="line">2. 同一个app在一段时间间隔内会有一个调用频率（rate-limited）。经测试， geocoding server一次可以处理的请求数为50个，并且时间间隔大约在1分钟左右。</span><br><span class="line"></span><br><span class="line">针对以上两点，我采用了dispatch_group，每一个请求结束后leave group，并且notify到主线程，将结果写入另外的文件。</span><br></pre></td></tr></table></figure>
</code></pre><ul>
<li><p>(void)geocodingForLocations:(NSArray <em>)locations {<br>  __weak typeof(self)wself = self;<br>  dispatch_group_t group = dispatch_group_create();<br>  [locations enumerateObjectsUsingBlock:^(id  _Nonnull obj, NSUInteger idx, BOOL </em> _Nonnull stop) {</p>
<pre><code>CLLocation *location = obj;

dispatch_group_enter(group);

CLGeocoder *geocoder = [[CLGeocoder alloc] init];
[geocoder reverseGeocodeLocation:location completionHandler:^(NSArray&lt;CLPlacemark *&gt; * _Nullable placemarks, NSError * _Nullable error) {
    for (CLPlacemark * placemark in placemarks) {
        NSLog(@&quot;location：%@&quot;,location);
        NSLog(@&quot;name：%@&quot;,placemark.name);
        NSDecimalNumberHandler *handle = [[NSDecimalNumberHandler alloc] initWithRoundingMode:NSRoundDown scale:6 raiseOnExactness:NO raiseOnOverflow:NO raiseOnUnderflow:NO raiseOnDivideByZero:NO] ;
        NSDecimalNumber *rLan = [[NSDecimalNumber alloc] initWithDouble:location.coordinate.latitude];
        NSDecimalNumber *rLon = [[NSDecimalNumber alloc] initWithDouble:location.coordinate.longitude];
        rLan = [rLan decimalNumberByRoundingAccordingToBehavior:handle];
        rLon = [rLon decimalNumberByRoundingAccordingToBehavior:handle];

        NSString *llllan = [NSString stringWithFormat:@&quot;%0.6f&quot;,location.coordinate.latitude];
        NSString *llllon = [NSString stringWithFormat:@&quot;%0.6f&quot;,location.coordinate.longitude];

        NSString *city = placemark.locality ?placemark.locality: placemark.administrativeArea;
        NSLog(@&quot;city：%@&quot;,city);
</code></pre></li>
</ul>
<pre><code>BOOL same = NO;
NSString *tempNameFromGoogle = [NSString stringWithFormat:@&quot;%@-%@&quot;,rLan,rLon];
//这里很耗时
for (NSDictionary *dic in self.locationsOfGoogle) {
    NSString *latitude      = dic[@&quot;lan&quot;];
    NSString *longtitude    = dic[@&quot;lon&quot;];
    NSString *cityName      = dic[@&quot;name&quot;];

    NSComparisonResult latiresult = [rLan compare:latitude];
</code></pre><p>//                    NSComparisonResult lonresult = [rLan compare:latitude];</p>
<pre><code>                if (([latitude isEqualToString:llllan] &amp;&amp; [longtitude isEqualToString:llllon]) || [cityName isEqualToString:city]){
                    //找到对应的坐标判断城市名
                    same = [cityName isEqualToString:city];
                    NSLog(@&quot;城市名是否相同：%d--%f,%f&quot;,same,latitude.doubleValue,longtitude.doubleValue);
                    tempNameFromGoogle = cityName;
                    break;
                }
            }

            [wself.citys appendString:[NSString stringWithFormat:@&quot;%f,%f,%@,%d,%@\r\n&quot;,location.coordinate.latitude,location.coordinate.longitude, city,same,tempNameFromGoogle]];
        }
        NSLog(@&quot;第%lu次 leave ： %lu&quot;,wself.k/50,idx);

        dispatch_group_leave(group);

    }];
}];

dispatch_group_notify(group, dispatch_get_main_queue(), ^{
    NSLog(@&quot;第%lu次 notify&quot;,wself.k/50);
    [self createFile];
});
</code></pre><p>}<br>```</p>
<p>六: MKMapView的zoomLevel<br>系统类没有直接获取zoomLevel的属性，参考一下<br><a href="https://stackoverflow.com/questions/4189621/setting-the-zoom-level-for-a-mkmapview" target="_blank" rel="noopener">https://stackoverflow.com/questions/4189621/setting-the-zoom-level-for-a-mkmapview</a></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/iOS/">iOS</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/Mapkit/">Mapkit</a>
    </span>
    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2018/07/27/Mapkit基本开发指南/#comment">Comments</a>
        </span>
      </span>
    </div>
    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/07/19/YYCache-源码解析/"><span>YYCache 源码解析</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/07/19/YYCache-源码解析/" rel="bookmark">
        <time class="entry-date published" datetime="2018-07-19T12:28:31.000Z">
          2018-07-19
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>YYCache 源码解析</p>
<p><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fibireme%2FYYCache" target="_blank" rel="noopener">YYCache</a>是国内开发者<a href="https://link.juejin.im/?target=https%3A%2F%2Fblog.ibireme.com%2F" target="_blank" rel="noopener">ibireme</a>开源的一个线程安全的高性能缓存组件，代码风格简洁清晰，在GitHub上已经有了1600+颗星。</p>
<p>阅读它的源码有助于建立比较完整的缓存设计的思路，同时也能巩固一下双向链表，线程锁，数据库操作相关的知识。如果你还没有看过YYCache的源码，那么恭喜你，阅读此文会对理解YYCache的源码有比较大的帮助。</p>
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/sourcecode/">sourcecode</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/YYCache/">YYCache</a><a href="/tags/hashmap/">hashmap</a><a href="/tags/双向链表/">双向链表</a>
    </span>
    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2018/07/19/YYCache-源码解析/#comment">Comments</a>
        </span>
      </span>
    </div>
    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/07/05/iOS底层原理总结-关联对象实现原理/"><span>iOS底层原理总结 - 关联对象实现原理</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/07/05/iOS底层原理总结-关联对象实现原理/" rel="bookmark">
        <time class="entry-date published" datetime="2018-07-05T13:56:59.000Z">
          2018-07-05
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h1 id="iOS底层原理总结-关联对象实现原理"><a href="#iOS底层原理总结-关联对象实现原理" class="headerlink" title="iOS底层原理总结 - 关联对象实现原理"></a>iOS底层原理总结 - 关联对象实现原理</h1><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><p>问： Category能否添加成员变量？如果可以，如何给Category添加成员变量？</p>
<p>答：不能直接添加成员变量，但是可以通过runtime的方式间接实现添加成员变量的效果。</p>
<h2 id="Runtime为Category动态关联对象"><a href="#Runtime为Category动态关联对象" class="headerlink" title="Runtime为Category动态关联对象"></a>Runtime为Category动态关联对象</h2><p>使用RunTime给系统的类添加属性，首先需要了解对象与属性的关系。我们通过之前的学习知道，对象一开始初始化的时候其属性为nil，给属性赋值其实就是让属性指向一块存储内容的内存，使这个对象的属性跟这块内存产生一种关联。</p>
<p>那么如果想动态的添加属性，其实就是动态的产生某种关联就好了。而想要给系统的类添加属性，只能通过分类。</p>
<p>这里给NSObject添加name属性，创建NSObject的分类 我们可以使用@property给分类添加属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@property(nonatomic,strong)NSString *name;</span><br></pre></td></tr></table></figure>
<p><strong>通过<a href="https://link.juejin.im/?target=https%3A%2F%2Fjuejin.im%2Fpost%2F5aef0a3b518825670f7bc0f3" target="_blank" rel="noopener">探寻Category的本质</a>我们知道，虽然在分类中可以写@property 添加属性，但是不会自动生成私有属性，也不会生成set,get方法的实现，只会生成set,get的声明，需要我们自己去实现。</strong><br>
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/principle/">principle</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/associate-object/">associate object</a>
    </span>
    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2018/07/05/iOS底层原理总结-关联对象实现原理/#comment">Comments</a>
        </span>
      </span>
    </div>
    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/07/05/iOS底层原理总结-Category的本质/"><span>iOS底层原理总结 - Category的本质</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/07/05/iOS底层原理总结-Category的本质/" rel="bookmark">
        <time class="entry-date published" datetime="2018-07-05T07:17:42.000Z">
          2018-07-05
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="iOS底层原理总结-Category的本质"><a href="#iOS底层原理总结-Category的本质" class="headerlink" title="iOS底层原理总结 - Category的本质"></a>iOS底层原理总结 - Category的本质</h2><h3 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h3><ol>
<li>Category的实现原理，以及Category为什么只能加方法不能加属性。</li>
<li>Category中有load方法吗？load方法是什么时候调用的？load 方法能继承吗？</li>
<li>load、initialize的区别，以及它们在category重写的时候的调用的次序。
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/principle/">principle</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/Category/">Category</a>
    </span>
    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2018/07/05/iOS底层原理总结-Category的本质/#comment">Comments</a>
        </span>
      </span>
    </div>
    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/07/05/iOS底层原理总结-RunLoop/"><span>iOS底层原理总结 - RunLoop</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/07/05/iOS底层原理总结-RunLoop/" rel="bookmark">
        <time class="entry-date published" datetime="2018-07-05T07:13:43.000Z">
          2018-07-05
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h1 id="iOS底层原理总结-RunLoop"><a href="#iOS底层原理总结-RunLoop" class="headerlink" title="iOS底层原理总结 - RunLoop"></a>iOS底层原理总结 - RunLoop</h1><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><ol>
<li>讲讲 RunLoop，项目中有用到吗？</li>
<li>RunLoop内部实现逻辑？</li>
<li>Runloop和线程的关系？</li>
<li>timer 与 Runloop 的关系？</li>
<li>程序中添加每3秒响应一次的NSTimer，当拖动tableview时timer可能无法响应要怎么解决？</li>
<li>Runloop 是怎么响应用户操作的， 具体流程是什么样的？</li>
<li>说说RunLoop的几种状态？</li>
<li>Runloop的mode作用是什么？</li>
</ol>
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/principle/">principle</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/runloop/">runloop</a>
    </span>
    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2018/07/05/iOS底层原理总结-RunLoop/#comment">Comments</a>
        </span>
      </span>
    </div>
    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/07/05/iOS底层原理总结-探寻Class的本质/"><span>iOS底层原理总结 - 探寻Class的本质</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/07/05/iOS底层原理总结-探寻Class的本质/" rel="bookmark">
        <time class="entry-date published" datetime="2018-07-05T07:06:44.000Z">
          2018-07-05
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h3 id="iOS底层原理总结-探寻Class的本质"><a href="#iOS底层原理总结-探寻Class的本质" class="headerlink" title="iOS底层原理总结 - 探寻Class的本质"></a>iOS底层原理总结 - 探寻Class的本质</h3><p>对小码哥底层班视频学习的总结与记录。面试题部分，通过对面试题的分析探索问题的本质内容。 上接 <a href="https://link.juejin.im?target=https%3A%2F%2Fjuejin.im%2Fpost%2F5ac81c75518825556534c0af" target="_blank" rel="noopener">iOS底层原理总结 - 探寻OC对象的本质</a></p>
<h3 id="Class的本质"><a href="#Class的本质" class="headerlink" title="Class的本质"></a>Class的本质</h3><p>我们知道不管是类对象还是元类对象，类型都是Class，class和mete-class的底层都是objc_class结构体的指针，内存中就是结构体，本章来探寻Class的本质。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class objectClass = [NSObject class];        </span><br><span class="line">Class objectMetaClass = object_getClass([NSObject class]);</span><br></pre></td></tr></table></figure>
<p>点击Class来到内部，我们可以发现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef struct objc_class *Class;</span><br></pre></td></tr></table></figure>
<p>Class对象其实是一个指向objc_class结构体的指针。因此我们可以说类对象或元类对象在内存中其实就是objc_class结构体。</p>
<p>我们来到objc_class内部，可以看到这段在底层原理中经常出现的代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">struct objc_class &#123;</span><br><span class="line">    Class _Nonnull isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line"></span><br><span class="line">#if !__OBJC2__</span><br><span class="line">    Class _Nullable super_class                              OBJC2_UNAVAILABLE;</span><br><span class="line">    const char * _Nonnull name                               OBJC2_UNAVAILABLE;</span><br><span class="line">    long version                                             OBJC2_UNAVAILABLE;</span><br><span class="line">    long info                                                OBJC2_UNAVAILABLE;</span><br><span class="line">    long instance_size                                       OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_ivar_list * _Nullable ivars                  OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_method_list * _Nullable * _Nullable methodLists                    OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_cache * _Nonnull cache                       OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_protocol_list * _Nullable protocols          OBJC2_UNAVAILABLE;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">&#125; OBJC2_UNAVAILABLE;</span><br><span class="line">/* Use `Class` instead of `struct objc_class *` */</span><br></pre></td></tr></table></figure>
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/principle/">principle</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/Class本质/">Class本质</a>
    </span>
    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2018/07/05/iOS底层原理总结-探寻Class的本质/#comment">Comments</a>
        </span>
      </span>
    </div>
    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/07/05/iOS底层原理总结-探寻OC对象的本质/"><span>iOS底层原理总结 - 探寻OC对象的本质</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/07/05/iOS底层原理总结-探寻OC对象的本质/" rel="bookmark">
        <time class="entry-date published" datetime="2018-07-05T06:05:22.000Z">
          2018-07-05
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="iOS底层原理总结-探寻OC对象的本质"><a href="#iOS底层原理总结-探寻OC对象的本质" class="headerlink" title="iOS底层原理总结 - 探寻OC对象的本质"></a>iOS底层原理总结 - 探寻OC对象的本质</h2><p>对小码哥底层班视频学习的总结与记录。面试题部分，通过对面试题的分析探索问题的本质内容。</p>
<blockquote>
<p>面试题：一个NSObject对象占用多少内存？</p>
</blockquote>
<p>探寻OC对象的本质，我们平时编写的Objective-C代码，底层实现其实都是C\C++代码。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/4/7/1629daf21d662684?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="OC代码的转化过程"></p>
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/principle/">principle</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/Object本质/">Object本质</a><a href="/tags/isa/">isa</a>
    </span>
    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2018/07/05/iOS底层原理总结-探寻OC对象的本质/#comment">Comments</a>
        </span>
      </span>
    </div>
    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/06/21/WWDC2018-图像最佳实践-Image-and-Graphics-Best-Practices/"><span>[WWDC2018] - 图像最佳实践 Image and Graphics Best Practices</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/06/21/WWDC2018-图像最佳实践-Image-and-Graphics-Best-Practices/" rel="bookmark">
        <time class="entry-date published" datetime="2018-06-21T10:22:40.000Z">
          2018-06-21
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h1 id="Image-and-Graphics-Best-Practices"><a href="#Image-and-Graphics-Best-Practices" class="headerlink" title="Image and Graphics Best Practices"></a>Image and Graphics Best Practices</h1><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p><a href="https://techblog.toutiao.com/2018/06/19/untitled-42/#first" target="_blank" rel="noopener">1.UIImage and UIImageView</a><br><a href="https://techblog.toutiao.com/2018/06/19/untitled-42/#second" target="_blank" rel="noopener">2.Custom drawing with UIKit</a><br><a href="https://techblog.toutiao.com/2018/06/19/untitled-42/#third" target="_blank" rel="noopener">3.Advanced CPU and GPU</a><br><a href="https://techblog.toutiao.com/2018/06/19/untitled-42/#summary" target="_blank" rel="noopener">4.总结</a></p>
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/graphic/">graphic</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/WWDC2018/">WWDC2018</a><a href="/tags/Rendering/">Rendering</a>
    </span>
    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2018/06/21/WWDC2018-图像最佳实践-Image-and-Graphics-Best-Practices/#comment">Comments</a>
        </span>
      </span>
    </div>
    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/06/08/Runtime的运用和减少应用崩溃/"><span>Runtime的运用和减少应用崩溃</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/06/08/Runtime的运用和减少应用崩溃/" rel="bookmark">
        <time class="entry-date published" datetime="2018-06-08T05:27:55.000Z">
          2018-06-08
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>Objective-C 是一个动态语言，它需要一个运行时系统来动态的创建类和对象、进行消息传递和转发。关于Runtime的知识大家可以参看<a href="https://link.jianshu.com?t=https://opensource.apple.com/tarballs/objc4/" target="_blank" rel="noopener">Apple开源的Runtime代码</a> 和<a href="https://link.jianshu.com?t=https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008048-CH1-SW1" target="_blank" rel="noopener">Rumtime编程指南</a> 。</p>
<p>本文总结一些其常用的方法。<br>
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/iOS/">iOS</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/runtime/">runtime</a>
    </span>
    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2018/06/08/Runtime的运用和减少应用崩溃/#comment">Comments</a>
        </span>
      </span>
    </div>
    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/05/25/老司机-iOS-周报-20-2018-05-21/"><span>老司机 iOS 周报 #20 | 2018-05-21</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/05/25/老司机-iOS-周报-20-2018-05-21/" rel="bookmark">
        <time class="entry-date published" datetime="2018-05-25T01:21:48.000Z">
          2018-05-25
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p><img src="https://user-gold-cdn.xitu.io/2018/4/16/162ccf8ac966f57a?imageView2/1/w/1304/h/734/q/85/format/webp/interlace/1" alt=""></p>
<p>老司机 iOS 周报，只为你呈现有价值的信息。</p>
<p>你也可以为这个项目出一份力，如果发现有价值的信息、文章、工具等可以到 <a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2FSwiftOldDriver%2FiOS-Weekly%2Fissues" target="_blank" rel="noopener">Issues</a> 里提给我们，我们会尽快处理。记得写上推荐的理由哦。有建议和意见也欢迎到 <a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2FSwiftOldDriver%2FiOS-Weekly%2Fissues" target="_blank" rel="noopener">Issues</a> 提出。</p>
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/swiftOldDriver/">swiftOldDriver</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/iOS/">iOS</a><a href="/tags/swift/">swift</a>
    </span>
    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2018/05/25/老司机-iOS-周报-20-2018-05-21/#comment">Comments</a>
        </span>
      </span>
    </div>
    
  </div>
</article>




<nav class="pagination">
  
  
  <a href="/page/2/" class="pagination-next">Next</a>
  
</nav>
    </main>

    <footer class="site-footer">
  <p class="site-info">
    <!--
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    </br>
  -->
    
    &copy; 2018 Han Liu
    
  </p>
</footer>
    
  </div>
</div>
</body>
</html>