<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  
    <meta name="description" content="Think in Different">
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <title>
    SDWebImage4.0源码阅读 |
    
    寒流‘s Blog</title>
  
    <link rel="shortcut icon" href="/favicon.ico">
  
  <link rel="stylesheet" href="/css/style.css">
  
    <link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">
  
  <script src="/js/pace.min.js"></script>
</head>

<body>
<main class="content">
  <section class="outer">
  <article id="post-SDWebImage4-0源码阅读" class="article article-type-post" itemscope itemprop="blogPost">

  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      SDWebImage4.0源码阅读
    </h1>
  

      </header>
    

    
      <div class="article-meta">
        <a href="/2018/04/24/SDWebImage4-0源码阅读/" class="article-date">
  <time datetime="2018-04-24T05:33:07.000Z" itemprop="datePublished">2018-04-24</time>
</a>
        
  <div class="article-category">
    <a class="article-category-link" href="/categories/sourcecode/">sourcecode</a>
  </div>

      </div>
    

    <div class="article-entry" itemprop="articleBody">
      
      
      
        <h3 id="参拜一下SDWebImage的源码。"><a href="#参拜一下SDWebImage的源码。" class="headerlink" title="参拜一下SDWebImage的源码。"></a>参拜一下SDWebImage的源码。</h3><p>并不是说一定要读如何如何、只是觉得源码的阅读是一种很好的学习方式。无论从架构还是技术点方面。</p>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul>
<li>常见疑问(面试大全？)<ul>
<li>磁盘目录位于哪里？</li>
<li>最大并发数、超时时长？</li>
<li>图片如何命名？</li>
<li>如何识别图片类型?</li>
<li>所查找到的图片的来源?</li>
<li><strong>所有下载的图片都将被写入缓存？磁盘呢？何时缓存的？</strong></li>
<li><strong>磁盘缓存的时长？清理操作的时间点？</strong></li>
<li><strong>磁盘清理的原则？</strong></li>
<li>下载图片时、会使用缓存协议么?</li>
<li>下载图片的URL必须是NSURL么？</li>
<li><strong>读取缓存以及读取磁盘的时候如何保证线程安全？</strong></li>
</ul>
</li>
<li>相关知识点<ul>
<li>NS_OPTIONS枚举与位运算</li>
<li>内联函数</li>
</ul>
</li>
<li>准备工作</li>
<li>工作原理</li>
<li>业务层级</li>
<li>核心代码(正常读取下载图片)<ul>
<li>最上层：UIView+WebCache</li>
<li>逻辑层：SDWebImageManager</li>
<li>业务层：<ul>
<li>缓存&amp;&amp;磁盘操作(SDImageCache)</li>
<li>下载操作(SDWebImageDownloader)</li>
</ul>
</li>
</ul>
</li>
<li>一些启发<ul>
<li>分层的接口API设计</li>
<li>线程安全</li>
<li>内联函数</li>
<li>精细的缓存管理原则</li>
<li>回调设计</li>
</ul>
</li>
</ul>
<a id="more"></a>
<h3 id="常见疑问-面试大全？"><a href="#常见疑问-面试大全？" class="headerlink" title="常见疑问(面试大全？)"></a>常见疑问(面试大全？)</h3><p>虽然我更推荐阅读源码、可如果实在没时间。这一段只要花费几分钟。<br>我还是比较喜欢把干货放在前面、方便伸手党(比如我)。<br>不过也不能保证涵盖全部问题、欢迎留言。</p>
<ul>
<li><h4 id="磁盘目录位于哪里？"><a href="#磁盘目录位于哪里？" class="headerlink" title="磁盘目录位于哪里？"></a>磁盘目录位于哪里？</h4></li>
</ul>
<p>缓存在磁盘沙盒目录下 <code>Library/Caches</code><br>二级目录为<code>~/Library/Caches/default/com.hackemist.SDWebImageCache.default</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)init &#123;</span><br><span class="line">    return [self initWithNamespace:@&quot;default&quot;];</span><br><span class="line">    //   ~Library/Caches/default</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (nonnull instancetype)initWithNamespace:(nonnull NSString *)ns &#123;</span><br><span class="line">    NSString *path = [self makeDiskCachePath:ns];</span><br><span class="line">    return [self initWithNamespace:ns diskCacheDirectory:path];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (nonnull instancetype)initWithNamespace:(nonnull NSString *)ns</span><br><span class="line">                       diskCacheDirectory:(nonnull NSString *)directory &#123;</span><br><span class="line">    if ((self = [super init])) &#123;</span><br><span class="line">        NSString *fullNamespace = [@&quot;com.hackemist.SDWebImageCache.&quot; stringByAppendingString:ns]</span><br><span class="line"></span><br><span class="line">        // Init the disk cache</span><br><span class="line">        if (directory != nil) &#123;</span><br><span class="line">            _diskCachePath = [directory stringByAppendingPathComponent:fullNamespace];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            NSString *path = [self makeDiskCachePath:ns];</span><br><span class="line">            _diskCachePath = path;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">//  _diskCachePath = ~/Library/Caches/default/com.hackemist.SDWebImageCache.default</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你也可以通过<code>[[SDImageCache sharedImageCache] addReadOnlyCachePath:bundledPath];</code>来自定义一个路径。</p>
<h6 id="但这个路径不会被存储使用、是给开发者自定义预装图片的路径。"><a href="#但这个路径不会被存储使用、是给开发者自定义预装图片的路径。" class="headerlink" title="但这个路径不会被存储使用、是给开发者自定义预装图片的路径。"></a>但这个路径不会被存储使用、是给开发者自定义预装图片的路径。</h6><ul>
<li><h4 id="最大并发数、超时时长？"><a href="#最大并发数、超时时长？" class="headerlink" title="最大并发数、超时时长？"></a>最大并发数、超时时长？</h4></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">_downloadQueue = [NSOperationQueue new];</span><br><span class="line">_downloadQueue.maxConcurrentOperationCount = 6;</span><br><span class="line">_downloadTimeout = 15.0;</span><br></pre></td></tr></table></figure>
<ul>
<li><h4 id="图片如何命名？"><a href="#图片如何命名？" class="headerlink" title="图片如何命名？"></a>图片如何命名？</h4></li>
</ul>
<p>这里写入缓存和写入磁盘是不同的。<br>写入缓存时、直接用图片url作为key</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//写入缓存</span><br><span class="line">NSUInteger cost = SDCacheCostForImage(image);</span><br><span class="line">[self.memCache setObject:image forKey:key cost:cost];</span><br></pre></td></tr></table></figure>
<p>写入磁盘时、用url的MD5编码作为key。可以防止文件名过长</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (nullable NSString *)cachedFileNameForKey:(nullable NSString *)key &#123;</span><br><span class="line">    const char *str = key.UTF8String;</span><br><span class="line">    if (str == NULL) &#123;</span><br><span class="line">        str = &quot;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    unsigned char r[CC_MD5_DIGEST_LENGTH];</span><br><span class="line">    CC_MD5(str, (CC_LONG)strlen(str), r);</span><br><span class="line">    NSURL *keyURL = [NSURL URLWithString:key];</span><br><span class="line">    NSString *ext = keyURL ? keyURL.pathExtension : key.pathExtension;</span><br><span class="line">    NSString *filename = [NSString stringWithFormat:@&quot;%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%@&quot;,</span><br><span class="line">                          r[0], r[1], r[2], r[3], r[4], r[5], r[6], r[7], r[8], r[9], r[10],</span><br><span class="line">                          r[11], r[12], r[13], r[14], r[15], ext.length == 0 ? @&quot;&quot; : [NSString stringWithFormat:@&quot;.%@&quot;, ext]];</span><br><span class="line">    return filename;</span><br><span class="line">    //key == https://gss2.bdstatic.com/-fo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=034361ab922397ddc274905638ebd9d2/d31b0ef41bd5ad64dddebb.jpg;</span><br><span class="line">    //filename == f029945f95894e152771806785bc4f18.jpg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><h4 id="如何识别图片类型"><a href="#如何识别图片类型" class="headerlink" title="如何识别图片类型?"></a>如何识别图片类型?</h4></li>
</ul>
<p>通过NSData数据的第一个字符进行判断。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">+ (SDImageFormat)sd_imageFormatForImageData:(nullable NSData *)data &#123;</span><br><span class="line">    if (!data) &#123;</span><br><span class="line">        return SDImageFormatUndefined;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // File signatures table: http://www.garykessler.net/library/file_sigs.html</span><br><span class="line">    uint8_t c;</span><br><span class="line">    [data getBytes:&amp;c length:1];</span><br><span class="line">    switch (c) &#123;</span><br><span class="line">        case 0xFF:</span><br><span class="line">            return SDImageFormatJPEG;</span><br><span class="line">        case 0x89:</span><br><span class="line">            return SDImageFormatPNG;</span><br><span class="line">        case 0x47:</span><br><span class="line">            return SDImageFormatGIF;</span><br><span class="line">        case 0x49:</span><br><span class="line">        case 0x4D:</span><br><span class="line">            return SDImageFormatTIFF;</span><br><span class="line">        case 0x52: &#123;</span><br><span class="line">            if (data.length &gt;= 12) &#123;</span><br><span class="line">                //RIFF....WEBP</span><br><span class="line">                NSString *testString = [[NSString alloc] initWithData:[data subdataWithRange:NSMakeRange(0, 12)] encoding:NSASCIIStringEncoding];</span><br><span class="line">                if ([testString hasPrefix:@&quot;RIFF&quot;] &amp;&amp; [testString hasSuffix:@&quot;WEBP&quot;]) &#123;</span><br><span class="line">                    return SDImageFormatWebP;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        case 0x00: &#123;</span><br><span class="line">            if (data.length &gt;= 12) &#123;</span><br><span class="line">                //....ftypheic ....ftypheix ....ftyphevc ....ftyphevx</span><br><span class="line">                NSString *testString = [[NSString alloc] initWithData:[data subdataWithRange:NSMakeRange(4, 8)] encoding:NSASCIIStringEncoding];</span><br><span class="line">                if ([testString isEqualToString:@&quot;ftypheic&quot;]</span><br><span class="line">                    || [testString isEqualToString:@&quot;ftypheix&quot;]</span><br><span class="line">                    || [testString isEqualToString:@&quot;ftyphevc&quot;]</span><br><span class="line">                    || [testString isEqualToString:@&quot;ftyphevx&quot;]) &#123;</span><br><span class="line">                    return SDImageFormatHEIC;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return SDImageFormatUndefined;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><h4 id="所查找到的图片的来源"><a href="#所查找到的图片的来源" class="headerlink" title="所查找到的图片的来源?"></a>所查找到的图片的来源?</h4></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_ENUM(NSInteger, SDImageCacheType) &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 从网上下载</span><br><span class="line">    */</span><br><span class="line">    SDImageCacheTypeNone,</span><br><span class="line">    /**</span><br><span class="line">     * 从磁盘获得</span><br><span class="line">     */</span><br><span class="line">    SDImageCacheTypeDisk,</span><br><span class="line">    /**</span><br><span class="line">     * 从内存获得</span><br><span class="line">     */</span><br><span class="line">    SDImageCacheTypeMemory</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><h4 id="所有下载的图片都将被写入缓存？磁盘呢？何时缓存的？"><a href="#所有下载的图片都将被写入缓存？磁盘呢？何时缓存的？" class="headerlink" title="所有下载的图片都将被写入缓存？磁盘呢？何时缓存的？"></a>所有下载的图片都将被写入缓存？磁盘呢？何时缓存的？</h4></li>
</ul>
<p>磁盘不是强制写入。从枚举<code>SDWebImageOptions</code>可见</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_OPTIONS(NSUInteger, SDWebImageOptions) &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     *  禁用磁盘缓存</span><br><span class="line">     */</span><br><span class="line">    SDWebImageCacheMemoryOnly = 1 &lt;&lt; 2,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而Memory缓存应该是必须写入的(因为我并没找到哪里可以禁止)。<br>缓存的时间点、有两个(开发者也可以主动缓存)、且都是由<code>SDWebImageManager</code>进行。<br>其一是下载成功后、自动保存。或者开发者通过代理处理图片并返回后缓存</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (nullable UIImage *)imageManager:(nonnull SDWebImageManager *)imageManager transformDownloadedImage:(nullable UIImage *)image withURL:(nullable NSURL *)imageURL;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">=========&gt;&gt;SDWebImageManager</span><br><span class="line">//获取转换用户后的图片</span><br><span class="line">UIImage *transformedImage = [self.delegate imageManager:self transformDownloadedImage:downloadedImage withURL:url];</span><br><span class="line"></span><br><span class="line">//用户处理成功</span><br><span class="line">if (transformedImage &amp;&amp; finished) &#123;</span><br><span class="line">      BOOL imageWasTransformed = ![transformedImage isEqual:downloadedImage];</span><br><span class="line"></span><br><span class="line">      //用户处理的后若未生成新的图片、则保存下载的二进制文件。</span><br><span class="line">      //不然则由imageCache内部生成二进制文件保存</span><br><span class="line">      [self.imageCache storeImage:transformedImage imageData:(imageWasTransformed ? nil : downloadedData) forKey:key toDisk:cacheOnDisk completion:nil];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其二是当缓存中没有、但是从硬盘中查询到了图片。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@autoreleasepool &#123;</span><br><span class="line">        //搜索硬盘</span><br><span class="line">        NSData *diskData = [self diskImageDataBySearchingAllPathsForKey:key];</span><br><span class="line">        UIImage *diskImage = [self diskImageForKey:key];</span><br><span class="line">        //缓存到内存、默认为YES</span><br><span class="line">        if (diskImage &amp;&amp; self.config.shouldCacheImagesInMemory) &#123;</span><br><span class="line">             NSUInteger cost = SDCacheCostForImage(diskImage);</span><br><span class="line">             //使用NSChache缓存。</span><br><span class="line">             [self.memCache setObject:diskImage forKey:key cost:cost];</span><br><span class="line">        &#125;</span><br><span class="line">       if (doneBlock) &#123;</span><br><span class="line">                dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">               doneBlock(diskImage, diskData, SDImageCacheTypeDisk);</span><br><span class="line">             &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><h4 id="磁盘缓存的时长？清理操作的时间点？"><a href="#磁盘缓存的时长？清理操作的时间点？" class="headerlink" title="磁盘缓存的时长？清理操作的时间点？"></a>磁盘缓存的时长？清理操作的时间点？</h4></li>
</ul>
<h5 id="默认为一周"><a href="#默认为一周" class="headerlink" title="默认为一周"></a>默认为一周</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static const NSInteger kDefaultCacheMaxCacheAge = 60 * 60 * 24 * 7; // 1 week</span><br></pre></td></tr></table></figure>
<p>能够以时间清除磁盘的方法为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)deleteOldFilesWithCompletionBlock:(nullable SDWebImageNoParamsBlock)completionBlock;</span><br></pre></td></tr></table></figure>
<p>调用的时机为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[[NSNotificationCenter defaultCenter] addObserver:self</span><br><span class="line">                                                 selector:@selector(deleteOldFiles)</span><br><span class="line">                                                     name:UIApplicationWillTerminateNotification</span><br><span class="line">                                                   object:nil];</span><br><span class="line"> [[NSNotificationCenter defaultCenter] addObserver:self</span><br><span class="line">                                                 selector:@selector(backgroundDeleteOldFiles)</span><br><span class="line">                                                     name:UIApplicationDidEnterBackgroundNotification</span><br><span class="line">                                                   object:nil];</span><br></pre></td></tr></table></figure>
<p>也就是当程序退出到后台、或者被杀死的时候。<br>这里、还有另外一个点。<br><strong>Long-Running Task任务</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">- (void)backgroundDeleteOldFiles &#123;</span><br><span class="line">    Class UIApplicationClass = NSClassFromString(@&quot;UIApplication&quot;);</span><br><span class="line">    if(!UIApplicationClass || ![UIApplicationClass respondsToSelector:@selector(sharedApplication)]) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    UIApplication *application = [UIApplication performSelector:@selector(sharedApplication)];</span><br><span class="line">    //后台任务标识--注册一个后台任务</span><br><span class="line">    __block UIBackgroundTaskIdentifier bgTask = [application beginBackgroundTaskWithExpirationHandler:^&#123;</span><br><span class="line">        //超时（大概150秒？）自动结束后台任务</span><br><span class="line">        //结束后台任务</span><br><span class="line">        [application endBackgroundTask:bgTask];</span><br><span class="line">        bgTask = UIBackgroundTaskInvalid;</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    [self deleteOldFilesWithCompletionBlock:^&#123;</span><br><span class="line"></span><br><span class="line">        //结束后台任务</span><br><span class="line">        [application endBackgroundTask:bgTask];</span><br><span class="line">        bgTask = UIBackgroundTaskInvalid;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>正常程序在进入后台后、虽然可以继续执行任务。但是在时间很短内就会被挂起待机。<br>Long-Running可以让系统为app再多分配一些时间来处理一些耗时任务。</p>
<ul>
<li><h4 id="磁盘清理的原则？"><a href="#磁盘清理的原则？" class="headerlink" title="磁盘清理的原则？"></a>磁盘清理的原则？</h4></li>
</ul>
<p>首先、通过时间进行清理。（最后修改时间&gt;一周）<br>然后、根据占据内存大小进行清理。（如果占据内存大于上限、则按时间排序、删除到上限的1/2。）<br><strong>这里我并没有看到使用频率优先级判断、所以应该是没有。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">- (void)deleteOldFilesWithCompletionBlock:(nullable SDWebImageNoParamsBlock)completionBlock &#123;</span><br><span class="line">    //异步清理超时图片</span><br><span class="line">    dispatch_async(self.ioQueue, ^&#123;</span><br><span class="line">        //获取磁盘目录</span><br><span class="line">        NSURL *diskCacheURL = [NSURL fileURLWithPath:self.diskCachePath isDirectory:YES];</span><br><span class="line">        //NSURLIsDirectoryKey 判断是否为目录</span><br><span class="line">        //NSURLContentModificationDateKey 判断最后修改时间</span><br><span class="line">        //NSURLTotalFileAllocatedSizeKey 判断文件大小</span><br><span class="line">        NSArray&lt;NSString *&gt; *resourceKeys = @[NSURLIsDirectoryKey, NSURLContentModificationDateKey, NSURLTotalFileAllocatedSizeKey];</span><br><span class="line"></span><br><span class="line">        //模具器--遍历磁盘路径下的文件</span><br><span class="line">        NSDirectoryEnumerator *fileEnumerator = [_fileManager enumeratorAtURL:diskCacheURL</span><br><span class="line">                                                   includingPropertiesForKeys:resourceKeys</span><br><span class="line">                                                                      options:NSDirectoryEnumerationSkipsHiddenFiles</span><br><span class="line">                                                                 errorHandler:NULL];</span><br><span class="line">        //计算一周前(需要释放)、的时间</span><br><span class="line">        NSDate *expirationDate = [NSDate dateWithTimeIntervalSinceNow:-self.config.maxCacheAge];</span><br><span class="line">        //保存缓存文件Dic</span><br><span class="line">        NSMutableDictionary&lt;NSURL *, NSDictionary&lt;NSString *, id&gt; *&gt; *cacheFiles = [NSMutableDictionary dictionary];</span><br><span class="line">        //缓存总大小</span><br><span class="line">        NSUInteger currentCacheSize = 0;</span><br><span class="line">        //需要删除的url路径</span><br><span class="line">        NSMutableArray&lt;NSURL *&gt; *urlsToDelete = [[NSMutableArray alloc] init];</span><br><span class="line">        //遍历磁盘文件枚举器</span><br><span class="line">        for (NSURL *fileURL in fileEnumerator) &#123;</span><br><span class="line">            NSError *error;</span><br><span class="line">            //获取每个文件所对应的三个参数（resourceKeys）</span><br><span class="line">            NSDictionary&lt;NSString *, id&gt; *resourceValues = [fileURL resourceValuesForKeys:resourceKeys error:&amp;error];</span><br><span class="line"></span><br><span class="line">            // Skip directories and errors.</span><br><span class="line">            if (error || !resourceValues || [resourceValues[NSURLIsDirectoryKey] boolValue]) &#123;</span><br><span class="line">                //如果是文件夹则跳过</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // Remove files that are older than the expiration date;</span><br><span class="line">            NSDate *modificationDate = resourceValues[NSURLContentModificationDateKey];</span><br><span class="line">            if ([[modificationDate laterDate:expirationDate] isEqualToDate:expirationDate]) &#123;</span><br><span class="line">                //如果时间超过指定日期、加入删除数组。跳过</span><br><span class="line">                [urlsToDelete addObject:fileURL];</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            //获取文件大小、并且把路径与大小存入字典。</span><br><span class="line">            // Store a reference to this file and account for its total size.</span><br><span class="line">            NSNumber *totalAllocatedSize = resourceValues[NSURLTotalFileAllocatedSizeKey];</span><br><span class="line">            currentCacheSize += totalAllocatedSize.unsignedIntegerValue;</span><br><span class="line">            cacheFiles[fileURL] = resourceValues;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //遍历删除文件</span><br><span class="line">        for (NSURL *fileURL in urlsToDelete) &#123;</span><br><span class="line">            [_fileManager removeItemAtURL:fileURL error:nil];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //如果剩余文件大小仍超过阈值</span><br><span class="line">        //优先删除最老的文件</span><br><span class="line">        if (self.config.maxCacheSize &gt; 0 &amp;&amp; currentCacheSize &gt; self.config.maxCacheSize) &#123;</span><br><span class="line">            // Target half of our maximum cache size for this cleanup pass.</span><br><span class="line">            const NSUInteger desiredCacheSize = self.config.maxCacheSize / 2;</span><br><span class="line"></span><br><span class="line">            // 将剩余的文件按修改时间排序</span><br><span class="line">            NSArray&lt;NSURL *&gt; *sortedFiles = [cacheFiles keysSortedByValueWithOptions:NSSortConcurrent</span><br><span class="line">                                                                     usingComparator:^NSComparisonResult(id obj1, id obj2) &#123;</span><br><span class="line">                                                                         return [obj1[NSURLContentModificationDateKey] compare:obj2[NSURLContentModificationDateKey]];</span><br><span class="line">                                                                     &#125;];</span><br><span class="line"></span><br><span class="line">            // 删除文件</span><br><span class="line">            for (NSURL *fileURL in sortedFiles) &#123;</span><br><span class="line">                if ([_fileManager removeItemAtURL:fileURL error:nil]) &#123;</span><br><span class="line">                    NSDictionary&lt;NSString *, id&gt; *resourceValues = cacheFiles[fileURL];</span><br><span class="line">                    NSNumber *totalAllocatedSize = resourceValues[NSURLTotalFileAllocatedSizeKey];</span><br><span class="line">                    currentCacheSize -= totalAllocatedSize.unsignedIntegerValue;</span><br><span class="line">                    //直到低于阈值的二分之一</span><br><span class="line">                    if (currentCacheSize &lt; desiredCacheSize) &#123;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //回调给主线程</span><br><span class="line">        if (completionBlock) &#123;</span><br><span class="line">            dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                completionBlock();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><h4 id="下载图片时、会使用网络协议缓存逻辑么"><a href="#下载图片时、会使用网络协议缓存逻辑么" class="headerlink" title="下载图片时、会使用网络协议缓存逻辑么?"></a>下载图片时、会使用网络协议缓存逻辑么?</h4></li>
</ul>
<p>默认情况下不会、由以下代码可见。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NSURLRequestCachePolicy cachePolicy = options &amp; SDWebImageDownloaderUseNSURLCache ? NSURLRequestUseProtocolCachePolicy : NSURLRequestReloadIgnoringLocalCacheData;</span><br><span class="line">        NSMutableURLRequest *request = [[NSMutableURLRequest alloc] initWithURL:url</span><br><span class="line">                                                                    cachePolicy:cachePolicy</span><br><span class="line">                                                                timeoutInterval:timeoutInterval];</span><br></pre></td></tr></table></figure>
<p>除非将<code>options</code>配置成<code>SDWebImageDownloaderUseNSURLCache</code>、否则每次都会从原地址重新下载、而不是用网络协议的缓存逻辑。</p>
<ul>
<li><h4 id="下载图片的URL必须是NSURL么？"><a href="#下载图片的URL必须是NSURL么？" class="headerlink" title="下载图片的URL必须是NSURL么？"></a>下载图片的URL必须是NSURL么？</h4></li>
</ul>
<p>不是、在<code>SDWebImageManager</code>中有过容错处理。所以即便你传入一个字符串、依旧可以正确的查找。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if ([url isKindOfClass:NSString.class]) &#123;</span><br><span class="line">        url = [NSURL URLWithString:(NSString *)url];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (![url isKindOfClass:NSURL.class]) &#123;</span><br><span class="line">        url = nil;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><strong>但是由于API暴露出的是<code>(nullable NSURL *)</code>、如果你传入字符串、会有黄色警告</strong></p>
<ul>
<li><h4 id="读取缓存以及读取磁盘的时候如何保证线程安全？"><a href="#读取缓存以及读取磁盘的时候如何保证线程安全？" class="headerlink" title="读取缓存以及读取磁盘的时候如何保证线程安全？"></a>读取缓存以及读取磁盘的时候如何保证线程安全？</h4></li>
<li><p>读取缓存<br>读取缓存的时候是在主线程进行。由于使用NSCache进行存储、所以不需要担心单个value对象的线程安全。</p>
</li>
<li><p>读取磁盘<br>磁盘的读取虽然创建了一个NSOperation对象、但据我所见这个对象只是用来标记该操作是否被取消、以及取消之后不再读取磁盘文件的作用。<br>真正的磁盘缓存是在另一个<code>IO专属线程</code>中的<code>一个串行队列</code>下进行的。<br>如果你搜索<code>self.ioQueue</code>还能发现、不只是读取磁盘内容。<br>包括删除、写入等所有磁盘内容都是在这个IO线程进行、以保证线程安全。<br>但计算大小、获取文件总数等操作。则是在主线程进行。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">_ioQueue = dispatch_queue_create(&quot;com.hackemist.SDWebImageCache&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">==========&gt;&gt;&gt;&gt;&gt;&lt;&lt;&lt;&lt;&lt;&lt;===========</span><br><span class="line">NSOperation *operation = [NSOperation new];</span><br><span class="line">    dispatch_async(self.ioQueue, ^&#123;</span><br><span class="line">        if (operation.isCancelled) &#123;</span><br><span class="line">            // do not call the completion if cancelled</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @autoreleasepool &#123;</span><br><span class="line">            //搜索硬盘</span><br><span class="line">            NSData *diskData = [self diskImageDataBySearchingAllPathsForKey:key];</span><br><span class="line">            UIImage *diskImage = [self diskImageForKey:key];</span><br><span class="line">            //缓存到内存、默认为YES</span><br><span class="line">            if (diskImage &amp;&amp; self.config.shouldCacheImagesInMemory) &#123;</span><br><span class="line">                NSUInteger cost = SDCacheCostForImage(diskImage);</span><br><span class="line">                //使用NSChache缓存。</span><br><span class="line">                [self.memCache setObject:diskImage forKey:key cost:cost];</span><br><span class="line">            &#125;</span><br><span class="line">            if (doneBlock) &#123;</span><br><span class="line">                dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                    doneBlock(diskImage, diskData, SDImageCacheTypeDisk);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    return operation;</span><br></pre></td></tr></table></figure>
<h3 id="相关知识点"><a href="#相关知识点" class="headerlink" title="相关知识点"></a>相关知识点</h3><p>如果对一些知识点不了解、可能对代码理解造成困扰。列举一下。</p>
<ul>
<li><h4 id="NS-OPTIONS枚举与位运算"><a href="#NS-OPTIONS枚举与位运算" class="headerlink" title="NS_OPTIONS枚举与位运算"></a>NS_OPTIONS枚举与位运算</h4></li>
</ul>
<p>上文中的SDWebImageOptions便是一个位移枚举</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_OPTIONS(NSUInteger, SDWebImageOptions) &#123;</span><br><span class="line">    SDWebImageRetryFailed = 1 &lt;&lt; 0,</span><br><span class="line">    SDWebImageLowPriority = 1 &lt;&lt; 1,</span><br><span class="line">    SDWebImageCacheMemoryOnly = 1 &lt;&lt; 2,        </span><br><span class="line">    SDWebImageProgressiveDownload = 1 &lt;&lt; 3,</span><br><span class="line">    SDWebImageRefreshCached = 1 &lt;&lt; 4,</span><br><span class="line">    SDWebImageContinueInBackground = 1 &lt;&lt; 5,</span><br><span class="line">    SDWebImageHandleCookies = 1 &lt;&lt; 6,</span><br><span class="line">    SDWebImageAllowInvalidSSLCertificates = 1 &lt;&lt; 7,</span><br><span class="line">    SDWebImageHighPriority = 1 &lt;&lt; 8,</span><br><span class="line">    SDWebImageDelayPlaceholder = 1 &lt;&lt; 9,</span><br><span class="line">    SDWebImageTransformAnimatedImage = 1 &lt;&lt; 10,</span><br><span class="line">    SDWebImageAvoidAutoSetImage = 1 &lt;&lt; 11,</span><br><span class="line">    SDWebImageScaleDownLargeImages = 1 &lt;&lt; 12</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>和我们普通用的枚举</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_ENUM(NSInteger, SDImageCacheType) &#123;</span><br><span class="line">    SDImageCacheTypeNone,</span><br><span class="line">    SDImageCacheTypeDisk,</span><br><span class="line">    SDImageCacheTypeMemory</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>从表面看有两点不同：</p>
<ul>
<li>枚举声明：NS_ENUM&amp;&amp; NS_OPTIONS<br>其实从定义的效果上来讲、二者作用相同。<br>更多的是语义化的角度。前者是<code>普通枚举</code>、后者是<code>位移枚举</code>。</li>
<li>枚举中的位运算符号<code>&lt;&lt;</code>.<br>位运算中、有三种基本运算符号.</li>
</ul>
<blockquote>
<ul>
<li><h5 id="按位与”-amp-”"><a href="#按位与”-amp-”" class="headerlink" title="按位与”&amp;”"></a>按位与”&amp;”</h5></li>
</ul>
<p>只有对应的两个二进位<strong><em>均为</em></strong>1时，结果位才为1，否则为0<br>比如9&amp;5，其实就是1001&amp;0101=0001，因此9&amp;5=1&gt;二进制中，与1相&amp;就保持原位，与0相&amp;就为0</p>
<ul>
<li><h5 id="按位或”-”"><a href="#按位或”-”" class="headerlink" title="按位或”|”"></a>按位或”|”</h5></li>
</ul>
<p>只要对应的二个二进位<strong><em>有一个</em></strong>为1时，结果位就为1，否则为0。<br>比如9|5，其实就是1001|0101=1101，因此9|5=13</p>
<ul>
<li><h5 id="左移”-lt-lt-”"><a href="#左移”-lt-lt-”" class="headerlink" title="左移”&lt;&lt;”"></a>左移”&lt;&lt;”</h5></li>
</ul>
<p>把整数a的各二进位全部左移n位，高位丢弃，低位补0。左移n位其实就是乘以2的n次方。<br>例如1&lt;&lt;2 就是0001左移2为0100，因此1&lt;&lt;2=4</p>
</blockquote>
<h5 id="于是、在使用位移枚举的时候、我们就有了这种写法："><a href="#于是、在使用位移枚举的时候、我们就有了这种写法：" class="headerlink" title="于是、在使用位移枚举的时候、我们就有了这种写法："></a>于是、在使用位移枚举的时候、我们就有了这种写法：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">options:SDWebImageRetryFailed | SDWebImageCacheMemoryOnly];</span><br></pre></td></tr></table></figure>
<p>上面的意思是。这个操作是如果失败了需要重试、并且只写入缓存。<br>其中 <code>options=SDWebImageRetryFailed | SDWebImageCacheMemoryOnly</code><br>也就是<code>0b00000001| 0b00000100 = 0b00000101</code> 十进制中 = 5.</p>
<h5 id="在内部判断时候就有了如下写法："><a href="#在内部判断时候就有了如下写法：" class="headerlink" title="在内部判断时候就有了如下写法："></a>在内部判断时候就有了如下写法：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//是否磁盘缓存</span><br><span class="line">BOOL cacheOnDisk = !(options &amp; SDWebImageCacheMemoryOnly);</span><br></pre></td></tr></table></figure>
<p>等价于 <code>0101 &amp; 0100 = 0100</code> 结果为真。<br>倘若</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BOOL lowPriority = !(options &amp; SDWebImageLowPriority);</span><br></pre></td></tr></table></figure>
<p>等价于 <code>0101 &amp; 0010 = 0000</code> 结果为假。</p>
<ul>
<li><h3 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h3></li>
</ul>
<p>在写入缓存时、出现了这样一行代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSUInteger cost = SDCacheCostForImage(diskImage);</span><br><span class="line">[self.memCache setObject:diskImage forKey:key cost:cost];</span><br></pre></td></tr></table></figure>
<p>其中SDCacheCostForImage指向一个静态内联函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FOUNDATION_STATIC_INLINE NSUInteger SDCacheCostForImage(UIImage *image) &#123;</span><br><span class="line">#if SD_MAC</span><br><span class="line">    return image.size.height * image.size.width;</span><br><span class="line">#elif SD_UIKIT || SD_WATCH</span><br><span class="line">    return image.size.height * image.size.width * image.scale * image.scale;</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中FOUNDATION_STATIC_INLINE作为宏指向static <strong>inline</strong>、所以也等价于</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static __inline__ NSUInteger SDCacheCostForImage(UIImage *image) &#123;</span><br><span class="line">#if SD_MAC</span><br><span class="line">    return image.size.height * image.size.width;</span><br><span class="line">#elif SD_UIKIT || SD_WATCH</span><br><span class="line">    return image.size.height * image.size.width * image.scale * image.scale;</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用宏写方法、我们都用过。但是表达式形式的宏定义有一定的弊端。（比如参数检查、越界等等）。</p>
<h6 id="内联函数完全可以取代表达式形式的宏定义。"><a href="#内联函数完全可以取代表达式形式的宏定义。" class="headerlink" title="内联函数完全可以取代表达式形式的宏定义。"></a>内联函数完全可以取代表达式形式的宏定义。</h6><p>顺便谈谈为什么要用内联函数吧。</p>
<ul>
<li>效率来看<ul>
<li>函数之间调用，是<strong>内存地址之间的调用</strong>、当函数调用完毕之后还会返回原来函数执行的地址。函数调用将会有时间开销。</li>
<li>内联函数在汇编中没有call语句。取消了函数的参数压栈</li>
</ul>
</li>
<li>相比表达式形式的宏定义<ul>
<li>需要预编译.因为inline内联函数也是函数、不需要预编译。</li>
<li>调用时候会首先检查它的参数的类型、保证调用正确。</li>
<li>可以使用所在类的保护成员及私有成员。</li>
</ul>
</li>
</ul>
<h5 id="需要注意的是"><a href="#需要注意的是" class="headerlink" title="需要注意的是"></a>需要注意的是</h5><ul>
<li>内联函数中尽量不要使用诸如循环语句等大量代码、可能会导致编译器放弃内联动作。</li>
<li>内联函数的定义须在调用之前。</li>
</ul>
<h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>随手下载了一个最新的 <strong>(4.2.3)</strong></p>
<h3 id="GitHub"><a href="#GitHub" class="headerlink" title="GitHub"></a><a href="https://link.jianshu.com?t=https%3A%2F%2Fgithub.com%2Frs%2FSDWebImage" target="_blank" rel="noopener">GitHub</a></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">PODS:</span><br><span class="line">- SDWebImage (4.2.3):</span><br><span class="line">- SDWebImage/Core (= 4.2.3)</span><br><span class="line">- SDWebImage/Core (4.2.3)</span><br><span class="line"></span><br><span class="line">DEPENDENCIES:</span><br><span class="line">- SDWebImage</span><br><span class="line"></span><br><span class="line">SPEC CHECKSUMS:</span><br><span class="line">SDWebImage: 791bb72962b3492327ddcac4b1880bd1b5458431</span><br><span class="line"></span><br><span class="line">PODFILE CHECKSUM: 7fbc0b76fb4d0b0b2afa7d3a90b7bd68dea25abb</span><br><span class="line"></span><br><span class="line">COCOAPODS: 1.3.1</span><br></pre></td></tr></table></figure>
<h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p>引用GitHub上一个导图</p>
<ul>
<li>1、外部API入口。<br>通过<code>UIImageView+WebCache</code> 的 <code>sd_setImageWithURL</code>方法(等)作为入口来加载图片。</li>
<li>2、内部API汇总。<br>通过<code>UIView+WebCache</code>的’sd_internalSetImageWithURL’对UIImageView、UIButton 、MKAnnotationView中图片的下载请求进行汇总。</li>
<li>3、开始加载图片。<br>通过<code>SDWebImageManager</code>的<code>loadImageWithURL</code>对图片进行加载。</li>
<li>4、查找本地<br>通过<code>SDImageCache</code>的<code>queryCacheOperationForKey</code>查找缓存中是否存在图片。如果不存在再通过<code>diskImageDataBySearchingAllPathsForKey</code>进行磁盘搜索。</li>
<li>5、返回本地图片给<code>SDWebImageManager</code></li>
<li>6、下载图片<br>如果本地查询不到对应图片、则通过<code>SDImageDownloader</code>的<code>downloadImage</code>进行图片下载。</li>
<li>7、下载完毕返回图片给<code>SDWebImageManager</code></li>
<li>8、由<code>UIView+WebCache</code>通过<code>storeImage</code>将下载图片保存本地</li>
<li>9、返回图片给<code>UIView+WebCache</code></li>
<li>10、设置图片<br>其中。</li>
</ul>
<h3 id="业务层级"><a href="#业务层级" class="headerlink" title="业务层级"></a>业务层级</h3><ul>
<li>整个架构简单分为三层。</li>
</ul>
<h4 id="最上层："><a href="#最上层：" class="headerlink" title="最上层："></a>最上层：</h4><p>负责业务的接入、图片的插入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;UIImageView+WebCache.h&quot;</span><br><span class="line">#import &quot;UIButton+WebCache.h&quot;</span><br><span class="line">#import &quot;UIImageView+HighlightedWebCache.h&quot;</span><br><span class="line">//以及其汇总的</span><br><span class="line">#import &quot;UIView+WebCache.h&quot;</span><br></pre></td></tr></table></figure>
<h4 id="逻辑层"><a href="#逻辑层" class="headerlink" title="逻辑层"></a>逻辑层</h4><p>负责不同类型业务的分发。<br>读取(或写入)缓存(或磁盘)、下载等具体逻辑处理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;SDWebImageManager.h&quot;</span><br></pre></td></tr></table></figure>
<h3 id="业务层"><a href="#业务层" class="headerlink" title="业务层"></a>业务层</h3><p>负责具体业务的实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//缓存&amp;&amp;磁盘操作</span><br><span class="line">#import &quot;SDImageCache.h&quot;</span><br><span class="line">//下载操作</span><br><span class="line">#import &quot;SDWebImageDownloader.h&quot;</span><br></pre></td></tr></table></figure>
<p>当然、还有其他的工具类。但主要的、就是上面几个。</p>
<h3 id="核心代码（正常读取下载图片）"><a href="#核心代码（正常读取下载图片）" class="headerlink" title="核心代码（正常读取下载图片）"></a>核心代码（正常读取下载图片）</h3><ul>
<li><h4 id="最上层：UIView-WebCache"><a href="#最上层：UIView-WebCache" class="headerlink" title="最上层：UIView+WebCache"></a>最上层：UIView+WebCache</h4></li>
</ul>
<p>所有的代码最终都会汇总到</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;UIView+WebCache.h&quot;</span><br><span class="line">/**</span><br><span class="line"> * @param url            图片地址链接</span><br><span class="line"> * @param placeholder    占位图</span><br><span class="line"> * @param options        下载图片的枚举。包括优先级、是否写入硬盘等</span><br><span class="line"> * @param operationKey   一个记录当前对象正在加载操作的key、保证只有最新的操作在进行、默认为类名。</span><br><span class="line">                         所以如果你想下载多个图片并且都展示一下、可以尝试自定义几个operationKey来操作。（我猜）</span><br><span class="line"> * @param setImageBlock  给开发者自定义set图片的callback</span><br><span class="line"> * @param progressBlock  下载进度callback</span><br><span class="line"> * @param completedBlock 下载完成的callback（sd已经给你set好了、只是会把图片给你罢了）</span><br><span class="line"> * @param context        一些额外的上下文字典。比如你可以搞一个专属的imageManager进来干活。</span><br><span class="line"> */</span><br><span class="line">- (void)sd_internalSetImageWithURL:(nullable NSURL *)url</span><br><span class="line">                  placeholderImage:(nullable UIImage *)placeholder</span><br><span class="line">                           options:(SDWebImageOptions)options</span><br><span class="line">                      operationKey:(nullable NSString *)operationKey</span><br><span class="line">                     setImageBlock:(nullable SDSetImageBlock)setImageBlock</span><br><span class="line">                          progress:(nullable SDWebImageDownloaderProgressBlock)progressBlock</span><br><span class="line">                         completed:(nullable SDExternalCompletionBlock)completedBlock</span><br><span class="line">                           context:(nullable NSDictionary *)context &#123;</span><br><span class="line">    //以当前实例的class作为OperationKey</span><br><span class="line">    NSString *validOperationKey = operationKey ?: NSStringFromClass([self class]);</span><br><span class="line">    //清除当前OperationKey下正在进行的操作。节省无用功</span><br><span class="line">    [self sd_cancelImageLoadOperationWithKey:validOperationKey];</span><br><span class="line">    //给对象实例绑定imageURLKey = url</span><br><span class="line">    objc_setAssociatedObject(self, &amp;imageURLKey, url, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">    //是否先加载占位图</span><br><span class="line">    if (!(options &amp; SDWebImageDelayPlaceholder)) &#123;</span><br><span class="line">        if ([context valueForKey:SDWebImageInternalSetImageGroupKey]) &#123;</span><br><span class="line">            dispatch_group_t group = [context valueForKey:SDWebImageInternalSetImageGroupKey];</span><br><span class="line">            dispatch_group_enter(group);</span><br><span class="line">        &#125;</span><br><span class="line">        //到主线城更新UI</span><br><span class="line">        dispatch_main_async_safe(^&#123;</span><br><span class="line">            //set 占位图</span><br><span class="line">            [self sd_setImage:placeholder imageData:nil basedOnClassOrViaCustomSetImageBlock:setImageBlock];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (url) &#123;</span><br><span class="line">        // 小菊花</span><br><span class="line">        if ([self sd_showActivityIndicatorView]) &#123;</span><br><span class="line">            [self sd_addActivityIndicator];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 允许开发者指定一个manager来进行操作</span><br><span class="line">        SDWebImageManager *manager;</span><br><span class="line">        if ([context valueForKey:SDWebImageExternalCustomManagerKey]) &#123;</span><br><span class="line">            manager = (SDWebImageManager *)[context valueForKey:SDWebImageExternalCustomManagerKey];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            manager = [SDWebImageManager sharedManager];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        __weak __typeof(self)wself = self;</span><br><span class="line">        id &lt;SDWebImageOperation&gt; operation = [manager loadImageWithURL:url options:options progress:progressBlock completed:^(UIImage *image, NSData *data, NSError *error, SDImageCacheType cacheType, BOOL finished, NSURL *imageURL) &#123;</span><br><span class="line">            //图片下载||读取完成</span><br><span class="line">            __strong __typeof (wself) sself = wself;</span><br><span class="line">            //小菊花</span><br><span class="line">            [sself sd_removeActivityIndicator];</span><br><span class="line">            if (!sself) &#123; return; &#125;</span><br><span class="line">            BOOL shouldCallCompletedBlock = finished || (options &amp; SDWebImageAvoidAutoSetImage);</span><br><span class="line">            //是否不插入图片</span><br><span class="line">            //1、有图片、但是主动配置</span><br><span class="line">            //2、没图片、设置了延迟加载占位图</span><br><span class="line">            BOOL shouldNotSetImage = ((image &amp;&amp; (options &amp; SDWebImageAvoidAutoSetImage)) ||</span><br><span class="line">                                      (!image &amp;&amp; !(options &amp; SDWebImageDelayPlaceholder)));</span><br><span class="line">            SDWebImageNoParamsBlock callCompletedBlockClojure = ^&#123;</span><br><span class="line">                //</span><br><span class="line">                if (!sself) &#123; return; &#125;</span><br><span class="line">                if (!shouldNotSetImage) &#123;</span><br><span class="line">                    [sself sd_setNeedsLayout];</span><br><span class="line">                &#125;</span><br><span class="line">                if (completedBlock &amp;&amp; shouldCallCompletedBlock) &#123;</span><br><span class="line">                    //操作完成的回调</span><br><span class="line">                    completedBlock(image, error, cacheType, url);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            // case 1a: we got an image, but the SDWebImageAvoidAutoSetImage flag is set</span><br><span class="line">            // OR</span><br><span class="line">            // case 1b: we got no image and the SDWebImageDelayPlaceholder is not set</span><br><span class="line">            if (shouldNotSetImage) &#123;</span><br><span class="line">                //如果不显示图片、直接回调。</span><br><span class="line">                dispatch_main_async_safe(callCompletedBlockClojure);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            /**自动插入图片***/</span><br><span class="line"></span><br><span class="line">            UIImage *targetImage = nil;</span><br><span class="line">            NSData *targetData = nil;</span><br><span class="line">            if (image) &#123;</span><br><span class="line">                // case 2a: we got an image and the SDWebImageAvoidAutoSetImage is not set</span><br><span class="line">                targetImage = image;</span><br><span class="line">                targetData = data;</span><br><span class="line">            &#125; else if (options &amp; SDWebImageDelayPlaceholder) &#123;</span><br><span class="line">                // case 2b: we got no image and the SDWebImageDelayPlaceholder flag is set</span><br><span class="line">                targetImage = placeholder;</span><br><span class="line">                targetData = nil;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if ([context valueForKey:SDWebImageInternalSetImageGroupKey]) &#123;</span><br><span class="line">                dispatch_group_t group = [context valueForKey:SDWebImageInternalSetImageGroupKey];</span><br><span class="line">                dispatch_group_enter(group);</span><br><span class="line">                dispatch_main_async_safe(^&#123;</span><br><span class="line">                    [sself sd_setImage:targetImage imageData:targetData basedOnClassOrViaCustomSetImageBlock:setImageBlock];</span><br><span class="line">                &#125;);</span><br><span class="line">                // ensure completion block is called after custom setImage process finish</span><br><span class="line">                dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                    callCompletedBlockClojure();</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                dispatch_main_async_safe(^&#123;</span><br><span class="line">                    [sself sd_setImage:targetImage imageData:targetData basedOnClassOrViaCustomSetImageBlock:setImageBlock];</span><br><span class="line">                    callCompletedBlockClojure();</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;];</span><br><span class="line"></span><br><span class="line">        //在读取图片之前。向正在进行加载的HashMap中加入当前operation</span><br><span class="line">        [self sd_setImageLoadOperation:operation forKey:validOperationKey];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        dispatch_main_async_safe(^&#123;</span><br><span class="line">            [self sd_removeActivityIndicator];</span><br><span class="line">            if (completedBlock) &#123;</span><br><span class="line">                NSError *error = [NSError errorWithDomain:SDWebImageErrorDomain code:-1 userInfo:@&#123;NSLocalizedDescriptionKey : @&quot;Trying to load a nil url&quot;&#125;];</span><br><span class="line">                completedBlock(nil, error, SDImageCacheTypeNone, url);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个简单的流程图</p>
<p><img src="upload-images.jianshu.io/upload_images/1552225-c7160080bd1d9a13.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt=""></p>
<p>UIView+WebCache流程图</p>
<ul>
<li><h4 id="逻辑层：SDWebImageManager"><a href="#逻辑层：SDWebImageManager" class="headerlink" title="逻辑层：SDWebImageManager"></a>逻辑层：SDWebImageManager</h4></li>
</ul>
<p>SDWebImage中最核心的类、调度这图片的下载(<code>SDWebImageDownloader</code>)以及缓存(<code>SDImageCache</code>)。</p>
<h5 id="此外、SDWebImageManager并不依托于UIView-WebCache、完全可以单独使用。"><a href="#此外、SDWebImageManager并不依托于UIView-WebCache、完全可以单独使用。" class="headerlink" title="此外、SDWebImageManager并不依托于UIView+WebCache、完全可以单独使用。"></a>此外、<code>SDWebImageManager</code>并不依托于<code>UIView+WebCache</code>、完全可以单独使用。</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br></pre></td><td class="code"><pre><span class="line">- (id &lt;SDWebImageOperation&gt;)loadImageWithURL:(nullable NSURL *)url</span><br><span class="line">                                     options:(SDWebImageOptions)options</span><br><span class="line">                                    progress:(nullable SDWebImageDownloaderProgressBlock)progressBlock</span><br><span class="line">                                   completed:(nullable SDInternalCompletionBlock)completedBlock &#123;</span><br><span class="line"></span><br><span class="line">    NSAssert(completedBlock != nil, @&quot;If you mean to prefetch the image, use -[SDWebImagePrefetcher prefetchURLs] instead&quot;);</span><br><span class="line"></span><br><span class="line">    //所以、我们并不需要在外部把字符串变为NSURL。</span><br><span class="line">    if ([url isKindOfClass:NSString.class]) &#123;</span><br><span class="line">        url = [NSURL URLWithString:(NSString *)url];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (![url isKindOfClass:NSURL.class]) &#123;</span><br><span class="line">        url = nil;</span><br><span class="line">    &#125;</span><br><span class="line">    //下载操作的对象</span><br><span class="line">    __block SDWebImageCombinedOperation *operation = [SDWebImageCombinedOperation new];</span><br><span class="line">    __weak SDWebImageCombinedOperation *weakOperation = operation;</span><br><span class="line"></span><br><span class="line">    BOOL isFailedUrl = NO;</span><br><span class="line">    if (url) &#123;</span><br><span class="line">        @synchronized (self.failedURLs) &#123;</span><br><span class="line">            //线程安全</span><br><span class="line">            isFailedUrl = [self.failedURLs containsObject:url];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //url为空 || (未设置失败重试 &amp;&amp; 这个url已经失败过)</span><br><span class="line">    if (url.absoluteString.length == 0 || (!(options &amp; SDWebImageRetryFailed) &amp;&amp; isFailedUrl)) &#123;</span><br><span class="line">        //发出一个获取失败的回调</span><br><span class="line">        [self callCompletionBlockForOperation:operation completion:completedBlock error:[NSError errorWithDomain:NSURLErrorDomain code:NSURLErrorFileDoesNotExist userInfo:nil] url:url];</span><br><span class="line">        return operation;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //将操作添加到正在进行的操作数池</span><br><span class="line">    @synchronized (self.runningOperations) &#123;</span><br><span class="line">        [self.runningOperations addObject:operation];</span><br><span class="line">    &#125;</span><br><span class="line">    //默认就是url作为key、也可以自定义mananger的相关block</span><br><span class="line">    NSString *key = [self cacheKeyForURL:url];</span><br><span class="line">    //通过key、查找本地图片</span><br><span class="line">    operation.cacheOperation = [self.imageCache queryCacheOperationForKey:key done:^(UIImage *cachedImage, NSData *cachedData, SDImageCacheType cacheType) &#123;</span><br><span class="line">        if (operation.isCancelled) &#123;</span><br><span class="line">            //操作被取消、移除操作池</span><br><span class="line">            [self safelyRemoveOperationFromRunning:operation];</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //本地没有图片 || 刷新缓存</span><br><span class="line">        if ((!cachedImage || options &amp; SDWebImageRefreshCached) &amp;&amp; (![self.delegate respondsToSelector:@selector(imageManager:shouldDownloadImageForURL:)] || [self.delegate imageManager:self shouldDownloadImageForURL:url])) &#123;</span><br><span class="line">            //有本地图片。但需要被刷新</span><br><span class="line">            if (cachedImage &amp;&amp; options &amp; SDWebImageRefreshCached) &#123;</span><br><span class="line">                //先回调出去本地图片。再继续下载操作</span><br><span class="line">                [self callCompletionBlockForOperation:weakOperation completion:completedBlock image:cachedImage data:cachedData error:nil cacheType:cacheType finished:YES url:url];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //下面是根据调用者传进来的option，来匹配设置了哪些，就给downloaderOptions赋值哪些option</span><br><span class="line">            SDWebImageDownloaderOptions downloaderOptions = 0;</span><br><span class="line">            if (options &amp; SDWebImageLowPriority) downloaderOptions |= SDWebImageDownloaderLowPriority;</span><br><span class="line">            if (options &amp; SDWebImageProgressiveDownload) downloaderOptions |= SDWebImageDownloaderProgressiveDownload;</span><br><span class="line">            if (options &amp; SDWebImageRefreshCached) downloaderOptions |= SDWebImageDownloaderUseNSURLCache;</span><br><span class="line">            if (options &amp; SDWebImageContinueInBackground) downloaderOptions |= SDWebImageDownloaderContinueInBackground;</span><br><span class="line">            if (options &amp; SDWebImageHandleCookies) downloaderOptions |= SDWebImageDownloaderHandleCookies;</span><br><span class="line">            if (options &amp; SDWebImageAllowInvalidSSLCertificates) downloaderOptions |= SDWebImageDownloaderAllowInvalidSSLCertificates;</span><br><span class="line">            if (options &amp; SDWebImageHighPriority) downloaderOptions |= SDWebImageDownloaderHighPriority;</span><br><span class="line">            if (options &amp; SDWebImageScaleDownLargeImages) downloaderOptions |= SDWebImageDownloaderScaleDownLargeImages;</span><br><span class="line"></span><br><span class="line">            if (cachedImage &amp;&amp; options &amp; SDWebImageRefreshCached) &#123;</span><br><span class="line">                // force progressive off if image already cached but forced refreshing</span><br><span class="line">                downloaderOptions &amp;= ~SDWebImageDownloaderProgressiveDownload;</span><br><span class="line">                // ignore image read from NSURLCache if image if cached but force refreshing</span><br><span class="line">                downloaderOptions |= SDWebImageDownloaderIgnoreCachedResponse;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //下载图片</span><br><span class="line">            SDWebImageDownloadToken *subOperationToken = [self.imageDownloader downloadImageWithURL:url options:downloaderOptions progress:progressBlock completed:^(UIImage *downloadedImage, NSData *downloadedData, NSError *error, BOOL finished) &#123;</span><br><span class="line">                __strong __typeof(weakOperation) strongOperation = weakOperation;</span><br><span class="line">                if (!strongOperation || strongOperation.isCancelled) &#123;</span><br><span class="line">                    // Do nothing if the operation was cancelled</span><br><span class="line">                    // See #699 for more details</span><br><span class="line">                    // if we would call the completedBlock, there could be a race condition between this block and another completedBlock for the same object, so if this one is called second, we will overwrite the new data</span><br><span class="line">                &#125; else if (error) &#123;</span><br><span class="line">                    [self callCompletionBlockForOperation:strongOperation completion:completedBlock error:error url:url];</span><br><span class="line"></span><br><span class="line">                    if (   error.code != NSURLErrorNotConnectedToInternet</span><br><span class="line">                        &amp;&amp; error.code != NSURLErrorCancelled</span><br><span class="line">                        &amp;&amp; error.code != NSURLErrorTimedOut</span><br><span class="line">                        &amp;&amp; error.code != NSURLErrorInternationalRoamingOff</span><br><span class="line">                        &amp;&amp; error.code != NSURLErrorDataNotAllowed</span><br><span class="line">                        &amp;&amp; error.code != NSURLErrorCannotFindHost</span><br><span class="line">                        &amp;&amp; error.code != NSURLErrorCannotConnectToHost</span><br><span class="line">                        &amp;&amp; error.code != NSURLErrorNetworkConnectionLost) &#123;</span><br><span class="line">                        @synchronized (self.failedURLs) &#123;</span><br><span class="line">                            //失败记录</span><br><span class="line">                            [self.failedURLs addObject:url];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                    if ((options &amp; SDWebImageRetryFailed)) &#123;</span><br><span class="line">                        //失败重新下载</span><br><span class="line">                        @synchronized (self.failedURLs) &#123;</span><br><span class="line">                            //从失败记录移除</span><br><span class="line">                            [self.failedURLs removeObject:url];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    //是否磁盘缓存</span><br><span class="line">                    BOOL cacheOnDisk = !(options &amp; SDWebImageCacheMemoryOnly);</span><br><span class="line"></span><br><span class="line">                    if (self != [SDWebImageManager sharedManager] &amp;&amp; self.cacheKeyFilter &amp;&amp; downloadedImage) &#123;</span><br><span class="line">                        //缩放</span><br><span class="line">                        downloadedImage = [self scaledImageForKey:key image:downloadedImage];</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    if (options &amp; SDWebImageRefreshCached &amp;&amp; cachedImage &amp;&amp; !downloadedImage) &#123;</span><br><span class="line"></span><br><span class="line">                        //是否需要转换图片</span><br><span class="line">                        //成功下载图片、自定义实现了图片处理的代理</span><br><span class="line">                    &#125; else if (downloadedImage &amp;&amp; (!downloadedImage.images || (options &amp; SDWebImageTransformAnimatedImage)) &amp;&amp; [self.delegate respondsToSelector:@selector(imageManager:transformDownloadedImage:withURL:)]) &#123;</span><br><span class="line">                        dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^&#123;</span><br><span class="line">                            //获取转换用户后的图片</span><br><span class="line">                            UIImage *transformedImage = [self.delegate imageManager:self transformDownloadedImage:downloadedImage withURL:url];</span><br><span class="line"></span><br><span class="line">                            //用户处理成功</span><br><span class="line">                            if (transformedImage &amp;&amp; finished) &#123;</span><br><span class="line">                                BOOL imageWasTransformed = ![transformedImage isEqual:downloadedImage];</span><br><span class="line"></span><br><span class="line">                                //用户处理的后若未生成新的图片、则保存下载的二进制文件。</span><br><span class="line">                                //不然则由imageCache内部生成二进制文件保存</span><br><span class="line">                                [self.imageCache storeImage:transformedImage imageData:(imageWasTransformed ? nil : downloadedData) forKey:key toDisk:cacheOnDisk completion:nil];</span><br><span class="line">                            &#125;</span><br><span class="line">                            //回调</span><br><span class="line">                            [self callCompletionBlockForOperation:strongOperation completion:completedBlock image:transformedImage data:downloadedData error:nil cacheType:SDImageCacheTypeNone finished:finished url:url];</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        //下载成功且未自定义代理--默认保存</span><br><span class="line">                        if (downloadedImage &amp;&amp; finished) &#123;</span><br><span class="line">                            [self.imageCache storeImage:downloadedImage imageData:downloadedData forKey:key toDisk:cacheOnDisk completion:nil];</span><br><span class="line">                        &#125;</span><br><span class="line">                        [self callCompletionBlockForOperation:strongOperation completion:completedBlock image:downloadedImage data:downloadedData error:nil cacheType:SDImageCacheTypeNone finished:finished url:url];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (finished) &#123;</span><br><span class="line">                    [self safelyRemoveOperationFromRunning:strongOperation];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;];</span><br><span class="line">            @synchronized(operation) &#123;</span><br><span class="line">                operation.cancelBlock = ^&#123;</span><br><span class="line">                    [self.imageDownloader cancel:subOperationToken];</span><br><span class="line">                    __strong __typeof(weakOperation) strongOperation = weakOperation;</span><br><span class="line">                    [self safelyRemoveOperationFromRunning:strongOperation];</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if (cachedImage) &#123;</span><br><span class="line">            //本地有图片--回调、关闭当前操作</span><br><span class="line">            __strong __typeof(weakOperation) strongOperation = weakOperation;</span><br><span class="line">            [self callCompletionBlockForOperation:strongOperation completion:completedBlock image:cachedImage data:cachedData error:nil cacheType:cacheType finished:YES url:url];</span><br><span class="line">            [self safelyRemoveOperationFromRunning:operation];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //本地没有、也不下载--回调、关闭当前操作</span><br><span class="line">            __strong __typeof(weakOperation) strongOperation = weakOperation;</span><br><span class="line">            [self callCompletionBlockForOperation:strongOperation completion:completedBlock image:nil data:nil error:nil cacheType:SDImageCacheTypeNone finished:YES url:url];</span><br><span class="line">            [self safelyRemoveOperationFromRunning:operation];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    return operation;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="upload-images.jianshu.io/upload_images/1552225-78b89b7c11951cba.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt=""></p>
<p>SDWebImageManager流程图</p>
<ul>
<li><h4 id="业务层-1"><a href="#业务层-1" class="headerlink" title="业务层:"></a>业务层:</h4></li>
</ul>
<h4 id="缓存-amp-amp-磁盘操作-SDImageCache"><a href="#缓存-amp-amp-磁盘操作-SDImageCache" class="headerlink" title="缓存&amp;&amp;磁盘操作(SDImageCache)"></a>缓存&amp;&amp;磁盘操作(SDImageCache)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line">- (nullable NSOperation *)queryCacheOperationForKey:(nullable NSString *)key done:(nullable SDCacheQueryCompletedBlock)doneBlock &#123;</span><br><span class="line">    if (!key) &#123;</span><br><span class="line">        if (doneBlock) &#123;</span><br><span class="line">            doneBlock(nil, nil, SDImageCacheTypeNone);</span><br><span class="line">        &#125;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    // First check the in-memory cache...</span><br><span class="line">    //搜索磁盘缓存</span><br><span class="line">    UIImage *image = [self imageFromMemoryCacheForKey:key];</span><br><span class="line">    if (image) &#123;</span><br><span class="line">        NSData *diskData = nil;</span><br><span class="line">        if (image.images) &#123;</span><br><span class="line">            diskData = [self diskImageDataBySearchingAllPathsForKey:key];</span><br><span class="line">        &#125;</span><br><span class="line">        if (doneBlock) &#123;</span><br><span class="line">            doneBlock(image, diskData, SDImageCacheTypeMemory);</span><br><span class="line">        &#125;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    NSOperation *operation = [NSOperation new];</span><br><span class="line">    dispatch_async(self.ioQueue, ^&#123;</span><br><span class="line">        if (operation.isCancelled) &#123;</span><br><span class="line">            // do not call the completion if cancelled</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @autoreleasepool &#123;</span><br><span class="line">            //搜索硬盘</span><br><span class="line">            NSData *diskData = [self diskImageDataBySearchingAllPathsForKey:key];</span><br><span class="line">            UIImage *diskImage = [self diskImageForKey:key];</span><br><span class="line">            //缓存到内存、默认为YES</span><br><span class="line">            if (diskImage &amp;&amp; self.config.shouldCacheImagesInMemory) &#123;</span><br><span class="line">                NSUInteger cost = SDCacheCostForImage(diskImage);</span><br><span class="line">                //使用NSChache缓存。</span><br><span class="line">                [self.memCache setObject:diskImage forKey:key cost:cost];</span><br><span class="line">            &#125;</span><br><span class="line">            if (doneBlock) &#123;</span><br><span class="line">                dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                    doneBlock(diskImage, diskData, SDImageCacheTypeDisk);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    return operation;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//查询缓存</span><br><span class="line">- (nullable UIImage *)imageFromMemoryCacheForKey:(nullable NSString *)key &#123;</span><br><span class="line">    //self.memCache  为NSCache实例</span><br><span class="line">    return [self.memCache objectForKey:key];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//查询磁盘</span><br><span class="line">- (nullable UIImage *)diskImageForKey:(nullable NSString *)key &#123;</span><br><span class="line">    NSData *data = [self diskImageDataBySearchingAllPathsForKey:key];</span><br><span class="line">    if (data) &#123;</span><br><span class="line">        //图片解码、调整方向</span><br><span class="line">        UIImage *image = [[SDWebImageCodersManager sharedInstance] decodedImageWithData:data];</span><br><span class="line">        //调整图片缩放比例 @2x/@3x</span><br><span class="line">        image = [self scaledImageForKey:key image:image];</span><br><span class="line">        //压缩图片</span><br><span class="line">        if (self.config.shouldDecompressImages) &#123;</span><br><span class="line">            image = [[SDWebImageCodersManager sharedInstance] decompressedImageWithImage:image data:&amp;data options:@&#123;SDWebImageCoderScaleDownLargeImagesKey: @(NO)&#125;];</span><br><span class="line">        &#125;</span><br><span class="line">        return image;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//写入缓存 &amp;&amp; 磁盘</span><br><span class="line">- (void)storeImage:(nullable UIImage *)image</span><br><span class="line">         imageData:(nullable NSData *)imageData</span><br><span class="line">            forKey:(nullable NSString *)key</span><br><span class="line">            toDisk:(BOOL)toDisk</span><br><span class="line">        completion:(nullable SDWebImageNoParamsBlock)completionBlock &#123;</span><br><span class="line">    if (!image || !key) &#123;</span><br><span class="line">        if (completionBlock) &#123;</span><br><span class="line">            completionBlock();</span><br><span class="line">        &#125;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    // if memory cache is enabled</span><br><span class="line">    if (self.config.shouldCacheImagesInMemory) &#123;</span><br><span class="line">        //写入缓存</span><br><span class="line">        NSUInteger cost = SDCacheCostForImage(image);</span><br><span class="line">        [self.memCache setObject:image forKey:key cost:cost];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (toDisk) &#123;</span><br><span class="line">        //写入磁盘</span><br><span class="line">        dispatch_async(self.ioQueue, ^&#123;</span><br><span class="line">            @autoreleasepool &#123;</span><br><span class="line">                NSData *data = imageData;</span><br><span class="line">                if (!data &amp;&amp; image) &#123;</span><br><span class="line">                    // If we do not have any data to detect image format, check whether it contains alpha channel to use PNG or JPEG format</span><br><span class="line">                    SDImageFormat format;</span><br><span class="line">                    if (SDCGImageRefContainsAlpha(image.CGImage)) &#123;</span><br><span class="line">                        format = SDImageFormatPNG;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        format = SDImageFormatJPEG;</span><br><span class="line">                    &#125;</span><br><span class="line">                    data = [[SDWebImageCodersManager sharedInstance] encodedDataWithImage:image format:format];</span><br><span class="line">                &#125;</span><br><span class="line">                [self storeImageDataToDisk:data forKey:key];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (completionBlock) &#123;</span><br><span class="line">                dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                    completionBlock();</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (completionBlock) &#123;</span><br><span class="line">            completionBlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//正式写入磁盘</span><br><span class="line">- (void)storeImageDataToDisk:(nullable NSData *)imageData forKey:(nullable NSString *)key &#123;</span><br><span class="line">    if (!imageData || !key) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [self checkIfQueueIsIOQueue];</span><br><span class="line">    //如果文件中不存在磁盘缓存路径 则创建</span><br><span class="line">    if (![_fileManager fileExistsAtPath:_diskCachePath]) &#123;</span><br><span class="line">        [_fileManager createDirectoryAtPath:_diskCachePath withIntermediateDirectories:YES attributes:nil error:NULL];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // get cache Path for image key  得到该key的缓存路径</span><br><span class="line">    NSString *cachePathForKey = [self defaultCachePathForKey:key];</span><br><span class="line">    // transform to NSUrl  将缓存路径转化为url</span><br><span class="line">    NSURL *fileURL = [NSURL fileURLWithPath:cachePathForKey];</span><br><span class="line">    //将imageData存储起来</span><br><span class="line">    [_fileManager createFileAtPath:cachePathForKey contents:imageData attributes:nil];</span><br><span class="line"></span><br><span class="line">    // disable iCloud backup  如果调用者关闭icloud 关闭iCloud备份</span><br><span class="line">    if (self.config.shouldDisableiCloud) &#123;</span><br><span class="line">        [fileURL setResourceValue:@YES forKey:NSURLIsExcludedFromBackupKey error:nil];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于此处只归纳正常读取下载流程的代码、所以其余关于图片过期&amp;&amp;释放流程的代码没有列出。后面会逐一进行归纳。</p>
<p><img src="upload-images.jianshu.io/upload_images/1552225-2e404fd11ffdb6e4.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt=""></p>
<p>查找本地流程图</p>
<h4 id="下载操作-SDWebImageDownloader"><a href="#下载操作-SDWebImageDownloader" class="headerlink" title="下载操作(SDWebImageDownloader)"></a>下载操作(SDWebImageDownloader)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line">- (nullable SDWebImageDownloadToken *)downloadImageWithURL:(nullable NSURL *)url</span><br><span class="line">                                                   options:(SDWebImageDownloaderOptions)options</span><br><span class="line">                                                  progress:(nullable SDWebImageDownloaderProgressBlock)progressBlock</span><br><span class="line">                                                 completed:(nullable SDWebImageDownloaderCompletedBlock)completedBlock &#123;</span><br><span class="line">    __weak SDWebImageDownloader *wself = self;</span><br><span class="line"></span><br><span class="line">    return [self addProgressCallback:progressBlock completedBlock:completedBlock forURL:url createCallback:^SDWebImageDownloaderOperation *&#123;</span><br><span class="line">        //创建下载operation</span><br><span class="line">        __strong __typeof (wself) sself = wself;</span><br><span class="line">        //超时时间</span><br><span class="line">        NSTimeInterval timeoutInterval = sself.downloadTimeout;</span><br><span class="line">        if (timeoutInterval == 0.0) &#123;</span><br><span class="line">            timeoutInterval = 15.0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // In order to prevent from potential duplicate caching (NSURLCache + SDImageCache) we disable the cache for image requests if told otherwise</span><br><span class="line"></span><br><span class="line">        //创建下载策略</span><br><span class="line">        //SDWebImageDownloaderUseNSURLCache 则使用 NSURLRequestUseProtocolCachePolicy 缓存协议</span><br><span class="line">        //默认NSURLRequestReloadIgnoringLocalCacheData从原地址重新下载</span><br><span class="line">        NSURLRequestCachePolicy cachePolicy = options &amp; SDWebImageDownloaderUseNSURLCache ? NSURLRequestUseProtocolCachePolicy : NSURLRequestReloadIgnoringLocalCacheData;</span><br><span class="line"></span><br><span class="line">        //创建下载请求</span><br><span class="line">        NSMutableURLRequest *request = [[NSMutableURLRequest alloc] initWithURL:url</span><br><span class="line">                                                                    cachePolicy:cachePolicy</span><br><span class="line">                                                                timeoutInterval:timeoutInterval];</span><br><span class="line"></span><br><span class="line">        request.HTTPShouldHandleCookies = (options &amp; SDWebImageDownloaderHandleCookies);</span><br><span class="line">        request.HTTPShouldUsePipelining = YES;</span><br><span class="line">        if (sself.headersFilter) &#123;</span><br><span class="line">            request.allHTTPHeaderFields = sself.headersFilter(url, [sself.HTTPHeaders copy]);</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            //默认 image/*;q=0.8</span><br><span class="line">            request.allHTTPHeaderFields = sself.HTTPHeaders;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //创建下载操作</span><br><span class="line">        SDWebImageDownloaderOperation *operation = [[sself.operationClass alloc] initWithRequest:request inSession:sself.session options:options];</span><br><span class="line">        //是否解压</span><br><span class="line">        operation.shouldDecompressImages = sself.shouldDecompressImages;</span><br><span class="line"></span><br><span class="line">        //证书</span><br><span class="line">        if (sself.urlCredential) &#123;</span><br><span class="line">            operation.credential = sself.urlCredential;</span><br><span class="line">        &#125; else if (sself.username &amp;&amp; sself.password) &#123;</span><br><span class="line">            //默认 账号密码为空的通用证书</span><br><span class="line">            operation.credential = [NSURLCredential credentialWithUser:sself.username password:sself.password persistence:NSURLCredentialPersistenceForSession];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //优先级。默认都不是</span><br><span class="line">        if (options &amp; SDWebImageDownloaderHighPriority) &#123;</span><br><span class="line">            operation.queuePriority = NSOperationQueuePriorityHigh;</span><br><span class="line">        &#125; else if (options &amp; SDWebImageDownloaderLowPriority) &#123;</span><br><span class="line">            operation.queuePriority = NSOperationQueuePriorityLow;</span><br><span class="line">        &#125;</span><br><span class="line">        //向下载队列 NSOperationQueue 中 添加本次下载操作</span><br><span class="line">        [sself.downloadQueue addOperation:operation];</span><br><span class="line"></span><br><span class="line">        //设置下载的顺序 是按照队列还是栈</span><br><span class="line">        if (sself.executionOrder == SDWebImageDownloaderLIFOExecutionOrder) &#123;</span><br><span class="line">            // Emulate LIFO execution order by systematically adding new operations as last operation&apos;s dependency</span><br><span class="line"></span><br><span class="line">            [sself.lastAddedOperation addDependency:operation];</span><br><span class="line">            sself.lastAddedOperation = operation;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return operation;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//通过progressBlock&amp;&amp;completedBlock以及Url和SDWebImageDownloaderOperation对token进行包装</span><br><span class="line">- (nullable SDWebImageDownloadToken *)addProgressCallback:(SDWebImageDownloaderProgressBlock)progressBlock</span><br><span class="line">                                           completedBlock:(SDWebImageDownloaderCompletedBlock)completedBlock</span><br><span class="line">                                                   forURL:(nullable NSURL *)url</span><br><span class="line">                                           createCallback:(SDWebImageDownloaderOperation *(^)(void))createCallback &#123;</span><br><span class="line">    // The URL will be used as the key to the callbacks dictionary so it cannot be nil. If it is nil immediately call the completed block with no image or data.</span><br><span class="line">    if (url == nil) &#123;</span><br><span class="line">        if (completedBlock != nil) &#123;</span><br><span class="line">            completedBlock(nil, nil, nil, NO);</span><br><span class="line">        &#125;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    __block SDWebImageDownloadToken *token = nil;</span><br><span class="line"></span><br><span class="line">    dispatch_barrier_sync(self.barrierQueue, ^&#123;</span><br><span class="line">        SDWebImageDownloaderOperation *operation = self.URLOperations[url];</span><br><span class="line">        if (!operation) &#123;</span><br><span class="line">            operation = createCallback();</span><br><span class="line">            //将url作为key、对应的下载操作operation作为value保存。</span><br><span class="line">            self.URLOperations[url] = operation;</span><br><span class="line"></span><br><span class="line">            __weak SDWebImageDownloaderOperation *woperation = operation;</span><br><span class="line">            operation.completionBlock = ^&#123;</span><br><span class="line">                dispatch_barrier_sync(self.barrierQueue, ^&#123;</span><br><span class="line">                    SDWebImageDownloaderOperation *soperation = woperation;</span><br><span class="line">                    if (!soperation) return;</span><br><span class="line">                    if (self.URLOperations[url] == soperation) &#123;</span><br><span class="line">                        //下载完成、移除操作</span><br><span class="line">                        [self.URLOperations removeObjectForKey:url];</span><br><span class="line">                    &#125;;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //将成progressBlock以及completedBlock组装成SDCallbacksDictionary.</span><br><span class="line">        id downloadOperationCancelToken = [operation addHandlersForProgress:progressBlock completed:completedBlock];</span><br><span class="line"></span><br><span class="line">        //生成下载任务标识。用于manager将来定位对应操作用</span><br><span class="line">        token = [SDWebImageDownloadToken new];</span><br><span class="line">        token.url = url;</span><br><span class="line">        token.downloadOperationCancelToken = downloadOperationCancelToken;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    return token;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="SDWebImageDownloaderOperation是具体下载操作、设计很多网络层的东西。将来可以单独开一篇、结合AFNetWorking没准会更好。"><a href="#SDWebImageDownloaderOperation是具体下载操作、设计很多网络层的东西。将来可以单独开一篇、结合AFNetWorking没准会更好。" class="headerlink" title="SDWebImageDownloaderOperation是具体下载操作、设计很多网络层的东西。将来可以单独开一篇、结合AFNetWorking没准会更好。"></a>SDWebImageDownloaderOperation是具体下载操作、设计很多网络层的东西。将来可以单独开一篇、结合AFNetWorking没准会更好。</h5><h3 id="一些启发"><a href="#一些启发" class="headerlink" title="一些启发"></a>一些启发</h3><ul>
<li><h5 id="分层的接口API设计。"><a href="#分层的接口API设计。" class="headerlink" title="分层的接口API设计。"></a>分层的接口API设计。</h5></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;UIImageView+WebCache.h&quot;</span><br><span class="line">#import &quot;UIButton+WebCache.h&quot;</span><br><span class="line">#import &quot;UIImageView+HighlightedWebCache.h&quot;</span><br><span class="line">//以及其汇总的</span><br><span class="line">#import &quot;UIView+WebCache.h&quot;</span><br></pre></td></tr></table></figure>
<p>所有外层API与具体业务无关。<br>使得<code>SDWebImageManager</code>可以脱离View层单独运作。</p>
<ul>
<li><h5 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h5></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@synchronized (self.runningOperations) &#123;</span><br><span class="line">        [self.runningOperations addObject:operation];</span><br><span class="line">    &#125;</span><br><span class="line">if (url) &#123;</span><br><span class="line">     @synchronized (self.failedURLs) &#123;</span><br><span class="line">         isFailedUrl = [self.failedURLs containsObject:url];</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line">.....</span><br></pre></td></tr></table></figure>
<p>所有可能引起资源抢夺的对象操作、全部有条件锁保护。<br>但是由于内嵌异常处理代码的存在、条件锁的性能是所有锁中最差的。不知道为什么SD中使用这么多。</p>
<ul>
<li><h5 id="内联函数-1"><a href="#内联函数-1" class="headerlink" title="内联函数"></a>内联函数</h5></li>
</ul>
<p>更高效的短函数执行、替代表达式形式的宏定义。</p>
<ul>
<li><h5 id="精细的缓存管理原则"><a href="#精细的缓存管理原则" class="headerlink" title="精细的缓存管理原则"></a>精细的缓存管理原则</h5></li>
</ul>
<p>详参上文提到的<strong>《磁盘清理的原则？》</strong></p>
<ul>
<li><h5 id="回调设计"><a href="#回调设计" class="headerlink" title="回调设计"></a>回调设计</h5></li>
</ul>
<p>SDWebImage中使用了两种、Block以及Delegate。</p>
<ul>
<li>Block使用的很多、举两个例子。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">======&gt;#import &quot;UIView+WebCache.h&quot;</span><br><span class="line">- (void)sd_internalSetImageWithURL:(nullable NSURL *)url</span><br><span class="line">                  placeholderImage:(nullable UIImage *)placeholder</span><br><span class="line">                           options:(SDWebImageOptions)options</span><br><span class="line">                      operationKey:(nullable NSString *)operationKey</span><br><span class="line">                     setImageBlock:(nullable SDSetImageBlock)setImageBlock</span><br><span class="line">                          progress:(nullable SDWebImageDownloaderProgressBlock)progressBlock</span><br><span class="line">                         completed:(nullable SDExternalCompletionBlock)completedBlock</span><br><span class="line">                           context:(nullable NSDictionary *)context;</span><br><span class="line"></span><br><span class="line">======&gt;SDWebImageDownloader</span><br><span class="line">- (nullable SDWebImageDownloadToken *)downloadImageWithURL:(nullable NSURL *)url</span><br><span class="line">                                                   options:(SDWebImageDownloaderOptions)options</span><br><span class="line">                                                  progress:(nullable SDWebImageDownloaderProgressBlock)progressBlock</span><br><span class="line">                                                 completed:(nullable SDWebImageDownloaderCompletedBlock)completedBlock;</span><br></pre></td></tr></table></figure>
<p>再来看代理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@protocol SDWebImageManagerDelegate &lt;NSObject&gt;</span><br><span class="line"></span><br><span class="line">@optional</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Controls which image should be downloaded when the image is not found in the cache.</span><br><span class="line"> *</span><br><span class="line"> * @param imageManager The current `SDWebImageManager`</span><br><span class="line"> * @param imageURL     The url of the image to be downloaded</span><br><span class="line"> *</span><br><span class="line"> * @return Return NO to prevent the downloading of the image on cache misses. If not implemented, YES is implied.</span><br><span class="line"> */</span><br><span class="line">- (BOOL)imageManager:(nonnull SDWebImageManager *)imageManager shouldDownloadImageForURL:(nullable NSURL *)imageURL;</span><br><span class="line">- (nullable UIImage *)imageManager:(nonnull SDWebImageManager *)imageManager transformDownloadedImage:(nullable UIImage *)image withURL:(nullable NSURL *)imageURL;</span><br></pre></td></tr></table></figure>
<p>不难看出、SDWebImage对回调的使用倾向于：</p>
<ul>
<li>Block<br>单个图片的分类、单个图片的下载。<br>每个操作任务中必现的progress以及completed。<br>所以、<strong>有很强的个体绑定需要或者使用次数不多时、倾向使用block</strong></li>
<li>Delegate<br>SDWebImageManager下载完成之后的自定义图片处理、是否下载某个url。<br>这两个方法如果需要的话都是将会调用多次的。所以、用Delegate更好、可以将方法常驻。</li>
<li>同理<br>UITableView的使用Delegate、是用为在滚动途中、代理方法需要被不断的执行。<br>UIButton也是将会被多次点击。<br>UIView的动画/GCD则可以使用Block、因为只执行一次、用完释放。<br>所以、在日常使用中、我们也可以参考上述原则进行设计。</li>
<li><h5 id="NSMapTable"><a href="#NSMapTable" class="headerlink" title="NSMapTable"></a>NSMapTable</h5></li>
</ul>
<p>用NSMapTable代替字典来存储当前正在进行的操作、并且将value设置为NSMapTableWeakMemory。防止对应value因为强引用不能自动释放。</p>
<h4 id="暂时想到的就这些、更多问题欢迎留言。"><a href="#暂时想到的就这些、更多问题欢迎留言。" class="headerlink" title="暂时想到的就这些、更多问题欢迎留言。"></a>暂时想到的就这些、更多问题欢迎留言。</h4><p>作者：kirito_song<br>链接：<a href="https://www.jianshu.com/p/3b8a7ae966d3" target="_blank" rel="noopener">https://www.jianshu.com/p/3b8a7ae966d3</a><br>來源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://hl1987.com/2018/04/24/SDWebImage4-0源码阅读/" data-id="cjqpafa4s0028njf0q1unb50f"
         class="article-share-link">Share</a>
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SDWebImage/">SDWebImage</a></li></ul>

    </footer>

  </div>

  
    
  <nav class="article-nav">
    
      <a href="/2018/04/26/iOS-APP-运行时防Crash工具XXShield练就/" class="article-nav-link">
        <strong class="article-nav-caption">Newer posts</strong>
        <div class="article-nav-title">
          
            iOS-APP-运行时防Crash工具XXShield练就
          
        </div>
      </a>
    
    
      <a href="/2018/04/20/深入理解iOS-Rendering-Process/" class="article-nav-link">
        <strong class="article-nav-caption">Olde posts</strong>
        <div class="article-nav-title">深入理解iOS Rendering Process</div>
      </a>
    
  </nav>


  

  
    
  <div class="gitalk" id="gitalk-container"></div>
  <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
  <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
  <script src="https://cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.min.js"></script>
  <script type="text/javascript">
      var gitalk = new Gitalk({
        clientID: '',
        clientSecret: '',
        repo: '',
        owner: 'hanangellove',
        admin: [''],
        // id: location.pathname,      // Ensure uniqueness and length less than 50
        id: md5(location.pathname),
        distractionFreeMode: false  // Facebook-like distraction free mode
      })

  gitalk.render('gitalk-container')
  </script>

  

</article>



</section>
  <footer class="footer">
  
  <div class="outer">
    <ul class="list-inline">
      <li>&copy; 2019 寒流‘s Blog</li>
      <li>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></li>
      <li>Theme  <a href="https://zhwangart.github.io">zhwangart</a></li>
      <!--
      <li><a href="/">Han Liu</a></li>
      -->
    </ul>
  </div>
</footer>
</main>
<aside class="sidebar">
  <button class="navbar-toggle"></button>

<nav class="navbar">
  
    <div class="logo">
      <a href="/"><img src="/images/hexo.svg" alt="寒流‘s Blog"></a>
    </div>
  
  <ul class="nav nav-main">
    
      <li class="nav-item">
        <a class="nav-item-link" href="/">Home</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/archives">Archives</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/gallery">Gallery</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/about">About</a>
      </li>
    
    <li class="nav-item">
      <a class="nav-item-link nav-item-search" title="Suche">
        <i class="fe fe-search"></i>
        Search
      </a>
    </li>
  </ul>
</nav>

<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
        <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
          <i class="fe fe-feed"></i>
        </a>
      
    </li>
  </ul>
</nav>

<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
</aside>
  <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/lazyload.min.js"></script>


  <script src="/fancybox/jquery.fancybox.min.js"></script>



  <script src="/js/search.js"></script>


<script src="/js/ocean.js"></script>

</body>
</html>