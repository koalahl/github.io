<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Mapkit基本开发指南 | 寒流‘s Blog | 编程与生活</title>

  
  <meta name="author" content="Han Liu">
  

  
  <meta name="description" content="Think in Different">
  

  
  
  <meta name="keywords" content="Mapkit">
  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  <meta property="og:title" content="Mapkit基本开发指南"/>

  <meta property="og:site_name" content="寒流‘s Blog"/>

  
  <meta property="og:image" content="/favicon.ico"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="寒流‘s Blog" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
</head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">寒流‘s Blog</a>
    </h1>
    <p class="site-description">编程与生活</p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/">首页</a></li>
      
        <li><a href="/categories/algorithm">算法</a></li>
      
        <li><a href="/categories/principle">原理</a></li>
      
        <li><a href="/categories/graphic">图形图像</a></li>
      
        <li><a href="/categories/performance">性能</a></li>
      
        <li><a href="/categories/iOSInterview">面试集</a></li>
      
        <li><a href="/categories/sourcecode">读源码</a></li>
      
        <li><a href="/link">博客</a></li>
      
        <li><a href="/categories">分类</a></li>
      
        <li><a href="/about">关于</a></li>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    <article>

  
    
    <h3 class="article-title"><span>Mapkit基本开发指南</span></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/07/27/Mapkit基本开发指南/" rel="bookmark">
        <time class="entry-date published" datetime="2018-07-27T06:29:49.000Z">
          2018-07-27
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>MapKit是iOS自带的地图库。可以实现定位，地理编码，地图标注等功能。 </p>
<p>一：查看是否导入MapKit.framework。 xcode5.1之后会自动导入<br>二：创建地图<br>        创建地图对象：<br>        <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.打开地图时的初始位置</span><br><span class="line">	1.1 设置地图中心点center</span><br></pre></td></tr></table></figure></p>
<pre><code>    CLLocationCoordinate2D center = CLLocationCoordinate2DMake(latitude, longitude);
    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.2设置地图可视范围 数字越小，可现实范围越小</span><br></pre></td></tr></table></figure>

        MKCoordinateSpan span = MKCoordinateSpanMake(53-3, 135-73);
    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.3设置region= cente+span</span><br></pre></td></tr></table></figure>

        CLLocationCoordinate2D center2 = CLLocationCoordinate2DMake(22.54387,113.950339);
           MKCoordinateSpan span2 = MKCoordinateSpanMake(0.1, 0.1);
          MKCoordinateRegion region2 = MKCoordinateRegionMake(center2, span2);
        [_mapView setRegion:region2 animated:YES];
    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2.地图类型</span><br></pre></td></tr></table></figure>

    MKMapTypeStandard = 0,
    MKMapTypeSatellite,
    MKMapTypeHybrid

    _mapView.mapType = MKMapTypeStandard;
    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3.设置地图上显示内容</span><br></pre></td></tr></table></figure>

    showsPointsOfInterest
    showsBuildings
    showsTraffic
    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">三： 获取当前点击位置的经纬度</span><br><span class="line">3.1给地图对象添加手势：</span><br></pre></td></tr></table></figure>

//长按放置大头针，并获取当前点击位置的经纬度
UILongPressGestureRecognizer *longPress = [[UILongPressGestureRecognizer alloc]initWithTarget:self action:@selector(whereAmI:)];
[_mapView addGestureRecognizer:longPress];
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">3.2创建地图编码器 CLGeocoder——地图编码器分为正向编码和反向编码。两种需要创建两个编码对象，不能公用。</span><br><span class="line">	``_coder = [[CLGeocoder alloc]init];``</span><br><span class="line">3.2.1正向地理编码：：将中文地址--&gt;经纬度</span><br></pre></td></tr></table></figure>

[_coder geocodeAddressString:name completionHandler:^(NSArray *placemarks, NSError *error) {
    NSLog(@&quot;Error:%@&quot;,[error localizedDescription]);
    NSLog(@&quot;------------正向地理编码------------&quot;);
    for (CLPlacemark * mark in placemarks) {
        CLLocation *location = mark.location;//是对CLLocationCoordinate2D的封装
        NSLog(@&quot;(纬度：%f,经度：%f)&quot;,location.coordinate.latitude,location.coordinate.longitude);
        NSLog(@&quot;%@&quot;,mark.name);//位置的完整名称
        NSLog(@&quot;%@&quot;,mark.thoroughfare);//位置名称
        NSLog(@&quot;%@&quot;,mark.locality);//城市
        NSLog(@&quot;%@&quot;,mark.subLocality);//区
        NSLog(@&quot;%@&quot;,mark.administrativeArea);//省

        //1.添加标注（大头针）
</code></pre><p>//            MKPointAnnotation *ann = [[MKPointAnnotation alloc]init];<br>//            //2.设置标注位置<br>//            ann.coordinate = CLLocationCoordinate2DMake(location.coordinate.latitude,location.coordinate.longitude);<br>//            ann.title = mark.thoroughfare;<br>//            ann.subtitle = mark.name;</p>
<pre><code>        /*也可以使用自定义的Annotation*/
        HLAnnotation *ann = [[HLAnnotation alloc]initWithTitle:mark.thoroughfare subtitle:mark.name coordinate:CLLocationCoordinate2DMake(location.coordinate.latitude, location.coordinate.longitude)];
        //3.将标注添加到地图上
        [_mapView addAnnotation:ann];
    }
}];
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3.2.2 反向地理编码：将经纬度—》中文地址信息</span><br></pre></td></tr></table></figure>

[_coder reverseGeocodeLocation:location completionHandler:^(NSArray *placemarks, NSError *error) {
    NSLog(@&quot;Error:%@&quot;,[error localizedDescription]);
    NSLog(@&quot;------------反向地理编码------------&quot;);
    for (CLPlacemark * mark in placemarks) {
        CLLocation *location = mark.location;//是对CLLocationCoordinate2D的封装
        NSLog(@&quot;(纬度：%f,经度：%f)&quot;,location.coordinate.latitude,location.coordinate.longitude);
        NSLog(@&quot;%@&quot;,mark.name);//位置的完整名称
        NSLog(@&quot;%@&quot;,mark.thoroughfare);//位置名称
        NSLog(@&quot;%@&quot;,mark.locality);//城市
        NSLog(@&quot;%@&quot;,mark.subLocality);//区
        NSLog(@&quot;%@&quot;,mark.administrativeArea);//省

        //1.添加标注（大头针）
        MKPointAnnotation *ann = [[MKPointAnnotation alloc]init];
        //2.设置标注位置
        ann.coordinate = CLLocationCoordinate2DMake(location.coordinate.latitude,location.coordinate.longitude);
        ann.title = mark.thoroughfare;
        ann.subtitle = mark.name;
        //3.将标注添加到地图上
        [_mapView addAnnotation:ann];

    }
}];
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3.3 获取当前点击位置-------主要方法是 [tap locationInView：_mapView];获取当前点击的位置</span><br></pre></td></tr></table></figure>

#pragma mark - 点击地图，添加标注大头针
- (void)whereAmI:(UITapGestureRecognizer *)tap{
    //1.获取点击点的位置
    CGPoint point =  [tap locationInView:_mapView];
    //将点位置转换为当前经纬度
    CLLocationCoordinate2D locationCor = [_mapView convertPoint:point toCoordinateFromView:_mapView];

    //NSLog(@&quot;(纬度：%f,经度：%f)&quot;,locationCor.latitude,locationCor.longitude);
    CLLocation *location = [[CLLocation alloc]initWithLatitude:locationCor.latitude longitude:locationCor.longitude];
    [self reverseGeocodeLocation:location];
}
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4.设置大头针的样式和状态—----需要遵守MKMapViewDelegate协议</span><br></pre></td></tr></table></figure>

#pragma  mark - MKMapViewDelegate
//也是有复用机制
- (MKAnnotationView *)mapView:(MKMapView *)mapView viewForAnnotation:(id&lt;MKAnnotation&gt;)annotation;
//设置大头针的状态——重点两个：1.设置大头针（pin）的拖拽状态为end。2.更新大头针的标注（annotation）内容
- (void)mapView:(MKMapView *)mapView annotationView:(MKAnnotationView *)view didChangeDragState:(MKAnnotationViewDragState)newState fromOldState:(MKAnnotationViewDragState)oldState;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">        </span><br><span class="line">//具体代码：</span><br></pre></td></tr></table></figure>

- (MKAnnotationView *)mapView:(MKMapView *)mapView viewForAnnotation:(id&lt;MKAnnotation&gt;)annotation{

    NSLog(@&quot;annotation的类型：%@&quot;,[annotation class]);

    //1.先从复用队列中取出可用的大头针，如果没有，则创建
    MKAnnotationView *annView =  [mapView dequeueReusableAnnotationViewWithIdentifier:@&quot;ann&quot;];
    //判断一下当前annotation的数据类型，如果是用户定位MKUserLocation类，则直接返回，这样当前位置的view就是一个蓝色小圆圈，而不是大头针。
    if ([annotation isKindOfClass:[MKUserLocation class]])
    {
        return annView;
    }
    if (annView == nil) {

        annView = [[MKPinAnnotationView alloc]initWithAnnotation:annotation reuseIdentifier:@&quot;ann&quot;];
    }
    //MKPinAnnotationView是MKAnnotationView的子类
    //如果使用 annView = [MKPinAnnotationView alloc]
    MKPinAnnotationView *pin = (MKPinAnnotationView *)annView;
    //pin.pinColor = MKPinAnnotationColorGreen;
    pin.animatesDrop = YES;

    //2.设置大头针
    //2.1设置大头针图片
    //annView.image = [UIImage imageNamed:@&quot;map&quot;];
    //2.2设置拖拽
    annView.draggable = YES;
    //2.3设置弹出泡泡
    annView.canShowCallout = YES;
    //2.4设置左右视图

    UIButton * right = [UIButton buttonWithType:UIButtonTypeDetailDisclosure];
    right.frame = CGRectMake(0, 0, 30, 30);
    annView.rightCalloutAccessoryView = right;
//    annView.leftCalloutAccessoryView
    return annView;
}
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//设置大头针的状态</span><br></pre></td></tr></table></figure>

- (void)mapView:(MKMapView *)mapView annotationView:(MKAnnotationView *)view didChangeDragState:(MKAnnotationViewDragState)newState fromOldState:(MKAnnotationViewDragState)oldState{
    if (newState == MKAnnotationViewDragStateEnding) {
        //结束大头针View的拖拽状态
        [view setDragState:MKAnnotationViewDragStateNone animated:YES];
        //更新当前大头针的标注内容
        HLAnnotation *ann = view.annotation;
        NSLog(@&quot;(%f,%f)&quot;,ann.coordinate.latitude,ann.coordinate.longitude);
        CLLocation *location = [[CLLocation alloc]initWithLatitude:ann.coordinate.latitude longitude:ann.coordinate.longitude];
        //反向获取位置信息
        [_coder reverseGeocodeLocation:location completionHandler:^(NSArray *placemarks, NSError *error) {
            NSLog(@&quot;Error:%@&quot;,[error localizedDescription]);
            NSLog(@&quot;------------反向地理编码------------&quot;);
            for (CLPlacemark * mark in placemarks) {
                CLLocation *location = mark.location;//是对CLLocationCoordinate2D的封装

                //2.设置标注位置
                ann.coordinate = CLLocationCoordinate2DMake(location.coordinate.latitude,location.coordinate.longitude);
                [ann setTitle:mark.thoroughfare];
                [ann setSubtitle:mark.name];
                //3.将标注添加到地图上
                [_mapView addAnnotation:ann];
            }
        }];
    }
}
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">四：定位</span><br><span class="line">用户定位与位置相关，所以使用的是CLLocationManager类。</span><br><span class="line">1.打开用户位置显示开关</span><br><span class="line">2.创建位置管理对象</span><br><span class="line">3.设置精度和更新频率</span><br><span class="line">4.启动位置更新</span><br></pre></td></tr></table></figure>

//创建位置管理对象
_manager = [[CLLocationManager alloc]init];
_mapView.showsUserLocation = YES;//显示用户当前位置
//设置精度和更新频率
_manager.desiredAccuracy = kCLLocationAccuracyNearestTenMeters;//精度
_manager.distanceFilter = 100.0;//更新频率，每经过100m更新一次

//启动定位，用完应该马上停止，定位结果在代理方法中获取
_manager.delegate = self;
[_manager startUpdatingLocation];
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line">那么如何让地图自动跳转到定位的位置呢？这里需要实现协议CLLocationManagerDelegate。定位结果就是从协议方法中取得</span><br></pre></td></tr></table></figure>

#pragma mark - CLLocationManagerDelegate
- (void)locationManager:(CLLocationManager *)manager didUpdateLocations:(NSArray *)locations{
    CLLocation *currentLocation = [locations lastObject];
    //将地图移动到当前定位的位置
    CLLocationCoordinate2D  currentCoordinate = currentLocation.coordinate;
    MKCoordinateSpan span = _mapView.region.span;//当前地图缩放比例
    MKCoordinateRegion region = {currentCoordinate,span};
    [_mapView setRegion:region];

    NSLog(@&quot;定位结束%@&quot;,currentLocation);

}
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">五：多个经纬度做反向地理编码。</span><br><span class="line"></span><br><span class="line">有个需求要求我们先把策划给的一张包含2664个城市经纬度的表，通过反向地理编码得出对应的城市名，在做的过程中遇到并处理了以下问题：</span><br><span class="line">流程：</span><br><span class="line">1.读取CVS文件，并写入数组中。</span><br><span class="line">2.每次从数组中拿出50个数据，并判断是否finish。</span><br><span class="line">3.创建定时器timer，实现一直循环第2步。</span><br><span class="line">4.每次反向编码后的城市名写入文件中。</span><br><span class="line"></span><br><span class="line">由于reverseGeocodeLocation处理经纬度的请求有限制：</span><br><span class="line">``reverseGeocodeLocation``方法有如下描述</span><br><span class="line">    &#123;%blockquote%&#125;</span><br><span class="line">    Submits a reverse-geocoding request for the specified location.</span><br><span class="line">This method submits the specified location data to the geocoding server asynchronously and returns. When the request completes, the geocoder executes the provided completion handler on the main thread.</span><br><span class="line">After initiating a reverse-geocoding request, do not attempt to initiate another reverse- or forward-geocoding request. Geocoding requests are rate-limited for each app, so making too many requests in a short period of time may cause some of the requests to fail. When the maximum rate is exceeded, the geocoder passes an error object with the value kCLErrorNetwork to your completion handler.</span><br><span class="line">&#123;%endblockquote%&#125;</span><br><span class="line"></span><br><span class="line">划重点：</span><br><span class="line">1. 这个方法是异步的。</span><br><span class="line">2. 同一个app在一段时间间隔内会有一个调用频率（rate-limited）。经测试， geocoding server一次可以处理的请求数为50个，并且时间间隔大约在1分钟左右。</span><br><span class="line"></span><br><span class="line">针对以上两点，我采用了dispatch_group，每一个请求结束后leave group，并且notify到主线程，将结果写入另外的文件。</span><br></pre></td></tr></table></figure>
</code></pre><ul>
<li><p>(void)geocodingForLocations:(NSArray <em>)locations {<br>  __weak typeof(self)wself = self;<br>  dispatch_group_t group = dispatch_group_create();<br>  [locations enumerateObjectsUsingBlock:^(id  _Nonnull obj, NSUInteger idx, BOOL </em> _Nonnull stop) {</p>
<pre><code>CLLocation *location = obj;

dispatch_group_enter(group);

CLGeocoder *geocoder = [[CLGeocoder alloc] init];
[geocoder reverseGeocodeLocation:location completionHandler:^(NSArray&lt;CLPlacemark *&gt; * _Nullable placemarks, NSError * _Nullable error) {
    for (CLPlacemark * placemark in placemarks) {
        NSLog(@&quot;location：%@&quot;,location);
        NSLog(@&quot;name：%@&quot;,placemark.name);
        NSDecimalNumberHandler *handle = [[NSDecimalNumberHandler alloc] initWithRoundingMode:NSRoundDown scale:6 raiseOnExactness:NO raiseOnOverflow:NO raiseOnUnderflow:NO raiseOnDivideByZero:NO] ;
        NSDecimalNumber *rLan = [[NSDecimalNumber alloc] initWithDouble:location.coordinate.latitude];
        NSDecimalNumber *rLon = [[NSDecimalNumber alloc] initWithDouble:location.coordinate.longitude];
        rLan = [rLan decimalNumberByRoundingAccordingToBehavior:handle];
        rLon = [rLon decimalNumberByRoundingAccordingToBehavior:handle];

        NSString *llllan = [NSString stringWithFormat:@&quot;%0.6f&quot;,location.coordinate.latitude];
        NSString *llllon = [NSString stringWithFormat:@&quot;%0.6f&quot;,location.coordinate.longitude];

        NSString *city = placemark.locality ?placemark.locality: placemark.administrativeArea;
        NSLog(@&quot;city：%@&quot;,city);
</code></pre></li>
</ul>
<pre><code>BOOL same = NO;
NSString *tempNameFromGoogle = [NSString stringWithFormat:@&quot;%@-%@&quot;,rLan,rLon];
//这里很耗时
for (NSDictionary *dic in self.locationsOfGoogle) {
    NSString *latitude      = dic[@&quot;lan&quot;];
    NSString *longtitude    = dic[@&quot;lon&quot;];
    NSString *cityName      = dic[@&quot;name&quot;];

    NSComparisonResult latiresult = [rLan compare:latitude];
</code></pre><p>//                    NSComparisonResult lonresult = [rLan compare:latitude];</p>
<pre><code>                if (([latitude isEqualToString:llllan] &amp;&amp; [longtitude isEqualToString:llllon]) || [cityName isEqualToString:city]){
                    //找到对应的坐标判断城市名
                    same = [cityName isEqualToString:city];
                    NSLog(@&quot;城市名是否相同：%d--%f,%f&quot;,same,latitude.doubleValue,longtitude.doubleValue);
                    tempNameFromGoogle = cityName;
                    break;
                }
            }

            [wself.citys appendString:[NSString stringWithFormat:@&quot;%f,%f,%@,%d,%@\r\n&quot;,location.coordinate.latitude,location.coordinate.longitude, city,same,tempNameFromGoogle]];
        }
        NSLog(@&quot;第%lu次 leave ： %lu&quot;,wself.k/50,idx);

        dispatch_group_leave(group);

    }];
}];

dispatch_group_notify(group, dispatch_get_main_queue(), ^{
    NSLog(@&quot;第%lu次 notify&quot;,wself.k/50);
    [self createFile];
});
</code></pre><p>}<br>```</p>
<p>六: MKMapView的zoomLevel<br>系统类没有直接获取zoomLevel的属性，参考一下<br><a href="https://stackoverflow.com/questions/4189621/setting-the-zoom-level-for-a-mkmapview" target="_blank" rel="noopener">https://stackoverflow.com/questions/4189621/setting-the-zoom-level-for-a-mkmapview</a></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/iOS/">iOS</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/Mapkit/">Mapkit</a>
    </span>
    

    </div>

    
  </div>
</article>

  
	<section id="comments" class="comment">
	  <div id="disqus_thread">
	  <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
	  </div>
	</section>

	<script type="text/javascript">
	var disqus_shortname = 'hanangellove';
	(function(){
	  var dsq = document.createElement('script');
	  dsq.type = 'text/javascript';
	  dsq.async = true;
	  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
	  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	}());
	(function(){
	  var dsq = document.createElement('script');
	  dsq.type = 'text/javascript';
	  dsq.async = true;
	  dsq.src = '//' + disqus_shortname + '.disqus.com/count.js';
	  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	}());
	</script>





    </main>

    <footer class="site-footer">
  <p class="site-info">
    <!--
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    </br>
  -->
    
    &copy; 2018 Han Liu
    
  </p>
</footer>
    
  </div>
</div>
</body>
</html>