<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>iOS底层原理总结 - RunLoop | 寒流‘s Blog | 编程与生活</title>

  
  <meta name="author" content="Han Liu">
  

  
  <meta name="description" content="Think in Different">
  

  
  
  <meta name="keywords" content="runloop">
  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  <meta property="og:title" content="iOS底层原理总结 - RunLoop"/>

  <meta property="og:site_name" content="寒流‘s Blog"/>

  
  <meta property="og:image" content="/favicon.ico"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="寒流‘s Blog" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
</head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">寒流‘s Blog</a>
    </h1>
    <p class="site-description">编程与生活</p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/">首页</a></li>
      
        <li><a href="/categories/algorithm">算法</a></li>
      
        <li><a href="/categories/principle">原理</a></li>
      
        <li><a href="/categories/graphic">图形图像</a></li>
      
        <li><a href="/categories/performance">性能</a></li>
      
        <li><a href="/categories/iOSInterview">面试集</a></li>
      
        <li><a href="/categories/sourcecode">读源码</a></li>
      
        <li><a href="/link">博客</a></li>
      
        <li><a href="/categories">分类</a></li>
      
        <li><a href="/about">关于</a></li>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    <article>

  
    
    <h3 class="article-title"><span>iOS底层原理总结 - RunLoop</span></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/07/05/iOS底层原理总结-RunLoop/" rel="bookmark">
        <time class="entry-date published" datetime="2018-07-05T07:13:43.000Z">
          2018-07-05
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h1 id="iOS底层原理总结-RunLoop"><a href="#iOS底层原理总结-RunLoop" class="headerlink" title="iOS底层原理总结 - RunLoop"></a>iOS底层原理总结 - RunLoop</h1><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><ol>
<li>讲讲 RunLoop，项目中有用到吗？</li>
<li>RunLoop内部实现逻辑？</li>
<li>Runloop和线程的关系？</li>
<li>timer 与 Runloop 的关系？</li>
<li>程序中添加每3秒响应一次的NSTimer，当拖动tableview时timer可能无法响应要怎么解决？</li>
<li>Runloop 是怎么响应用户操作的， 具体流程是什么样的？</li>
<li>说说RunLoop的几种状态？</li>
<li>Runloop的mode作用是什么？</li>
</ol>
<a id="more"></a>
<h2 id="一-RunLoop简介"><a href="#一-RunLoop简介" class="headerlink" title="一. RunLoop简介"></a>一. RunLoop简介</h2><p>运行循环，在程序运行过程中循环做一些事情，如果没有Runloop程序执行完毕就会立即退出，如果有Runloop程序会一直运行，并且时时刻刻在等待用户的输入操作。RunLoop可以在需要的时候自己跑起来运行，在没有操作的时候就停下来休息。充分节省CPU资源，提高程序性能。</p>
<h2 id="二-RunLoop基本作用："><a href="#二-RunLoop基本作用：" class="headerlink" title="二. RunLoop基本作用："></a>二. RunLoop基本作用：</h2><ol>
<li><p><strong>保持程序持续运行</strong>，程序一启动就会开一个主线程，主线程一开起来就会跑一个主线程对应的RunLoop,RunLoop保证主线程不会被销毁，也就保证了程序的持续运行</p>
</li>
<li><p><strong>处理App中的各种事件</strong>（比如：触摸事件，定时器事件，Selector事件等）</p>
</li>
<li><p><strong>节省CPU资源，提高程序性能</strong>，程序运行起来时，当什么操作都没有做的时候，RunLoop就告诉CPU，现在没有事情做，我要去休息，这时CPU就会将其资源释放出来去做其他的事情，当有事情做的时候RunLoop就会立马起来去做事情<strong>我们先通过API内一张图片来简单看一下RunLoop内部运行原理</strong></p>
<p><img src="data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;495&quot; height=&quot;261&quot;&gt;&lt;/svg" alt="RunLoop内部运行原理"></p>
<p>通过图片可以看出，RunLoop在跑圈过程中，当接收到Input sources 或者 Timer sources时就会交给对应的处理方去处理。当没有事件消息传入的时候，RunLoop就休息了。这里只是简单的理解一下这张图，接下来我们来了解RunLoop对象和其一些相关类，来更深入的理解RunLoop运行流程。</p>
</li>
</ol>
<h2 id="三-RunLoop在哪里开启"><a href="#三-RunLoop在哪里开启" class="headerlink" title="三. RunLoop在哪里开启"></a>三. RunLoop在哪里开启</h2><p>UIApplicationMain函数内启动了Runloop，程序不会马上退出，而是保持运行状态。因此每一个应用必须要有一个runloop， 我们知道主线程一开起来，就会跑一个和主线程对应的RunLoop，那么RunLoop一定是在程序的入口main函数中开启。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>进入UIApplicationMain</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UIKIT_EXTERN int UIApplicationMain(int argc, char *argv[], NSString * __nullable principalClassName, NSString * __nullable delegateClassName);</span><br></pre></td></tr></table></figure>
<p>我们发现它返回的是一个int数，那么我们对main函数做一些修改</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        NSLog(@&quot;开始&quot;);</span><br><span class="line">        int re = UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));</span><br><span class="line">        NSLog(@&quot;结束&quot;);</span><br><span class="line">        return re;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序，我们发现只会打印开始，并不会打印结束，这<strong>说明在UIApplicationMain函数中，开启了一个和主线程相关的RunLoop，导致UIApplicationMain不会返回，一直在运行中，也就保证了程序的持续运行</strong>。 我们来看到RunLoop的源码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 用DefaultMode启动</span><br><span class="line">void CFRunLoopRun(void) &#123;    /* DOES CALLOUT */</span><br><span class="line">    int32_t result;</span><br><span class="line">    do &#123;</span><br><span class="line">        result = CFRunLoopRunSpecific(CFRunLoopGetCurrent(), kCFRunLoopDefaultMode, 1.0e10, false);</span><br><span class="line">        CHECK_FOR_FORK();</span><br><span class="line">    &#125; while (kCFRunLoopRunStopped != result &amp;&amp; kCFRunLoopRunFinished != result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们发现RunLoop确实是do while通过判断result的值实现的。因此，我们可以把RunLoop看成一个死循环。如果没有RunLoop，UIApplicationMain函数执行完毕之后将直接返回，也就没有程序持续运行一说了。</p>
<h2 id="四-RunLoop对象"><a href="#四-RunLoop对象" class="headerlink" title="四. RunLoop对象"></a>四. RunLoop对象</h2><blockquote>
<p>Fundation框架 （基于CFRunLoopRef的封装） NSRunLoop对象</p>
<p>CoreFoundation CFRunLoopRef对象</p>
</blockquote>
<p>因为Fundation框架是基于CFRunLoopRef的一层OC封装，这里我们主要研究CFRunLoopRef源码</p>
<h4 id="如何获得RunLoop对象"><a href="#如何获得RunLoop对象" class="headerlink" title="如何获得RunLoop对象"></a>如何获得RunLoop对象</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Foundation</span><br><span class="line">[NSRunLoop currentRunLoop]; // 获得当前线程的RunLoop对象</span><br><span class="line">[NSRunLoop mainRunLoop]; // 获得主线程的RunLoop对象</span><br><span class="line"></span><br><span class="line">Core Foundation</span><br><span class="line">CFRunLoopGetCurrent(); // 获得当前线程的RunLoop对象</span><br><span class="line">CFRunLoopGetMain(); // 获得主线程的RunLoop对象</span><br></pre></td></tr></table></figure>
<h2 id="五-RunLoop和线程间的关系"><a href="#五-RunLoop和线程间的关系" class="headerlink" title="五. RunLoop和线程间的关系"></a>五. RunLoop和线程间的关系</h2><blockquote>
<ol>
<li>每条线程都有唯一的一个与之对应的RunLoop对象<blockquote>
<ol>
<li>RunLoop保存在一个全局的Dictionary里，线程作为key,RunLoop作为value</li>
<li>主线程的RunLoop已经自动创建好了，子线程的RunLoop需要主动创建</li>
<li>RunLoop在第一次获取时创建，在线程结束时销毁</li>
</ol>
</blockquote>
</li>
</ol>
</blockquote>
<h3 id="通过源码查看上述对应"><a href="#通过源码查看上述对应" class="headerlink" title="通过源码查看上述对应"></a>通过源码查看上述对应</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">// 拿到当前Runloop 调用_CFRunLoopGet0</span><br><span class="line">CFRunLoopRef CFRunLoopGetCurrent(void) &#123;</span><br><span class="line">    CHECK_FOR_FORK();</span><br><span class="line">    CFRunLoopRef rl = (CFRunLoopRef)_CFGetTSD(__CFTSDKeyRunLoop);</span><br><span class="line">    if (rl) return rl;</span><br><span class="line">    return _CFRunLoopGet0(pthread_self());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 查看_CFRunLoopGet0方法内部</span><br><span class="line">CF_EXPORT CFRunLoopRef _CFRunLoopGet0(pthread_t t) &#123;</span><br><span class="line">    if (pthread_equal(t, kNilPthreadT)) &#123;</span><br><span class="line">    t = pthread_main_thread_np();</span><br><span class="line">    &#125;</span><br><span class="line">    __CFLock(&amp;loopsLock);</span><br><span class="line">    if (!__CFRunLoops) &#123;</span><br><span class="line">        __CFUnlock(&amp;loopsLock);</span><br><span class="line">    CFMutableDictionaryRef dict = CFDictionaryCreateMutable(kCFAllocatorSystemDefault, 0, NULL, &amp;kCFTypeDictionaryValueCallBacks);</span><br><span class="line">    // 根据传入的主线程获取主线程对应的RunLoop</span><br><span class="line">    CFRunLoopRef mainLoop = __CFRunLoopCreate(pthread_main_thread_np());</span><br><span class="line">    // 保存主线程 将主线程-key和RunLoop-Value保存到字典中</span><br><span class="line">    CFDictionarySetValue(dict, pthreadPointer(pthread_main_thread_np()), mainLoop);</span><br><span class="line">    if (!OSAtomicCompareAndSwapPtrBarrier(NULL, dict, (void * volatile *)&amp;__CFRunLoops)) &#123;</span><br><span class="line">        CFRelease(dict);</span><br><span class="line">    &#125;</span><br><span class="line">    CFRelease(mainLoop);</span><br><span class="line">        __CFLock(&amp;loopsLock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 从字典里面拿，将线程作为key从字典里获取一个loop</span><br><span class="line">    CFRunLoopRef loop = (CFRunLoopRef)CFDictionaryGetValue(__CFRunLoops, pthreadPointer(t));</span><br><span class="line">    __CFUnlock(&amp;loopsLock);</span><br><span class="line"></span><br><span class="line">    // 如果loop为空，则创建一个新的loop，所以runloop会在第一次获取的时候创建</span><br><span class="line">    if (!loop) &#123;  </span><br><span class="line">    CFRunLoopRef newLoop = __CFRunLoopCreate(t);</span><br><span class="line">        __CFLock(&amp;loopsLock);</span><br><span class="line">    loop = (CFRunLoopRef)CFDictionaryGetValue(__CFRunLoops, pthreadPointer(t));</span><br><span class="line"></span><br><span class="line">    // 创建好之后，以线程为key runloop为value，一对一存储在字典中，下次获取的时候，则直接返回字典内的runloop</span><br><span class="line">    if (!loop) &#123; </span><br><span class="line">        CFDictionarySetValue(__CFRunLoops, pthreadPointer(t), newLoop);</span><br><span class="line">        loop = newLoop;</span><br><span class="line">    &#125;</span><br><span class="line">        // don&apos;t release run loops inside the loopsLock, because CFRunLoopDeallocate may end up taking it</span><br><span class="line">        __CFUnlock(&amp;loopsLock);</span><br><span class="line">    CFRelease(newLoop);</span><br><span class="line">    &#125;</span><br><span class="line">    if (pthread_equal(t, pthread_self())) &#123;</span><br><span class="line">        _CFSetTSD(__CFTSDKeyRunLoop, (void *)loop, NULL);</span><br><span class="line">        if (0 == _CFGetTSD(__CFTSDKeyRunLoopCntr)) &#123;</span><br><span class="line">            _CFSetTSD(__CFTSDKeyRunLoopCntr, (void *)(PTHREAD_DESTRUCTOR_ITERATIONS-1), (void (*)(void *))__CFFinalizeRunLoop);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return loop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>从上面的代码可以看出，线程和 RunLoop 之间是一一对应的，其关系是保存在一个 Dictionary 里。所以我们创建子线程RunLoop时，只需在子线程中获取当前线程的RunLoop对象即可<code>[NSRunLoop currentRunLoop];</code>如果不获取，那子线程就不会创建与之相关联的RunLoop，并且只能在一个线程的内部获取其 RunLoop<code>[NSRunLoop currentRunLoop];</code>方法调用时，会先看一下字典里有没有存子线程相对用的RunLoop，如果有则直接返回RunLoop，如果没有则会创建一个，并将与之对应的子线程存入字典中。当线程结束时，RunLoop会被销毁。</strong></p>
<h2 id="六-RunLoop结构体"><a href="#六-RunLoop结构体" class="headerlink" title="六. RunLoop结构体"></a>六. RunLoop结构体</h2><p>通过源码我们找到__CFRunLoop结构体</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">struct __CFRunLoop &#123;</span><br><span class="line">    CFRuntimeBase _base;</span><br><span class="line">    pthread_mutex_t _lock;            /* locked for accessing mode list */</span><br><span class="line">    __CFPort _wakeUpPort;            // used for CFRunLoopWakeUp </span><br><span class="line">    Boolean _unused;</span><br><span class="line">    volatile _per_run_data *_perRunData;              // reset for runs of the run loop</span><br><span class="line">    pthread_t _pthread;</span><br><span class="line">    uint32_t _winthread;</span><br><span class="line">    CFMutableSetRef _commonModes;</span><br><span class="line">    CFMutableSetRef _commonModeItems;</span><br><span class="line">    CFRunLoopModeRef _currentMode;</span><br><span class="line">    CFMutableSetRef _modes;</span><br><span class="line">    struct _block_item *_blocks_head;</span><br><span class="line">    struct _block_item *_blocks_tail;</span><br><span class="line">    CFAbsoluteTime _runTime;</span><br><span class="line">    CFAbsoluteTime _sleepTime;</span><br><span class="line">    CFTypeRef _counterpart;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>除一些记录性属性外，主要来看一下以下两个成员变量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CFRunLoopModeRef _currentMode;</span><br><span class="line">CFMutableSetRef _modes;</span><br></pre></td></tr></table></figure>
<p>CFRunLoopModeRef 其实是指向__CFRunLoopMode结构体的指针，__CFRunLoopMode结构体源码如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">typedef struct __CFRunLoopMode *CFRunLoopModeRef;</span><br><span class="line">struct __CFRunLoopMode &#123;</span><br><span class="line">    CFRuntimeBase _base;</span><br><span class="line">    pthread_mutex_t _lock;    /* must have the run loop locked before locking this */</span><br><span class="line">    CFStringRef _name;</span><br><span class="line">    Boolean _stopped;</span><br><span class="line">    char _padding[3];</span><br><span class="line">    CFMutableSetRef _sources0;</span><br><span class="line">    CFMutableSetRef _sources1;</span><br><span class="line">    CFMutableArrayRef _observers;</span><br><span class="line">    CFMutableArrayRef _timers;</span><br><span class="line">    CFMutableDictionaryRef _portToV1SourceMap;</span><br><span class="line">    __CFPortSet _portSet;</span><br><span class="line">    CFIndex _observerMask;</span><br><span class="line">#if USE_DISPATCH_SOURCE_FOR_TIMERS</span><br><span class="line">    dispatch_source_t _timerSource;</span><br><span class="line">    dispatch_queue_t _queue;</span><br><span class="line">    Boolean _timerFired; // set to true by the source when a timer has fired</span><br><span class="line">    Boolean _dispatchTimerArmed;</span><br><span class="line">#endif</span><br><span class="line">#if USE_MK_TIMER_TOO</span><br><span class="line">    mach_port_t _timerPort;</span><br><span class="line">    Boolean _mkTimerArmed;</span><br><span class="line">#endif</span><br><span class="line">#if DEPLOYMENT_TARGET_WINDOWS</span><br><span class="line">    DWORD _msgQMask;</span><br><span class="line">    void (*_msgPump)(void);</span><br><span class="line">#endif</span><br><span class="line">    uint64_t _timerSoftDeadline; /* TSR */</span><br><span class="line">    uint64_t _timerHardDeadline; /* TSR */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>主要查看以下成员变量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CFMutableSetRef _sources0;</span><br><span class="line">CFMutableSetRef _sources1;</span><br><span class="line">CFMutableArrayRef _observers;</span><br><span class="line">CFMutableArrayRef _timers;</span><br></pre></td></tr></table></figure>
<p>通过上面分析我们知道，CFRunLoopModeRef代表RunLoop的运行模式，一个RunLoop包含若干个Mode，每个Mode又包含若干个Source0/Source1/Timer/Observer，而RunLoop启动时只能选择其中一个Mode作为currentMode。</p>
<h3 id="Source1-Source0-Timers-Observer分别代表什么"><a href="#Source1-Source0-Timers-Observer分别代表什么" class="headerlink" title="Source1/Source0/Timers/Observer分别代表什么"></a>Source1/Source0/Timers/Observer分别代表什么</h3><p><strong>1. Source1 : 基于Port的线程间通信</strong></p>
<p><strong>2. Source0 : 触摸事件，PerformSelectors</strong></p>
<p>我们通过代码验证一下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;点击了屏幕&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打断点之后打印堆栈信息，当xcode工具区打印的堆栈信息不全时，可以在控制台通过“bt”指令打印完整的堆栈信息，由堆栈信息中可以发现，触摸事件确实是会触发Source0事件。</p>
<p><img src="data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;950&quot; height=&quot;334&quot;&gt;&lt;/svg" alt="touchesBegan堆栈信息"></p>
<p>同样的方式验证performSelector堆栈信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;</span><br><span class="line">    [self performSelectorOnMainThread:@selector(test) withObject:nil waitUntilDone:YES];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>可以发现PerformSelectors同样是触发Source0事件</p>
<p><img src="data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;1090&quot; height=&quot;243&quot;&gt;&lt;/svg" alt="performSelector堆栈信息"></p>
<p>其实，当我们触发了事件（触摸/锁屏/摇晃等）后，由IOKit.framework生成一个 IOHIDEvent事件，而IOKit是苹果的硬件驱动框架，由它进行底层接口的抽象封装与系统进行交互传递硬件感应的事件，并专门处理用户交互设备，由IOHIDServices和IOHIDDisplays两部分组成，其中IOHIDServices是专门处理用户交互的，它会将事件封装成IOHIDEvents对象，接着用mach port转发给需要的App进程，随后 Source1就会接收IOHIDEvent，之后再回调__IOHIDEventSystemClientQueueCallback()，__IOHIDEventSystemClientQueueCallback()内触发Source0，Source0 再触发 _UIApplicationHandleEventQueue()。所以触摸事件看到是在 Source0 内的。</p>
<p><strong>3. Timers : 定时器，NSTimer</strong></p>
<p>通过代码验证</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[NSTimer scheduledTimerWithTimeInterval:3.0 repeats:NO block:^(NSTimer * _Nonnull timer) &#123;</span><br><span class="line">    NSLog(@&quot;NSTimer ---- timer调用了&quot;);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>打印完整堆栈信息</p>
<p><img src="data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;1102&quot; height=&quot;248&quot;&gt;&lt;/svg" alt="Timer对战信息"></p>
<p><strong>4. Observer : 监听器，用于监听RunLoop的状态</strong></p>
<h2 id="七-详解RunLoop相关类及作用"><a href="#七-详解RunLoop相关类及作用" class="headerlink" title="七. 详解RunLoop相关类及作用"></a>七. 详解RunLoop相关类及作用</h2><p>通过上面的分析，我们对RunLoop内部结构有了大致的了解，接下来来详细分析RunLoop的相关类。以下为Core Foundation中关于RunLoop的5个类</p>
<blockquote>
<p><strong>CFRunLoopRef - 获得当前RunLoop和主RunLoop</strong></p>
<p><strong>CFRunLoopModeRef - RunLoop 运行模式，只能选择一种，在不同模式中做不同的操作</strong></p>
<p><strong>CFRunLoopSourceRef - 事件源，输入源</strong></p>
<p><strong>CFRunLoopTimerRef - 定时器时间</strong></p>
<p><strong>CFRunLoopObserverRef - 观察者</strong></p>
</blockquote>
<h3 id="1-CFRunLoopModeRef"><a href="#1-CFRunLoopModeRef" class="headerlink" title="1. CFRunLoopModeRef"></a>1. CFRunLoopModeRef</h3><p><strong>CFRunLoopModeRef代表RunLoop的运行模式 一个 RunLoop 包含若干个 Mode，每个Mode又包含若干个Source、Timer、Observer 每次RunLoop启动时，只能指定其中一个 Mode，这个Mode被称作 CurrentMode 如果需要切换Mode，只能退出RunLoop，再重新指定一个Mode进入，这样做主要是为了分隔开不同组的Source、Timer、Observer，让其互不影响。如果Mode里没有任何Source0/Source1/Timer/Observer，RunLoop会立马退出</strong>如图所示：</p>
<p><img src="data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;364&quot; height=&quot;278&quot;&gt;&lt;/svg" alt="CFRunLoopModeRef示意图"></p>
<p><strong>注意：一种Mode中可以有多个Source(事件源，输入源，基于端口事件源例键盘触摸等) Observer(观察者，观察当前RunLoop运行状态) 和Timer(定时器事件源)。但是必须至少有一个Source或者Timer，因为如果Mode为空，RunLoop运行到空模式不会进行空转，就会立刻退出。</strong></p>
<h3 id="系统默认注册的5个Mode"><a href="#系统默认注册的5个Mode" class="headerlink" title="系统默认注册的5个Mode:"></a>系统默认注册的5个Mode:</h3><p>RunLoop 有五种运行模式，其中常见的有1.2两种</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. kCFRunLoopDefaultMode：App的默认Mode，通常主线程是在这个Mode下运行</span><br><span class="line">2. UITrackingRunLoopMode：界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响</span><br><span class="line">3. UIInitializationRunLoopMode: 在刚启动 App 时第进入的第一个 Mode，启动完成后就不再使用，会切换到kCFRunLoopDefaultMode</span><br><span class="line">4. GSEventReceiveRunLoopMode: 接受系统事件的内部 Mode，通常用不到</span><br><span class="line">5. kCFRunLoopCommonModes: 这是一个占位用的Mode，作为标记kCFRunLoopDefaultMode和UITrackingRunLoopMode用，并不是一种真正的Mode</span><br></pre></td></tr></table></figure>
<h3 id="Mode间的切换"><a href="#Mode间的切换" class="headerlink" title="Mode间的切换"></a>Mode间的切换</h3><p>我们平时在开发中一定遇到过，当我们使用NSTimer每一段时间执行一些事情时滑动UIScrollView，NSTimer就会暂停，当我们停止滑动以后，NSTimer又会重新恢复的情况，我们通过一段代码来看一下</p>
<p><strong>代码中的注释也很重要，展示了我们探索的过程</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">-(void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event</span><br><span class="line">&#123;</span><br><span class="line">    // [NSTimer scheduledTimerWithTimeInterval:2.0 target:self selector:@selector(show) userInfo:nil repeats:YES];</span><br><span class="line">    NSTimer *timer = [NSTimer timerWithTimeInterval:2.0 target:self selector:@selector(show) userInfo:nil repeats:YES];</span><br><span class="line">    // 加入到RunLoop中才可以运行</span><br><span class="line">    // 1. 把定时器添加到RunLoop中，并且选择默认运行模式NSDefaultRunLoopMode = kCFRunLoopDefaultMode</span><br><span class="line">    // [[NSRunLoop mainRunLoop] addTimer:timer forMode:NSDefaultRunLoopMode];</span><br><span class="line">    // 当textFiled滑动的时候，timer失效，停止滑动时，timer恢复</span><br><span class="line">    // 原因：当textFiled滑动的时候，RunLoop的Mode会自动切换成UITrackingRunLoopMode模式，因此timer失效，当停止滑动，RunLoop又会切换回NSDefaultRunLoopMode模式，因此timer又会重新启动了</span><br><span class="line"></span><br><span class="line">    // 2. 当我们将timer添加到UITrackingRunLoopMode模式中，此时只有我们在滑动textField时timer才会运行</span><br><span class="line">    // [[NSRunLoop mainRunLoop] addTimer:timer forMode:UITrackingRunLoopMode];</span><br><span class="line"></span><br><span class="line">    // 3. 那个如何让timer在两个模式下都可以运行呢？</span><br><span class="line">    // 3.1 在两个模式下都添加timer 是可以的，但是timer添加了两次，并不是同一个timer</span><br><span class="line">    // 3.2 使用站位的运行模式 NSRunLoopCommonModes标记，凡是被打上NSRunLoopCommonModes标记的都可以运行，下面两种模式被打上标签</span><br><span class="line">    //0 : &lt;CFString 0x10b7fe210 [0x10a8c7a40]&gt;&#123;contents = &quot;UITrackingRunLoopMode&quot;&#125;</span><br><span class="line">    //2 : &lt;CFString 0x10a8e85e0 [0x10a8c7a40]&gt;&#123;contents = &quot;kCFRunLoopDefaultMode&quot;&#125;</span><br><span class="line">    // 因此也就是说如果我们使用NSRunLoopCommonModes，timer可以在UITrackingRunLoopMode，kCFRunLoopDefaultMode两种模式下运行</span><br><span class="line">    [[NSRunLoop mainRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];</span><br><span class="line">    NSLog(@&quot;%@&quot;,[NSRunLoop mainRunLoop]);</span><br><span class="line">&#125;</span><br><span class="line">-(void)show</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;-------&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由上述代码可以看出，NSTimer不管用是因为Mode的切换，因为如果我们在主线程使用定时器，此时RunLoop的Mode为kCFRunLoopDefaultMode，即定时器属于kCFRunLoopDefaultMode，那么此时我们滑动ScrollView时，RunLoop的Mode会切换到UITrackingRunLoopMode，因此在主线程的定时器就不在管用了，调用的方法也就不再执行了，当我们停止滑动时，RunLoop的Mode切换回kCFRunLoopDefaultMode，所以NSTimer就又管用了。</p>
<p>同样道理的还有ImageView的显示，我们直接来看代码，不再赘述了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-(void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">    // performSelector默认是在default模式下运行，因此在滑动ScrollView时，图片不会加载</span><br><span class="line">    // [self.imageView performSelector:@selector(setImage:) withObject:[UIImage imageNamed:@&quot;abc&quot;] afterDelay:2.0 ];</span><br><span class="line">    // inModes: 传入Mode数组</span><br><span class="line">    [self.imageView performSelector:@selector(setImage:) withObject:[UIImage imageNamed:@&quot;abc&quot;] afterDelay:2.0 inModes:@[NSDefaultRunLoopMode,UITrackingRunLoopMode]];</span><br></pre></td></tr></table></figure>
<p>使用GCD也可是创建计时器，而且更为精确我们来看一下代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">-(void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event</span><br><span class="line">&#123;</span><br><span class="line">    //创建队列</span><br><span class="line">    dispatch_queue_t queue = dispatch_get_global_queue(0, 0);</span><br><span class="line">    //1.创建一个GCD定时器</span><br><span class="line">    /*</span><br><span class="line">     第一个参数:表明创建的是一个定时器</span><br><span class="line">     第四个参数:队列</span><br><span class="line">     */</span><br><span class="line">    dispatch_source_t timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue);</span><br><span class="line">    // 需要对timer进行强引用，保证其不会被释放掉，才会按时调用block块</span><br><span class="line">    // 局部变量，让指针强引用</span><br><span class="line">    self.timer = timer;</span><br><span class="line">    //2.设置定时器的开始时间,间隔时间,精准度</span><br><span class="line">    /*</span><br><span class="line">     第1个参数:要给哪个定时器设置</span><br><span class="line">     第2个参数:开始时间</span><br><span class="line">     第3个参数:间隔时间</span><br><span class="line">     第4个参数:精准度 一般为0 在允许范围内增加误差可提高程序的性能</span><br><span class="line">     GCD的单位是纳秒 所以要*NSEC_PER_SEC</span><br><span class="line">     */</span><br><span class="line">    dispatch_source_set_timer(timer, DISPATCH_TIME_NOW, 2.0 * NSEC_PER_SEC, 0 * NSEC_PER_SEC);</span><br><span class="line"></span><br><span class="line">    //3.设置定时器要执行的事情</span><br><span class="line">    dispatch_source_set_event_handler(timer, ^&#123;</span><br><span class="line">        NSLog(@&quot;---%@--&quot;,[NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    // 启动</span><br><span class="line">    dispatch_resume(timer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-CFRunLoopSourceRef事件源（输入源）"><a href="#2-CFRunLoopSourceRef事件源（输入源）" class="headerlink" title="2. CFRunLoopSourceRef事件源（输入源）"></a>2. CFRunLoopSourceRef事件源（输入源）</h3><h4 id="Source分为两种"><a href="#Source分为两种" class="headerlink" title="Source分为两种"></a>Source分为两种</h4><blockquote>
<p>Source0：非基于Port的 用于用户主动触发的事件（点击button 或点击屏幕）</p>
<p>Source1：基于Port的 通过内核和其他线程相互发送消息（与内核相关）</p>
</blockquote>
<p>触摸事件及PerformSelectors会触发Source0事件源在前文已经验证过，这里不在赘述</p>
<h3 id="3-CFRunLoopObserverRef"><a href="#3-CFRunLoopObserverRef" class="headerlink" title="3. CFRunLoopObserverRef"></a>3. CFRunLoopObserverRef</h3><p><strong>CFRunLoopObserverRef是观察者，能够监听RunLoop的状态改变</strong></p>
<p>我们直接来看代码，给RunLoop添加监听者，监听其运行状态</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">-(void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event</span><br><span class="line">&#123;</span><br><span class="line">     //创建监听者</span><br><span class="line">     /*</span><br><span class="line">     第一个参数 CFAllocatorRef allocator：分配存储空间 CFAllocatorGetDefault()默认分配</span><br><span class="line">     第二个参数 CFOptionFlags activities：要监听的状态 kCFRunLoopAllActivities 监听所有状态</span><br><span class="line">     第三个参数 Boolean repeats：YES:持续监听 NO:不持续</span><br><span class="line">     第四个参数 CFIndex order：优先级，一般填0即可</span><br><span class="line">     第五个参数 ：回调 两个参数observer:监听者 activity:监听的事件</span><br><span class="line">     */</span><br><span class="line">     /*</span><br><span class="line">     所有事件</span><br><span class="line">     typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123;</span><br><span class="line">     kCFRunLoopEntry = (1UL &lt;&lt; 0),   //   即将进入RunLoop</span><br><span class="line">     kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1), // 即将处理Timer</span><br><span class="line">     kCFRunLoopBeforeSources = (1UL &lt;&lt; 2), // 即将处理Source</span><br><span class="line">     kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5), //即将进入休眠</span><br><span class="line">     kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6),// 刚从休眠中唤醒</span><br><span class="line">     kCFRunLoopExit = (1UL &lt;&lt; 7),// 即将退出RunLoop</span><br><span class="line">     kCFRunLoopAllActivities = 0x0FFFFFFFU</span><br><span class="line">     &#125;;</span><br><span class="line">     */</span><br><span class="line">    CFRunLoopObserverRef observer = CFRunLoopObserverCreateWithHandler(CFAllocatorGetDefault(), kCFRunLoopAllActivities, YES, 0, ^(CFRunLoopObserverRef observer, CFRunLoopActivity activity) &#123;</span><br><span class="line">        switch (activity) &#123;</span><br><span class="line">            case kCFRunLoopEntry:</span><br><span class="line">                NSLog(@&quot;RunLoop进入&quot;);</span><br><span class="line">                break;</span><br><span class="line">            case kCFRunLoopBeforeTimers:</span><br><span class="line">                NSLog(@&quot;RunLoop要处理Timers了&quot;);</span><br><span class="line">                break;</span><br><span class="line">            case kCFRunLoopBeforeSources:</span><br><span class="line">                NSLog(@&quot;RunLoop要处理Sources了&quot;);</span><br><span class="line">                break;</span><br><span class="line">            case kCFRunLoopBeforeWaiting:</span><br><span class="line">                NSLog(@&quot;RunLoop要休息了&quot;);</span><br><span class="line">                break;</span><br><span class="line">            case kCFRunLoopAfterWaiting:</span><br><span class="line">                NSLog(@&quot;RunLoop醒来了&quot;);</span><br><span class="line">                break;</span><br><span class="line">            case kCFRunLoopExit:</span><br><span class="line">                NSLog(@&quot;RunLoop退出了&quot;);</span><br><span class="line">                break;</span><br><span class="line"></span><br><span class="line">            default:</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    // 给RunLoop添加监听者</span><br><span class="line">    /*</span><br><span class="line">     第一个参数 CFRunLoopRef rl：要监听哪个RunLoop,这里监听的是主线程的RunLoop</span><br><span class="line">     第二个参数 CFRunLoopObserverRef observer 监听者</span><br><span class="line">     第三个参数 CFStringRef mode 要监听RunLoop在哪种运行模式下的状态</span><br><span class="line">     */</span><br><span class="line">    CFRunLoopAddObserver(CFRunLoopGetCurrent(), observer, kCFRunLoopDefaultMode);</span><br><span class="line">     /*</span><br><span class="line">     CF的内存管理（Core Foundation）</span><br><span class="line">     凡是带有Create、Copy、Retain等字眼的函数，创建出来的对象，都需要在最后做一次release</span><br><span class="line">     GCD本来在iOS6.0之前也是需要我们释放的，6.0之后GCD已经纳入到了ARC中，所以我们不需要管了</span><br><span class="line">     */</span><br><span class="line">    CFRelease(observer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们来看一下输出</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/4/23/162f05adf144fbab?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="监听者监听RunLoop运行状态"></p>
<p>以上可以看出，Observer确实用来监听RunLoop的状态，包括唤醒，休息，以及处理各种事件。</p>
<h2 id="八-RunLoop处理逻辑"><a href="#八-RunLoop处理逻辑" class="headerlink" title="八. RunLoop处理逻辑"></a>八. RunLoop处理逻辑</h2><p>这时我们再来分析RunLoop的处理逻辑，就会简单明了很多，现在回头看官方文档RunLoop的处理逻辑，对RunLoop的处理逻辑有新的认识。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/4/23/162f05adf11cf166?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="官方文档RunLoop处理逻辑"></p>
<h3 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h3><p>下面源码仅保留了主流程代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">// 共外部调用的公开的CFRunLoopRun方法，其内部会调用CFRunLoopRunSpecific</span><br><span class="line">void CFRunLoopRun(void) &#123;    /* DOES CALLOUT */</span><br><span class="line">    int32_t result;</span><br><span class="line">    do &#123;</span><br><span class="line">        result = CFRunLoopRunSpecific(CFRunLoopGetCurrent(), kCFRunLoopDefaultMode, 1.0e10, false);</span><br><span class="line">        CHECK_FOR_FORK();</span><br><span class="line">    &#125; while (kCFRunLoopRunStopped != result &amp;&amp; kCFRunLoopRunFinished != result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 经过精简的 CFRunLoopRunSpecific 函数代码，其内部会调用__CFRunLoopRun函数</span><br><span class="line">SInt32 CFRunLoopRunSpecific(CFRunLoopRef rl, CFStringRef modeName, CFTimeInterval seconds, Boolean returnAfterSourceHandled) &#123;     /* DOES CALLOUT */</span><br><span class="line"></span><br><span class="line">    // 通知Observers : 进入Loop</span><br><span class="line">    // __CFRunLoopDoObservers内部会调用 __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__</span><br><span class="line">函数</span><br><span class="line">    if (currentMode-&gt;_observerMask &amp; kCFRunLoopEntry ) __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopEntry);</span><br><span class="line"></span><br><span class="line">    // 核心的Loop逻辑</span><br><span class="line">    result = __CFRunLoopRun(rl, currentMode, seconds, returnAfterSourceHandled, previousMode);</span><br><span class="line"></span><br><span class="line">    // 通知Observers : 退出Loop</span><br><span class="line">    if (currentMode-&gt;_observerMask &amp; kCFRunLoopExit ) __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit);</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 精简后的 __CFRunLoopRun函数，保留了主要代码</span><br><span class="line">static int32_t __CFRunLoopRun(CFRunLoopRef rl, CFRunLoopModeRef rlm, CFTimeInterval seconds, Boolean stopAfterHandle, CFRunLoopModeRef previousMode) &#123;</span><br><span class="line">    int32_t retVal = 0;</span><br><span class="line">    do &#123;</span><br><span class="line">        // 通知Observers：即将处理Timers</span><br><span class="line">        __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeTimers); </span><br><span class="line"></span><br><span class="line">        // 通知Observers：即将处理Sources</span><br><span class="line">        __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeSources);</span><br><span class="line"></span><br><span class="line">        // 处理Blocks</span><br><span class="line">        __CFRunLoopDoBlocks(rl, rlm);</span><br><span class="line"></span><br><span class="line">        // 处理Sources0</span><br><span class="line">        if (__CFRunLoopDoSources0(rl, rlm, stopAfterHandle)) &#123;</span><br><span class="line">            // 处理Blocks</span><br><span class="line">            __CFRunLoopDoBlocks(rl, rlm);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 如果有Sources1，就跳转到handle_msg标记处</span><br><span class="line">        if (__CFRunLoopServiceMachPort(dispatchPort, &amp;msg, sizeof(msg_buffer), &amp;livePort, 0, &amp;voucherState, NULL)) &#123;</span><br><span class="line">            goto handle_msg;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 通知Observers：即将休眠</span><br><span class="line">        __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeWaiting);</span><br><span class="line"></span><br><span class="line">        // 进入休眠，等待其他消息唤醒</span><br><span class="line">        __CFRunLoopSetSleeping(rl);</span><br><span class="line">        __CFPortSetInsert(dispatchPort, waitSet);</span><br><span class="line">        do &#123;</span><br><span class="line">            __CFRunLoopServiceMachPort(waitSet, &amp;msg, sizeof(msg_buffer), &amp;livePort, poll ? 0 : TIMEOUT_INFINITY, &amp;voucherState, &amp;voucherCopy);</span><br><span class="line">        &#125; while (1);</span><br><span class="line"></span><br><span class="line">        // 醒来</span><br><span class="line">        __CFPortSetRemove(dispatchPort, waitSet);</span><br><span class="line">        __CFRunLoopUnsetSleeping(rl);</span><br><span class="line"></span><br><span class="line">        // 通知Observers：已经唤醒</span><br><span class="line">        __CFRunLoopDoObservers(rl, rlm, kCFRunLoopAfterWaiting);</span><br><span class="line"></span><br><span class="line">    handle_msg: // 看看是谁唤醒了RunLoop，进行相应的处理</span><br><span class="line">        if (被Timer唤醒的) &#123;</span><br><span class="line">            // 处理Timer</span><br><span class="line">            __CFRunLoopDoTimers(rl, rlm, mach_absolute_time());</span><br><span class="line">        &#125;</span><br><span class="line">        else if (被GCD唤醒的) &#123;</span><br><span class="line">            __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);</span><br><span class="line">        &#125; else &#123; // 被Sources1唤醒的</span><br><span class="line">            __CFRunLoopDoSource1(rl, rlm, rls, msg, msg-&gt;msgh_size, &amp;reply);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 执行Blocks</span><br><span class="line">        __CFRunLoopDoBlocks(rl, rlm);</span><br><span class="line"></span><br><span class="line">        // 根据之前的执行结果，来决定怎么做，为retVal赋相应的值</span><br><span class="line">        if (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123;</span><br><span class="line">            retVal = kCFRunLoopRunHandledSource;</span><br><span class="line">        &#125; else if (timeout_context-&gt;termTSR &lt; mach_absolute_time()) &#123;</span><br><span class="line">            retVal = kCFRunLoopRunTimedOut;</span><br><span class="line">        &#125; else if (__CFRunLoopIsStopped(rl)) &#123;</span><br><span class="line">            __CFRunLoopUnsetStopped(rl);</span><br><span class="line">            retVal = kCFRunLoopRunStopped;</span><br><span class="line">        &#125; else if (rlm-&gt;_stopped) &#123;</span><br><span class="line">            rlm-&gt;_stopped = false;</span><br><span class="line">            retVal = kCFRunLoopRunStopped;</span><br><span class="line">        &#125; else if (__CFRunLoopModeIsEmpty(rl, rlm, previousMode)) &#123;</span><br><span class="line">            retVal = kCFRunLoopRunFinished;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; while (0 == retVal);</span><br><span class="line"></span><br><span class="line">    return retVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述源代码中，相应处理事件函数内部还会调用更底层的函数，内部调用才是真正处理事件的函数，通过上面bt打印全部堆栈信息也可以得到验证。</p>
<blockquote>
<p><code>__CFRunLoopDoObservers 内部调用 __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__</code></p>
<p><code>__CFRunLoopDoBlocks 内部调用 __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__</code></p>
<p><code>__CFRunLoopDoSources0 内部调用 __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__</code></p>
<p><code>__CFRunLoopDoTimers 内部调用 __CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__</code></p>
<p><code>GCD 调用 __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__</code></p>
<p><code>__CFRunLoopDoSource1 内部调用 __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__</code></p>
</blockquote>
<h3 id="RunLoop处理逻辑流程图"><a href="#RunLoop处理逻辑流程图" class="headerlink" title="RunLoop处理逻辑流程图"></a>RunLoop处理逻辑流程图</h3><p>此时我们按照源码重新整理一下RunLoop处理逻辑就会很清晰</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/4/25/162fb71bddf31b33?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="RunLoop处理逻辑"></p>
<h2 id="九-RunLoop退出"><a href="#九-RunLoop退出" class="headerlink" title="九. RunLoop退出"></a>九. RunLoop退出</h2><ol>
<li>主线程销毁RunLoop退出</li>
<li>Mode中有一些Timer 、Source、 Observer，这些保证Mode不为空时保证RunLoop没有空转并且是在运行的，当Mode中为空的时候，RunLoop会立刻退出</li>
<li>我们在启动RunLoop的时候可以设置什么时候停止</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[NSRunLoop currentRunLoop]runUntilDate:&lt;#(nonnull NSDate *)#&gt;</span><br><span class="line">[NSRunLoop currentRunLoop]runMode:&lt;#(nonnull NSString *)#&gt; beforeDate:&lt;#(nonnull NSDate *)#&gt;</span><br></pre></td></tr></table></figure>
<h2 id="十-RunLoop应用"><a href="#十-RunLoop应用" class="headerlink" title="十. RunLoop应用"></a>十. RunLoop应用</h2><h3 id="1-常驻线程"><a href="#1-常驻线程" class="headerlink" title="1. 常驻线程"></a>1. 常驻线程</h3><p>常驻线程的作用：我们知道，当子线程中的任务执行完毕之后就被销毁了，那么如果我们需要开启一个子线程，在程序运行过程中永远都存在，那么我们就会面临一个问题，如何让子线程永远活着，这时就要用到常驻线程：给子线程开启一个RunLoop<strong>注意：子线程执行完操作之后就会立即释放，即使我们使用强引用引用子线程使子线程不被释放，也不能给子线程再次添加操作，或者再次开启。</strong>子线程开启RunLoop的代码，先点击屏幕开启子线程并开启子线程RunLoop，然后点击button。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;ViewController.h&quot;</span><br><span class="line"></span><br><span class="line">@interface ViewController ()</span><br><span class="line">@property(nonatomic,strong)NSThread *thread;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ViewController</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">&#125;</span><br><span class="line">-(void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event</span><br><span class="line">&#123;</span><br><span class="line">   // 创建子线程并开启</span><br><span class="line">    NSThread *thread = [[NSThread alloc]initWithTarget:self selector:@selector(show) object:nil];</span><br><span class="line">    self.thread = thread;</span><br><span class="line">    [thread start];</span><br><span class="line">&#125;</span><br><span class="line">-(void)show</span><br><span class="line">&#123;</span><br><span class="line">    // 注意：打印方法一定要在RunLoop创建开始运行之前，如果在RunLoop跑起来之后打印，RunLoop先运行起来，已经在跑圈了就出不来了，进入死循环也就无法执行后面的操作了。</span><br><span class="line">    // 但是此时点击Button还是有操作的，因为Button是在RunLoop跑起来之后加入到子线程的，当Button加入到子线程RunLoop就会跑起来</span><br><span class="line">    NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">    // 1.创建子线程相关的RunLoop，在子线程中创建即可，并且RunLoop中要至少有一个Timer 或 一个Source 保证RunLoop不会因为空转而退出，因此在创建的时候直接加入</span><br><span class="line">    // 添加Source [NSMachPort port] 添加一个端口</span><br><span class="line">    [[NSRunLoop currentRunLoop] addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode];</span><br><span class="line">    // 添加一个Timer</span><br><span class="line">    NSTimer *timer = [NSTimer scheduledTimerWithTimeInterval:2.0 target:self selector:@selector(test) userInfo:nil repeats:YES];</span><br><span class="line">    [[NSRunLoop currentRunLoop] addTimer:timer forMode:NSDefaultRunLoopMode];    </span><br><span class="line">    //创建监听者</span><br><span class="line">    CFRunLoopObserverRef observer = CFRunLoopObserverCreateWithHandler(CFAllocatorGetDefault(), kCFRunLoopAllActivities, YES, 0, ^(CFRunLoopObserverRef observer, CFRunLoopActivity activity) &#123;</span><br><span class="line">        switch (activity) &#123;</span><br><span class="line">            case kCFRunLoopEntry:</span><br><span class="line">                NSLog(@&quot;RunLoop进入&quot;);</span><br><span class="line">                break;</span><br><span class="line">            case kCFRunLoopBeforeTimers:</span><br><span class="line">                NSLog(@&quot;RunLoop要处理Timers了&quot;);</span><br><span class="line">                break;</span><br><span class="line">            case kCFRunLoopBeforeSources:</span><br><span class="line">                NSLog(@&quot;RunLoop要处理Sources了&quot;);</span><br><span class="line">                break;</span><br><span class="line">            case kCFRunLoopBeforeWaiting:</span><br><span class="line">                NSLog(@&quot;RunLoop要休息了&quot;);</span><br><span class="line">                break;</span><br><span class="line">            case kCFRunLoopAfterWaiting:</span><br><span class="line">                NSLog(@&quot;RunLoop醒来了&quot;);</span><br><span class="line">                break;</span><br><span class="line">            case kCFRunLoopExit:</span><br><span class="line">                NSLog(@&quot;RunLoop退出了&quot;);</span><br><span class="line">                break;</span><br><span class="line"></span><br><span class="line">            default:</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    // 给RunLoop添加监听者</span><br><span class="line">    CFRunLoopAddObserver(CFRunLoopGetCurrent(), observer, kCFRunLoopDefaultMode);</span><br><span class="line">    // 2.子线程需要开启RunLoop</span><br><span class="line">    [[NSRunLoop currentRunLoop]run];</span><br><span class="line">    CFRelease(observer);</span><br><span class="line">&#125;</span><br><span class="line">- (IBAction)btnClick:(id)sender &#123;</span><br><span class="line">    [self performSelector:@selector(test) onThread:self.thread withObject:nil waitUntilDone:NO];</span><br><span class="line">&#125;</span><br><span class="line">-(void)test</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;,[NSThread currentThread]);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p><strong>注意：创建子线程相关的RunLoop，在子线程中创建即可，并且RunLoop中要至少有一个Timer 或 一个Source 保证RunLoop不会因为空转而退出，因此在创建的时候直接加入，如果没有加入Timer或者Source，或者只加入一个监听者，运行程序会崩溃</strong></p>
<h3 id="2-自动释放池"><a href="#2-自动释放池" class="headerlink" title="2. 自动释放池"></a>2. 自动释放池</h3><p>Timer和Source也是一些变量，需要占用一部分存储空间，所以要释放掉，如果不释放掉，就会一直积累，占用的内存也就越来越大，这显然不是我们想要的。 那么什么时候释放，怎么释放呢？ RunLoop内部有一个自动释放池，<strong>当RunLoop开启时，就会自动创建一个自动释放池，当RunLoop在休息之前会释放掉自动释放池的东西，然后重新创建一个新的空的自动释放池</strong>，当RunLoop被唤醒重新开始跑圈时，Timer,Source等新的事件就会放到新的自动释放池中，<strong>当RunLoop退出的时候也会被释放</strong>。 注意：只有主线程的RunLoop会默认启动。也就意味着会自动创建自动释放池，子线程需要在线程调度方法中手动添加自动释放池。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@autorelease&#123;  </span><br><span class="line">      // 执行代码 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>NSTimer、ImageView显示、PerformSelector等在上面已经有过例子，这里不再赘述。</p>
<h2 id="最后检验一下自己"><a href="#最后检验一下自己" class="headerlink" title="最后检验一下自己"></a>最后检验一下自己</h2><p>文章开头的面试题，在文中都可以找到答案，这里不在赘述了。</p>
<h3 id="文献资料"><a href="#文献资料" class="headerlink" title="文献资料"></a>文献资料</h3><p><a href="https://link.juejin.im/?target=https%3A%2F%2Fdeveloper.apple.com%2Flibrary%2Fmac%2Fdocumentation%2FCocoa%2FConceptual%2FMultithreading%2FRunLoopManagement%2FRunLoopManagement.html" target="_blank" rel="noopener">苹果官方文档</a></p>
<p><a href="https://link.juejin.im/?target=https%3A%2F%2Fopensource.apple.com%2Ftarballs%2FCF%2F" target="_blank" rel="noopener">CFRunLoopRef源码</a></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/principle/">principle</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/runloop/">runloop</a>
    </span>
    

    </div>

    
  </div>
</article>

  
	<section id="comments" class="comment">
	  <div id="disqus_thread">
	  <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
	  </div>
	</section>

	<script type="text/javascript">
	var disqus_shortname = 'hanangellove';
	(function(){
	  var dsq = document.createElement('script');
	  dsq.type = 'text/javascript';
	  dsq.async = true;
	  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
	  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	}());
	(function(){
	  var dsq = document.createElement('script');
	  dsq.type = 'text/javascript';
	  dsq.async = true;
	  dsq.src = '//' + disqus_shortname + '.disqus.com/count.js';
	  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	}());
	</script>





    </main>

    <footer class="site-footer">
  <p class="site-info">
    <!--
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    </br>
  -->
    
    &copy; 2018 Han Liu
    
  </p>
</footer>
    
  </div>
</div>
</body>
</html>