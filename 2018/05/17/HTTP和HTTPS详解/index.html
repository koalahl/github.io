<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  
    <meta name="description" content="Think in Different">
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <title>
    HTTP和HTTPS详解 |
    
    寒流‘s Blog</title>
  
    <link rel="shortcut icon" href="/favicon.ico">
  
  <link rel="stylesheet" href="/css/style.css">
  
    <link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">
  
  <script src="/js/pace.min.js"></script>
</head>

<body>
<main class="content">
  <section class="outer">
  <article id="post-HTTP和HTTPS详解" class="article article-type-post" itemscope itemprop="blogPost">

  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      HTTP和HTTPS详解
    </h1>
  

      </header>
    

    
      <div class="article-meta">
        <a href="/2018/05/17/HTTP和HTTPS详解/" class="article-date">
  <time datetime="2018-05-17T06:52:13.000Z" itemprop="datePublished">2018-05-17</time>
</a>
        
  <div class="article-category">
    <a class="article-category-link" href="/categories/iOSInterview/">iOSInterview</a>
  </div>

      </div>
    

    <div class="article-entry" itemprop="articleBody">
      
      
      
        <p><img src="https://user-gold-cdn.xitu.io/2018/5/11/1634e5e739628b16?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p>
<h3 id="计算机通信原理"><a href="#计算机通信原理" class="headerlink" title="计算机通信原理"></a>计算机通信原理</h3><p>互联网的关键技术就是TCP/IP协议。两台计算机之间的通信是通过TCP/IP协议在因特网上进行的。实际上这个是两个协议：</p>
<ul>
<li>TCP: Transmission Control Protocol 传输控制协议</li>
<li>IP: Internet Protocol 网际协议。</li>
</ul>
<blockquote>
<p>引自维基百科<a href="https://link.juejin.im/?target=https%3A%2F%2Fzh.wikipedia.org%2Fwiki%2FTCP%2FIP%25E5%258D%258F%25E8%25AE%25AE%25E6%2597%258F" target="_blank" rel="noopener">TCP/IP协议族</a>是一个网络通信模型，以及一整个网络传输协议家族，为互联网的基础通信架构。该协议家族的两个核心协议：TCP（传输控制协议）和IP（网际协议），为该家族中最早通过的标准。这个协议族由互联网工程任务组负责维护。</p>
</blockquote>
<a id="more"></a>
<h4 id="TCP-应用程序之间的通信"><a href="#TCP-应用程序之间的通信" class="headerlink" title="TCP: 应用程序之间的通信"></a>TCP: 应用程序之间的通信</h4><p>TCP确保数据包以正确的次序到达，并且尝试确认数据包的内容没有改变。TCP在IP地址之上引端口（port），它允许计算机通过网络提供各种服务。一些端口号为不同的服务保留，而且这些端口号是众所周知。</p>
<p>服务或者守护进程：在提供服务的机器上，有程序监听特定端口上的通信流。例如大多数电子邮件通信流出现在端口25上，用于wwww的HTTP通信流出现在80端口上。</p>
<p>当应用程序希望通过 TCP 与另一个应用程序通信时，它会发送一个通信请求。这个请求必须被送到一个确切的地址。在双方“握手”之后，TCP 将在两个应用程序之间建立一个全双工 (full-duplex) 的通信，占用两个计算机之间整个的通信线路。TCP 用于从应用程序到网络的数据传输控制。TCP 负责在数据传送之前将它们分割为 IP 包，然后在它们到达的时候将它们重组。</p>
<p>TCP/IP 就是TCP 和 IP 两个协议在一起协同工作，有上下层次的关系。</p>
<p>TCP 负责应用软件（比如你的浏览器）和网络软件之间的通信。IP 负责计算机之间的通信。TCP 负责将数据分割并装入 IP 包，IP 负责将包发送至接受者，传输过程要经IP路由器负责根据通信量、网络中的错误或者其他参数来进行正确地寻址，然后在它们到达的时候重新组合它们。</p>
<h4 id="IP-计算机之间的通信"><a href="#IP-计算机之间的通信" class="headerlink" title="IP: 计算机之间的通信"></a>IP: 计算机之间的通信</h4><p>IP协议是计算机用来相互识别的通信的一种机制，每台计算机都有一个IP.用来在internet上标识这台计算机。 IP 负责在因特网上发送和接收数据包。通过 IP，消息（或者其他数据）被分割为小的独立的包，并通过因特网在计算机之间传送。IP 负责将每个包路由至它的目的地。</p>
<p>IP协议仅仅是允许计算机相互发消息，但它并不检查消息是否以发送的次序到达而且没有损坏（只检查关键的头数据）。为了提供消息检验功能，直接在IP协议上设计了传输控制协议TCP。</p>
<h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><h4 id="HTTP概念"><a href="#HTTP概念" class="headerlink" title="HTTP概念"></a>HTTP概念</h4><blockquote>
<p>引自维基百科<a href="https://link.juejin.im/?target=https%3A%2F%2Fzh.wikipedia.org%2Fwiki%2F%25E8%25B6%2585%25E6%2596%2587%25E6%259C%25AC%25E4%25BC%25A0%25E8%25BE%2593%25E5%258D%258F%25E8%25AE%25AE" target="_blank" rel="noopener">HTTP</a>:超文本传输协议（英文：HyperText Transfer Protocol，缩写：HTTP）是一种用于分布式、协作式和超媒体信息系统的应用层协议。HTTP是万维网的数据通信的基础。 设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。通过HTTP或者HTTPS协议请求的资源由统一资源标识符（Uniform Resource Identifiers，URI）来标识。</p>
</blockquote>
<h4 id="HTTP协议层"><a href="#HTTP协议层" class="headerlink" title="HTTP协议层"></a>HTTP协议层</h4><p>HTTP（HyperText Transfer Protocol），超文本传输协议，是一个基于TCP实现的应用层协议。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/5/11/1634e5e73955739d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p>
<h4 id="HTTP请求响应模型"><a href="#HTTP请求响应模型" class="headerlink" title="HTTP请求响应模型"></a>HTTP请求响应模型</h4><p>HTTP由请求和响应构成，是一个标准的客户端服务器模型（B/S）。HTTP协议永远都是客户端发起请求，服务器回送响应。见下图:</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/5/11/1634e5e73941831d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p>
<p>HTTP是一个无状态的协议。无状态是指客户机（Web浏览器）和服务器之间不需要建立持久的连接，这意味着当一个客户端向服务器端发出请求，然后服务器返回响应(response)，连接就被关闭了，在服务器端不保留连接的有关信息.HTTP遵循请求(Request)/应答(Response)模型。客户机（浏览器）向服务器发送请求，服务器处理请求并返回适当的应答。所有HTTP连接都被构造成一套请求和应答。</p>
<h4 id="HTTP工作过程"><a href="#HTTP工作过程" class="headerlink" title="HTTP工作过程"></a>HTTP工作过程</h4><p>一次HTTP操作称为一个事务，其工作整个过程如下：</p>
<h5 id="地址解析"><a href="#地址解析" class="headerlink" title="地址解析"></a>地址解析</h5><p>如用客户端浏览器请求这个页面：<a href="http://localhost.com:8080/index.htm" target="_blank" rel="noopener">http://localhost.com:8080/index.htm</a></p>
<p>从中分解出协议名、主机名、端口、对象路径等部分，对于我们的这个地址，解析得到的结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">协议名：http</span><br><span class="line">主机名：localhost.com</span><br><span class="line">端口：8080</span><br><span class="line">对象路径：/index.htm</span><br></pre></td></tr></table></figure>
<p>在这一步，需要域名系统DNS解析域名localhost.com,得主机的IP地址。</p>
<h5 id="封装HTTP请求数据包"><a href="#封装HTTP请求数据包" class="headerlink" title="封装HTTP请求数据包"></a>封装HTTP请求数据包</h5><p>把以上部分结合本机自己的信息，封装成一个HTTP请求数据包</p>
<h5 id="封装成TCP包，建立TCP连接（TCP的三次握手）"><a href="#封装成TCP包，建立TCP连接（TCP的三次握手）" class="headerlink" title="封装成TCP包，建立TCP连接（TCP的三次握手）"></a>封装成TCP包，建立TCP连接（TCP的三次握手）</h5><p>在HTTP工作开始之前，客户机（Web浏览器）首先要通过网络与服务器建立连接，该连接是通过TCP来完成的，该协议与IP协议共同构建Internet，即著名的TCP/IP协议族，因此Internet又被称作是TCP/IP网络。HTTP是比TCP更高层次的应用层协议，根据规则，只有低层协议建立之后才能，才能进行更层协议的连接，因此，首先要建立TCP连接，一般TCP连接的端口号是80。这里是8080端口。</p>
<h5 id="客户机发送请求命令"><a href="#客户机发送请求命令" class="headerlink" title="客户机发送请求命令"></a>客户机发送请求命令</h5><p>建立连接后，客户机发送一个请求给服务器，请求方式的格式为：统一资源标识符（URL）、协议版本号，后边是MIME信息包括请求修饰符、客户机信息和可内容。</p>
<h5 id="服务器响应"><a href="#服务器响应" class="headerlink" title="服务器响应"></a>服务器响应</h5><p>服务器接到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是MIME信息包括服务器信息、实体信息和可能的内容。</p>
<p>实体消息是服务器向浏览器发送头信息后，它会发送一个空白行来表示头信息的发送到此为结束，接着，它就以Content-Type应答头信息所描述的格式发送用户所请求的实际数据</p>
<h5 id="服务器关闭TCP连接"><a href="#服务器关闭TCP连接" class="headerlink" title="服务器关闭TCP连接"></a>服务器关闭TCP连接</h5><p>一般情况下，一旦Web服务器向浏览器发送了请求数据，它就要关闭TCP连接，然后如果浏览器或者服务器在其头信息加入了这行代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection:keep-alive</span><br></pre></td></tr></table></figure>
<p>TCP连接在发送后将仍然保持打开状态，于是，浏览器可以继续通过相同的连接发送请求。保持连接节省了为每个请求建立新连接所需的时间，还节约了网络带宽。</p>
<h4 id="HTTP工作过程用到的概念"><a href="#HTTP工作过程用到的概念" class="headerlink" title="HTTP工作过程用到的概念"></a>HTTP工作过程用到的概念</h4><h5 id="报文格式"><a href="#报文格式" class="headerlink" title="报文格式"></a>报文格式</h5><p>HTTP1.0的报文有两种类型：请求和响应。其报文格式分别为：</p>
<h6 id="请求报文格式"><a href="#请求报文格式" class="headerlink" title="请求报文格式"></a>请求报文格式</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">请求方法 URL HTTP/版本号</span><br><span class="line">请求首部字段(可选)</span><br><span class="line">空行</span><br><span class="line">body(只对Post请求有效)</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GET http://m.baidu.com/ HTTP/1.1</span><br><span class="line">Host m.baidu.com</span><br><span class="line">Connection Keep-Alive</span><br><span class="line">...// 其他header</span><br><span class="line"></span><br><span class="line">key=iOS</span><br></pre></td></tr></table></figure>
<h6 id="响应报文格式"><a href="#响应报文格式" class="headerlink" title="响应报文格式"></a>响应报文格式</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HTTP/版本号 返回码 返回码描述</span><br><span class="line">应答首部字段(可选)</span><br><span class="line">空行</span><br><span class="line">body</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type text/html;charset=UTF-8</span><br><span class="line">...// 其他header</span><br><span class="line"></span><br><span class="line">&lt;html&gt;...</span><br></pre></td></tr></table></figure>
<h5 id="URL的结构"><a href="#URL的结构" class="headerlink" title="URL的结构"></a>URL的结构</h5><p>使用HTTP协议访问资源是通过URL（Uniform Resource Locator）统一资源定位符来实现的。URL的格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">scheme://host:port/path?query</span><br><span class="line"></span><br><span class="line">scheme: 表示协议，如Http, Https, Ftp等；</span><br><span class="line">host: 表示所访问资源所在的主机名：如：www.baidu.com;</span><br><span class="line">port: 表示端口号，默认为80；</span><br><span class="line">path: 表示所访问的资源在目标主机上的储存路径；</span><br><span class="line">query: 表示查询条件；</span><br><span class="line"></span><br><span class="line">例如： http://www.baidu.com/search?words=Baidu</span><br></pre></td></tr></table></figure>
<h5 id="HTTP的请求方法"><a href="#HTTP的请求方法" class="headerlink" title="HTTP的请求方法"></a>HTTP的请求方法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET: 获取URL指定的资源；</span><br><span class="line">POST：传输实体信息</span><br><span class="line">PUT：上传文件</span><br><span class="line">DELETE：删除文件</span><br><span class="line">HEAD：获取报文首部，与GET相比，不返回报文主体部分</span><br><span class="line">OPTIONS：询问支持的方法</span><br><span class="line">TRACE：追踪请求的路径；</span><br><span class="line">CONNECT：要求在与代理服务器通信时建立隧道，使用隧道进行TCP通信。主要使用SSL和TLS将数据加密后通过网络隧道进行传输。</span><br></pre></td></tr></table></figure>
<h5 id="报文字段"><a href="#报文字段" class="headerlink" title="报文字段"></a>报文字段</h5><p>HTTP首部字段由字段名和字段值组成，中间以”:”分隔，如Content-Type: text/html.其中，同一个字段名可对应多个字段值。</p>
<p>HTTP的报文字段分为5种：</p>
<ul>
<li>请求报文字段</li>
<li>应答报文字段</li>
<li>实体首部字段</li>
<li>通用报文字段</li>
<li>其他报文字段</li>
</ul>
<h6 id="请求报文字段"><a href="#请求报文字段" class="headerlink" title="请求报文字段"></a>请求报文字段</h6><p>HTTP请求中支持的报文字段。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">Accept：客户端能够处理的媒体类型。如text/html, 表示客户端让服务器返回html类型的数据，如果没有，返回text</span><br><span class="line">类型的也可以。媒体类型的格式一般为：type/subType, 表示优先请求subType类型的数据，如果没有，返回type类型</span><br><span class="line">数据也可以。</span><br><span class="line"></span><br><span class="line">常见的媒体类型：</span><br><span class="line">文本文件：text/html, text/plain, text/css, application/xml</span><br><span class="line">图片文件：iamge/jpeg, image/gif, image/png;</span><br><span class="line">视频文件：video/mpeg</span><br><span class="line">应用程序使用的二进制文件：application/octet-stream, application/zip</span><br><span class="line"></span><br><span class="line">Accept字段可设置多个字段值，这样服务器依次进行匹配，并返回最先匹配到的媒体类型，当然，也可通过q参数来设置</span><br><span class="line">媒体类型的权重，权重越高，优先级越高。q的取值为[0, 1], 可取小数点后3位，默认为1.0。例如：</span><br><span class="line">Accept: text/html, application/xml; q=0.9, */*</span><br><span class="line"></span><br><span class="line">Accept-Charset: 表示客户端支持的字符集。例如：Accept-Charset: GB2312, ISO-8859-1</span><br><span class="line"></span><br><span class="line">Accept-Encoding： 表示客户端支持的内容编码格式。如：Accept-Encoding：gzip</span><br><span class="line"></span><br><span class="line">常用的内容编码：</span><br><span class="line">gzip: 由文件压缩程序gzip生成的编码格式；</span><br><span class="line">compress: 由Unix文件压缩程序compress生成的编码格式；</span><br><span class="line">deflate: 组合使用zlib和deflate压缩算法生成的编码格式；</span><br><span class="line">identity：默认的编码格式，不执行压缩。</span><br><span class="line"></span><br><span class="line">Accept-Language：表示客户端支持的语言。如：Accept-Language: zh-cn, en</span><br><span class="line"></span><br><span class="line">Authorization：表示客户端的认证信息。客户端在访问需要认证的也是时，服务器会返回401，随后客户端将认证信息</span><br><span class="line">加在Authorization字段中发送到服务器后，如果认证成功，则返回200. 如Linux公社下的Ftp服务器就是这种流程：</span><br><span class="line">ftp://ftp1.linuxidc.com。</span><br><span class="line"></span><br><span class="line">Host: 表示访问资源所在的主机名，即URL中的域名部分。如：m.baidu.com</span><br><span class="line"></span><br><span class="line">If-Match: If-Match的值与所请求资源的ETag值（实体标记，与资源相关联。资源变化，实体标记跟着变化）一致时，</span><br><span class="line">服务器才处理此请求。</span><br><span class="line"></span><br><span class="line">If-Modified-Since: 用于确认客户端拥有的本地资源的时效性。 如果客户端请求的资源在If-Modified-Since指定</span><br><span class="line">的时间后发生了改变，则服务器处理该请求。如：If-Modified-Since:Thu 09 Jul 2018 00:00:00, 表示如果客户</span><br><span class="line">端请求的资源在2018年1月9号0点之后发生了变化，则服务器处理改请求。通过该字段我们可解决以下问题：有一个包含大</span><br><span class="line">量数据的接口，且实时性较高，我们在刷新时就可使用改字段，从而避免多余的流量消耗。</span><br><span class="line"></span><br><span class="line">If-None-Match: If-Match的值与所请求资源的ETag值不一致时服务器才处理此请求。</span><br><span class="line"></span><br><span class="line">If-Range： If-Range的值（ETag值或时间）与所访问资源的ETag值或时间相一致时，服务器处理此请求，并返回</span><br><span class="line">Range字段中设置的指定范围的数据。如果不一致，则返回所有内容。If-Range其实算是If-Match的升级版，因为它</span><br><span class="line">的值不匹配时，依然能够返回数据，而If-Match不匹配时，请求不会被处理，需要数据时需再次进行请求。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">If-Unmodified-Since：与If-Modified-Since相反，表示请求的资源在指定的时间之后未发生变化时，才处理请求，</span><br><span class="line">否则返回412。</span><br><span class="line"></span><br><span class="line">Max-Forwards：表示请求可经过的服务器的最大数目，请求每被转发一次，Max-Forwards减1，当Max-Forwards为0</span><br><span class="line">时，所在的服务器将不再转发，而是直接做出应答。通过此字段可定位通信问题，比如之前支付宝光纤被挖断，就可通过设</span><br><span class="line">置Max-Forwards来定位大概的位置。</span><br><span class="line"></span><br><span class="line">Proxy-Authorization：当客户端接收到来自代理服务器的认证质询时，客户端会将认证信息添加到</span><br><span class="line">Proxy-Authorization来完成认证。与Authorization类似，只不过Authorization是发生在客户端与服务端之间。</span><br><span class="line"></span><br><span class="line">Range：获取部分资源，例如：Range: bytes=500-1000表示获取指定资源的第500到1000字节之间的内容，如果服务器</span><br><span class="line">能够正确处理，则返回206作为应答，表示返回了部分数据，如果不能处理这种范围请求，则以200作为应答，返回完整的</span><br><span class="line">数据，</span><br><span class="line"></span><br><span class="line">Referer：告知服务器请求是从哪个页面发起的。例如在百度首页中搜索某个关键字，结果页面的请求头部就会有这个字段，</span><br><span class="line">其值为https://www.baidu.com/。通过这个字段可统计广告的点击情况。</span><br><span class="line"></span><br><span class="line">User-Agent：将发起请求的浏览器和代理名称等信息发送给服务端，例如：</span><br><span class="line">User-Agent: Mozilla/5.0 (Linux; Android 5.0; SM-G900P Build/LRX21T) AppleWebKit/537.36</span><br><span class="line">(KHTML, like Gecko) Chrome/63.0.3239.84 Mobile Safari/537.36</span><br></pre></td></tr></table></figure>
<h6 id="应答报文字段"><a href="#应答报文字段" class="headerlink" title="应答报文字段"></a>应答报文字段</h6><p>HTTP应答中支持的报文字段。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">表示不能处理。</span><br><span class="line"></span><br><span class="line">Age：服务端告知客户端，源服务器（而不是缓存服务器）在多久之前创建了响应。</span><br><span class="line">单位为秒。</span><br><span class="line"></span><br><span class="line">ETag： 实体资源的标识，可用来请求指定的资源。</span><br><span class="line"></span><br><span class="line">Location：请求的资源所在的新位置。</span><br><span class="line"></span><br><span class="line">Proxy-Authenticate：将代理服务器需要的认证信息发送给客户端。</span><br><span class="line"></span><br><span class="line">Retry-After：服务端告知客户端多久之后再重试，一般与503和3xx重定向类型的应答一起使用。</span><br><span class="line"></span><br><span class="line">Server：告知服务端当前使用的HTTP服务器应用程序的相关信息。</span><br><span class="line"></span><br><span class="line">WWW-Authenticate：告知客户端适用于所访问资源的认证方案，如Basic或Digest。401的响应中肯定带有</span><br><span class="line">WWW-Authenticate字段。</span><br></pre></td></tr></table></figure>
<h6 id="实体首部字段"><a href="#实体首部字段" class="headerlink" title="实体首部字段"></a>实体首部字段</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Allow：通知客户端，服务器所支持的请求方法。但服务器收到不支持的请求方法时，会以405（Method Not Allowed）</span><br><span class="line">作为响应。</span><br><span class="line"></span><br><span class="line">Content-Encoding：告知客户端，服务器对资源的内容编码。</span><br><span class="line"></span><br><span class="line">Content-Language：告知客户端，资源所使用的自然语言。</span><br><span class="line"></span><br><span class="line">Content-Length：告知客户端资源的长度</span><br><span class="line"></span><br><span class="line">Content-Location：告知客户端资源所在的位置。</span><br><span class="line"></span><br><span class="line">Content-Type：告知客户端资源的媒体类型，取值同请求首部字段中的Accept。</span><br><span class="line"></span><br><span class="line">Expires：告知客户端资源的失效日期。可用于对缓存的处理。</span><br><span class="line"></span><br><span class="line">Last-Modified：告知客户端资源最后一次修改的时间。</span><br></pre></td></tr></table></figure>
<h6 id="通用报文字段"><a href="#通用报文字段" class="headerlink" title="通用报文字段"></a>通用报文字段</h6><p>即可在HTTP请求中使用，也可在HTTP应答中使用的报文字段。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control：控制缓存行为；</span><br><span class="line"></span><br><span class="line">Connection：管理持久连接，设置其值为Keep-Alive可实现长连接。</span><br><span class="line"></span><br><span class="line">Date：创建HTTP报文的日期和时间。</span><br><span class="line"></span><br><span class="line">Pragma：Http/1.1之前的历史遗留字段，仅作为HTTP/1.0向后兼容而定义，虽然是通用字段，当通常被使用在客户单的</span><br><span class="line">请求中，如Pragma: no-cache, 表示客户端在请求过程中不循序服务端返回缓存的数据；</span><br><span class="line"></span><br><span class="line">Transfer-Encoding：规定了传输报文主题时使用的传输编码，如Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">Upgrade: 用于检查HTTP协议或其他协议是否有可使用的更高版本。</span><br><span class="line"></span><br><span class="line">Via：追踪客户端和服务端之间的报文的传输路径，还可避免会环的发生，所以在经过代理时必须添加此字段。</span><br><span class="line"></span><br><span class="line">Warning：Http/1.1的报文字段，从Http/1.0的AfterRetry演变而来，用来告知用户一些与缓存相关的警告信息。</span><br></pre></td></tr></table></figure>
<h6 id="其他报文字段"><a href="#其他报文字段" class="headerlink" title="其他报文字段"></a>其他报文字段</h6><p>这些字段不是HTTP协议中定义的，但被广泛应用于HTTP请求中。</p>
<ul>
<li><p>Cookie：属于请求型报文字段，在请求时添加Cookie, 以实现HTTP的状态记录。</p>
</li>
<li><p>Set-Cookie：属于应答型报文字段。服务器给客户端传递Cookie信息时，就是通过此字段实现的。</p>
</li>
</ul>
<p>Set-Cookie的字段属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">NAME=VALUE：赋予Cookie的名称和值；</span><br><span class="line">expires=DATE: Cookie的有效期；</span><br><span class="line">path=PATH: 将服务器上的目录作为Cookie的适用对象，若不指定，则默认为文档所在的文件目录；</span><br><span class="line">domin=域名：作为Cookies适用对象的域名，若不指定，则默认为创建Cookie的服务器域名；</span><br><span class="line">Secure: 仅在HTTPS安全通信是才会发送Cookie；</span><br><span class="line">HttpOnly: 使Cookie不能被JS脚本访问；</span><br><span class="line"></span><br><span class="line">如：Set-Cookie:BDSVRBFE=Go; max-age=10; domain=m.baidu.com; path=/</span><br></pre></td></tr></table></figure>
<h5 id="HTTP应答状态码"><a href="#HTTP应答状态码" class="headerlink" title="HTTP应答状态码"></a>HTTP应答状态码</h5><table>
<thead>
<tr>
<th>状态码</th>
<th>类别</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1xx</td>
<td>Informational(信息性状态码)</td>
<td>请求正在被处理</td>
</tr>
<tr>
<td>2xx</td>
<td>Success(成功状态码)</td>
<td>请求处理成功</td>
</tr>
<tr>
<td>3xx</td>
<td>Redirection(重定向状态码)</td>
<td>需要进行重定向</td>
</tr>
<tr>
<td>4xx</td>
<td>Client Error(客户端状态码)</td>
<td>服务器无法处理请求</td>
</tr>
<tr>
<td>5xx</td>
<td>Server Error(服务端状态码)</td>
<td>服务器处理请求时出错</td>
</tr>
</tbody>
</table>
<p>常见应答状态码：</p>
<p><img src="data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;1097&quot; height=&quot;686&quot;&gt;&lt;/svg" alt=""></p>
<p>了解应答状态码的含义，有助于我们在开发过程中定位问题，比如出现4xx, 我们首先需要检查的是请求是否有问题，而出现5xx时，则应让服务端做相应的检查工作。</p>
<h4 id="HTTP缺点"><a href="#HTTP缺点" class="headerlink" title="HTTP缺点"></a>HTTP缺点</h4><ul>
<li>通信使用明文，可能被窃听</li>
<li>不验证通信方的身份，可能遭遇伪装</li>
<li>无法证明报文的完整性，有可能遭遇篡改</li>
</ul>
<p>以上是HTTP的缺点，这在网络通信中对企业安全是很致命的问题。那HTTPS能解决这些问题吗？下面讲讲HTTPS。</p>
<h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><p>HTTP+加密+认证+完整性保护 = HTTPS</p>
<h4 id="HTTPS概念"><a href="#HTTPS概念" class="headerlink" title="HTTPS概念"></a>HTTPS概念</h4><blockquote>
<p>引自维基百科<a href="https://link.juejin.im/?target=https%3A%2F%2Fzh.wikipedia.org%2Fwiki%2F%25E8%25B6%2585%25E6%2596%2587%25E6%259C%25AC%25E4%25BC%25A0%25E8%25BE%2593%25E5%25AE%2589%25E5%2585%25A8%25E5%258D%258F%25E8%25AE%25AE" target="_blank" rel="noopener">HTTPS</a>：超文本传输安全协议（英语：Hypertext Transfer Protocol Secure，缩写：HTTPS，常称为HTTP over TLS，HTTP over SSL或HTTP Secure）是一种通过计算机网络进行安全通信的传输协议。HTTPS经由HTTP进行通信，但利用SSL/TLS来加密数据包。HTTPS开发的主要目的，是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。这个协议由网景公司（Netscape）在1994年首次提出，随后扩展到互联网上。历史上，HTTPS连接经常用于万维网上的交易支付和企业信息系统中敏感信息的传输。在2000年代晚期和2010年代早期，HTTPS开始广泛使用于保护所有类型网站上的网页真实性，保护账户和保持用户通信，身份和网络浏览的私密性。</p>
</blockquote>
<p>HTTP协议采用明文传输信息，存在信息窃听、信息篡改和信息劫持的风险，而协议TLS/SSL具有身份验证、信息加密和完整性校验的功能，可以避免此类问题发生。</p>
<p>TLS/SSL全称安全传输层协议Transport Layer Security, 是介于TCP和HTTP之间的一层安全协议，不影响原有的TCP协议和HTTP协议，所以使用HTTPS基本上不需要对HTTP页面进行太多的改造。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/5/11/1634e5e73936060f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p>
<p>HTTPS是在HTTP上建立SSL加密层，并对传输数据进行加密，是HTTP协议的安全版。HTTPS主要作用是：</p>
<ul>
<li>对数据进行加密，并建立一个信息安全通道，来保证传输过程中的数据安全</li>
<li>对网站服务器进行真实身份认证</li>
</ul>
<h4 id="HTTPS和HTTP的区别"><a href="#HTTPS和HTTP的区别" class="headerlink" title="HTTPS和HTTP的区别"></a>HTTPS和HTTP的区别</h4><p><img src="https://user-gold-cdn.xitu.io/2018/5/11/1634e5e73b781926?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p>
<p>可以看到HTTPS比HTTP多了一层TLS/SSL协议，这个协议是干嘛的，有什么作用呢？ 下面讲解TLS/SSL工作原理。</p>
<h4 id="TLS-SSL工作原理"><a href="#TLS-SSL工作原理" class="headerlink" title="TLS/SSL工作原理"></a>TLS/SSL工作原理</h4><p>HTTPS协议的主要功能基本都依赖于TLS/SSL协议，TLS/SSL的功能实现主要依赖于三类基本算法：散列函数 Hash、对称加密和非对称加密，其利用非对称加密实现身份认证和密钥协商，对称加密算法采用协商的密钥对数据加密，基于散列函数验证信息的完整性。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/5/11/1634e5e77c014d22?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/5/11/1634e5e77c5d7fff?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p>
<h5 id="散列函数Hash"><a href="#散列函数Hash" class="headerlink" title="散列函数Hash"></a>散列函数Hash</h5><p>常见的有 MD5、SHA1、SHA256，该类函数特点是函数单向不可逆、对输入非常敏感、输出长度固定，针对数据的任何修改都会改变散列函数的结果，用于防止信息篡改并验证数据的完整性; 在信息传输过程中，散列函数不能单独实现信息防篡改，因为明文传输，中间人可以修改信息之后重新计算信息摘要，因此需要对传输的信息以及信息摘要进行加密;</p>
<h5 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h5><p>常见的有AES-CBC、DES、3DES、AES-GCM等，相同的密钥可以用于信息的加密和解密，掌握密钥才能获取信息，能够防止信息窃听，通信方式是1对1; 对称加密的优势是信息传输1对1，需要共享相同的密码，密码的安全是保证信息安全的基础，服务器和 N 个客户端通信，需要维持 N 个密码记录，且缺少修改密码的机制;</p>
<h5 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h5><p>即常见的 RSA 算法，还包括 ECC、DH 等算法，算法特点是，密钥成对出现，一般称为公钥(公开)和私钥(保密)，公钥加密的信息只能私钥解开，私钥加密的信息只能公钥解开。因此掌握公钥的不同客户端之间不能互相解密信息，只能和掌握私钥的服务器进行加密通信，服务器可以实现1对多的通信，客户端也可以用来验证掌握私钥的服务器身份。 非对称加密的特点是信息传输1对多，服务器只需要维持一个私钥就能够和多个客户端进行加密通信，但服务器发出的信息能够被所有的客户端解密，且该算法的计算复杂，加密速度慢。</p>
<p><strong>结合三类算法的特点，TLS的基本工作方式是，客户端使用非对称加密与服务器进行通信，实现身份验证并协商对称加密使用的密钥， 然后对称加密算法采用协商密钥对信息以及信息摘要进行加密通信，不同的节点之间采用的对称密钥不同，从而可以保证信息只能通信双方获取。</strong></p>
<h4 id="PKI体系"><a href="#PKI体系" class="headerlink" title="PKI体系"></a>PKI体系</h4><h5 id="RSA身份验证的隐患"><a href="#RSA身份验证的隐患" class="headerlink" title="RSA身份验证的隐患"></a>RSA身份验证的隐患</h5><p>身份验证和密钥协商是TLS的基础功能，要求的前提是合法的服务器掌握着对应的私钥。但RSA算法无法确保服务器身份的合法性，因为公钥并不包含服务器的信息，存在安全隐患:</p>
<ul>
<li>客户端C和服务器S进行通信，中间节点M截获了二者的通信;</li>
<li>节点M自己计算产生一对公钥pub_M和私钥pri_M;</li>
<li>C向S请求公钥时，M把自己的公钥pub_M发给了C;</li>
<li>C使用公钥 pub_M加密的数据能够被M解密，因为M掌握对应的私钥pri_M，而 C无法根据公钥信息判断服务器的身份，从而 C和 * M之间建立了”可信”加密连接;</li>
<li>中间节点 M和服务器S之间再建立合法的连接，因此 C和 S之间通信被M完全掌握，M可以进行信息的窃听、篡改等操作。</li>
<li>另外，服务器也可以对自己的发出的信息进行否认，不承认相关信息是自己发出。</li>
</ul>
<p>因此该方案下至少存在两类问题：中间人攻击和信息抵赖。</p>
<p><img src="data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;699&quot; height=&quot;525&quot;&gt;&lt;/svg" alt=""></p>
<h5 id="身份验证CA和证书"><a href="#身份验证CA和证书" class="headerlink" title="身份验证CA和证书"></a>身份验证CA和证书</h5><p>解决上述身份验证问题的关键是确保获取的公钥途径是合法的，能够验证服务器的身份信息，为此需要引入权威的第三方机构CA(如沃通CA)。CA 负责核实公钥的拥有者的信息，并颁发认证”证书”，同时能够为使用者提供证书验证服务，即PKI体系(PKI基础知识)。</p>
<p>基本的原理为，CA负责审核信息，然后对关键信息利用私钥进行”签名”，公开对应的公钥，客户端可以利用公钥验证签名。CA也可以吊销已经签发的证书，基本的方式包括两类 CRL 文件和 OCSP。CA使用具体的流程如下：</p>
<p><img src="data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;790&quot; height=&quot;623&quot;&gt;&lt;/svg" alt=""></p>
<p>a.服务方S向第三方机构CA提交公钥、组织信息、个人信息(域名)等信息并申请认证;</p>
<p>b.CA通过线上、线下等多种手段验证申请者提供信息的真实性，如组织是否存在、企业是否合法，是否拥有域名的所有权等;</p>
<p>c.如信息审核通过，CA会向申请者签发认证文件-证书。 证书包含以下信息：申请者公钥、申请者的组织信息和个人信息、签发机构 CA的信息、有效时间、证书序列号等信息的明文，同时包含一个签名; 签名的产生算法：首先，使用散列函数计算公开的明文信息的信息摘要，然后，采用 CA的私钥对信息摘要进行加密，密文即签名;</p>
<p>d.客户端 C 向服务器 S 发出请求时，S 返回证书文件;</p>
<p>e.客户端 C读取证书中的相关的明文信息，采用相同的散列函数计算得到信息摘要，然后，利用对应 CA的公钥解密签名数据，对比证书的信息摘要，如果一致，则可以确认证书的合法性，即公钥合法;</p>
<p>f.客户端然后验证证书相关的域名信息、有效时间等信息;</p>
<p>g.客户端会内置信任CA的证书信息(包含公钥)，如果CA不被信任，则找不到对应 CA的证书，证书也会被判定非法。</p>
<p>在这个过程注意几点：</p>
<p>a.申请证书不需要提供私钥，确保私钥永远只能服务器掌握;</p>
<p>b.证书的合法性仍然依赖于非对称加密算法，证书主要是增加了服务器信息以及签名;</p>
<p>c.内置 CA 对应的证书称为根证书，颁发者和使用者相同，自己为自己签名，即自签名证书（为什么说”部署自签SSL证书非常不安全”）</p>
<p>d.证书=公钥+申请者与颁发者信息+签名;</p>
<h5 id="证书链"><a href="#证书链" class="headerlink" title="证书链"></a>证书链</h5><p>如 CA根证书和服务器证书中间增加一级证书机构，即中间证书，证书的产生和验证原理不变，只是增加一层验证，只要最后能够被任何信任的CA根证书验证合法即可。</p>
<p>a.服务器证书 server.pem 的签发者为中间证书机构 inter，inter 根据证书 inter.pem 验证 server.pem 确实为自己签发的有效证书;</p>
<p>b.中间证书 inter.pem 的签发 CA 为 root，root 根据证书 root.pem 验证 inter.pem 为自己签发的合法证书;</p>
<p>c.客户端内置信任 CA 的 root.pem 证书，因此服务器证书 server.pem 的被信任。</p>
<p><img src="data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;698&quot; height=&quot;219&quot;&gt;&lt;/svg" alt=""></p>
<p>服务器证书、中间证书与根证书在一起组合成一条合法的证书链，证书链的验证是自下而上的信任传递的过程。 二级证书结构存在的优势：</p>
<p>a.减少根证书结构的管理工作量，可以更高效的进行证书的审核与签发;</p>
<p>b.根证书一般内置在客户端中，私钥一般离线存储，一旦私钥泄露，则吊销过程非常困难，无法及时补救;</p>
<p>c.中间证书结构的私钥泄露，则可以快速在线吊销，并重新为用户签发新的证书;</p>
<p>d.证书链四级以内一般不会对 HTTPS 的性能造成明显影响。</p>
<p><img src="data:image/svg+xml;utf8,&lt;?xml version=&quot;1.0&quot;?&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;747&quot; height=&quot;494&quot;&gt;&lt;/svg" alt=""></p>
<p>证书链有以下特点：</p>
<p>a.同一本服务器证书可能存在多条合法的证书链。 因为证书的生成和验证基础是公钥和私钥对，如果采用相同的公钥和私钥生成不同的中间证书，针对被签发者而言，该签发机构都是合法的 CA，不同的是中间证书的签发机构不同;</p>
<p>b.不同证书链的层级不一定相同，可能二级、三级或四级证书链。 中间证书的签发机构可能是根证书机构也可能是另一个中间证书机构，所以证书链层级不一定相同。</p>
<h5 id="证书吊销"><a href="#证书吊销" class="headerlink" title="证书吊销"></a>证书吊销</h5><p>CA 机构能够签发证书，同样也存在机制宣布以往签发的证书无效。证书使用者不合法，CA 需要废弃该证书;或者私钥丢失，使用者申请让证书无效。主要存在两类机制：CRL 与 OCSP。</p>
<h6 id="CRL"><a href="#CRL" class="headerlink" title="CRL"></a>CRL</h6><p>Certificate Revocation List, 证书吊销列表(什么是证书吊销列表(CRL)？吊销列表起什么作用)，一个单独的文件。该文件包含了 CA 已经吊销的证书序列号(唯一)与吊销日期，同时该文件包含生效日期并通知下次更新该文件的时间，当然该文件必然包含 CA 私钥的签名以验证文件的合法性。 证书中一般会包含一个 URL 地址 CRL Distribution Point，通知使用者去哪里下载对应的 CRL 以校验证书是否吊销。该吊销方式的优点是不需要频繁更新，但是不能及时吊销证书，因为 CRL 更新时间一般是几天，这期间可能已经造成了极大损失。</p>
<h6 id="OCSP"><a href="#OCSP" class="headerlink" title="OCSP"></a>OCSP</h6><p>Online Certificate Status Protocol, 证书状态在线查询协议，一个实时查询证书是否吊销的方式。请求者发送证书的信息并请求查询，服务器返回正常、吊销或未知中的任何一个状态。证书中一般也会包含一个 OCSP 的 URL 地址，要求查询服务器具有良好的性能。部分 CA 或大部分的自签 CA (根证书)都是未提供 CRL 或 OCSP 地址的，对于吊销证书会是一件非常麻烦的事情。</p>
<h4 id="HTTPS性能与优化"><a href="#HTTPS性能与优化" class="headerlink" title="HTTPS性能与优化"></a>HTTPS性能与优化</h4><h5 id="HTTPS性能损耗"><a href="#HTTPS性能损耗" class="headerlink" title="HTTPS性能损耗"></a>HTTPS性能损耗</h5><p>前文讨论了HTTPS原理与优势：身份验证、信息加密与完整性校验等，且未对TCP和HTTP协议做任何修改。但通过增加新协议以实现更安全的通信必然需要付出代价，HTTPS协议的性能损耗主要体现如下：</p>
<ul>
<li>增加延时</li>
</ul>
<p>分析前面的握手过程，一次完整的握手至少需要两端依次来回两次通信，至少增加延时2<em> RTT，利用会话缓存从而复用连接，延时也至少1</em> RTT*</p>
<ul>
<li>消耗较多的CPU资源</li>
</ul>
<p>除数据传输之外，HTTPS通信主要包括对对称加解密、非对称加解密(服务器主要采用私钥解密数据);压测 TS8 机型的单核 CPU：对称加密算法AES-CBC-256 吞吐量 600Mbps，非对称 RSA 私钥解密200次/s。不考虑其它软件层面的开销，10G 网卡为对称加密需要消耗 CPU 约17核，24核CPU最多接入 HTTPS 连接 4800; 静态节点当前10G 网卡的 TS8 机型的 HTTP 单机接入能力约为10w/s，如果将所有的HTTP连接变为HTTPS连接，则明显RSA的解密最先成为瓶颈。因此，RSA的解密能力是当前困扰HTTPS接入的主要难题。</p>
<h5 id="HTTPS接入优化"><a href="#HTTPS接入优化" class="headerlink" title="HTTPS接入优化"></a>HTTPS接入优化</h5><h6 id="CDN接入"><a href="#CDN接入" class="headerlink" title="CDN接入"></a>CDN接入</h6><p>HTTPS 增加的延时主要是传输延时 RTT，RTT 的特点是节点越近延时越小，CDN 天然离用户最近，因此选择使用 CDN 作为 HTTPS 接入的入口，将能够极大减少接入延时。CDN 节点通过和业务服务器维持长连接、会话复用和链路质量优化等可控方法，极大减少 HTTPS 带来的延时。</p>
<h6 id="会话缓存"><a href="#会话缓存" class="headerlink" title="会话缓存"></a>会话缓存</h6><p>虽然前文提到 HTTPS 即使采用会话缓存也要至少1*RTT的延时，但是至少延时已经减少为原来的一半，明显的延时优化;同时，基于会话缓存建立的 HTTPS 连接不需要服务器使用RSA私钥解密获取 Pre-master 信息，可以省去CPU 的消耗。如果业务访问连接集中，缓存命中率高，则HTTPS的接入能力讲明显提升。当前TRP平台的缓存命中率高峰时期大于30%，10k/s的接入资源实际可以承载13k/的接入，收效非常可观。</p>
<h6 id="硬件加速"><a href="#硬件加速" class="headerlink" title="硬件加速"></a>硬件加速</h6><p>为接入服务器安装专用的SSL硬件加速卡，作用类似 GPU，释放 CPU，能够具有更高的 HTTPS 接入能力且不影响业务程序的。测试某硬件加速卡单卡可以提供35k的解密能力，相当于175核 CPU，至少相当于7台24核的服务器，考虑到接入服务器其它程序的开销，一张硬件卡可以实现接近10台服务器的接入能力。</p>
<h6 id="远程解密"><a href="#远程解密" class="headerlink" title="远程解密"></a>远程解密</h6><p>本地接入消耗过多的 CPU 资源，浪费了网卡和硬盘等资源，考虑将最消耗 CPU 资源的RSA解密计算任务转移到其它服务器，如此则可以充分发挥服务器的接入能力，充分利用带宽与网卡资源。远程解密服务器可以选择 CPU 负载较低的机器充当，实现机器资源复用，也可以是专门优化的高计算性能的服务器。当前也是 CDN 用于大规模HTTPS接入的解决方案之一。</p>
<h6 id="SPDY-HTTP2"><a href="#SPDY-HTTP2" class="headerlink" title="SPDY/HTTP2"></a>SPDY/HTTP2</h6><p>前面的方法分别从减少传输延时和单机负载的方法提高 HTTPS 接入性能，但是方法都基于不改变 HTTP 协议的基础上提出的优化方法，SPDY/HTTP2 利用 TLS/SSL 带来的优势，通过修改协议的方法来提升 HTTPS 的性能，提高下载速度等。</p>
<p>作者：jackyshan_<br>链接：<a href="https://juejin.im/post/5af557a3f265da0b9265a498?utm_source=gold_browser_extension" target="_blank" rel="noopener">https://juejin.im/post/5af557a3f265da0b9265a498?utm_source=gold_browser_extension</a><br>來源：掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://hl1987.com/2018/05/17/HTTP和HTTPS详解/" data-id="cjw81wo0d000jmyf0725rcrmr"
         class="article-share-link">Share</a>
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/HTTP/">HTTP</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/HTTPS/">HTTPS</a></li></ul>

    </footer>

  </div>

  
    
  <nav class="article-nav">
    
      <a href="/2018/05/25/老司机-iOS-周报-20-2018-05-21/" class="article-nav-link">
        <strong class="article-nav-caption">Newer posts</strong>
        <div class="article-nav-title">
          
            老司机 iOS 周报 #20 | 2018-05-21
          
        </div>
      </a>
    
    
      <a href="/2018/04/27/RunLoop与GCD-、Autorelease-Pool之间的关系/" class="article-nav-link">
        <strong class="article-nav-caption">Olde posts</strong>
        <div class="article-nav-title">RunLoop与GCD 、Autorelease Pool之间的关系</div>
      </a>
    
  </nav>


  

  
    
  <div class="gitalk" id="gitalk-container"></div>
  <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
  <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
  <script src="https://cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.min.js"></script>
  <script type="text/javascript">
      var gitalk = new Gitalk({
        clientID: '',
        clientSecret: '',
        repo: '',
        owner: 'hanangellove',
        admin: [''],
        // id: location.pathname,      // Ensure uniqueness and length less than 50
        id: md5(location.pathname),
        distractionFreeMode: false  // Facebook-like distraction free mode
      })

  gitalk.render('gitalk-container')
  </script>

  

</article>



</section>
  <footer class="footer">
  
  <div class="outer">
    <ul class="list-inline">
      <li>&copy; 2019 寒流‘s Blog</li>
      <li>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></li>
      <li>Theme  <a href="https://github.com/zhwangart/hexo-theme-ocean">Ocean</a></li>
      <!--
      <li><a href="/">Han Liu</a></li>
      -->
    </ul>
  </div>
</footer>
</main>
<aside class="sidebar">
  <button class="navbar-toggle"></button>

<nav class="navbar">
  
    <div class="logo">
      <a href="/"><img src="/images/hexo.svg" alt="寒流‘s Blog"></a>
    </div>
  
  <ul class="nav nav-main">
    
      <li class="nav-item">
        <a class="nav-item-link" href="/">Home</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/archives">Archives</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/gallery">Gallery</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/about">About</a>
      </li>
    
    <li class="nav-item">
      <a class="nav-item-link nav-item-search" title="Suche">
        <i class="fe fe-search"></i>
        Search
      </a>
    </li>
  </ul>
</nav>

<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
        <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
          <i class="fe fe-feed"></i>
        </a>
      
    </li>
  </ul>
</nav>

<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
</aside>
  <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/lazyload.min.js"></script>


  <script src="/fancybox/jquery.fancybox.min.js"></script>



  <script src="/js/search.js"></script>


<script src="/js/ocean.js"></script>

</body>
</html>